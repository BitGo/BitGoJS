import * as t from 'io-ts';
import { httpRoute, httpRequest, optional } from '@api-ts/io-ts-http';
import { BitgoExpressError } from '../../schemas/error';

/**
 * Request parameters for fanning out unspents in a wallet (v2)
 */
export const FanoutUnspentsRequestParams = {
  /** The coin identifier (e.g., 'btc', 'tbtc') */
  coin: t.string,
  /** The ID of the wallet */
  id: t.string,
} as const;

/**
 * Request body for fanning out unspents in a wallet (v2)
 *
 * This endpoint supports the full set of parameters available in the BitGo SDK
 * for advanced UTXO management. The fanout operation takes existing unspents and
 * creates a larger number of equally-sized outputs for improved transaction parallelization.
 */
export const FanoutUnspentsRequestBody = {
  /** Passphrase to decrypt the user key on the wallet */
  walletPassphrase: optional(t.string),
  /** Private key in string form, if walletPassphrase is not available */
  xprv: optional(t.string),
  /** Number of new unspents to make */
  numUnspentsToMake: optional(t.number),
  /** Minimum value of unspents to use in base units (e.g. satoshis). For doge, only string is allowed. */
  minValue: optional(t.union([t.number, t.string])),
  /** Maximum value of unspents to use in base units (e.g. satoshis). For doge, only string is allowed. */
  maxValue: optional(t.union([t.number, t.string])),
  /** Minimum height of unspents on the block chain to use*/
  minHeight: optional(t.number),
  /** Minimum confirmation threshold for external inputs */
  minConfirms: optional(t.number),
  /** Flag for enforcing minConfirms for change inputs */
  enforceMinConfirmsForChange: optional(t.boolean),
  /** Maximum number of unspents to use in the transaction. Mutually exclusive with unspents. */
  maxNumInputsToUse: optional(t.number),
  /** Unspents to fan out in the transaction. Mutually exclusive with maxNumInputsToUse. */
  unspents: optional(t.array(t.string)),
  /**
   * Custom fee rate (in base units) per kilobyte (or virtual kilobyte). For example, satoshis per kvByte
   *
   * If the feeRate is less than the minimum required network fee, then the minimum fee applies. For example, 1000 sat/kvByte, a flat 1000 microAlgos, or a flat 10 drops of xrp. For XRP, the actual fee is usually 4.5 times the open ledger fee.
   *
   * Note: The feeRate overrides the maxFeeRate and minFeeRate.
   */
  feeRate: optional(t.number),
  /**
   * (BTC only) The maximum fee rate (in base units) per kilobyte (or virtual kilobyte). For example, satoshis per kvByte. The maxFeeRate limits the fee rate generated by both feeMultiplier and numBlocks.
   *
   * Note: The feeRate overrides the maxFeeRate.
   */
  maxFeeRate: optional(t.number),
  /** Maximum relative portion that can be spent towards fees */
  maxFeePercentage: optional(t.number),
  /** Block target for fee estimation */
  feeTxConfirmTarget: optional(t.number),
  /** Comment to attach to the transaction */
  comment: optional(t.string),
  /** One-time password for 2FA */
  otp: optional(t.string),
  /** Address to use for generated outputs. Must be wallet address. */
  targetAddress: optional(t.string),
  /** [UTXO only] Format of the returned transaction hex serialization. legacy for serialized transaction in custom bitcoinjs-lib format. psbt for BIP174 serialized transaction */
  txFormat: optional(t.union([t.literal('legacy'), t.literal('psbt'), t.literal('psbt-lite')])),
  /** If true, enables fanout of large number of unspents by creating multiple transactions (200 unspents per tx) */
  bulk: optional(t.boolean),
} as const;

/**
 * Single transaction response object
 */
const FanoutUnspentsSingleTxResponse = t.type({
  /** The status of the transaction ('accepted', 'signed', 'pendingApproval', or 'otp') */
  status: t.string,
  /** The transaction hex/serialized transaction */
  tx: t.string,
  /** The transaction hash/ID */
  hash: optional(t.string),
  /** Alternative field for transaction ID (some responses use this instead of hash) */
  txid: optional(t.string),
  /** The fee amount in base units (satoshis for BTC) */
  fee: optional(t.number),
  /** The fee rate in base units per kilobyte (satoshis/kB for BTC) */
  feeRate: optional(t.number),
  /** Whether the transaction is instant */
  instant: optional(t.boolean),
  /** The instant transaction ID (if applicable) */
  instantId: optional(t.string),
  /** Travel rule information */
  travelInfos: optional(t.unknown),
  /** BitGo fee information (if applicable) */
  bitgoFee: optional(t.unknown),
  /** Travel rule result (if applicable) */
  travelResult: optional(t.unknown),
});

/**
 * Response for fanning out unspents in a wallet (v2)
 *
 * Returns transaction details after the fanout operation is built, signed, and sent.
 * When bulk=true, an array of transaction objects is returned; otherwise, a single transaction object is returned.
 */
export const FanoutUnspentsResponse = t.union([
  FanoutUnspentsSingleTxResponse,
  t.array(FanoutUnspentsSingleTxResponse),
]);

/**
 * Fan out unspents on a wallet
 *
 * Creates transactions that distribute existing unspents into more outputs, enabling parallel
 * transaction creation. Supports bulk mode to handle large fanouts across multiple transactions.
 *
 * @operationId express.wallet.fanoutunspents
 * @tag Express
 */
export const PostFanoutUnspents = httpRoute({
  path: '/api/v2/{coin}/wallet/{id}/fanoutunspents',
  method: 'POST',
  request: httpRequest({
    params: FanoutUnspentsRequestParams,
    body: FanoutUnspentsRequestBody,
  }),
  response: {
    /** Successfully fanned out unspents */
    200: FanoutUnspentsResponse,
    /** Invalid request or fan out operation fails */
    400: BitgoExpressError,
  },
});
