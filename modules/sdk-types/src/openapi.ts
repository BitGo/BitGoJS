/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };

/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = T | U extends any ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only]
  ? Only
  : T extends [infer A, infer B, ...infer Rest]
  ? OneOf<[XOR<A, B>, ...Rest]>
  : never;

export interface paths {
  '/api/v2/{coin}/wallet/{walletId}/addresses': {
    /**
     * List addresses
     * @description List receive addresses on a wallet
     */
    get: operations['v2.wallet.addresses'];
  };
  '/api/v2/{coin}/wallet/{walletId}/address': {
    /**
     * Create address
     * @description Creates a new receive address for a wallet. If you create a forwarder address, whenever it receives assets, BitGo automatically deploys a forwarder smart contract to flush the balance to the base address. See [Blockchain Reference](/coins/Algorand) topics to learn more about address management, fees, and consolidations for specific assets.
     *
     * **Note:** New Ethereum addresses require blockchain confirmation before you can consolidate from them.
     */
    post: operations['v2.wallet.newaddress'];
  };
  '/api/v2/{coin}/wallet/{walletId}/address/{addressId}/deployment': {
    /**
     * Deploy address
     * @description This API call is to manually deploy an ETH address
     */
    post: operations['v2.wallet.deployForwarder'];
  };
  '/api/v2/{coin}/wallet/{walletId}/address/{addressId}/tokenforward': {
    /**
     * Forward tokens from address
     * @description This API call is to manually forward tokens from an ETH or CELO address
     */
    post: operations['v2.wallet.forwardToken'];
  };
  '/api/v2/{coin}/wallet/{walletId}/address/{addressOrId}': {
    /**
     * Get address
     * @description Gets a receive address on a wallet
     */
    get: operations['v2.wallet.singlewalletaddress'];
    /**
     * Update address
     * @description Update a receive address on a wallet
     */
    put: operations['v2.wallet.updateaddress'];
  };
  '/api/v2/{coin}/wallet/{walletId}/address/{addressOrId}/proof': {
    /**
     * Get proof of address ownership
     * @description Gets proof of ownership for an address of a TRUST wallet. Returns a unique BTC proof or ETH IOU that you can use with your travel-rule solutions. Only available for BTC and ETH.
     */
    get: operations['v2.wallet.addressProof'];
  };
  '/api/v2/{coin}/wallet/{walletId}/potentialStuckTxs': {
    /**
     * Get list of potentially stuck transactions and their nonces for eth-like coins
     * @description Gets a list of potentially problematic transactions, their nonces, the reason they are stuck, and possible solutions for a given wallet
     */
    get: operations['v2.wallet.getpotentialstucktxs'];
  };
  '/api/v2/{coin}/wallet/{walletId}/fundforwarders': {
    /**
     * Send funds to forwarder
     * @description Send funds from a fee address to forwarder. Only supports account-based coins and tokens (like ETH).
     */
    post: operations['v2.wallet.fundforwarders'];
  };
  '/api/v2/enterprise/{enterpriseId}': {
    /** Get enterprise */
    get: operations['enterprise.getById'];
    /** Update enterprise */
    put: operations['enterprise.update'];
  };
  '/api/v2/enterprise/{enterpriseId}/tssconfig': {
    /**
     * Get enterprise TSS config
     * @description This api fetches the enterprise TSS config if it exists. The caller of this API must have view permissions on the enterprise.
     */
    get: operations['v2.enterprise.tssconfig.get'];
  };
  '/api/v2/enterprise/{enterpriseId}/tssconfig/ecdsa/challenge': {
    /**
     * Update enterprise ECDSA TSS challenge
     * @description This api is used to upload a new ECDSA challenge for the enterprise. This will replace the existing challenge if one exists.
     */
    put: operations['v2.enterprise.tssconfig.ecdsa.challenge.update'];
  };
  '/api/v2/enterprise/{enterpriseId}/availableassets': {
    /**
     * List available assets
     * @description Lists all available assets for a given enterprise. Must have view permissions on the enterprise
     */
    get: operations['v2.enterprise.availableassets.get'];
  };
  '/api/v2/enterprise': {
    /** List enterprises */
    get: operations['enterprise.list'];
  };
  '/api/v1/enterprise/{enterpriseId}/user': {
    /** List enterprise users */
    get: operations['enterprise.user.list'];
  };
  '/api/v2/enterprise/{enterpriseId}/user': {
    /** Add user to enterprise */
    post: operations['v2.enterprise.user.add'];
    /** Remove user from enterprise */
    delete: operations['v2.enterprise.user.remove'];
  };
  '/api/v2/enterprise/{enterpriseId}/user/{userId}/signingkey': {
    /**
     * Get enterprise user signing key
     * @description Get the signing key for an enterprise user. The signing key is used to sign arbitrary messages, which other enterprise users can verify. The caller of this API must have view permissions on the enterprise.
     */
    get: operations['v2.enterprise.user.signingkey.get'];
  };
  '/api/v2/enterprise/{enterpriseId}/freeze': {
    /** Freeze the enterprise */
    post: operations['enterprise.freeze'];
  };
  '/api/v2/enterprise/{enterpriseId}/walletLimits': {
    /** Get enterprise's wallet limits */
    get: operations['enterprise.walletLimits'];
  };
  '/api/v2/{coin}/enterprise/{enterpriseId}/feeAddressBalance': {
    /**
     * Get gas tank balance
     * @description Returns gas tank balance for an asset.
     */
    get: operations['v2.enterprise.feeAddressBalance'];
  };
  '/api/v2/enterprise/{enterpriseId}/transfer': {
    /**
     * List all transfers on all wallets in an enterprise
     * @description Returns all the transfers without blockchain information (inputs, outputs, confirms). Use the coin specific route
     * to annotate blockchain information.
     */
    get: operations['v2.enterprise.listtransfers'];
  };
  '/api/v2/{coin}/transfer': {
    /**
     * List transfers on all wallets in an enterprise for a given coin and block height
     * @description Returns all the transfers. Currently requires an enterpriseId and block height.
     */
    get: operations['v2.listtransfers'];
  };
  '/api/v2/{coin}/tx/fee': {
    /**
     * Get fee estimate
     * @description Returns the estimated fee for a transaction. UTXO coins will return a fee per kB, while Account-based coins will return a flat fee estimate
     */
    get: operations['v2.tx.getfeeestimate'];
  };
  '/api/v2/{coin}/wallet/averagefee': {
    /**
     * Get average fee
     * @description Returns the average fee for a specific number of blocks. Only for ETH and TETH.
     */
    post: operations['v2.wallet.getaveragefee'];
  };
  '/api/v2/user/{id}': {
    /**
     * Get user
     * @description Returns the associated user
     */
    get: operations['user.get'];
  };
  '/api/v2/user/sharingkey': {
    /** Get another users public key for wallet sharing */
    post: operations['user.sharingkey'];
  };
  '/api/v2/{coin}/key/{idOrPub}': {
    /**
     * Get key
     * @description Get Key using either the key id or the pub.
     * When using the public key, it will only return the mandatory fields.
     */
    get: operations['v2.key.get'];
  };
  '/api/v2/{coin}/key': {
    /** List keys */
    get: operations['v2.key.list'];
    /** Create key */
    post: operations['v2.key.add'];
  };
  '/api/v2/{coin}/wallet/{walletId}/policy/rule': {
    /**
     * Update policy rule
     * @description Updates a rule on the policy attached to a wallet
     */
    put: operations['v2.wallet.updatepolicy'];
    /**
     * Add policy rule
     * @description Adds a rule to a wallet’s policy. A wallet policy’s rules control the
     * conditions under which BitGo will use its single key to sign a
     * transaction. An email notification will be sent to all wallet users
     * when a policy is updated. This email is NOT sent for the first time
     * policy is added.
     */
    post: operations['v2.wallet.createpolicy'];
    /**
     * Delete policy rule
     * @description Deletes a rule from the policy attached to a wallet
     */
    delete: operations['v2.wallet.removepolicy'];
  };
  '/api/v2/pendingApprovals': {
    /** List pending approvals */
    get: operations['v2.approval.list'];
  };
  '/api/v2/pendingApprovals/{id}': {
    /** Get pending approval */
    get: operations['v2.approval.get'];
    /**
     * Update pending approval
     * @description Updates the state of a pending approval to "approved" or "rejected".
     * You can manage pending approvals programmatically by API or with the
     * BigGo web UI. Ensure your authentication token has the proper scope.
     * When creating an access token in the web UI, check the permission,
     * "Update Pending Approvals" (under "Account Settings" &gt; "Developer
     * Options" &gt; "Access Tokens").
     *
     * BitGo recommends that you create a webhook policy so that you can
     * automate approving and rejecting transactions.
     */
    put: operations['v2.approval.update'];
  };
  '/api/v2/user/login': {
    /**
     * Login
     * @description Creates a short-lived (1 hour) access token for use with the API.  The token must be specified to subsequent
     * API calls via the "Authorization" HTTP header:
     * """text
     * Authorization: Bearer 9b72c68ef394f5146f0f3efc1feafb7a971752cb00e79fafcfd8c1d2db83639c
     * """
     * We don't recommend using this endpoint for scripting.  The preferred
     * approach is to create a long-lived token in the web UI (see the
     * Developer Options section in User Settings).
     */
    post: operations['user.login'];
  };
  '/api/v2/{coin}/wallet/{walletId}/transfer': {
    /**
     * List transfers
     * @description Returns deposits and withdrawals for a wallet.  Transfers are sorted
     * in descending order by "height", then "id". Transfers with "rejected"
     * and "pendingApproval" states are excluded by default.
     */
    get: operations['v2.wallet.listtransfers'];
  };
  '/api/v2/{coin}/wallet/{walletId}/transfer/{transferId}': {
    /**
     * Get transfer
     * @description A transfer is a wallet specific object. Each transfer will only output the respective wallet id which the
     * transfer is associated with.
     *
     * If there is a transaction between two BitGo wallets, then two transfers will be created, one for wallet A,
     * and one for wallet B. Transfer A will only annotate the walletId on entries where the address belongs to
     * wallet A. Transfer B will only annotate the walletId on entries where the address belongs to wallet B.
     */
    get: operations['v2.wallet.gettransfer'];
  };
  '/api/v2/{coin}/wallet/{walletId}/transfer/sequenceId/{sequenceId}': {
    /** Get transfer by sequence id */
    get: operations['v2.wallet.gettransferbysequenceid'];
  };
  '/api/v2/user/logout': {
    /**
     * Logout
     * @description Disables an access token
     */
    get: operations['user.logout'];
  };
  '/api/v2/user/session': {
    /**
     * Get session
     * @description Returns the session associated with access token passed via the "Authorization" header.
     */
    get: operations['user.getsession'];
  };
  '/api/v2/user/lock': {
    /**
     * Lock session
     * @description Locks the current user session.  This disallows operations that require
     * an unlocked token, such as sending a transaction.
     */
    post: operations['user.lock'];
  };
  '/api/v2/user/unlock': {
    /**
     * Unlock session
     * @description Unlocks the current user session, enabling operations that require
     * an unlocked token, such as sending a transaction. Call this endpoint
     * if an API returns a "401" response with the "needsUnlock"
     * body parameter set to "true".
     *
     * **Note:** Unlocking a token with spending limits, removes all spending limits from the token.
     */
    post: operations['user.unlock'];
  };
  '/api/v2/{coin}/wallet': {
    /**
     * List wallets by coin
     * @description Get a list of all wallets per coin, for example, all <i>Bitcoin</i> wallets in your enterprise.
     */
    get: operations['v2.wallet.listbycoin'];
    /**
     * Add wallet (advanced only)
     * @description Add Wallet is for advanced API users. It lets you manually create and
     * specify keys. The recommended (and simpler) method is [Generate Wallet](https://developers.bitgo.com/api/express.wallet.generate)
     * with the SDK or BitGo Express. You can also create wallets in the BitGo UI.
     *
     * This API creates a new wallet for the user or enterprise. The keys to
     * use with the new wallet (passed in the 'keys' parameter) must be
     * registered with BitGo prior to using this API.
     *
     * BitGo currently only supports 2-of-3 (e.g., m=2 and n=3) wallets. The
     * third key, and only the third key, must be a BitGo key. The first key
     * is by convention the user key, with its encrypted xprv stored on BitGo.
     *
     * Ethereum and XRP wallets can only be created under an enterprise. Pass in the
     * id of the enterprise to associate the wallet with. Your enterprise id
     * can be seen by clicking on the "Manage Organization" link in the
     * enterprise dropdown. Using the Add Wallet API, you can create a wallet
     * using either the enterprise fee address (used by default for all
     * wallets in the enterprise), or a unique fee address (created manually
     * with the Keychains API). Pass the desired key as the third key ID in
     * the 'keys' array. In either case, the fee address must be funded
     * before creating the wallet.
     *
     * You cannot generate a wallet by passing in a subtoken (i.e. ERC20 token) as the coin.
     * Subtokens use the wallet of their parent coin and it is not possible to create a
     * wallet specific to one token. For example, to create a wallet for an ERC20 token,
     * create an Ethereum wallet. It can hold any ERC20 tokens as well as Ether.
     *
     * BitGo Ethereum wallet is a smart-contract implementing multi-signature scheme.
     * Because contracts itself can not initiate transactions, fee addresses are used
     * for this purpose. Ethereum transactions initiated by a given address, are
     * confirmed by the network in order of creation, so one lower fee transaction can
     * potentially delay all subsequent transactions. To help lower network fee costs,
     * two fee addresses are provided.
     *
     * "feeAddress" is a main fee address usable for all operations.
     * "lowPriorityFeeAddress" is a secondary fee address that can be used to pay
     * lower fee for Create Address operations without risking delaying subsequent
     * higher-priority transactions initiated by main fee address.
     */
    post: operations['v2.wallet.add'];
  };
  '/api/v2/wallets': {
    /**
     * List wallets
     * @description Get a list of all wallets for which you have permission. To narrow your search, use the <b>List wallets</b> parameters below or call <b>List wallets by coin</b>, <b>Get Wallet</b> (by "coin" and "walletId") or <b>Get wallet by address</b> (by "coin" and "address").<br><br>
     * Compare the List/Get wallet APIs&#58; <ul> <li><b>List wallets</b> returns 1 or more wallets for 1 or more coins across 1 or more enterprises (within an array).</li> <li><b>List wallets by coin</b> returns 1 or more wallets <i>for one coin only</i> across 1 or more enterprises (within an array).</li> <li><b>Get wallet</b> and <b>Get wallet by address</b> return one wallet.</li> </ul>
     * Test the List/Get wallet APIs. With the same parameter values, these calls should return the same wallet (with minor differences in the responses)&#58;
     * <table> <tr> <th>API</th> <th>URL</th></tr> <tr> <td><b>List wallets</b></td> <td><code>{{baseUrl}}/api/v2/wallets?coin={coin}&enterprise={enterpriseid}&id={walletId}&expandBalance=true</code></td></tr> <tr> <td><b>List wallets by coin</b></td> <td><code>{{baseUrl}}/api/v2/{coin}/wallet?enterprise={enterpriseid}&searchLabel={wallet name}</code></td></tr> <tr> <td><b>Get wallet</b></td> <td><code>{{baseUrl}}/api/v2/{coin}/wallet/{walletId}</code></td></tr> <tr> <td><b>Get wallet by address</b></td> <td><code>{{baseUrl}}/api/v2/{coin}/wallet/address/{address}</code></td></tr> </table>
     */
    get: operations['v2.wallet.list'];
  };
  '/api/v2/wallets/count': {
    /**
     * Get wallets count
     * @description Returns a count of all the wallets for which you have any permission (view, spend, admin). If you don't have permission to view all wallets in the enterprise, then returns a count of the wallets only for which the you are a member.
     * You can use this endpoint in conjunction with the [List wallets](https://developers.bitgo.com/api/v2.wallet.list) endpoint to enable paginating a list of wallets. For example, once you get the wallets count, you can use that count to calculate the number of pages you need to display all the wallets.
     */
    get: operations['v2.wallet.count'];
  };
  '/api/v2/{coin}/wallet/address/{address}': {
    /**
     * Get wallet by address
     * @description Get one wallet by its "coin" and receive "address". Multiple receive addresses can map to one "walletId".
     */
    get: operations['v2.wallet.getwalletbyaddress'];
  };
  '/api/v2/{coin}/wallet/{walletId}': {
    /**
     * Get wallet
     * @description Get one wallet by its "coin" and "walletId". One "walletId" can map to multiple receive addresses.
     */
    get: operations['v2.wallet.get'];
    /**
     * Update wallet
     * @description Update a wallet by its "coin" and "walletId".
     */
    put: operations['v2.wallet.update'];
    /**
     * Delete wallet
     * @description Delete one wallet by its "coin" and "walletId". Once removed, you can no longer view or access this wallet, but it does remain accessible to other wallet users. If you are the only user on this wallet, you can only delete it if it has a 0 balance.
     */
    delete: operations['v2.wallet.remove'];
  };
  '/api/v2/wallet/{walletId}': {
    /**
     * Get wallet by ID
     * @description Get one wallet by its "walletId". One "walletId" can map to multiple receive addresses.
     */
    get: operations['v2.wallet.getbyid'];
  };
  '/api/v2/{coin}/wallet/{walletId}/user/{userId}': {
    /**
     * Remove user from wallet
     * @description After a user has accepted a wallet share, they become a party on a
     * wallet and the wallet share is considered “complete”. In order to
     * revoke the share after they have accepted, you can remove the user
     * from the wallet.
     *
     * This operation requires approval by another wallet administrator
     * if there is more than a single administrator on a wallet.
     */
    delete: operations['v2.wallet.removeuser'];
  };
  '/api/v2/{coin}/wallet/{walletId}/freeze': {
    /**
     * Freeze wallet
     * @description Lock the wallet, preventing any outgoing transactions for a specified number of seconds
     */
    post: operations['v2.wallet.freeze'];
  };
  '/api/v2/{coin}/wallet/{walletId}/unspents': {
    /**
     * Get unspents
     * @description Returns unspent transaction outputs for a wallet
     */
    get: operations['v2.wallet.unspents'];
  };
  '/api/v2/{coin}/wallet/{walletId}/crosschainunspents': {
    /**
     * Get cross-chain unspents
     * @description Returns atomic cross-chain unspents that can be imported by the wallet. Supported coins: AVAX.
     */
    get: operations['v2.wallet.crosschainunspents'];
  };
  '/api/v2/{coin}/wallet/{walletId}/maximumSpendable': {
    /**
     * Get maximum spendable
     * @description Returns the maximum amount that can be spent with a single transaction
     * on the wallet.
     *
     * The maximum spendable amount can differ from a wallet’s total balance.
     * A transaction can only use up to 200 unspents. Wallets that have more
     * than 200 unspents cannot spend the full balance in one transaction.
     * Additionally, the value returned for the maximum spendable amount
     * accounts for the current fee level by deducting the estimated fees.
     * The amount will only be calculated based on the unspents that fit the
     * parameters passed.
     */
    get: operations['v2.wallet.maximumspendable'];
  };
  '/api/v2/{coin}/wallet/{walletId}/unspent/{unspentId}/inscriptions': {
    /**
     * Get inscribed satoshis on unspent
     * @description Returns inscribed satoshis (and associated data) for an unspent in a wallet.
     * To use this endpoint, BitGo must enable inscription tracking for your enterprise. Contact support@bitgo.com.
     */
    get: operations['v2.wallet.unspent.inscriptions'];
  };
  '/api/v2/{coin}/wallet/{walletId}/spending': {
    /**
     * Get spending limits and current amount spent
     * @description Returns the wallet's currently configured spending limits and the current
     * amount spent during the periods defined by the spending limits.
     */
    get: operations['v2.wallet.spending'];
  };
  '/api/v2/wallet/{walletId}/reservedunspents': {
    /**
     * List unspent reservation
     * @description Query reserved unspents in the wallet.
     */
    get: operations['v2.wallet.reservedunspent.list'];
    /**
     * Modifying unspent reservation
     * @description Modify expire time of reserved unspents.
     */
    put: operations['v2.wallet.reservedunspent.put'];
    /**
     * Make unspent reservation
     * @description Mark the unspents as reserved and cannot be used in transactions until the given expire time.
     */
    post: operations['v2.wallet.reservedunspent.add'];
    /**
     * Release unspent reservation
     * @description Release unspents from reservation to be accessible for transactions.
     */
    delete: operations['v2.wallet.reservedunspent.delete'];
  };
  '/api/v2/wallet/balances': {
    /**
     * List total balances
     * @description Selects wallets based on the given filter parameters. Gets all balances for the selected wallets and sums up the
     * balances by coin.
     */
    get: operations['v2.wallet.gettotalbalances'];
  };
  '/api/v2/{coin}/wallet/{walletId}/requestreshare': {
    /**
     * Request wallet reshare
     * @description Indicates that the calling user has lost access to the user key and would like to it to be reshared with them.
     */
    post: operations['v2.wallet.sharing.requestreshare'];
  };
  '/api/v2/{coin}/wallet/{walletId}/share': {
    /**
     * Create a wallet share
     * @description Share wallet with an existing BitGo user
     */
    post: operations['v2.wallet.sharing.createshare'];
  };
  '/api/v2/wallet/requestaccess': {
    /**
     * Request wallet access
     * @description Allow users that are members of an org to send a notification out to admins of a wallet to get access. You must supply either a walletId or a enterpriseId and walletType
     */
    post: operations['v2.wallet.requestaccess'];
  };
  '/api/v2/wallet/{walletId}/rejectreshare': {
    /**
     * Reject a wallet reshare request
     * @description If a user requested a reshare, another admin on the wallet can use this endpoint to reject their reshare request.
     */
    post: operations['v2.wallet.sharing.rejectreshare'];
  };
  '/api/v2/walletshares': {
    /**
     * List wallet shares
     * @description List shares of all wallets with other BitGo users. Returns only wallets on which the current user has spend permission.
     */
    get: operations['v2.wallet.sharing.listallshares'];
  };
  '/api/v2/walletshares/count': {
    /**
     * List counts of wallet shares
     * @description List counts of wallet shares by enterprises that the current user is the receiver
     */
    get: operations['v2.walletshares.count.list'];
  };
  '/api/v1/{coin}/walletshare/{shareId}': {
    /**
     * Get wallet share V1
     * @description Returns a wallet share, requires unlock if the wallet share includes a keychain.
     */
    get: operations['v1.wallet.sharing.getshare'];
  };
  '/api/v2/{coin}/walletshare/{shareId}': {
    /**
     * Get wallet share
     * @description Returns a wallet share, requires unlock if the wallet share includes a keychain.
     */
    get: operations['v2.wallet.sharing.getshare'];
    /** Update a wallet share */
    post: operations['v2.wallet.sharing.updateshare'];
    /**
     * Cancel a wallet share
     * @description Cancels a pending outgoing wallet share, or rejects an incoming share.
     * The share must not have been accepted yet.
     */
    delete: operations['v2.wallet.sharing.cancelshare'];
  };
  '/api/v2/{coin}/walletshare/{shareId}/resendemail': {
    /**
     * Resend a wallet share invitation email
     * @description Resends the wallet share invitation to the share recipient. The wallet
     * share must not have been accepted yet.
     */
    post: operations['v2.wallet.sharing.resendemail'];
  };
  '/api/v2/{coin}/wallet/{walletId}/webhooks': {
    /**
     * List wallet webhooks
     * @description List webhooks set up on the wallet. Currently, the types of
     * webhooks that can be attached to a wallet are "transfer",
     * "pendingapproval", and "address_confirmation" notifications.
     */
    get: operations['v2.wallet.listwebhooks'];
    /**
     * Add wallet webhook
     * @description Add a webhook to a wallet that sends an HTTP callback from BitGo to a specified URL when specific conditions occur. A wallet can have up to 10 webhooks of each wallet-webhook type.
     * Wallet-webhook types:
     * 1. **Address confirmation** - An address initializes on chain (ETH and XRP only).
     * 2. **Pending approval** - A wallet-level policy-triggering event occurs (such as a withdrawal, user change, policy change, pending approval state updates, and so forth).
     * 3. **Transaction request** - A transaction request state changes.
     * 4. **Transfer** - Any transfer occurs.
     *
     * **Note:** Unconfirmed webhook notifications don't trigger for [RBF](https://bitcoinops.org/en/topics/replace-by-fee/) transactions, or if a transaction confirms on chain immediately after it's sent. BitGo doesn't send 'unconfirmed' notifications in these cases.
     */
    post: operations['v2.wallet.addwebhook'];
    /**
     * Remove wallet webhook
     * @description Removing a webhook will cause new events of the specified type to no
     * longer trigger HTTP callbacks to your URLs
     */
    delete: operations['v2.wallet.removewebhook'];
  };
  '/api/v2/{coin}/wallet/{walletId}/webhooks/{webhookId}/simulate': {
    /**
     * Simulate wallet webhook
     * @description Simulates and tests a webhook so you can view its response. A
     * "transferId", "pendingApprovalId" or "txRequestId" is required.
     */
    post: operations['v2.wallet.simulatewebhook'];
  };
  '/api/v2/{coin}/webhooks': {
    /**
     * List block webhooks
     * @description Returns block webhooks. The types of webhooks are "block" and
     * "wallet_confirmation" notifications.
     */
    get: operations['v2.webhooks.list'];
    /**
     * Add block webhook
     * @description Adds a webhook that will result in an HTTP callback at the
     * specified URL from BitGo when events are triggered.
     *
     * Types of block webhooks:
     *
     * 1. Block webhooks will fire when a new block is seen on the coin network.
     * 2. Wallet confirmation webhooks will fire when a wallet has been initialized.
     */
    post: operations['v2.webhooks.add'];
    /**
     * Remove block webhook
     * @description Removing a webhook will cause new events of the specified type to no
     * longer trigger HTTP callbacks to your URLs.
     */
    delete: operations['v2.webhooks.remove'];
  };
  '/api/v2/{coin}/webhooks/{webhookId}/simulate': {
    /**
     * Simulate block webhook
     * @description Simulates and tests a block webhook so you can view its response.
     */
    post: operations['v2.webhooks.simulate'];
  };
  '/api/v2/{coin}/reports': {
    /**
     * Generate coin specific report
     * @description Generate a report of transactions across all wallets for the user with the given coin
     */
    get: operations['v2.report.coinSpecific.generate'];
  };
  '/api/v2/reports': {
    /**
     * List reports
     * @description Lists generated reports.
     */
    get: operations['v2.reports.list'];
    /**
     * Generate report
     * @description Creates a new report in pending status.
     */
    post: operations['v2.reports.create'];
  };
  '/api/v2/reports/{reportId}': {
    /**
     * Get report
     * @description Returns a single report by report ID.
     */
    get: operations['v2.reports.getById'];
  };
  '/api/v2/reports/{reportId}/document': {
    /**
     * Download report
     * @description Returns binary data encoded based on report format (pdf/csv).
     */
    get: operations['v2.reports.getById1'];
  };
  '/api/v2/{coin}/reports/{walletId}': {
    /**
     * Generate a wallet report
     * @description Generate a report of transactions for the given wallet
     */
    get: operations['v2.report.wallet.generate'];
  };
  '/api/v2/xlm/federation': {
    /**
     * Look up user accounts by their Stellar address or id
     * @description Types of searches available:
     *
     * 1. By name: Resolve a Stellar address into an account
     * 2. By id: Resolve an account id into an account
     */
    get: operations['v2.federation'];
  };
  '/api/v2/{coin}/material': {
    /**
     * Look up material
     * @description Currently available only for Polkadot. Material contains some basic transaction information that is common to all transactions. For Polkadot, this data changes every release.
     */
    get: operations['v2.materialData'];
  };
  '/api/v2/sendlabels': {
    /**
     * List send labels
     * @description List all send labels for the enterprise. Address and coin parameters optional.
     */
    get: operations['v2.sendlabels.list'];
    /**
     * Create send label
     * @description Create an address send label for an id
     */
    post: operations['v2.sendlabels.create'];
  };
  '/api/v2/sendlabels/{id}': {
    /**
     * Get send label by id
     * @description Gets an address send label by the specified id
     */
    get: operations['v2.sendlabels.get'];
    /**
     * Update send label
     * @description Updates an address send label by the specified id
     */
    put: operations['v2.sendlabels.update'];
    /** Delete send label */
    delete: operations['v2.sendlabels.delete'];
  };
  '/api/v2/enterprise/{enterpriseId}/txrequests': {
    /**
     * Get transaction requests by enterprise
     * @description Get a paginated list of transaction requests filtered by enterprise.
     */
    get: operations['v2.enterprise.txrequest.get'];
  };
  '/api/v2/wallet/{walletId}/txrequests': {
    /**
     * Get transaction requests by wallet
     * @description Get a paginated list of transaction requests filtered by wallet. Use only with TSS wallets.
     */
    get: operations['v2.wallet.txrequest.get'];
    /**
     * Create transaction request
     * @description Allows users to create a transaction request given they have spender permissions on the wallet. Use only with TSS wallets. For multisignature wallets, use [Build a transaction](/api/v2.wallet.tx.build).
     */
    post: operations['v2.wallet.txrequest.create'];
  };
  '/api/v2/wallet/{walletId}/txrequests/awaitingsignature': {
    /** Get transaction requests ready for signature */
    get: operations['v2.wallet.txrequest.awaitingsignature.list'];
  };
  '/api/v2/wallet/{walletId}/txrequests/{id}': {
    /**
     * Update transaction request
     * @description Allows users to update an existing transaction request given they have spender permissions on the wallet. Use only with TSS wallets.
     */
    put: operations['v2.wallet.txrequest.update'];
  };
  '/api/v2/wallet/{walletId}/txrequests/{id}/signatureshares': {
    /**
     * Create a signature share for the transaction request
     * @description Allows users to supply their signature share for signing. Use only with TSS wallets.
     */
    post: operations['v2.wallet.txrequest.signatureshare.create'];
    /**
     * Delete signature shares on a transaction request.
     * @description Allows users to clear the signature shares on a transaction request. This will also set the state to pendingUserSignature. Use only with TSS wallets.
     */
    delete: operations['v2.wallet.txrequest.signatureshare.delete'];
  };
  '/api/v2/wallet/{walletId}/txrequests/{id}/transactions/{transactionIdx}/signatureshares': {
    /**
     * Create a signature share for a transaction on a transaction request
     * @description Allows users to supply their signature share for signing.
     * This route is only valid for transaction request full. Use only with TSS wallets.
     */
    post: operations['v2.wallet.txrequest.transaction.signatureshare.create'];
  };
  '/api/v2/wallet/{walletId}/txrequests/{id}/transactions/{transactionIdx}/challenge': {
    /**
     * Create ECDSA TSS challenge for transaction
     * @description Create the challenge required for signing ECDSA transactions. You must call this endpoint before calling [Create a signature share for the transaction request](/api/v2.wallet.txrequest.signatureshare.create).
     */
    post: operations['v2.wallet.txrequest.transaction.challenge.create'];
  };
  '/api/v2/wallet/{walletId}/txrequests/{id}/messages/{messageIdx}/challenge': {
    /**
     * Create ECDSA TSS challenge for message
     * @description Create the challenge required for signing ECDSA transactions. You must call this endpoint before calling [Create a signature share for the transaction request](/api/v2.wallet.txrequest.signatureshare.create).
     */
    post: operations['v2.wallet.txrequest.message.challenge.create'];
  };
  '/api/v2/wallet/{walletId}/txrequests/{id}/commit': {
    /**
     * Exchange commitments for EdDSA transactions (lite)
     * @description Exchange commitments for signing EdDSA transactions. This route is only valid for transaction request lite. You must call this endpoint before calling [Create a signature share for the transaction request](/api/v2.wallet.txrequest.signatureshare.create).
     */
    post: operations['v2.wallet.txrequest.commitment.exchange'];
  };
  '/api/v2/wallet/{walletId}/txrequests/{id}/transactions/{transactionIdx}/commit': {
    /**
     * Exchange commitments for EdDSA transactions (full)
     * @description Exchange commitments for signing EdDSA transactions. This route is only valid for transaction request full. You must call this endpoint before calling [Create a signature share for the transaction request](/api/v2.wallet.txrequest.signatureshare.create).
     */
    post: operations['v2.wallet.txrequest.transaction.commitment.exchange'];
  };
  '/api/v2/wallet/{walletId}/txrequests/rebuild': {
    /**
     * Rebuild transaction requests
     * @description Rebuild multiple transaction requests for a wallet. This is for convenience. The txRequests rebuild in sequential order based on creation date.
     */
    post: operations['v2.wallet.txrequests.rebuild'];
  };
  '/api/v2/wallet/{walletId}/txrequests/{id}/transfers': {
    /**
     * Create transfer for transaction request
     * @description Create a transfer for a transaction request and return that transfer. Use only with TSS wallets.
     */
    post: operations['v2.wallet.txrequest.transfers.create'];
  };
  '/api/v2/{coin}/wallet/{walletId}/tx/build': {
    /**
     * Build a transaction
     * @description Build a transaction from the wallet using provided options. Use only with multisignature wallets. For TSS wallets, use [Create transaction request](https://developers.bitgo.com/api/v2.wallet.txrequest.create). If you want to build, sign, and send all in one call, use [Send transaction](https://developers.bitgo.com/api/express.wallet.sendcoins).
     */
    post: operations['v2.wallet.tx.build'];
  };
  '/api/v2/{coin}/wallet/{walletId}/consolidateUnspents': {
    /**
     * Consolidate unspents
     * @description Consolidate unspents in a wallet.
     */
    post: operations['v2.wallet.consolidateunspents'];
  };
  '/api/v2/{coin}/wallet/{walletId}/tx/initiate': {
    /**
     * Initiate a transaction
     * @description Initiate an unsigned transaction to create a pending approval. This is useful to request funds to be sent from custodial wallets. Use only with custodial wallets.
     */
    post: operations['v2.wallet.tx.initiate'];
  };
  '/api/v2/{coin}/wallet/{walletId}/tx/send': {
    /**
     * Send a half-signed transaction
     * @description Send a half-signed transaction from the specified wallet.
     * Instead of this endpoint, you likely want to use [send transaction](https://developers.bitgo.com/api/express.wallet.sendcoins)
     * in the SDK.
     */
    post: operations['v2.wallet.tx.send'];
  };
  '/api/v2/{coin}/wallet/{walletId}/trustline/initiate': {
    /**
     * Initiate a trustline transaction
     * @description Initiate an unsigned trustline transaction to create a pending approval. Trustline transactions manage trusted tokens on the account. Available for Stellar. Use only with custodial wallets.
     */
    post: operations['v2.wallet.trustline.initiate'];
  };
  '/api/v2/{coin}/requiredReserve': {
    /**
     * Get balance reserve data
     * @description Returns information about reserve requirements for an account. Currently only available for Stellar.
     */
    get: operations['v2.tx.fetchReserve'];
  };
  '/api/v2/bankaccounts': {
    /**
     * List bank accounts
     * @description This route is potentially useful for finding the "idHash" of the desired account to use for fiat withdrawals. The "idHash" field
     * is used as the recipient address along with an optional hyphen separator and memo (example: "5812dcaa9a285aa6-memohere").
     */
    get: operations['v2.bankaccount.list'];
    /** Create a bank account */
    post: operations['v2.bankaccount.create'];
  };
  '/api/v2/bankaccounts/{bankAccountId}': {
    /**
     * Get bank account
     * @description This route is potentially useful for finding the "idHash" of the desired account to use for fiat withdrawals. The "idHash" field
     * is used as the recipient address along with an optional hyphen separator and memo (example: "5812dcaa9a285aa6-memohere").
     */
    get: operations['v2.bankaccount.get'];
    /** Update bank account */
    put: operations['v2.bankaccount.update'];
    /**
     * Delete bank account
     * @description Removes a bank account if not already verified
     */
    delete: operations['v2.bankaccount.delete'];
  };
  '/api/v2/pingexpress': {
    /**
     * Ping BitGo Express
     * @description Ping bitgo express to ensure that it is still running. Unlike /ping, this does not try connecting to bitgo.com.
     */
    get: operations['express.ping'];
  };
  '/api/v2/{coin}/wallet/{walletId}/sendcoins': {
    /**
     * Send transaction
     * @description This call allows you to create and send cryptocurrency to a destination address.
     */
    post: operations['express.wallet.sendcoins'];
  };
  '/api/v2/{coin}/wallet/{walletId}/sendmany': {
    /**
     * Send to many
     * @description Send coins or tokens to one or more recipients. You can use this endpoint to schedule outgoing transactions in bulk, lowering your aggregate amount of blockchain fees.
     *
     * Currently available for UTXO and EVM coins, as well as SOL. Works with both multisignature and TSS wallets. Also supports external-signer mode for EdDSA-based coins in TSS wallets.
     */
    post: operations['express.wallet.sendmany'];
  };
  '/api/v2/encrypt': {
    /**
     * Encrypt messages
     * @description Symmetrically encrypt an arbitrary message with provided password
     */
    post: operations['express.encrypt'];
  };
  '/api/v2/decrypt': {
    /**
     * Decrypt messages
     * @description Decrypt a ciphertext generated by encrypt route with provided password
     */
    post: operations['express.decrypt'];
  };
  '/api/v2/calculateminerfeeinfo': {
    /**
     * Calculate mining fee
     * @deprecated
     * @description Calculate the fee and estimated size in bytes for a Bitcoin transaction
     */
    post: operations['express.calculateminerfeeinfo'];
  };
  '/api/v2/{coin}/keychain/local': {
    /**
     * Create key
     * @description Local client-side function to create a new keychain.
     *
     * Creating your keychains is a critical step for safely securing your Bitcoin. When generating new keychains, this API uses a random number generator that adheres to industry standards. If you provide your own seed, you must take extreme caution when creating it.
     * Returns an object containing the xprv and xpub for the new chain. The created keychain is not known to the BitGo service. To use it with the BitGo service, use the ‘Store Keychain’ API call.
     *
     * For security reasons, it is highly recommended that you encrypt and destroy the original xprv immediately to prevent theft.
     */
    post: operations['express.keychain.local'];
  };
  '/api/v2/{coin}/wallet/generate': {
    /**
     * Generate wallet
     * @description This API call creates a new wallet. Under the hood, the SDK (or BitGo Express) does the following:
     *
     * 1. Creates the user keychain locally on the machine, and encrypts it with the provided passphrase (skipped if userKey is provided).
     * 2. Creates the backup keychain locally on the machine.
     * 3. Uploads the encrypted user keychain and public backup keychain.
     * 4. Creates the BitGo key (and the backup key if backupXpubProvider is set) on the service.
     * 5. Creates the wallet on BitGo with the 3 public keys above.
     *
     * ⓘ Ethereum wallets can only be created under an enterprise. Pass in the id of the enterprise to associate the wallet with. Your enterprise id can be seen by clicking on the “Manage Organization” link on the enterprise dropdown. Each enterprise has a fee address which will be used to pay for transaction fees on all Ethereum wallets in that enterprise. The fee address is displayed in the dashboard of the website, please fund it before creating a wallet.
     *
     * ⓘ You cannot generate a wallet by passing in a subtoken as the coin. Subtokens share wallets with their parent coin and it is not possible to create a wallet specific to one token. Please see Coin-Specific Implementation for details.
     *
     * ⓘ This endpoint should be called through BitGo Express if used without the SDK, such as when using cURL.
     */
    post: operations['express.wallet.generate'];
  };
  '//api/v2/{coin}/wallet/{walletId}/share': {
    /**
     * Share wallet
     * @description Share wallet with an existing BitGo user
     */
    post: operations['express.wallet.share'];
  };
  '/api/v2/{coin}/walletshare/{walletId}/acceptshare': {
    /**
     * Accept wallet share
     * @description Accept a wallet share, adding the wallet to the user's list
     */
    post: operations['express.wallet.acceptshare'];
  };
  '/api/v2/{coin}/signtx': {
    /**
     * Sign transaction
     * @description This route is for users who would like to maintain their own keys, or otherwise would not like BitGo to decrypt their key, and instead provide it in the clear themselves
     */
    post: operations['express.signtx'];
  };
  '/api/v2/{coin}/wallet/{walletId}/signtx': {
    /**
     * Sign wallet transaction
     * @description Sign transactions for multisignature wallets using external-signing mode. You must maintain your keys, in the clear, on a separate Express server. BitGo doesn't decrypt your private keys.
     */
    post: operations['express.wallet.signtx'];
  };
  '/api/v2/{coin}/wallet/{walletId}/signtxtss': {
    /**
     * Sign TSS transaction
     * @description Sign transactions for TSS wallets using external-signing mode. You must maintain your keys, in the clear, on a separate Express server. BitGo doesn't decrypt your private TSS key shares.
     */
    post: operations['express.wallet.signtxtss'];
  };
  '/api/v2/{coin}/wallet/{walletId}/recovertoken': {
    /**
     * Recover ETH token
     * @description Recover an unsupported Ethereum token from a BitGo multisig wallet
     */
    post: operations['express.wallet.recovertoken'];
  };
  '/api/v2/{coin}/wallet/{walletId}/consolidateAccount/build': {
    /**
     * Consolidate account (advanced)
     * @description This endpoint, builds a consolidation transaction. Once built, you must sign and send the transaction.
     * Consolidates the receive address balances to the root address of a wallet. Consolidation is limited to account-based assets.
     * The spendable balance of a wallet is the balance of the funds in the root address. Therefore, funds from wallets with multiple receive addresses must be consolidated before sending.
     */
    post: operations['v2.wallet.consolidateaccount.build'];
  };
  '/api/v2/{coin}/wallet/{walletId}/consolidateunspents': {
    /**
     * Consolidate unspents
     * @description Consolidate unspents on a wallet
     */
    post: operations['express.wallet.consolidateunspents'];
  };
  '/api/v2/{coin}/wallet/{walletId}/fanoutunspents': {
    /**
     * Fan out unspents
     * @description Fan out unspents on a wallet
     */
    post: operations['express.wallet.fanoutunspents'];
  };
  '/api/v2/{coin}/wallet/{walletId}/sweep': {
    /**
     * Sweep funds
     * @description The sweep call spends the full balance of the wallet to the provided address. On UTXO coins, the sweep call will
     * fail if the wallet has any unconfirmed funds, or if there are more unspents than can be sent with a
     * single transaction.
     */
    post: operations['express.wallet.sweep'];
  };
  '/api/v2/{coin}/wallet/{walletId}/acceleratetx': {
    /**
     * Accelerate Transaction
     * @description Send a child-pays-for-parent (CPFP) transaction to accelerate the target unconfirmed transactions.
     *
     * **Background**:
     * In Bitcoin, a transaction can only be included in a block when all its inputs are confirmed.
     * This requirement can be used to increase the effective fee rate of a stuck low-fee transaction.
     * One of the stuck transaction's outputs is spent in a child transaction with a much higher fee.
     * Miners include the transactions with the highest fees first to maximize their revenue,
     * but the high-fee child transaction can only be included once the parent transaction is confirmed.
     * The miners are therefore incentivized to include both the parent and the child transaction together in a block.
     * A child-pays-for-parent transaction can be created by a recipient of the transaction or by the sender if the
     * target transaction has a change output.
     *
     * **Notes**:
     * 1. As other coins do not have a blockspace market, this route is only available for Bitcoin at this time.<br/>
     * 2. If a target transaction depends on other unconfirmed transactions, this route adds sufficient fees
     * to elevate the entire transaction ancestry's effective fee rate to the "cpfpFeeRate".
     */
    post: operations['express.wallet.acceleratetx'];
  };
  '/api/v2/{coin}/wallet/{walletId}/transfer/{transferId}/comment': {
    /**
     * Update comment
     * @description Update the comment of a transfer
     * Requirements:
     *   - Transaction must be generated from a BitGo wallet
     */
    post: operations['v2.transfer.comment'];
  };
  '/api/v2/{coin}/wallet/{walletId}/tx/changeFee': {
    /**
     * Change Fee
     * @description Change the fee rate of a transaction in an attempt to accelerate its confirmation.
     * Supported by: ETH, ERC20 tokens, CELO, RSK, ETC
     * Requirements:
     *   - Transaction gas price must increase by at least 10 Gwei or 20% higher than the original transaction fee
     *   - At least 15 minutes must have passed since original send
     */
    post: operations['v2.wallet.changefee'];
  };
  '/api/v2/{coin}/canonicaladdress': {
    /**
     * Canonicalize address
     * @description Canonicalize an LTC or BCH address.
     */
    post: operations['express.canonicaladdress'];
  };
  '/api/v2/{coin}/verifyaddress': {
    /**
     * Verify address
     * @description Verify address for a given coin
     */
    post: operations['express.verifycoinaddress'];
  };
  '/api/v2/pendingapprovals/count': {
    /**
     * List counts of pending approvals
     * @description List counts of pending approvals by enterprises that the current user is a part of
     */
    get: operations['v2.pendingapprovals.count.list'];
  };
  '/api/v2/{coin}/pendingapprovals/{approvalId}': {
    /**
     * Resolve pending approval
     * @description Accept or reject a pending approval
     */
    put: operations['express.pendingapprovals'];
  };
  '/api/v2/auditlog': {
    /** List audit logs */
    get: operations['v2.auditlog.list'];
  };
  '/api/v2/{coin}/wallet/{walletId}/balances/staked': {
    /**
     * Get staked balance data
     * @description Returns staking information about validator and staked amount for the current wallet. Currently only available for Casper and Stacks.
     */
    get: operations['v2.wallet.staked'];
  };
  '/api/v2/{coin}/wallet/{walletId}/balances/totalrewards': {
    /**
     * Get total rewards data
     * @description Returns staking information receiving address and the total rewards received for the current wallet. Currently only available for Stacks.
     */
    get: operations['v2.wallet.totalrewards'];
  };
  '/api/v2/wallet/{walletId}/lightning/withdrawal': {
    /**
     * Withdraw from lightning balance
     * @description This API call is used to request a withdrawal of on-chain funds from the custodial lightning balance. Withdrawals are deducted from the wallet's lightning balance.
     */
    post: operations['v2.wallet.lightning.withdraw'];
  };
  '/api/v2/wallet/{walletId}/lightning/address': {
    /**
     * Create address for lightning deposits
     * @description This API call is used to create a new address to deposit funds to the
     * wallet's custodial lightning balance. Funds sent to this address will
     * be credited to the wallet's lightning balance.
     */
    post: operations['v2.wallet.lightning.newAddress'];
  };
  '/api/v2/wallet/{walletId}/lightning/invoices': {
    /**
     * Fetch lightning invoices
     * @description This API call is used to fetch previously created lightning invoices
     * associated with a given walletId.
     */
    get: operations['v2.wallet.lightning.getInvoices'];
  };
  '/api/v2/wallet/{walletId}/lightning/invoice': {
    /**
     * Create a lightning invoice
     * @description This API call is used to create a new lightning invoice which can be
     * used for requesting and receiving payments over the lightning network.
     */
    post: operations['v2.wallet.lightning.invoice'];
  };
  '/api/v2/wallet/{walletId}/lightning/balance': {
    /**
     * Get lightning balance
     * @description Get the custodial lightning balance for the wallet.
     */
    get: operations['v2.wallet.lightning.balance'];
  };
  '/api/v2/wallet/{walletId}/lightning/payment': {
    /**
     * Send a lightning payment
     * @description Send a lightning payment that pays a provided payment request using the
     * wallet's custodial lightning balance.
     */
    post: operations['v2.wallet.lightning.payment'];
  };
  '/api/v2/{coin}/wallet/{walletId}/forwarders/balances': {
    /**
     * List forwarder addresses and balances
     * @description Lists all forwarder addresses and their balances for a wallet. By default, returns low-balance forwarder addresses. A forwarder address has a low balance if the number of assets in it is less than the balance times by the current gas price times the transaction gas limit.
     */
    get: operations['v2.wallet.forwarders.balance'];
  };
  '/api/v2/{coin}/tss/pubkey': {
    /**
     * Get Bitgo TSS GPG public key
     * @description It is necessary to use correct TSS BitGo public GPG key when performing TSS operations. Different public keys might be necessary in different cases. This endpoint returns a valid GPG public key taking into account all factors, including: coin, user and enterprise feature flags. Using incorrect key may cause signing and wallet creation errors.
     */
    get: operations['v2.tsspubkey.getbycoin'];
  };
  '/api/v2/{coin}/wallet/{walletId}/sequenceIds': {
    /**
     * List last 10 contract sequenceIds of a wallet
     * @description Lists last 10 contract sequenceIds of the base address of a wallet alongwith their transaction ids.
     */
    get: operations['v2.wallet.getSequenceIds'];
  };
  '/api/v2/tssconfigs/ecdsa': {
    /**
     * List ECDSA TSS configurations per enterprise
     * @description List all ECDSA TSS configurations from all enterprises for a user. Returns an empty array if the user's enterprise doesn't have any ECDSA TSS configurations.
     */
    get: operations['v2.tssconfigs.ecdsa.get'];
    /**
     * Delete ECDSA TSS configurations
     * @description Deletes the ECDSA TSS configurations from all enterprises the user is an admin of.
     */
    delete: operations['v2.tssconfigs.ecdsa.delete'];
  };
  '/api/v2/{coin}/wallet/{walletId}/consolidateAccount': {
    /**
     * Consolidate account (simple)
     * @description This Express endpoint, builds, signs, and sends the consolidation transaction all in 1 call.
     * Consolidates the receive address balances to the root address of a wallet. Consolidation is limited to account-based assets.
     * The spendable balance of a wallet is the balance of the funds in the root address. Therefore, funds from wallets with multiple receive addresses must be consolidated before sending.
     */
    post: operations['express.wallet.consolidateAccount'];
  };
  '/api/v2/organization/{organizationId}/enterprise': {
    /**
     * Create enterprise
     * @description Create an enterprise in the specified organization. Also create a user if it doesn't already exist.
     */
    post: operations['v2.organization.enterprise.create'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/supportedCurrencies': {
    /**
     * List Partner-Supported Currencies
     * @description List currencies which can be allocated/deallocated to/from a connection to a BitGo Network Partner.
     */
    get: operations['v1EnterpriseSupportedCurrenciesRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients/settlementTransfers': {
    /**
     * List Client Settlement Transfers
     * @description Lists all settlement transfers for your BitGo Network client account.
     */
    get: operations['v1ClientSettlementTransfersGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients/settlements/{settlementId}': {
    /**
     * Get Client Settlement
     * @description This API call allows clients to get a list of settlement transactions for any connected network account, for a specific settlement. The settlement and its metadata will be returned along with all related settlement transfers in and out of the clients’ network accounts.
     */
    get: operations['v1ClientSettlementGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients/settlements': {
    /**
     * List Client Settlements
     * @description This API call allows clients to get a list of settlements that involve their accounts and their metadata.
     */
    get: operations['v1ClientSettlementsGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/partners/settlements/{settlementId}': {
    /**
     * Get Partner Settlement
     * @description Returns a settlement for your BitGo Network partner account.
     */
    get: operations['v1PartnerSettlementGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/partners/settlements': {
    /**
     * List Partner Settlements
     * @description Lists all settlements for your BitGo Network partner account.
     */
    get: operations['v1PartnerSettlementsGetRoute'];
    /**
     * Perform Partner Settlement
     * @description Partner route to perform a Settlement.
     */
    post: operations['v1PartnerSettlementsPostRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/partners/settlements/nonReconciled': {
    /**
     * [DEPRECATED] Perform Partner Settlement
     * @description [DEPRECATED] Partner route to perform a Settlement. NOTE: this route is being deprecated in favor of the POST /api/network/v1/enterprises/{enterpriseId}/partners/settlements route.
     */
    post: operations['v1PartnerSettlementsNonReconciledPostRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/partners': {
    /**
     * List Partners
     * @description Lists all BitGo Network Partners.
     */
    get: operations['v1PartnersGetRoute'];
    /**
     * Create Partner
     * @description Create a new BitGo Network Partner.
     */
    post: operations['v1PartnersPostRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients/connections/{connectionId}/deallocations': {
    /**
     * Deallocate Funds from Connection
     * @description This API call allows clients to deallocate funds from a connected partner. A successful deallocation will unlock funds and ensure that they are available for actions (withdrawal/rebalancing) at BitGo. Note: Deallocations will happen synchronously and deallocated amounts can be viewed in the BitGo Application or via a balance endpoint.
     */
    post: operations['V1ClientDeallocationsPostRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients/connections/{connectionId}': {
    /**
     * Get Client Connection
     * @description Returns a BitGo Network connection by its connection ID. For use only by BitGo Network clients.
     */
    get: operations['v1ClientConnectionGetRoute'];
    /**
     * Update Client Connection
     * @description Update a BitGo Network connection by its connection ID. For use only by BitGo Network clients.
     */
    put: operations['v1ClientConnectionPutRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/partners/connections/{connectionId}': {
    /**
     * Get Partner Connection
     * @description Returns a BitGo Network connection by its connection ID. For use only by BitGo Network partners.
     */
    get: operations['v1PartnerConnectionGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/partners/connections': {
    /**
     * List Partner Connections
     * @description Returns all your BitGo Network connections. For use only by BitGo Network partners.
     */
    get: operations['v1PartnerConnectionsGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients/connections': {
    /**
     * List Client Connections
     * @description Lists all your BitGo Network connections. For use only by BitGo Network clients.
     */
    get: operations['v1ClientConnectionsGetRoute'];
    /**
     * Connect to Partner
     * @description Connect your BitGo Network client account to a BitGo Network partner, enabling you to trade funds that you have custodied with BitGo. You must have an account on the partner's site. Clients can have multiple connections to the same partner.
     */
    post: operations['v1ClientConnectionsPostRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients': {
    /**
     * Create Client
     * @description Create a new BitGo Network client.
     */
    post: operations['v1ClientsPostRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/partners/balances': {
    /**
     * List partner balances
     * @description Lists all your BitGo Network balances. For use only by BitGo Network partners.
     */
    get: operations['v1PartnerBalancesGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients/balances': {
    /**
     * List Client Balances
     * @description This API call allows clients to get trading and allocated balances at BitGo for any connected trading partner. The trading balances are live data. The data under networkBalances are not the live balances at the partner, the live balances should be viewed on the partner’s platform. networkBalances will only update as a result of allocations, deallocations, and settlement.
     */
    get: operations['v1ClientBalancesGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients/allocations/{allocationId}': {
    /**
     * Get client Allocation or Deallocation
     * @description Returns an allocation or deallocation. For use only by BitGo Network clients.
     */
    get: operations['v1ClientAllocationGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/partners/allocations/{allocationId}': {
    /**
     * Get Partner Allocation or Deallocation
     * @description Returns an allocation or deallocation. For use only by BitGo Network partners.
     */
    get: operations['v1PartnerAllocationGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients/allocations': {
    /**
     * List Client Allocations and Deallocations
     * @description This API call allows clients to get a list of allocations & deallocations for any connected network account. Note that this endpoint requires a “types” query parameter set to “allocation” to view allocations or "deallocation" to view deallocations.
     */
    get: operations['v1ClientAllocationsGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/partners/allocations': {
    /**
     * List partner Allocations and Deallocations
     * @description Lists all allocations and deallocations. For use only by BitGo Network partners.
     */
    get: operations['v1PartnerAllocationsGetRoute'];
  };
  '/api/network/v1/enterprises/{enterpriseId}/clients/connections/{connectionId}/allocations': {
    /**
     * Allocate funds to Partner Connection
     * @description This API call allows clients to allocate funds to a connected partner for trade. A successful allocation indicates that funds are locked at BitGo and available for spend on the connected partner. Note: Allocations will happen synchronously and allocated amounts can be viewed in the BitGo Application or via a balances endpoint.
     */
    post: operations['V1ClientAllocationsPostRoute'];
  };
  '/api/clearing/v1/enterprise/{enterpriseId}/account/{accountId}/trading-partners': {
    /**
     * List settlement trading partners
     * @description List trading partners (counterparties) for a trading account.
     */
    get: operations['V1ListTradingPartnersByAccountRoute'];
  };
  '/api/clearing/v1/enterprise/{enterpriseId}/account/{accountId}/trading-partner': {
    /**
     * List settlement trading partners
     * @description Creates a trading partner (counterparty) for a trading account.
     */
    post: operations['V1TradingPartnerPostRoute'];
  };
  '/api/clearing/v1/enterprise/{enterpriseId}/account/{accountId}/settlements': {
    /**
     * List settlements by account
     * @description List settlements by trading account.
     */
    get: operations['V1ListSettlementsByAccountRoute'];
  };
  '/api/clearing/v1/enterprise/{enterpriseId}/settlements': {
    /**
     * List settlements by enterprise
     * @description List settlements by enterprise.
     */
    get: operations['V1ListSettlementsByEnterpriseRoute'];
  };
  '/api/clearing/v1/enterprise/{enterpriseId}/account/{accountId}/settlement/{settlementId}': {
    /**
     * Get settlement by ID.
     * @description Get settlement by ID.
     */
    get: operations['V1GetSettlementByIdRoute'];
  };
  '/api/clearing/v1/enterprise/{enterpriseId}/account/{accountId}/settlement': {
    /**
     * Create settlement
     * @description Creates a settlement.
     */
    post: operations['V1EnterpriseAccountSettlementPostRoute'];
  };
  '/api/clearing/v1/enterprise/{enterpriseId}/account/{accountId}/settlement/{settlementId}/signing': {
    /**
     * Get settlement signing
     * @description Get settlement signing.
     */
    get: operations['V1GetSettlementSigningRoute'];
    /**
     * Sign settlement
     * @description Signs a Settlement.
     */
    post: operations['V1PostSettlementSigningRoute'];
  };
  '/api/clearing/v1/enterprise/{enterpriseId}/account/{accountId}/approval-requests/{approvalRequestId}': {
    /**
     * Update settlement approval request
     * @description Update an approval request for a settlement.
     */
    put: operations['V1ApprovalRequestPutRoute'];
  };
  '/api/clearing/v1/enterprise/{enterpriseId}/account-settings/{accountId}': {
    /**
     * Get settlement trading account settings
     * @description Get settlement settings for a trading account.
     */
    get: operations['V1AccountSettingsGetRoute'];
  };
  '/api/v1/marketdata/cryptocompare/historical/prices': {
    /**
     * Get historical prices
     * @description Get a list of historical prices in a specified time range. Using this endpoint requires an access token with the appropriate enterprise ID.
     */
    get: operations['marketdata.cryptocompare.historical.prices.get'];
  };
  '/api/v1/marketdata/cryptocompare/spot/prices': {
    /**
     * Get spot prices
     * @description Get historical spot prices from a specific time. Using this endpoint requires an access token with the appropriate enterprise ID.
     */
    get: operations['marketdata.cryptocompare.spot.prices.get'];
  };
  '/api/v1/internal/marketdata/spot/prices': {
    /**
     * Get spot prices
     * @description Get historical spot prices from a specific time.
     */
    get: operations['internal.marketdata.spot.prices.get'];
  };
  '/api/portfolio/v1/user/current': {
    /**
     * Get Current User
     * @description Get the current user’s public information
     */
    get: operations['portfolio.user.current'];
  };
  '/api/portfolio/v1/portfolios': {
    /**
     * List Portfolios
     * @description Get a list of the portfolios to which the user with the access token belongs
     */
    get: operations['portfolio.portfolios'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/historical_prices': {
    /**
     * List Historical Prices
     * @description Get a list of daily historical prices in the portfolio's functional currency - defaults to prior month
     */
    get: operations['portfolio.prices'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/connections': {
    /**
     * List Connections
     * @description Get a list of the connections for a given portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.connections'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/connections/{connectionId}': {
    /**
     * Get Connection
     * @description Get information for a single connection within a given portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.connection'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/accounts': {
    /**
     * List Accounts
     * @description Get a list of the accounts for a given portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.accounts'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/accounts/{accountId}': {
    /**
     * Get Account
     * @description Get information for a single account within a given portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.account'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/balances': {
    /**
     * List Balances
     * @description Get balance information (grouped by instrument) for a single portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.balances'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/connections/{connectionId}/balances': {
    /**
     * List Connection Balances
     * @description Get balance information (grouped by instrument) for a single connection within a given portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.connection.balances'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/accounts/{accountId}/balances': {
    /**
     * List Account Balances
     * @description Get balance information (grouped by instrument) for a single account within a given portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.account.balances'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/transactions': {
    /**
     * List Transactions
     * @description List all transactions for a given portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.transactions'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/transactions/{transactionId}': {
    /**
     * Get Transaction
     * @description Get details for a single transaction by Transaction ID within a given portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.transaction'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/line_items': {
    /**
     * List Line Items
     * @description List all accounting line items within a given portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.line_items'];
  };
  '/api/portfolio/v1/portfolios/{portfolioId}/line_items/{itemId}': {
    /**
     * Get Line Item
     * @description Get details for a single accounting line item by Line Item ID within a given portfolio to which the user with the access token belongs
     */
    get: operations['portfolio.line_item'];
  };
  '/api/prime/trading/v1/user/current': {
    /**
     * Get Current User
     * @description Get the current user’s public information.
     */
    get: operations['trade.user.current'];
  };
  '/api/prime/trading/v1/accounts': {
    /**
     * List Accounts
     * @description Get the list of trading accounts that the current user belongs to.
     */
    get: operations['trade.accounts'];
  };
  '/api/prime/trading/v1/accounts/{accountId}/balances': {
    /**
     * Get Account Balance
     * @description Get balance information about a single trading account.
     */
    get: operations['trade.accounts.balances'];
  };
  '/api/prime/trading/v1/accounts/{accountId}/orders': {
    /**
     * List Orders
     * @description Lists all orders from the given trading account.
     */
    get: operations['trade.orders.detail'];
    /**
     * Place Order
     * @description Places a new order. There are several types of orders available - Market, Limit, and TWAP (with or without a limit). Orders can only be placed if your account has a sufficient balance. When an order is placed, funds will be reserved for the amount of the order.
     */
    post: operations['trade.orders.add'];
  };
  '/api/prime/trading/v1/accounts/{accountId}/orders/{orderId}': {
    /**
     * Get Order
     * @description Get a single order by order id.
     */
    get: operations['trade.orders.order'];
  };
  '/api/prime/trading/v1/accounts/{accountId}/orders/{orderId}/cancel': {
    /**
     * Cancel Order
     * @description Attempt to cancel an order that was previously placed. The response will return successful if the cancel request is submitted. Use Get Order endpoint or subscribe to the orders websocket to get the order details.
     */
    put: operations['trade.orders.order.cancel'];
  };
  '/api/prime/trading/v1/accounts/{accountId}/trades': {
    /**
     * List Trades
     * @description Lists trades from the trading account. This will include trades that have not yet settled.
     */
    get: operations['trade.trades'];
  };
  '/api/prime/trading/v1/accounts/{accountId}/trades/{tradeId}': {
    /**
     * Get Trade
     * @description Get the details of a single trade by trade id.
     */
    get: operations['trade.trades.trade'];
  };
  '/api/prime/trading/v1/accounts/{accountId}/currencies': {
    /**
     * List Currencies
     * @description Gets a list of all available currencies.
     */
    get: operations['trade.currencies'];
  };
  '/api/prime/trading/v1/accounts/{accountId}/products': {
    /**
     * List Products
     * @description Gets a list of all available products.
     */
    get: operations['trade.products'];
  };
  '/api/prime/trading/v1/accounts/{accountId}/products/{product}/level1': {
    /**
     * Get Level1 Order Book
     * @description Gets a snapshot of the level1 order book for product
     */
    get: operations['trade.products.product.level1'];
  };
  '/api/prime/trading/v1/accounts/{accountId}/products/{product}/level2': {
    /**
     * Get Level2 Order Book
     * @description Gets a snapshot of the order book for product
     */
    get: operations['products.product.level2'];
  };
  '/api/staking/v1/{coin}/wallets/{walletId}/requests': {
    /**
     * Retrieve Staking Requests for a User's Wallet
     * @description Retrieve Staking Requests for a User's Wallet.
     */
    get: operations['Retrieve Staking Requests for a Users Wallet'];
    /**
     * Staking Request Creation
     * @description Create a Staking Request of type STAKE or UNSTAKE.
     */
    post: operations['Create staking request'];
  };
  '/api/staking/v1/wallets/{walletId}/requests': {
    /**
     * List Staking Requests for a Wallet
     * @description List Staking Requests for a Wallet.
     */
    get: operations['List Filtered Staking Requests for a Wallet'];
  };
  '/api/staking/v1/requests/{stakingRequestId}': {
    /**
     * Retrieve Staking Request for a staking request id
     * @description Retrieve A Specific Staking Request.
     */
    get: operations['Retrieve A Specific Staking Request'];
  };
  '/api/staking/v1/enterprises/{enterpriseId}/requests/transactions': {
    /**
     * Retrieve staking requests and staking transactions for a given enterprise and query params
     * @description Retrieve staking requests and staking transactions for a given enterprise and query params.
     */
    get: operations['Retrieve staking requests for a given enterprise'];
  };
  '/api/staking/v1/{coin}/wallets/{walletId}/requests/{stakingRequestId}/transactions/{stakingTransactionId}': {
    /**
     * Act On A Transaction like sending a transaction
     * @description Use to act on a transaction like sending a transaction
     */
    post: operations['Act On A Transaction'];
  };
  '/api/staking/v1/{coin}/wallets/{walletId}': {
    /**
     * Get Staking Wallet Details
     * @description Get staking wallet information including staking delegated balance, rewards accrued, and rewards accrual annual percentage rate.
     */
    get: operations['v1.stakingWallet.get'];
  };
  '/api/staking/v1/{coin}/wallets/{walletId}/delegations': {
    /**
     * Retrieve Staking Wallet Delegations
     * @description Retrieve staking wallet delegation information.
     */
    get: operations['Retrieve Staking Wallet Delegations'];
  };
  '/api/staking/v1/{coin}/enterprises/{enterpriseId}': {
    /**
     * Retrieve Staking Enterprise Information
     * @description Retrieve staking staking information like staking delegated balance, rewards accrued, and rewards accrual annual percentage rate.
     */
    get: operations['Retrieve Staking Enterprise Information'];
  };
  '/api/staking/v1/{coin}/reward-accrual-report': {
    /**
     * Retrieve Staking Reward History
     * @description Retrieve staking staking reward history.
     */
    get: operations['Retrieve Staking Reward History'];
  };
  '/api/staking/v1/{coin}/wallets/{walletId}/delegations/accruals': {
    /**
     * Retrieve Staking Delegation Accrual History
     * @description Retrieve staking delegation accrual history.
     */
    get: operations['Retrieve Staking Delegation Accrual History'];
  };
  '/api/staking/v1/{coin}/wallets/{walletId}/attributes': {
    /**
     * Retrieve Staking Wallet State Attribute Information
     * @description Retrieve Staking Wallet State Attribute Information.
     */
    get: operations['Retrieve Staking Wallet State Attribute Information'];
  };
  '/api/staking/v1/coins': {
    /**
     * Retrieve coins available for staking and some basic information
     * @description Retrieve coins available for staking and some basic information
     */
    get: operations['Retrieve coins available for staking and some basic information'];
  };
  '/api/staking/v1/{coin}/wallets/{walletId}/validators': {
    /**
     * List staking validators for a wallet
     * @description Returns a list of staking validators for a wallet, and includes the total delegated amount and the amount of accrued rewards.
     */
    get: operations['v1.validators.list'];
  };
  '/api/staking/v1/validators': {
    /**
     * List staking partnered validators
     * @description Returns a list of staking partnered validators.
     */
    get: operations['v1.partneredValidators.list'];
  };
  '/api/staking/v1/enterprises/{enterpriseId}/license': {
    /**
     * Get staking license
     * @description Returns a staking license for the given enterprise.
     */
    get: operations['v1.license'];
  };
  '/api/staking/v1/enterprises/{enterpriseId}/wallets': {
    /**
     * List Enterprise Staking Wallets Rewards
     * @description Returns total rewards per staking wallet for an enterprise.
     */
    get: operations['v1.enterprise.stakingWallets.list'];
  };
  '/api/trade/v1/enterprise/{enterpriseId}/account/{accountId}/settings': {
    /**
     * Get Trading Account Settings
     * @description The Get Trading Account Settings API displays the current settings on your trading account.
     */
    get: operations['v1.trade.getAccountSettings'];
    /**
     * Update Trading Account Settings
     * @description The Update Trading Account Settings API allows you to modify the settings on your trading account.
     */
    put: operations['v1.trade.updateAccountSettings'];
  };
  '/api/trade/v1/enterprise/{enterpriseId}/account/{accountId}/tradingpartners': {
    /**
     * List Trading Partners
     * @description The List Trading Partners API gets the trading partners for the given trading account.
     */
    get: operations['v1.tradingPartner.listTradingPartners'];
    /**
     * Add Trading Partner
     * @description The Add Trading Partners API lets you add a trading partner given your trading partner's referral code
     */
    post: operations['v1.tradingPartner.add'];
  };
  '/api/trade/v1/enterprise/{enterpriseId}/tradingpartners': {
    /**
     * List Trading Partners By Enterprise
     * @description The List Trading Partners By Enterprise API gets the trading partners for the given enterprise.
     */
    get: operations['v1.tradingPartner.listTradingPartnersByEnterprise'];
  };
  '/api/trade/v1/enterprise/{enterpriseId}/account/{accountId}/tradingpartners/{partnershipId}': {
    /**
     * Update Trading Partner Request
     * @description The Update Trading Partner Request API allows you to accept, reject, or cancel a pending trading partner request
     */
    put: operations['v1.tradingPartner.update'];
  };
  '/api/trade/v1/enterprise/{enterpriseId}/account/{accountId}/tradingpartners/{partnerAccountId}/balance': {
    /**
     * Account Balance Check
     * @description The Account Balance Check API verifies whether an account has enough funds to support a settlement of some amount.
     */
    get: operations['v1.tradingPartner.accountBalanceCheck'];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    ConflictingParameters: {
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'Invalid';
      /**
       * @description Human-readable error message
       * @enum {string}
       */
      error: 'Only one of walletId or walletType can be provided';
      /** @description Client request id */
      requestId: string;
    };
    /** UUID */
    UUID: string;
    /** NonEmptyString */
    NonEmptyString: string;
    /** BNSupportedCurrency */
    BNSupportedCurrency: string;
    /** V1SupportedCurrencies */
    V1SupportedCurrencies: {
      [key: string]: {
        ofcCurrency: string;
        backingCurrency: string;
        partnerNames: string[];
      }[];
    };
    /** V1EnterpriseSupportedCurrenciesResponse */
    V1EnterpriseSupportedCurrenciesResponse: {
      /** V1SupportedCurrencies */
      supportedCurrencies: {
        [key: string]: {
          ofcCurrency: string;
          backingCurrency: string;
          partnerNames: string[];
        }[];
      };
      /** NonEmptyString */
      domain: string;
    };
    /** V1ErrorPayload */
    V1ErrorPayload: {
      error: string;
    };
    /**
     * TrustOrg
     * @enum {string}
     */
    TrustOrg: 'BitGo Trust' | 'BitGo New York' | 'BitGo Germany' | 'BitGo Switzerland' | 'Frankfurt DE Trust';
    /** V1SupportedCurrenciesResponse */
    V1SupportedCurrenciesResponse: {
      /** V1SupportedCurrencies */
      supportedCurrencies: {
        [key: string]: {
          ofcCurrency: string;
          backingCurrency: string;
          partnerNames: string[];
        }[];
      };
      /** NonEmptyString */
      domain: string;
    };
    /** IntFromString */
    IntFromString: string;
    /** PageSize */
    PageSize: string;
    /** OfcTokenIdentifier */
    OfcTokenIdentifier: string;
    /**
     * SettlementStatuses
     * @enum {string}
     */
    SettlementStatuses: 'failed' | 'completed' | 'pending';
    /** NonZeroBigIntFromString */
    NonZeroBigIntFromString: string;
    /** MaskedV1SettlementTransfersOutput */
    MaskedV1SettlementTransfersOutput: {
      /** UUID */
      id: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      /** NonEmptyString */
      currency: string;
      /** UUID */
      settlementId: string;
      /** NonZeroBigIntFromString */
      quantity: string;
      txIds: {
        length: number;
        toString: Record<string, never>;
        toLocaleString: Record<string, never>;
        concat: Record<string, never>;
        join: Record<string, never>;
        slice: Record<string, never>;
        indexOf: Record<string, never>;
        lastIndexOf: Record<string, never>;
        every: Record<string, never>;
        some: Record<string, never>;
        forEach: Record<string, never>;
        map: Record<string, never>;
        filter: Record<string, never>;
        reduce: Record<string, never>;
        reduceRight: Record<string, never>;
        find: Record<string, never>;
        findIndex: Record<string, never>;
        entries: Record<string, never>;
        keys: Record<string, never>;
        values: Record<string, never>;
        includes: Record<string, never>;
        flatMap: Record<string, never>;
        flat: Record<string, never>;
        '__@iterator@82': Record<string, never>;
      };
      /**
       * SettlementStatuses
       * @enum {string}
       */
      settlementStatus: 'failed' | 'completed' | 'pending';
      /** NonEmptyString */
      sourceTradingAccountId?: string;
      /** NonEmptyString */
      sourceClientName?: string;
      /** NonEmptyString */
      destinationTradingAccountId?: string;
      /** NonEmptyString */
      destinationClientName?: string;
      /** UUID */
      sourceNetworkAccountId?: string;
      /** NonEmptyString */
      sourceConnectionName?: string;
      /** UUID */
      destinationNetworkAccountId?: string;
      /** NonEmptyString */
      destinationConnectionName?: string;
    }[];
    /** V1ClientGetSettlementTransfersOkPayload */
    V1ClientGetSettlementTransfersOkPayload: {
      /** MaskedV1SettlementTransfersOutput */
      settlementTransfers: {
        /** UUID */
        id: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** NonEmptyString */
        currency: string;
        /** UUID */
        settlementId: string;
        /** NonZeroBigIntFromString */
        quantity: string;
        txIds: {
          length: number;
          toString: Record<string, never>;
          toLocaleString: Record<string, never>;
          concat: Record<string, never>;
          join: Record<string, never>;
          slice: Record<string, never>;
          indexOf: Record<string, never>;
          lastIndexOf: Record<string, never>;
          every: Record<string, never>;
          some: Record<string, never>;
          forEach: Record<string, never>;
          map: Record<string, never>;
          filter: Record<string, never>;
          reduce: Record<string, never>;
          reduceRight: Record<string, never>;
          find: Record<string, never>;
          findIndex: Record<string, never>;
          entries: Record<string, never>;
          keys: Record<string, never>;
          values: Record<string, never>;
          includes: Record<string, never>;
          flatMap: Record<string, never>;
          flat: Record<string, never>;
          '__@iterator@82': Record<string, never>;
        };
        /**
         * SettlementStatuses
         * @enum {string}
         */
        settlementStatus: 'failed' | 'completed' | 'pending';
        /** NonEmptyString */
        sourceTradingAccountId?: string;
        /** NonEmptyString */
        sourceClientName?: string;
        /** NonEmptyString */
        destinationTradingAccountId?: string;
        /** NonEmptyString */
        destinationClientName?: string;
        /** UUID */
        sourceNetworkAccountId?: string;
        /** NonEmptyString */
        sourceConnectionName?: string;
        /** UUID */
        destinationNetworkAccountId?: string;
        /** NonEmptyString */
        destinationConnectionName?: string;
      }[];
    };
    /** V1SettlementTransfersOutput */
    V1SettlementTransfersOutput: {
      /** NonEmptyString */
      sourceTradingAccountId: string;
      /** UUID */
      sourceNetworkAccountId?: string;
      /** NonEmptyString */
      destinationTradingAccountId: string;
      /** UUID */
      destinationNetworkAccountId: string;
      /** UUID */
      id: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      /** NonEmptyString */
      currency: string;
      /** UUID */
      settlementId: string;
      /** NonZeroBigIntFromString */
      quantity: string;
      txIds: {
        length: number;
        toString: Record<string, never>;
        toLocaleString: Record<string, never>;
        concat: Record<string, never>;
        join: Record<string, never>;
        slice: Record<string, never>;
        indexOf: Record<string, never>;
        lastIndexOf: Record<string, never>;
        every: Record<string, never>;
        some: Record<string, never>;
        forEach: Record<string, never>;
        map: Record<string, never>;
        filter: Record<string, never>;
        reduce: Record<string, never>;
        reduceRight: Record<string, never>;
        find: Record<string, never>;
        findIndex: Record<string, never>;
        entries: Record<string, never>;
        keys: Record<string, never>;
        values: Record<string, never>;
        includes: Record<string, never>;
        flatMap: Record<string, never>;
        flat: Record<string, never>;
        '__@iterator@82': Record<string, never>;
      };
    }[];
    /** V1AdminGetSettlementTransfersOkPayload */
    V1AdminGetSettlementTransfersOkPayload: {
      /** V1SettlementTransfersOutput */
      settlementTransfers: {
        /** NonEmptyString */
        sourceTradingAccountId: string;
        /** UUID */
        sourceNetworkAccountId?: string;
        /** NonEmptyString */
        destinationTradingAccountId: string;
        /** UUID */
        destinationNetworkAccountId: string;
        /** UUID */
        id: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** NonEmptyString */
        currency: string;
        /** UUID */
        settlementId: string;
        /** NonZeroBigIntFromString */
        quantity: string;
        txIds: {
          length: number;
          toString: Record<string, never>;
          toLocaleString: Record<string, never>;
          concat: Record<string, never>;
          join: Record<string, never>;
          slice: Record<string, never>;
          indexOf: Record<string, never>;
          lastIndexOf: Record<string, never>;
          every: Record<string, never>;
          some: Record<string, never>;
          forEach: Record<string, never>;
          map: Record<string, never>;
          filter: Record<string, never>;
          reduce: Record<string, never>;
          reduceRight: Record<string, never>;
          find: Record<string, never>;
          findIndex: Record<string, never>;
          entries: Record<string, never>;
          keys: Record<string, never>;
          values: Record<string, never>;
          includes: Record<string, never>;
          flatMap: Record<string, never>;
          flat: Record<string, never>;
          '__@iterator@82': Record<string, never>;
        };
      }[];
    };
    /** V1SettlementOutput */
    V1SettlementOutput: OneOf<
      [
        {
          /** @enum {string} */
          status: 'pending';
          /** NonEmptyString */
          notes?: string;
          /** NonEmptyString */
          reason?: string;
          /** Format: date */
          createdAt: string;
          /** Format: date */
          updatedAt: string;
          /** UUID */
          id: string;
          /** UUID */
          partnerId: string;
          /** NonEmptyString */
          externalId: string;
          reconciled: boolean;
          /** NonEmptyString */
          initiatedBy: string;
        },
        {
          /** @enum {string} */
          status: 'failed';
          /** NonEmptyString */
          reason: string;
          /** NonEmptyString */
          notes?: string;
          /** Format: date */
          createdAt: string;
          /** Format: date */
          updatedAt: string;
          /** UUID */
          id: string;
          /** UUID */
          partnerId: string;
          /** NonEmptyString */
          externalId: string;
          reconciled: boolean;
          /** NonEmptyString */
          initiatedBy: string;
        },
        {
          /** @enum {string} */
          status: 'completed';
          /** NonEmptyString */
          notes?: string;
          /** NonEmptyString */
          reason?: string;
          /** Format: date */
          createdAt: string;
          /** Format: date */
          updatedAt: string;
          /** UUID */
          id: string;
          /** UUID */
          partnerId: string;
          /** NonEmptyString */
          externalId: string;
          reconciled: boolean;
          /** NonEmptyString */
          initiatedBy: string;
        }
      ]
    >;
    /** V1ClientGetSettlementOkPayload */
    V1ClientGetSettlementOkPayload: {
      /** V1SettlementOutput */
      settlement: OneOf<
        [
          {
            /** @enum {string} */
            status: 'pending';
            /** NonEmptyString */
            notes?: string;
            /** NonEmptyString */
            reason?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** UUID */
            id: string;
            /** UUID */
            partnerId: string;
            /** NonEmptyString */
            externalId: string;
            reconciled: boolean;
            /** NonEmptyString */
            initiatedBy: string;
          },
          {
            /** @enum {string} */
            status: 'failed';
            /** NonEmptyString */
            reason: string;
            /** NonEmptyString */
            notes?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** UUID */
            id: string;
            /** UUID */
            partnerId: string;
            /** NonEmptyString */
            externalId: string;
            reconciled: boolean;
            /** NonEmptyString */
            initiatedBy: string;
          },
          {
            /** @enum {string} */
            status: 'completed';
            /** NonEmptyString */
            notes?: string;
            /** NonEmptyString */
            reason?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** UUID */
            id: string;
            /** UUID */
            partnerId: string;
            /** NonEmptyString */
            externalId: string;
            reconciled: boolean;
            /** NonEmptyString */
            initiatedBy: string;
          }
        ]
      >;
      /** MaskedV1SettlementTransfersOutput */
      settlementTransfers: {
        /** UUID */
        id: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** NonEmptyString */
        currency: string;
        /** UUID */
        settlementId: string;
        /** NonZeroBigIntFromString */
        quantity: string;
        txIds: {
          length: number;
          toString: Record<string, never>;
          toLocaleString: Record<string, never>;
          concat: Record<string, never>;
          join: Record<string, never>;
          slice: Record<string, never>;
          indexOf: Record<string, never>;
          lastIndexOf: Record<string, never>;
          every: Record<string, never>;
          some: Record<string, never>;
          forEach: Record<string, never>;
          map: Record<string, never>;
          filter: Record<string, never>;
          reduce: Record<string, never>;
          reduceRight: Record<string, never>;
          find: Record<string, never>;
          findIndex: Record<string, never>;
          entries: Record<string, never>;
          keys: Record<string, never>;
          values: Record<string, never>;
          includes: Record<string, never>;
          flatMap: Record<string, never>;
          flat: Record<string, never>;
          '__@iterator@82': Record<string, never>;
        };
        /**
         * SettlementStatuses
         * @enum {string}
         */
        settlementStatus: 'failed' | 'completed' | 'pending';
        /** NonEmptyString */
        sourceTradingAccountId?: string;
        /** NonEmptyString */
        sourceClientName?: string;
        /** NonEmptyString */
        destinationTradingAccountId?: string;
        /** NonEmptyString */
        destinationClientName?: string;
        /** UUID */
        sourceNetworkAccountId?: string;
        /** NonEmptyString */
        sourceConnectionName?: string;
        /** UUID */
        destinationNetworkAccountId?: string;
        /** NonEmptyString */
        destinationConnectionName?: string;
      }[];
    };
    /** V1ListSettlementsOkPayload */
    V1ListSettlementsOkPayload: {
      settlements: OneOf<
        [
          {
            /** @enum {string} */
            status: 'pending';
            /** NonEmptyString */
            notes?: string;
            /** NonEmptyString */
            reason?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** UUID */
            id: string;
            /** UUID */
            partnerId: string;
            /** NonEmptyString */
            externalId: string;
            reconciled: boolean;
            /** NonEmptyString */
            initiatedBy: string;
          },
          {
            /** @enum {string} */
            status: 'failed';
            /** NonEmptyString */
            reason: string;
            /** NonEmptyString */
            notes?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** UUID */
            id: string;
            /** UUID */
            partnerId: string;
            /** NonEmptyString */
            externalId: string;
            reconciled: boolean;
            /** NonEmptyString */
            initiatedBy: string;
          },
          {
            /** @enum {string} */
            status: 'completed';
            /** NonEmptyString */
            notes?: string;
            /** NonEmptyString */
            reason?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** UUID */
            id: string;
            /** UUID */
            partnerId: string;
            /** NonEmptyString */
            externalId: string;
            reconciled: boolean;
            /** NonEmptyString */
            initiatedBy: string;
          }
        ]
      >[];
    };
    /** V1SettlementTransferOutput */
    V1SettlementTransferOutput: {
      /** NonEmptyString */
      sourceTradingAccountId: string;
      /** UUID */
      sourceNetworkAccountId?: string;
      /** NonEmptyString */
      destinationTradingAccountId: string;
      /** UUID */
      destinationNetworkAccountId: string;
      /** UUID */
      id: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      /** NonEmptyString */
      currency: string;
      /** UUID */
      settlementId: string;
      /** NonZeroBigIntFromString */
      quantity: string;
      txIds: {
        length: number;
        toString: Record<string, never>;
        toLocaleString: Record<string, never>;
        concat: Record<string, never>;
        join: Record<string, never>;
        slice: Record<string, never>;
        indexOf: Record<string, never>;
        lastIndexOf: Record<string, never>;
        every: Record<string, never>;
        some: Record<string, never>;
        forEach: Record<string, never>;
        map: Record<string, never>;
        filter: Record<string, never>;
        reduce: Record<string, never>;
        reduceRight: Record<string, never>;
        find: Record<string, never>;
        findIndex: Record<string, never>;
        entries: Record<string, never>;
        keys: Record<string, never>;
        values: Record<string, never>;
        includes: Record<string, never>;
        flatMap: Record<string, never>;
        flat: Record<string, never>;
        '__@iterator@82': Record<string, never>;
      };
    };
    /** V1GetSettlementOkPayload */
    V1GetSettlementOkPayload: {
      /** V1SettlementOutput */
      settlement: OneOf<
        [
          {
            /** @enum {string} */
            status: 'pending';
            /** NonEmptyString */
            notes?: string;
            /** NonEmptyString */
            reason?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** UUID */
            id: string;
            /** UUID */
            partnerId: string;
            /** NonEmptyString */
            externalId: string;
            reconciled: boolean;
            /** NonEmptyString */
            initiatedBy: string;
          },
          {
            /** @enum {string} */
            status: 'failed';
            /** NonEmptyString */
            reason: string;
            /** NonEmptyString */
            notes?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** UUID */
            id: string;
            /** UUID */
            partnerId: string;
            /** NonEmptyString */
            externalId: string;
            reconciled: boolean;
            /** NonEmptyString */
            initiatedBy: string;
          },
          {
            /** @enum {string} */
            status: 'completed';
            /** NonEmptyString */
            notes?: string;
            /** NonEmptyString */
            reason?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** UUID */
            id: string;
            /** UUID */
            partnerId: string;
            /** NonEmptyString */
            externalId: string;
            reconciled: boolean;
            /** NonEmptyString */
            initiatedBy: string;
          }
        ]
      >;
      settlementTransfers: {
        /** NonEmptyString */
        sourceTradingAccountId: string;
        /** UUID */
        sourceNetworkAccountId?: string;
        /** NonEmptyString */
        destinationTradingAccountId: string;
        /** UUID */
        destinationNetworkAccountId: string;
        /** UUID */
        id: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** NonEmptyString */
        currency: string;
        /** UUID */
        settlementId: string;
        /** NonZeroBigIntFromString */
        quantity: string;
        txIds: {
          length: number;
          toString: Record<string, never>;
          toLocaleString: Record<string, never>;
          concat: Record<string, never>;
          join: Record<string, never>;
          slice: Record<string, never>;
          indexOf: Record<string, never>;
          lastIndexOf: Record<string, never>;
          every: Record<string, never>;
          some: Record<string, never>;
          forEach: Record<string, never>;
          map: Record<string, never>;
          filter: Record<string, never>;
          reduce: Record<string, never>;
          reduceRight: Record<string, never>;
          find: Record<string, never>;
          findIndex: Record<string, never>;
          entries: Record<string, never>;
          keys: Record<string, never>;
          values: Record<string, never>;
          includes: Record<string, never>;
          flatMap: Record<string, never>;
          flat: Record<string, never>;
          '__@iterator@82': Record<string, never>;
        };
      }[];
    };
    /** V1CompleteSettlementOutput */
    V1CompleteSettlementOutput: {
      /** @enum {string} */
      status: 'completed';
      /** NonEmptyString */
      notes?: string;
      /** NonEmptyString */
      reason?: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      /** UUID */
      id: string;
      /** UUID */
      partnerId: string;
      /** NonEmptyString */
      externalId: string;
      reconciled: boolean;
      /** NonEmptyString */
      initiatedBy: string;
    };
    /** V1PartnerSettlementOkPayload */
    V1PartnerSettlementOkPayload: {
      /** V1CompleteSettlementOutput */
      settlement: {
        /** @enum {string} */
        status: 'completed';
        /** NonEmptyString */
        notes?: string;
        /** NonEmptyString */
        reason?: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** UUID */
        id: string;
        /** UUID */
        partnerId: string;
        /** NonEmptyString */
        externalId: string;
        reconciled: boolean;
        /** NonEmptyString */
        initiatedBy: string;
      };
    };
    /** V1PartnerIncompleteSettlementOrErrorPayload */
    V1PartnerIncompleteSettlementOrErrorPayload: OneOf<
      [
        {
          error: string;
        },
        {
          settlement: OneOf<
            [
              {
                /** @enum {string} */
                status: 'pending';
                /** NonEmptyString */
                notes?: string;
                /** NonEmptyString */
                reason?: string;
                /** Format: date */
                createdAt: string;
                /** Format: date */
                updatedAt: string;
                /** UUID */
                id: string;
                /** UUID */
                partnerId: string;
                /** NonEmptyString */
                externalId: string;
                reconciled: boolean;
                /** NonEmptyString */
                initiatedBy: string;
              },
              {
                /** @enum {string} */
                status: 'failed';
                /** NonEmptyString */
                reason: string;
                /** NonEmptyString */
                notes?: string;
                /** Format: date */
                createdAt: string;
                /** Format: date */
                updatedAt: string;
                /** UUID */
                id: string;
                /** UUID */
                partnerId: string;
                /** NonEmptyString */
                externalId: string;
                reconciled: boolean;
                /** NonEmptyString */
                initiatedBy: string;
              }
            ]
          >;
        }
      ]
    >;
    /**
     * nullable
     * @description Error: Not codec <A, O>(codec: import("/Users/manavchawla/bitgo-dev/api-docs/bitgo-microservices/packages/lib/bitgo-network-types/node_modules/io-ts/lib/index").Type<A, O, unknown>) => import("/Users/manavchawla/bitgo-dev/api-docs/bitgo-microservices/packages/lib/bitgo-network-types/node_modules/io-ts/lib/index").UnionC<[import("/Users/manavchawla/bitgo-dev/api-docs/bitgo-microservices/packages/lib/bitgo-network-types/node_modules/io-ts/lib/index").Type<A, O, unknown>, import("/Users/manavchawla/bitgo-dev/api-docs/bitgo-microservices/packages/lib/bitgo-network-types/node_modules/io-ts/lib/index").NullC]>
     */
    nullable: unknown;
    /**
     * PartnerConnectionKeySchema
     * @enum {string}
     */
    PartnerConnectionKeySchema: 'token' | 'tokenAndSignature';
    /** V1PartnersOutput */
    V1PartnersOutput: {
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      /** UUID */
      id: string;
      /** NonEmptyString */
      enterpriseId: string;
      institutionId: null | string;
      /** NonEmptyString */
      name: string;
      /**
       * PartnerConnectionKeySchema
       * @enum {string}
       */
      connectionKeySchema: 'token' | 'tokenAndSignature';
      /** UUID */
      clientId: string;
      broker: boolean;
    };
    /** V1PartnerAdminPutOkPayload */
    V1PartnerAdminPutOkPayload: {
      /** V1PartnersOutput */
      partner: {
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** UUID */
        id: string;
        /** NonEmptyString */
        enterpriseId: string;
        institutionId: null | string;
        /** NonEmptyString */
        name: string;
        /**
         * PartnerConnectionKeySchema
         * @enum {string}
         */
        connectionKeySchema: 'token' | 'tokenAndSignature';
        /** UUID */
        clientId: string;
        broker: boolean;
      };
    };
    /** V1PartnersAdminGetOkPayload */
    V1PartnersAdminGetOkPayload: {
      partners: {
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** UUID */
        id: string;
        /** NonEmptyString */
        enterpriseId: string;
        institutionId: null | string;
        /** NonEmptyString */
        name: string;
        /**
         * PartnerConnectionKeySchema
         * @enum {string}
         */
        connectionKeySchema: 'token' | 'tokenAndSignature';
        /** UUID */
        clientId: string;
        broker: boolean;
      }[];
    };
    /** V1PartnersPostOkPayload */
    V1PartnersPostOkPayload: {
      /** V1PartnersOutput */
      partner: {
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** UUID */
        id: string;
        /** NonEmptyString */
        enterpriseId: string;
        institutionId: null | string;
        /** NonEmptyString */
        name: string;
        /**
         * PartnerConnectionKeySchema
         * @enum {string}
         */
        connectionKeySchema: 'token' | 'tokenAndSignature';
        /** UUID */
        clientId: string;
        broker: boolean;
      };
    };
    /** V1PartnersLimitedOutput */
    V1PartnersLimitedOutput: {
      /** UUID */
      id: string;
      /** NonEmptyString */
      name: string;
      institutionId: null | string;
      /**
       * PartnerConnectionKeySchema
       * @enum {string}
       */
      connectionKeySchema: 'token' | 'tokenAndSignature';
    };
    /** V1PartnersGetOkPayload */
    V1PartnersGetOkPayload: {
      partners: {
        /** UUID */
        id: string;
        /** NonEmptyString */
        name: string;
        institutionId: null | string;
        /**
         * PartnerConnectionKeySchema
         * @enum {string}
         */
        connectionKeySchema: 'token' | 'tokenAndSignature';
      }[];
    };
    /** PositiveBigIntFromString */
    PositiveBigIntFromString: string;
    /** PositiveBNCurrencyAmount */
    PositiveBNCurrencyAmount: {
      /** BNSupportedCurrency */
      currency: string;
      /** PositiveBigIntFromString */
      quantity: string;
    };
    /** PositiveCurrencyAmount */
    PositiveCurrencyAmount: {
      /** NonEmptyString */
      currency: string;
      /** PositiveBigIntFromString */
      quantity: string;
    };
    /** V1ClearedAllocation */
    V1ClearedAllocation: {
      /** @enum {string} */
      status: 'cleared';
      /** UUID */
      id: string;
      /** PositiveCurrencyAmount */
      amount: {
        /** NonEmptyString */
        currency: string;
        /** PositiveBigIntFromString */
        quantity: string;
      };
      /** UUID */
      connectionId: string;
      /** NonEmptyString */
      clientExternalId: string;
      /** NonEmptyString */
      partnerExternalId?: string;
      /** NonEmptyString */
      initiatedBy: string;
      /** NonEmptyString */
      notes?: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
    };
    /** V1DeallocationClearedPostPayload */
    V1DeallocationClearedPostPayload: {
      /** V1ClearedAllocation */
      deallocation: {
        /** @enum {string} */
        status: 'cleared';
        /** UUID */
        id: string;
        /** PositiveCurrencyAmount */
        amount: {
          /** NonEmptyString */
          currency: string;
          /** PositiveBigIntFromString */
          quantity: string;
        };
        /** UUID */
        connectionId: string;
        /** NonEmptyString */
        clientExternalId: string;
        /** NonEmptyString */
        partnerExternalId?: string;
        /** NonEmptyString */
        initiatedBy: string;
        /** NonEmptyString */
        notes?: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
      };
    };
    /** V1ReleasedAllocation */
    V1ReleasedAllocation: {
      /** @enum {string} */
      status: 'released';
      /** NonEmptyString */
      reason: string;
      /** UUID */
      id: string;
      /** PositiveCurrencyAmount */
      amount: {
        /** NonEmptyString */
        currency: string;
        /** PositiveBigIntFromString */
        quantity: string;
      };
      /** UUID */
      connectionId: string;
      /** NonEmptyString */
      clientExternalId: string;
      /** NonEmptyString */
      partnerExternalId?: string;
      /** NonEmptyString */
      initiatedBy: string;
      /** NonEmptyString */
      notes?: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
    };
    /** V1DeallocationReleasedWithErrorPostPayload */
    V1DeallocationReleasedWithErrorPostPayload: {
      /** V1ReleasedAllocation */
      deallocation: {
        /** @enum {string} */
        status: 'released';
        /** NonEmptyString */
        reason: string;
        /** UUID */
        id: string;
        /** PositiveCurrencyAmount */
        amount: {
          /** NonEmptyString */
          currency: string;
          /** PositiveBigIntFromString */
          quantity: string;
        };
        /** UUID */
        connectionId: string;
        /** NonEmptyString */
        clientExternalId: string;
        /** NonEmptyString */
        partnerExternalId?: string;
        /** NonEmptyString */
        initiatedBy: string;
        /** NonEmptyString */
        notes?: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
      };
      error: string;
    };
    /** V1ReservedAllocationOutput */
    V1ReservedAllocationOutput: {
      /** NonEmptyString */
      reason: string;
      /** @enum {string} */
      status: 'reserved';
      /** UUID */
      id: string;
      /** PositiveCurrencyAmount */
      amount: {
        /** NonEmptyString */
        currency: string;
        /** PositiveBigIntFromString */
        quantity: string;
      };
      /** UUID */
      connectionId: string;
      /** NonEmptyString */
      clientExternalId: string;
      /** NonEmptyString */
      partnerExternalId?: string;
      /** NonEmptyString */
      initiatedBy: string;
      /** NonEmptyString */
      notes?: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
    };
    /** V1ReservedDeallocationOrErrorPayload */
    V1ReservedDeallocationOrErrorPayload: OneOf<
      [
        {
          error: string;
        },
        {
          /** V1ReservedAllocationOutput */
          deallocation: {
            /** NonEmptyString */
            reason: string;
            /** @enum {string} */
            status: 'reserved';
            /** UUID */
            id: string;
            /** PositiveCurrencyAmount */
            amount: {
              /** NonEmptyString */
              currency: string;
              /** PositiveBigIntFromString */
              quantity: string;
            };
            /** UUID */
            connectionId: string;
            /** NonEmptyString */
            clientExternalId: string;
            /** NonEmptyString */
            partnerExternalId?: string;
            /** NonEmptyString */
            initiatedBy: string;
            /** NonEmptyString */
            notes?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
          };
        }
      ]
    >;
    /** V1ConnectionOutput */
    V1ConnectionOutput: {
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      partnersConnectionId: null | string;
      partnersClientId: null | string;
      initialized: boolean;
      /** UUID */
      id: string;
      /** NonEmptyString */
      name: string;
      /** UUID */
      clientId: string;
      /** UUID */
      partnerId: string;
      /** UUID */
      networkAccountId: string;
      active: boolean;
      /** NonEmptyString */
      proof: string;
      /** NonEmptyString */
      nonce: string;
    };
    /** V1ConnectionPayload */
    V1ConnectionPayload: {
      /** V1ConnectionOutput */
      connection: {
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        partnersConnectionId: null | string;
        partnersClientId: null | string;
        initialized: boolean;
        /** UUID */
        id: string;
        /** NonEmptyString */
        name: string;
        /** UUID */
        clientId: string;
        /** UUID */
        partnerId: string;
        /** UUID */
        networkAccountId: string;
        active: boolean;
        /** NonEmptyString */
        proof: string;
        /** NonEmptyString */
        nonce: string;
      };
    };
    /** BooleanFromString */
    BooleanFromString: string;
    /** V1ConnectionsGetOkPayload */
    V1ConnectionsGetOkPayload: {
      connections: {
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        partnersConnectionId: null | string;
        partnersClientId: null | string;
        initialized: boolean;
        /** UUID */
        id: string;
        /** NonEmptyString */
        name: string;
        /** UUID */
        clientId: string;
        /** UUID */
        partnerId: string;
        /** UUID */
        networkAccountId: string;
        active: boolean;
        /** NonEmptyString */
        proof: string;
        /** NonEmptyString */
        nonce: string;
      }[];
    };
    /** ConnectionKey */
    ConnectionKey: OneOf<
      [
        {
          /** @enum {string} */
          schema: 'token';
          /** NonEmptyString */
          connectionToken: string;
        },
        {
          /** @enum {string} */
          schema: 'tokenAndSignature';
          /** NonEmptyString */
          connectionToken: string;
          /** NonEmptyString */
          signature: string;
        }
      ]
    >;
    /** V1ClientsOutput */
    V1ClientsOutput: {
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      /** UUID */
      id: string;
      /** NonEmptyString */
      enterpriseId: string;
      /** NonEmptyString */
      walletId: string;
    };
    /** V1ClientsAdminGetOkPayload */
    V1ClientsAdminGetOkPayload: {
      clients: {
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** UUID */
        id: string;
        /** NonEmptyString */
        enterpriseId: string;
        /** NonEmptyString */
        walletId: string;
      }[];
    };
    /** V1ClientsPostOkPayload */
    V1ClientsPostOkPayload: {
      /** V1ClientsOutput */
      client: {
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** UUID */
        id: string;
        /** NonEmptyString */
        enterpriseId: string;
        /** NonEmptyString */
        walletId: string;
      };
    };
    /** NonNegativeBigIntFromString */
    NonNegativeBigIntFromString: string;
    /** AccountBalanceRecord */
    AccountBalanceRecord: {
      [key: string]: {
        /** NonNegativeBigIntFromString */
        available: string;
        /** NonNegativeBigIntFromString */
        held: string;
      };
    };
    /** NetworkAccountBalanceRecordForPartner */
    NetworkAccountBalanceRecordForPartner: {
      [key: string]: {
        /** UUID */
        clientId: string;
        /** NonEmptyString */
        partnersConnectionId: string;
        /** AccountBalanceRecord */
        balances: {
          [key: string]: {
            /** NonNegativeBigIntFromString */
            available: string;
            /** NonNegativeBigIntFromString */
            held: string;
          };
        };
      };
    };
    /** V1PartnerBalancesGetPayload */
    V1PartnerBalancesGetPayload: {
      /** UUID */
      partnerId: string;
      /** AccountBalanceRecord */
      balances: {
        [key: string]: {
          /** NonNegativeBigIntFromString */
          available: string;
          /** NonNegativeBigIntFromString */
          held: string;
        };
      };
      /** NetworkAccountBalanceRecordForPartner */
      networkBalances: {
        [key: string]: {
          /** UUID */
          clientId: string;
          /** NonEmptyString */
          partnersConnectionId: string;
          /** AccountBalanceRecord */
          balances: {
            [key: string]: {
              /** NonNegativeBigIntFromString */
              available: string;
              /** NonNegativeBigIntFromString */
              held: string;
            };
          };
        };
      };
    };
    /** NetworkAccountBalanceRecordForClient */
    NetworkAccountBalanceRecordForClient: {
      [key: string]: {
        /** UUID */
        partnerId: string;
        /** NonEmptyString */
        partnersConnectionId: string;
        /** NonEmptyString */
        name: string;
        /** AccountBalanceRecord */
        balances: {
          [key: string]: {
            /** NonNegativeBigIntFromString */
            available: string;
            /** NonNegativeBigIntFromString */
            held: string;
          };
        };
      };
    };
    /** V1ClientBalancesGetPayload */
    V1ClientBalancesGetPayload: {
      /** UUID */
      clientId: string;
      /** AccountBalanceRecord */
      balances: {
        [key: string]: {
          /** NonNegativeBigIntFromString */
          available: string;
          /** NonNegativeBigIntFromString */
          held: string;
        };
      };
      /** NetworkAccountBalanceRecordForClient */
      networkBalances: {
        [key: string]: {
          /** UUID */
          partnerId: string;
          /** NonEmptyString */
          partnersConnectionId: string;
          /** NonEmptyString */
          name: string;
          /** AccountBalanceRecord */
          balances: {
            [key: string]: {
              /** NonNegativeBigIntFromString */
              available: string;
              /** NonNegativeBigIntFromString */
              held: string;
            };
          };
        };
      };
    };
    /** V1AdminClientBalancesGetPayload */
    V1AdminClientBalancesGetPayload: {
      [key: string]: {
        [key: string]: {
          /** NonNegativeBigIntFromString */
          available: string;
          /** NonNegativeBigIntFromString */
          held: string;
        };
      };
    };
    /** V1AdminConnectionBalancesGetPayload */
    V1AdminConnectionBalancesGetPayload: {
      [key: string]: {
        /** NonEmptyString */
        name: string;
        /** UUID */
        clientId: string;
        /** NonEmptyString */
        clientEnterpriseId: string;
        /** UUID */
        partnerId: string;
        /** NonEmptyString */
        partnerName: string;
        /** NonEmptyString */
        partnerEnterpriseId: string;
        /** AccountBalanceRecord */
        balances: {
          [key: string]: {
            /** NonNegativeBigIntFromString */
            available: string;
            /** NonNegativeBigIntFromString */
            held: string;
          };
        };
        /** NonEmptyString */
        partnersConnectionId: string;
      };
    };
    /**
     * AllocationStatus
     * @enum {string}
     */
    AllocationStatus: 'cleared' | 'released' | 'reserved';
    /**
     * AllocationType
     * @enum {string}
     */
    AllocationType: 'allocation' | 'deallocation';
    /** V1AllocationGetOutput */
    V1AllocationGetOutput: {
      reason: null | string;
      /**
       * AllocationStatus
       * @enum {string}
       */
      status: 'cleared' | 'released' | 'reserved';
      /**
       * AllocationType
       * @enum {string}
       */
      type: 'allocation' | 'deallocation';
      /** UUID */
      id: string;
      /** PositiveCurrencyAmount */
      amount: {
        /** NonEmptyString */
        currency: string;
        /** PositiveBigIntFromString */
        quantity: string;
      };
      /** UUID */
      connectionId: string;
      /** NonEmptyString */
      clientExternalId: string;
      /** NonEmptyString */
      partnerExternalId?: string;
      /** NonEmptyString */
      initiatedBy: string;
      /** NonEmptyString */
      notes?: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
    };
    /** V1AllocationGetPayload */
    V1AllocationGetPayload: {
      /** V1AllocationGetOutput */
      allocation: {
        reason: null | string;
        /**
         * AllocationStatus
         * @enum {string}
         */
        status: 'cleared' | 'released' | 'reserved';
        /**
         * AllocationType
         * @enum {string}
         */
        type: 'allocation' | 'deallocation';
        /** UUID */
        id: string;
        /** PositiveCurrencyAmount */
        amount: {
          /** NonEmptyString */
          currency: string;
          /** PositiveBigIntFromString */
          quantity: string;
        };
        /** UUID */
        connectionId: string;
        /** NonEmptyString */
        clientExternalId: string;
        /** NonEmptyString */
        partnerExternalId?: string;
        /** NonEmptyString */
        initiatedBy: string;
        /** NonEmptyString */
        notes?: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
      };
    };
    /**
     * sortDirection
     * @enum {string}
     */
    sortDirection: 'ASC' | 'DESC';
    /** V1AllocationsGetPayload */
    V1AllocationsGetPayload: {
      allocations: {
        reason: null | string;
        /**
         * AllocationStatus
         * @enum {string}
         */
        status: 'cleared' | 'released' | 'reserved';
        /**
         * AllocationType
         * @enum {string}
         */
        type: 'allocation' | 'deallocation';
        /** UUID */
        id: string;
        /** PositiveCurrencyAmount */
        amount: {
          /** NonEmptyString */
          currency: string;
          /** PositiveBigIntFromString */
          quantity: string;
        };
        /** UUID */
        connectionId: string;
        /** NonEmptyString */
        clientExternalId: string;
        /** NonEmptyString */
        partnerExternalId?: string;
        /** NonEmptyString */
        initiatedBy: string;
        /** NonEmptyString */
        notes?: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
      }[];
    };
    /** V1AllocationsClearedPostPayload */
    V1AllocationsClearedPostPayload: {
      /** V1ClearedAllocation */
      allocation: {
        /** @enum {string} */
        status: 'cleared';
        /** UUID */
        id: string;
        /** PositiveCurrencyAmount */
        amount: {
          /** NonEmptyString */
          currency: string;
          /** PositiveBigIntFromString */
          quantity: string;
        };
        /** UUID */
        connectionId: string;
        /** NonEmptyString */
        clientExternalId: string;
        /** NonEmptyString */
        partnerExternalId?: string;
        /** NonEmptyString */
        initiatedBy: string;
        /** NonEmptyString */
        notes?: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
      };
    };
    /** V1AllocationsReleasedWithErrorPostPayload */
    V1AllocationsReleasedWithErrorPostPayload: {
      /** V1ReleasedAllocation */
      allocation: {
        /** @enum {string} */
        status: 'released';
        /** NonEmptyString */
        reason: string;
        /** UUID */
        id: string;
        /** PositiveCurrencyAmount */
        amount: {
          /** NonEmptyString */
          currency: string;
          /** PositiveBigIntFromString */
          quantity: string;
        };
        /** UUID */
        connectionId: string;
        /** NonEmptyString */
        clientExternalId: string;
        /** NonEmptyString */
        partnerExternalId?: string;
        /** NonEmptyString */
        initiatedBy: string;
        /** NonEmptyString */
        notes?: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
      };
      error: string;
    };
    /** V1ReservedAllocationOrErrorPayload */
    V1ReservedAllocationOrErrorPayload: OneOf<
      [
        {
          error: string;
        },
        {
          /** V1ReservedAllocationOutput */
          allocation: {
            /** NonEmptyString */
            reason: string;
            /** @enum {string} */
            status: 'reserved';
            /** UUID */
            id: string;
            /** PositiveCurrencyAmount */
            amount: {
              /** NonEmptyString */
              currency: string;
              /** PositiveBigIntFromString */
              quantity: string;
            };
            /** UUID */
            connectionId: string;
            /** NonEmptyString */
            clientExternalId: string;
            /** NonEmptyString */
            partnerExternalId?: string;
            /** NonEmptyString */
            initiatedBy: string;
            /** NonEmptyString */
            notes?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
          };
        }
      ]
    >;
    /**
     * TradingPartnerStatuses
     * @enum {string}
     */
    TradingPartnerStatuses: 'accepted' | 'rejected' | 'canceled' | 'pending';
    /** TradingPartnerResponse */
    TradingPartnerResponse: {
      id: string;
      primaryAccountId: string;
      primaryEnterpriseName: string;
      secondaryAccountId: string;
      secondaryEnterpriseName: string;
      /**
       * TradingPartnerStatuses
       * @enum {string}
       */
      status: 'accepted' | 'rejected' | 'canceled' | 'pending';
      /** Format: date */
      updatedAt: string;
    };
    /** TradingPartnerListResponse */
    TradingPartnerListResponse: {
      tradingPartnerList: {
        id: string;
        primaryAccountId: string;
        primaryEnterpriseName: string;
        secondaryAccountId: string;
        secondaryEnterpriseName: string;
        /**
         * TradingPartnerStatuses
         * @enum {string}
         */
        status: 'accepted' | 'rejected' | 'canceled' | 'pending';
        /** Format: date */
        updatedAt: string;
      }[];
    };
    /** V1ErrorPayload */
    V1ErrorPayload1: {
      error: string;
      errorName: string;
    };
    /**
     * withFallback
     * @description Error: Not codec typeof import("/Users/phanisatrasala/workspace/bitgo-microservices/packages/lib/clearing-settlement-types/node_modules/io-ts-types/lib/withFallback").withFallback
     */
    withFallback: unknown;
    /**
     * SettlementStatus
     * @enum {string}
     */
    SettlementStatus: 'canceled' | 'rejected' | 'pending' | 'failed' | 'expired' | 'settled';
    /**
     * ApprovalRequestStatus
     * @enum {string}
     */
    ApprovalRequestStatus:
      | 'acknowledged'
      | 'canceled'
      | 'rejected'
      | 'approved'
      | 'pending'
      | 'failed'
      | 'overdue'
      | 'expired';
    /** ApprovalRequestResponseForSettlement */
    ApprovalRequestResponseForSettlement: {
      /** Format: date */
      approvedAt?: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      /** NonEmptyString */
      id: string;
      /** NonEmptyString */
      accountId: string;
      /**
       * ApprovalRequestStatus
       * @enum {string}
       */
      status: 'acknowledged' | 'canceled' | 'rejected' | 'approved' | 'pending' | 'failed' | 'overdue' | 'expired';
      /** NonEmptyString */
      payload: string;
      /** NonEmptyString */
      signature?: string;
    };
    /** SupportedCurrency */
    SupportedCurrency: string;
    /** SettlementTransferResponse */
    SettlementTransferResponse: {
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      /** UUID */
      id: string;
      /** NonEmptyString */
      sourceTradingAccountId: string;
      /** NonEmptyString */
      destinationTradingAccountId: string;
      /** SupportedCurrency */
      currency: string;
      /** PositiveBigIntFromString */
      quantity: string;
      txIds?: string[];
    };
    /** SettlementResponse */
    SettlementResponse: {
      approvalRequests: {
        /** Format: date */
        approvedAt?: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** NonEmptyString */
        id: string;
        /** NonEmptyString */
        accountId: string;
        /**
         * ApprovalRequestStatus
         * @enum {string}
         */
        status: 'acknowledged' | 'canceled' | 'rejected' | 'approved' | 'pending' | 'failed' | 'overdue' | 'expired';
        /** NonEmptyString */
        payload: string;
        /** NonEmptyString */
        signature?: string;
      }[];
      settlementTransfers: {
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** UUID */
        id: string;
        /** NonEmptyString */
        sourceTradingAccountId: string;
        /** NonEmptyString */
        destinationTradingAccountId: string;
        /** SupportedCurrency */
        currency: string;
        /** PositiveBigIntFromString */
        quantity: string;
        txIds?: string[];
      }[];
      /** NonEmptyString */
      requesterAccountName: string;
      /** Format: date */
      finalizedAt?: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      /** NonEmptyString */
      id: string;
      /** NonEmptyString */
      externalId: string;
      notation?: string;
      /** NonEmptyString */
      requesterAccountId: string;
      /**
       * SettlementStatus
       * @enum {string}
       */
      status: 'canceled' | 'rejected' | 'pending' | 'failed' | 'expired' | 'settled';
      /** @enum {string} */
      type: 'direct';
    };
    /** SettlementListResponse */
    SettlementListResponse: {
      settlementList: {
        approvalRequests: {
          /** Format: date */
          approvedAt?: string;
          /** Format: date */
          createdAt: string;
          /** Format: date */
          updatedAt: string;
          /** NonEmptyString */
          id: string;
          /** NonEmptyString */
          accountId: string;
          /**
           * ApprovalRequestStatus
           * @enum {string}
           */
          status: 'acknowledged' | 'canceled' | 'rejected' | 'approved' | 'pending' | 'failed' | 'overdue' | 'expired';
          /** NonEmptyString */
          payload: string;
          /** NonEmptyString */
          signature?: string;
        }[];
        settlementTransfers: {
          /** Format: date */
          createdAt: string;
          /** Format: date */
          updatedAt: string;
          /** UUID */
          id: string;
          /** NonEmptyString */
          sourceTradingAccountId: string;
          /** NonEmptyString */
          destinationTradingAccountId: string;
          /** SupportedCurrency */
          currency: string;
          /** PositiveBigIntFromString */
          quantity: string;
          txIds?: string[];
        }[];
        /** NonEmptyString */
        requesterAccountName: string;
        /** Format: date */
        finalizedAt?: string;
        /** Format: date */
        createdAt: string;
        /** Format: date */
        updatedAt: string;
        /** NonEmptyString */
        id: string;
        /** NonEmptyString */
        externalId: string;
        notation?: string;
        /** NonEmptyString */
        requesterAccountId: string;
        /**
         * SettlementStatus
         * @enum {string}
         */
        status: 'canceled' | 'rejected' | 'pending' | 'failed' | 'expired' | 'settled';
        /** @enum {string} */
        type: 'direct';
      }[];
    };
    /** BigIntFromString */
    BigIntFromString: string;
    /** AssetTransfer */
    AssetTransfer: {
      /** SupportedCurrency */
      currency: string;
      /** BigIntFromString */
      quantity: string;
    };
    /** TradePayloadResponse */
    TradePayloadResponse: {
      payload: string;
    };
    /** ApprovalRequestResponse */
    ApprovalRequestResponse: {
      /** NonEmptyString */
      settlementId: string;
      /** Format: date */
      approvedAt?: string;
      /** Format: date */
      createdAt: string;
      /** Format: date */
      updatedAt: string;
      /** NonEmptyString */
      id: string;
      /** NonEmptyString */
      accountId: string;
      /**
       * ApprovalRequestStatus
       * @enum {string}
       */
      status: 'acknowledged' | 'canceled' | 'rejected' | 'approved' | 'pending' | 'failed' | 'overdue' | 'expired';
      /** NonEmptyString */
      payload: string;
      /** NonEmptyString */
      signature?: string;
    };
    /**
     * ApprovalRequestUpdateStatus
     * @enum {string}
     */
    ApprovalRequestUpdateStatus: 'acknowledged' | 'canceled' | 'rejected';
    /** PositiveIntConfig */
    PositiveIntConfig: string | number;
    /** FeeRate */
    FeeRate: {
      /** PositiveIntConfig */
      settlement: string | number;
    };
    /** TradingAccountSettingsResponse */
    TradingAccountSettingsResponse: {
      accountId: string;
      affirmationExpirationTime: number;
      /** FeeRate */
      feeRates?: {
        /** PositiveIntConfig */
        settlement: string | number;
      };
      referralCode: string;
    };
    /** @description The Always Deny Action. The Always Deny Action automatically denies a transfer. */
    AlwaysDenyAction: {
      /**
       * @description The name of the Action.
       * @example approvals.always.deny
       * @enum {string}
       */
      name: 'approvals.always.deny';
      /**
       * @description A label for the Action which can be shown to an end user.
       * @example Deny
       */
      label: string;
      /**
       * @description A description for the Action which can be shown to an end user.
       * @example Always Deny
       */
      description: string;
      /**
       * @description Status of the Action. Indicates if the Actions is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Action is available for use.
       * * "INACTIVE" - The Action is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
      /**
       * @description true, if this is an internal Action, false otherwise.
       * @example false
       */
      adminOnly: boolean;
    };
    /** @description The Wallet Admin Approval Action. The Wallet Admin Approval Action requires approval from one or more Wallet admins before a transfer can be executed. */
    WalletAdminAction: {
      /**
       * @description The name of the Action.
       * @example approvals.customer.walletAdmin
       * @enum {string}
       */
      name: 'approvals.customer.walletAdmin';
      /**
       * @description A label for the Action which can be shown to an end user.
       * @example Wallet Admin
       */
      label: string;
      /**
       * @description A description for the Action which can be shown to an end user.
       * @example Wallet admin approval
       */
      description: string;
      /**
       * @description Status of the Action. Indicates if the Actions is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Action is available for use.
       * * "INACTIVE" - The Action is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
      /**
       * @description true, if this is an internal Action, false otherwise.
       * @example false
       */
      adminOnly: boolean;
      /** @description A list of Parameters to control how the Action behaves. */
      parameters: components['schemas']['MinRequireActionParameter'][];
    };
    /** @description Minimum required number of approvers. */
    MinRequireActionParameter: {
      /**
       * @description The name of the Action Parameter.
       * @example minRequired
       * @enum {string}
       */
      name: 'minRequired';
      /**
       * @description A label for the Action Parameter which can be shown to an end user.
       * @example Approvals Required
       */
      label: string;
      /**
       * @description A description for the Action Parameter which can be shown to an end user.
       * @example Minimum required number of approvers
       */
      description: string;
      /**
       * @description The type of acceptable values for this Condition Parameter.
       * @example NON_NEGATIVE_NUMBER
       * @enum {string}
       */
      type: 'NON_NEGATIVE_NUMBER';
      /**
       * @description A value may or may not be provided, i.e. the parameter is optional.
       * @example OPTIONAL
       * @enum {string}
       */
      required: 'OPTIONAL';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example false
       */
      allowMultiple: boolean;
    };
    /** @description The Final Approval Approval Action. The Final Approval Action requires one user from a set of one or more users to approve a transfer before it can be executed. Final Approval happens after Wallet Admin Approval if a Policy Rule happens to use both Actions. These users may be Wallet Viewers or Spenders, in other words, they do not have to be Wallet admins. */
    FinalApprovalAction: {
      /**
       * @description The name of the Action.
       * @example approvals.customer.finalApproval
       * @enum {string}
       */
      name: 'approvals.customer.finalApproval';
      /**
       * @description A label for the Action which can be shown to an end user.
       * @example Final Approval
       */
      label: string;
      /**
       * @description A description for the Action which can be shown to an end user.
       * @example Final Approval
       */
      description: string;
      /**
       * @description Status of the Action. Indicates if the Actions is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Action is available for use.
       * * "INACTIVE" - The Action is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
      /**
       * @description true, if this is an internal Action, false otherwise.
       * @example false
       */
      adminOnly: boolean;
      /** @description A list of Parameters to control how the Action behaves. */
      parameters: components['schemas']['UserIdsActionParameter'][];
    };
    /** @description The final approvers. */
    UserIdsActionParameter: {
      /**
       * @description The name of the Action Parameter.
       * @example userIds
       * @enum {string}
       */
      name: 'userIds';
      /**
       * @description A label for the Action Parameter which can be shown to an end user.
       * @example Users
       */
      label: string;
      /**
       * @description A description for the Action Parameter which can be shown to an end user.
       * @example List of users for final approval
       */
      description: string;
      /**
       * @description The type of acceptable values for this Condition Parameter.
       * @example BITGO_USER_ID
       * @enum {string}
       */
      type: 'BITGO_USER_ID';
      /**
       * @description A value must be always provided for exactly one or more of the Action Parameters with a 'required' value of "ONE_OR_MORE". In other words, all the Action Parameters with a 'required' of "ONE_OR_MORE" form a group, and a value must be provided for one or more of the Action Parameters in the group.
       * @example ONE_OR_MORE
       * @enum {string}
       */
      required: 'ONE_OR_MORE';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example true
       */
      allowMultiple: boolean;
    };
    /** @description The Enterprise Admin Approval Action. The Enterprise Admin Approval Action requires approval from one Enterprise admin before the underlying request can be executed. */
    EnterpriseAdminAction: {
      /**
       * @description The name of the Action.
       * @example approvals.customer.enterpriseAdmin
       * @enum {string}
       */
      name: 'approvals.customer.enterpriseAdmin';
      /**
       * @description A label for the Action which can be shown to an end user.
       * @example Enterprise Admin
       */
      label: string;
      /**
       * @description A description for the Action which can be shown to an end user.
       * @example Enterprise admin approval
       */
      description: string;
      /**
       * @description Status of the Action. Indicates if the Actions is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Action is available for use.
       * * "INACTIVE" - The Action is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
      /**
       * @description true, if this is an internal Action, false otherwise.
       * @example false
       */
      adminOnly: boolean;
    };
    /** @description Wrapper object for a list of Actions. Not paginated. */
    Actions: {
      actions: (
        | components['schemas']['AlwaysDenyAction']
        | components['schemas']['WalletAdminAction']
        | components['schemas']['FinalApprovalAction']
        | components['schemas']['EnterpriseAdminAction']
      )[];
    };
    /** @description A combination of Conditions and Actions. */
    Clause: {
      actions?: (
        | components['schemas']['AlwaysDenyActionRequest']
        | components['schemas']['EnterpriseAdminActionRequest']
        | components['schemas']['WalletAdminActionRequest']
        | components['schemas']['FinalApprovalActionRequest']
      )[];
      conditions?: (
        | components['schemas']['TransferAmountConditionRequest']
        | components['schemas']['TransferVelocityLimitConditionRequest']
        | components['schemas']['TransferDestinationTypeConditionRequest']
        | components['schemas']['WalletWhitelistExistsConditionRequest']
        | components['schemas']['EnterpriseWhitelistExistsConditionRequest']
        | components['schemas']['RuleFilteringConditionsConditionRequest']
      )[];
    };
    /** @description The Transfer Amount Condition. The Transfer Amount Condition allows you to create Policy Rules that trigger based on the amount being transferred expressed as a value in coin, i.e. BTC, or dollars. */
    TransferAmountCondition: {
      /**
       * @description The name of the Condition.
       * @example transfer.amount
       * @enum {string}
       */
      name: 'transfer.amount';
      /**
       * @description A label for the Condition which can be shown to an end user..
       * @example Transfer Amount
       */
      label: string;
      /**
       * @description A description for the Condition which can be shown to an end user..
       * @example Allows creating a Condition based on the Transfer Amount
       */
      description: string;
      /**
       * @description Status of the Condition. Indicates if the Condition is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Condition is available for use.
       * * "INACTIVE" - The Condition is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
      /** @description A list of Parameters to control how the Condition behaves. */
      parameters: (
        | components['schemas']['OperatorConditionParameter']
        | components['schemas']['AmountConditionParameter']
        | components['schemas']['CoinConditionParameter']
      )[];
    };
    /** @description The boolean operator used when comparing the transfer amount with the amount defined in this Condition. */
    OperatorConditionParameter: {
      /**
       * @description The name of the Condition Parameter.
       * @example operator
       * @enum {string}
       */
      name: 'operator';
      /**
       * @description A label for the Condition Parameter which can be shown to an end user.
       * @example Comparison Operator
       */
      label: string;
      /**
       * @description A description for the Condition Parameter which can be shown to an end user.
       * @example The comparison operator to use when comparing the transfer amount with the given amount
       */
      description: string;
      /**
       * @description Accepts only enumerated values as listed in the 'values' property of this Condition.
       * @example ENUMERATED
       * @enum {string}
       */
      type: 'ENUMERATED';
      /**
       * @description A value must always be provided, i.e. the parameter is required.
       * @example ALWAYS
       * @enum {string}
       */
      required: 'ALWAYS';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example false
       */
      allowMultiple: boolean;
      /** @description A list of valid values, only values from this list will be accepted. */
      values: (
        | components['schemas']['GreaterThanValue']
        | components['schemas']['GreaterThanOrEqualToValue']
        | components['schemas']['LessThanValue']
        | components['schemas']['LessThanOrEqualToValue']
      )[];
    };
    /** @description The > operator. */
    GreaterThanValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: '>';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Greater than
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example The transfer amount must be greater than the given amount for the Condition to trigger
       */
      description: string;
    };
    /** @description The >= operator. */
    GreaterThanOrEqualToValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: '>=';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Greater than or equal to
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example The transfer amount must be greater than or equal to the given amount for the Condition to trigger
       */
      description: string;
    };
    /** @description The < operator. */
    LessThanValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: '<';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Less than
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example The transfer amount must be less than the given amount for the Condition to trigger
       */
      description: string;
    };
    /** @description The <= operator. */
    LessThanOrEqualToValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: '<=';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Less than or equal to
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example The transfer amount must be less than or equal to the given amount for the Condition to trigger
       */
      description: string;
    };
    /** @description The amount incoming transfers will be compared with. */
    AmountConditionParameter: {
      /**
       * @description The name of the Condition Parameter.
       * @example amount
       * @enum {string}
       */
      name: 'amount';
      /**
       * @description A label for the Condition Parameter which can be shown to an end user.
       * @example The amount to compare to
       */
      label: string;
      /**
       * @description A description for the Condition Parameter which can be shown to an end user.
       * @example The transfer amount will be compared with this amount
       */
      description: string;
      /**
       * @description The type of acceptable values for this Condition Parameter.
       * @example NON_NEGATIVE_NUMBER
       * @enum {string}
       */
      type: 'NON_NEGATIVE_NUMBER';
      /**
       * @description A value must always be provided, i.e. the parameter is required.
       * @example ALWAYS
       * @enum {string}
       */
      required: 'ALWAYS';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example false
       */
      allowMultiple: boolean;
    };
    /** @description The coin the amount is expressed in. */
    CoinConditionParameter: {
      /**
       * @description The name of the Condition Parameter.
       * @example coin
       * @enum {string}
       */
      name: 'coin';
      /**
       * @description A label for the Condition Parameter which can be shown to an end user.
       * @example Currency
       */
      label: string;
      /**
       * @description A description for the Condition Parameter which can be shown to an end user.
       * @example This condition only applies to transfers of this currency (USD applies to all transfers)
       */
      description: string;
      /**
       * @description The type of acceptable values for this Condition Parameter.
       * @example COIN_OR_USD
       * @enum {string}
       */
      type: 'COIN_OR_USD';
      /**
       * @description A value must always be provided, i.e. the parameter is required.
       * @example ALWAYS
       * @enum {string}
       */
      required: 'ALWAYS';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example false
       */
      allowMultiple: boolean;
    };
    /** @description The Transfer Velocity Limit Condition. The Transfer Velocity Limit Condition allows you to create Policy Rules that trigger based on how much has been transferred over a particular period of time from a specific Wallet or from all of your Wallets, the amount being transferred can be expressed as a value in coin, i.e. ETH, or dollars. */
    TransferVelocityLimitCondition: {
      /**
       * @description The name of the Condition.
       * @example transfer.velocity.limit
       * @enum {string}
       */
      name: 'transfer.velocity.limit';
      /**
       * @description A label for the Condition which can be shown to an end user..
       * @example Spending Limit
       */
      label: string;
      /**
       * @description A description for the Condition which can be shown to an end user..
       * @example Allows creating a Condition based on the amount of coin or USD that can be spent over a period of time
       */
      description: string;
      /**
       * @description Status of the Condition. Indicates if the Condition is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Condition is available for use.
       * * "INACTIVE" - The Condition is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
      /** @description A list of Parameters to control how the Condition behaves. */
      parameters: (
        | components['schemas']['VelocityAmountConditionParameter']
        | components['schemas']['TimeWindowConditionParameter']
        | components['schemas']['VelocityCoinConditionParameter']
        | components['schemas']['ScopeConditionParameter']
      )[];
    };
    /** @description The amount that can be spent within the Time Window */
    VelocityAmountConditionParameter: {
      /**
       * @description The name of the Condition Parameter.
       * @example amount
       * @enum {string}
       */
      name: 'amount';
      /**
       * @description A label for the Condition Parameter which can be shown to an end user.
       * @example Amount
       */
      label: string;
      /**
       * @description A description for the Condition Parameter which can be shown to an end user.
       * @example The amount that can be spent within the Time Window
       */
      description: string;
      /**
       * @description The type of acceptable values for this Condition Parameter.
       * @example NON_NEGATIVE_NUMBER
       * @enum {string}
       */
      type: 'NON_NEGATIVE_NUMBER';
      /**
       * @description A value must always be provided, i.e. the parameter is required.
       * @example ALWAYS
       * @enum {string}
       */
      required: 'ALWAYS';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example false
       */
      allowMultiple: boolean;
    };
    /** @description The period of time this condition covers, in seconds. */
    TimeWindowConditionParameter: {
      /**
       * @description The name of the Condition Parameter.
       * @example timeWindow
       * @enum {string}
       */
      name: 'timeWindow';
      /**
       * @description A label for the Condition Parameter which can be shown to an end user.
       * @example Time Window
       */
      label: string;
      /**
       * @description A description for the Condition Parameter which can be shown to an end user.
       * @example The period of time this condition covers, in seconds
       */
      description: string;
      /**
       * @description The type of acceptable values for this Condition Parameter.
       * @example NON_NEGATIVE_NUMBER
       * @enum {string}
       */
      type: 'NON_NEGATIVE_NUMBER';
      /**
       * @description A value must always be provided, i.e. the parameter is required.
       * @example ALWAYS
       * @enum {string}
       */
      required: 'ALWAYS';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example false
       */
      allowMultiple: boolean;
    };
    /** @description The unit the amount is denoted in, can be a coin or a fiat currency. */
    VelocityCoinConditionParameter: {
      /**
       * @description The name of the Condition Parameter.
       * @example coin
       * @enum {string}
       */
      name: 'coin';
      /**
       * @description A label for the Condition Parameter which can be shown to an end user.
       * @example Unit
       */
      label: string;
      /**
       * @description A description for the Condition Parameter which can be shown to an end user.
       * @example The unit the amount is denoted in, can be a coin or a fiat currency
       */
      description: string;
      /**
       * @description The type of acceptable values for this Condition Parameter.
       * @example COIN_OR_USD
       * @enum {string}
       */
      type: 'COIN_OR_USD';
      /**
       * @description A value must always be provided, i.e. the parameter is required.
       * @example ALWAYS
       * @enum {string}
       */
      required: 'ALWAYS';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example false
       */
      allowMultiple: boolean;
    };
    /** @description Defines the entities that will be included in the velocity calculation. */
    ScopeConditionParameter: {
      /**
       * @description The name of the Condition Parameter.
       * @example scope
       * @enum {string}
       */
      name: 'scope';
      /**
       * @description A label for the Condition Parameter which can be shown to an end user.
       * @example Scope
       */
      label: string;
      /**
       * @description A description for the Condition Parameter which can be shown to an end user.
       * @example Entities that will be included in the velocity calculation
       */
      description: string;
      /**
       * @description Accepts only enumerated values as listed in the 'values' property of this Condition.
       * @example ENUMERATED
       * @enum {string}
       */
      type: 'ENUMERATED';
      /**
       * @description A value must always be provided, i.e. the parameter is required.
       * @example ALWAYS
       * @enum {string}
       */
      required: 'ALWAYS';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example false
       */
      allowMultiple: boolean;
      /** @description A list of valid values, only values from this list will be accepted. */
      values: (components['schemas']['WalletValue'] | components['schemas']['EnterpriseValue'])[];
    };
    /** @description Only spending from the source Wallet will be included. */
    WalletValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'wallet';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Wallet
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example Only spending from the transferring wallet will be included
       */
      description: string;
    };
    /** @description Spending from the entire enterprise will be included. */
    EnterpriseValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'enterprise';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Enterprise
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example Spending from the entire transferring wallet's enterprise will be included
       */
      description: string;
    };
    /** @description The Transfer Destination Type Condition. The Destination Type Condition allows you to create Policy Rules that trigger based on where the funds are being transferred to. */
    TransferDestinationTypeCondition: {
      /**
       * @description The name of the Condition.
       * @example transfer.destination.type
       * @enum {string}
       */
      name: 'transfer.destination.type';
      /**
       * @description A label for the Condition which can be shown to an end user..
       * @example Destination Type
       */
      label: string;
      /**
       * @description A description for the Condition which can be shown to an end user..
       * @example Allows creating a Condition based on the type of the funds destination
       */
      description: string;
      /**
       * @description Status of the Condition. Indicates if the Condition is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Condition is available for use.
       * * "INACTIVE" - The Condition is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
      /** @description A list of Parameters to control how the Condition behaves. */
      parameters: components['schemas']['DestinationTypeConditionParameter'][];
    };
    /** @description The Wallet Whitelist Exists Condition. Allows creating a Condition based on whether a Wallet Whitelist exists. */
    WalletWhitelistExistsCondition: {
      /**
       * @description The name of the Condition.
       * @example wallet.whitelist.exists
       * @enum {string}
       */
      name: 'wallet.whitelist.exists';
      /**
       * @description A label for the Condition which can be shown to an end user..
       * @example A Wallet Whitelist Exists
       */
      label: string;
      /**
       * @description A description for the Condition which can be shown to an end user..
       * @example Allows creating a Condition based on whether a Wallet Whitelist exists
       */
      description: string;
      /**
       * @description Status of the Condition. Indicates if the Condition is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Condition is available for use.
       * * "INACTIVE" - The Condition is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
    };
    /** @description The Enterprise Whitelist Exists Condition. Allows creating a Condition based on whether an Enterprise Whitelist exists. */
    EnterpriseWhitelistExistsCondition: {
      /**
       * @description The name of the Condition.
       * @example wallet.whitelist.exists
       * @enum {string}
       */
      name: 'enterprise.whitelist.exists';
      /**
       * @description A label for the Condition which can be shown to an end user..
       * @example An Enterprise Whitelist Exists
       */
      label: string;
      /**
       * @description A description for the Condition which can be shown to an end user..
       * @example Allows creating a Condition based on whether an Enterprise Whitelist exists
       */
      description: string;
      /**
       * @description Status of the Condition. Indicates if the Condition is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Condition is available for use.
       * * "INACTIVE" - The Condition is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
    };
    /** @description The type of destination this condition will match. */
    DestinationTypeConditionParameter: {
      /**
       * @description The name of the Condition Parameter.
       * @example type
       * @enum {string}
       */
      name: 'type';
      /**
       * @description A label for the Condition Parameter which can be shown to an end user.
       * @example Type
       */
      label: string;
      /**
       * @description A description for the Condition Parameter which can be shown to an end user.
       * @example The type of destination this condition will match
       */
      description: string;
      /**
       * @description Accepts only enumerated values as listed in the 'values' property of this Condition.
       * @example ENUMERATED
       * @enum {string}
       */
      type: 'ENUMERATED';
      /**
       * @description A value must always be provided, i.e. the parameter is required.
       * @example ALWAYS
       * @enum {string}
       */
      required: 'ALWAYS';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example false
       */
      allowMultiple: boolean;
      /** @description A list of valid values, only values from this list will be accepted. */
      values: (
        | components['schemas']['WalletWhitelistedAddressValue']
        | components['schemas']['EnterpriseWhitelistedAddressValue']
        | components['schemas']['NonWalletWhitelistedAddressValue']
        | components['schemas']['NonEnterpriseWhitelistedAddressValue']
      )[];
    };
    /** @description The destination is whitelisted at the Wallet level. */
    WalletWhitelistedAddressValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'walletWhitelistedAddress';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Wallet Whitelisted Address
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example The destination is whitelisted at the wallet level
       */
      description: string;
    };
    /** @description The destination is not whitelisted at the wallet level. */
    NonWalletWhitelistedAddressValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'nonWalletWhitelistedAddress';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Non Wallet Whitelisted Address
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example The destination is not whitelisted at the wallet level
       */
      description: string;
    };
    /** @description The destination is whitelisted at the enterprise level. */
    EnterpriseWhitelistedAddressValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'enterpriseWhitelistedAddress';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Enterprise Whitelisted Address
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example The destination is whitelisted at the enterprise level
       */
      description: string;
    };
    /** @description The destination is not whitelisted at the enterprise level. */
    NonEnterpriseWhitelistedAddressValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'nonEnterpriseWhitelistedAddress';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Non Enterprise Whitelisted Address
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example The destination is not whitelisted at the enterprise level
       */
      description: string;
    };
    /** @description Wrapper object for a list of Filtering Conditions. Not paginated. */
    FilteringConditions: {
      conditions: (
        | components['schemas']['WalletTypeCondition']
        | components['schemas']['WalletIdsCondition']
        | components['schemas']['WalletAllCondition']
        | components['schemas']['RuleAllCondition']
      )[];
    };
    /** @description The Wallet All Condition for the All Wallets Scope. */
    WalletAllCondition: {
      /**
       * @description The name of the Condition.
       * @example wallet.all
       * @enum {string}
       */
      name: 'wallet.all';
      /**
       * @description A label for the Condition which can be shown to an end user.
       * @example Wallet All
       */
      label: string;
      /**
       * @description A description for the Condition which can be shown to an end user.
       * @example For all Wallets
       */
      description: string;
      /**
       * @description Status of the Condition. Indicates if the Condition is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Condition is available for use.
       * * "INACTIVE" - The Condition is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
    };
    /** @description The Rule All Condition for the All Policy Rules Scope. */
    RuleAllCondition: {
      /**
       * @description The name of the Condition.
       * @example rule.all
       * @enum {string}
       */
      name: 'rule.all';
      /**
       * @description A label for the Condition which can be shown to an end user.
       * @example Rule All
       */
      label: string;
      /**
       * @description A description for the Condition which can be shown to an end user.
       * @example For all Policy Rules
       */
      description: string;
      /**
       * @description Status of the Condition. Indicates if the Condition is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Condition is available for use.
       * * "INACTIVE" - The Condition is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
    };
    /** @description The Wallet Ids Condition for the All Wallets Scope. */
    WalletIdsCondition: {
      /**
       * @description The name of the Condition.
       * @example wallet.ids
       * @enum {string}
       */
      name: 'wallet.ids';
      /**
       * @description A label for the Condition which can be shown to an end user.
       * @example Wallet Id
       */
      label: string;
      /**
       * @description A description for the Condition which can be shown to an end user.
       * @example The Wallet Ids
       */
      description: string;
      /**
       * @description Status of the Condition. Indicates if the Condition is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Condition is available for use.
       * * "INACTIVE" - The Condition is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
      /** @description A list of Parameters to control how the Condition behaves. */
      parameters: components['schemas']['WalletIdParameter'][];
    };
    /** @description The Wallet Id parameter determines on which Wallets this Condition will trigger. */
    WalletIdParameter: {
      /**
       * @description The name of the Condition Parameter.
       * @example walletId
       * @enum {string}
       */
      name: 'walletId';
      /**
       * @description A label for the Condition Parameter which can be shown to an end user.
       * @example Wallet Id
       */
      label: string;
      /**
       * @description A description for the Condition Parameter which can be shown to an end user.
       * @example he Wallet Ids
       */
      description: string;
      /**
       * @description The type of acceptable values for this Condition Parameter.
       * @example BITGO_WALLET_ID
       * @enum {string}
       */
      type: 'BITGO_WALLET_ID';
      /**
       * @description This Conditions Parameter must always be provided.
       * @example ALWAYS
       * @enum {string}
       */
      required: 'ALWAYS';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example true
       */
      allowMultiple: boolean;
    };
    /** @description The Wallet Type Condition for the All Wallets Scope. */
    WalletTypeCondition: {
      /**
       * @description The name of the Condition.
       * @example wallet.type
       * @enum {string}
       */
      name: 'wallet.type';
      /**
       * @description A label for the Condition which can be shown to an end user.
       * @example Wallet Type
       */
      label: string;
      /**
       * @description A description for the Condition which can be shown to an end user.
       * @example Allows creating a Condition based on the Wallet Type
       */
      description: string;
      /**
       * @description Status of the Condition. Indicates if the Condition is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Condition is available for use.
       * * "INACTIVE" - The Condition is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
      /** @description A list of Parameters to control how the Condition behaves. */
      parameters: components['schemas']['WalletTypeParameter'][];
    };
    /** @description The Wallet Type parameter determines on what type of Wallet this Condition will trigger. */
    WalletTypeParameter: {
      /**
       * @description The name of the Condition Parameter.
       * @example walletType
       * @enum {string}
       */
      name: 'walletType';
      /**
       * @description A label for the Condition Parameter which can be shown to an end user.
       * @example Type
       */
      label: string;
      /**
       * @description A description for the Condition Parameter which can be shown to an end user.
       * @example The Wallet Type
       */
      description: string;
      /**
       * @description This Conditions Parameter has a set of defined values.
       * @enum {string}
       */
      type: 'ENUMERATED';
      /**
       * @description This Conditions Parameter must always be provided.
       * @enum {string}
       */
      required: 'ALWAYS';
      /**
       * @description true, if multiple values can be provided, i.e. as a list of values. When false only one value can be provided, i.e. a list with more than one element will be rejected.
       * @example true
       */
      allowMultiple: boolean;
      /** @description A list of valid values, only values from this list will be accepted. */
      values: (
        | components['schemas']['CustodialValue']
        | components['schemas']['HotValue']
        | components['schemas']['ColdValue']
        | components['schemas']['TradingValue']
        | components['schemas']['CustodialPairedValue']
        | components['schemas']['BackingValue']
      )[];
    };
    /** @description The Custodial Wallet Wallet Type. */
    CustodialValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'custodial';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Custodial Wallet
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example A custodial wallet
       */
      description: string;
    };
    /** @description The Hot Wallet Wallet Type. */
    HotValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'hot';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Hot Wallet
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example A hot wallet
       */
      description: string;
    };
    /** @description The Cold Wallet Wallet Type. */
    ColdValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'cold';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Cold Wallet
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example A cold wallet
       */
      description: string;
    };
    /** @description The Trading Wallet Wallet Type. */
    TradingValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'trading';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Trading Wallet
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example A trading wallet
       */
      description: string;
    };
    /** @description The Custodial Paired Wallet Wallet Type. */
    CustodialPairedValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'custodialPaired';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Custodial Paired Wallet
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example A custodial paired wallet
       */
      description: string;
    };
    /** @description The Hot Wallet Wallet Type. */
    BackingValue: {
      /**
       * @description The actual value.
       * @enum {string}
       */
      value: 'backing';
      /**
       * @description A label for the Condition Parameter Value which can be shown to an end user.
       * @example Backing Wallet
       */
      label: string;
      /**
       * @description A description for the Condition Parameter Value which can be shown to an end user.
       * @example A backing wallet
       */
      description: string;
    };
    /** @description Wrapper object for a list of Conditions. Not paginated. */
    Conditions: {
      conditions?: (
        | components['schemas']['TransferDestinationTypeCondition']
        | components['schemas']['TransferVelocityLimitCondition']
        | components['schemas']['EnterpriseWhitelistExistsCondition']
        | components['schemas']['WalletWhitelistExistsCondition']
        | components['schemas']['TransferAmountCondition']
      )[];
    };
    /** @description Common fields of a paginated result paged with a nextBatchPrevId. */
    PaginatedResultsWithNextBatchPrevId: {
      /** @description The value to pass as the prevId to the API for getting the next page. */
      nextBatchPrevId: string;
    };
    /** @description Common fields of a paginated result. */
    PaginatedResults: {
      /** @description Page number. Page numbers start at 1. */
      page: number;
      /** @description Total number of pages. Total pages start at 1. */
      totalPages: number;
      /** @description Total number of elements across all pages. */
      totalElements: number;
    };
    /** @description The Always Deny Action. */
    AlwaysDenyActionRequest: {
      /**
       * @description Name of the associated Action.
       * @example approvals.always.deny
       * @enum {string}
       */
      name: 'approvals.always.deny';
    };
    /** @description The Wallet Admin Approval Action. */
    WalletAdminActionRequest: {
      /**
       * @description Name of the associated Action.
       * @example approvals.customer.walletAdmin
       * @enum {string}
       */
      name: 'approvals.customer.walletAdmin';
      /** @description Required data needed to configure the Action. */
      parameters: {
        /**
         * @description Number of required approvals
         * @example 1
         */
        minRequired: string;
      };
      operator?: components['schemas']['OperatorType'];
    };
    /** @description The Enterprise Admin Approval Action. */
    EnterpriseAdminActionRequest: {
      /**
       * @description Name of the associated Action.
       * @example approvals.customer.enterpriseAdmin
       * @enum {string}
       */
      name: 'approvals.customer.enterpriseAdmin';
      operator?: components['schemas']['OperatorType'];
    };
    /** @description The Final Approval Action. */
    FinalApprovalActionRequest: {
      /**
       * @description Name of the associated Action.
       * @example approvals.customer.finalApproval
       * @enum {string}
       */
      name: 'approvals.customer.finalApproval';
      /** @description Required data needed to configure the Action. */
      parameters: {
        /**
         * @description The final approvers
         * @example [
         *   "63cf101298470200073bbae71add80d5"
         * ]
         */
        userIds: string[];
      };
      operator?: components['schemas']['OperatorType'];
    };
    /** @description The Transfer Amount Condition. */
    TransferAmountConditionRequest: {
      /**
       * @description Name of the Condition.
       * @example transfer.amount
       * @enum {string}
       */
      name: 'transfer.amount';
      /** @description Required data needed to evaluate the Condition. */
      parameters: {
        /**
         * @description The comparison operator to use when comparing the transfer amount with the given amount
         * @example >
         * @enum {string}
         */
        operator: '>' | '>=' | '<' | '<=';
        /**
         * @description The transfer amount will be compared with this amount
         * @example 100000000
         */
        amount: string;
        /**
         * @description This condition only applies to transfers of this currency (USD applies to all transfers)
         * @example btc
         */
        coin: string;
      };
      operator?: components['schemas']['OperatorType'];
    };
    /** @description The Transfer Velocity Limit Condition. */
    TransferVelocityLimitConditionRequest: {
      /**
       * @description Name of the Condition.
       * @example transfer.velocity.limit
       * @enum {string}
       */
      name: 'transfer.velocity.limit';
      /** @description Required data needed to evaluate the Condition. */
      parameters: {
        /**
         * @description Entities that will be included in the velocity calculation
         * @example wallet
         * @enum {string}
         */
        scope: 'wallet' | 'enterprise';
        /**
         * @description The amount that can be spent within the Time Window
         * @example 60
         */
        timeWindow: string;
        /**
         * @description The transfer amount will be compared with this amount
         * @example 100000000
         */
        amount: string;
        /**
         * @description The unit that the amount is denoted in, can be a coin or a fiat currency
         * @example ETH
         */
        coin: string;
      };
      operator?: components['schemas']['OperatorType'];
    };
    /** @description The Transfer Destination Type Condition. */
    TransferDestinationTypeConditionRequest: {
      /**
       * @description Name of the Condition.
       * @example transfer.destination.type
       * @enum {string}
       */
      name: 'transfer.destination.type';
      /** @description Required data needed to evaluate the Condition. */
      parameters: {
        /**
         * @description The type of destination this condition will match
         * @example walletWhitelistedAddress
         * @enum {string}
         */
        type:
          | 'walletWhitelistedAddress'
          | 'enterpriseWhitelistedAddress'
          | 'nonWalletWhitelistedAddress'
          | 'nonEnterpriseWhitelistedAddress';
      };
      operator?: components['schemas']['OperatorType'];
    };
    /** @description The Wallet Whitelist Exists Condition. */
    WalletWhitelistExistsConditionRequest: {
      /**
       * @description Name of the Condition.
       * @example wallet.whitelist.exists
       * @enum {string}
       */
      name: 'wallet.whitelist.exists';
      operator?: components['schemas']['OperatorType'];
    };
    /** @description The Enterprise Whitelist Exists Condition. */
    EnterpriseWhitelistExistsConditionRequest: {
      /**
       * @description Name of the Condition.
       * @example enterprise.whitelist.exists
       * @enum {string}
       */
      name: 'enterprise.whitelist.exists';
      operator?: components['schemas']['OperatorType'];
    };
    /** @description The Rule Filtering Conditions Condition. */
    RuleFilteringConditionsConditionRequest: {
      /**
       * @description Name of the Condition.
       * @example rule.filtering.conditions
       * @enum {string}
       */
      name: 'rule.filtering.conditions';
      /** @description Required data needed to evaluate the Condition. */
      parameters: {
        /**
         * @description The type of filtering condition this condition will match
         * @example wallet.all
         * @enum {string}
         */
        filteringConditions: 'wallet.all' | 'wallet.type' | 'wallet.ids';
      };
      operator?: components['schemas']['OperatorType'];
    };
    /** @description The Wallet Ids Filtering Condition. */
    WalletIdsFilteringCondition: {
      /**
       * @description Name of the Condition.
       * @example wallet.ids
       * @enum {string}
       */
      name: 'wallet.ids';
      /** @description Required data needed to evaluate the Filtering Condition. */
      parameters: {
        walletId: string[];
      };
    };
    /** @description The Wallet All Filtering Condition. */
    WalletAllFilteringCondition: {
      /**
       * @description Name of the Condition.
       * @example wallet.all
       * @enum {string}
       */
      name: 'wallet.all';
    };
    /** @description The Rule All Filtering Condition. */
    RuleAllFilteringCondition: {
      /**
       * @description Name of the Condition.
       * @example rule.all
       * @enum {string}
       */
      name: 'rule.all';
    };
    /** @description The Wallet Type Filtering Condition. */
    WalletTypeFilteringCondition: {
      /**
       * @description Name of the Condition.
       * @example wallet.type
       * @enum {string}
       */
      name: 'wallet.type';
      /** @description Required data needed to evaluate the Filtering Condition. */
      parameters: {
        walletType: ('hot' | 'custodial')[];
      };
    };
    /** @description description: All versions of a policy rule. Not paginated. */
    PolicyRuleVersions: {
      /**
       * @description List of policy rule versions. The list is sorted by version number in descending order, but rules with a
       * null version, such as those in pending approval or denied, appear first.
       */
      versions: components['schemas']['PolicyRule1'][];
    };
    /**
     * @description A Policy Rule, the combination of a Scope, a Touchpoint, Conditions, and Actions. It allows you to define what
     * needs to happen (Actions) before a user can execute a sensitive operation (Touchpoint) on a Scope (e.g. a Wallet)
     * depending on the specific details of the operation (Conditions). See Concepts.
     */
    PolicyRule: {
      /**
       * @description Id of the Policy Rule. This identifier is not unique in isolation, it must be paired with an specific Policy Rule Version number to uniquely identified a particular version of a Policy Rule. A UUID.
       * @example 306258df-dcab-489e-a9fe-ff28ce9fa312
       */
      id: string;
      /**
       * @description The uniqueId of the Policy Rule version. A UUID.
       * @example cb4e0a0a-2768-4024-904a-178ca6d2cd54
       */
      uniqueId: string;
      /**
       * @description Human readable name of the rule.
       * @example My first policy rule
       */
      name: string;
      /**
       * @description Indicates if the Policy Rule is considered in Evaluations.
       *
       * * "ACTIVE" - Will be Evaluated.
       * * "INACTIVE" - Will NOT be Evaluated.
       * * "DENIED" - The requested policy rule change was Denied.
       * * "PENDING_APPROVAL" - This version of the policy rule is Pending Approval before it can be activated.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE' | 'DENIED' | 'PENDING_APPROVAL';
      /**
       * @description The Policy Rule Version, an integer that is incremented each time the Policy Rule changes.
       * @default 1
       * @example 1
       */
      version?: number;
      /**
       * @description true, if the Policy Rule is a BitGo internal rule. Typically, this allows setting Global Policy Rules across enterprises.
       * @example false
       */
      adminOnly: boolean;
      /**
       * @description The id of the Touchpoint associated with the Policy Rule. A UUID.
       * @example 0a244ae3-26cf-48ed-9854-edd5b9751f3e
       */
      touchpointId: string;
      /**
       * @description Label of the Touchpoint associated with the Policy Rule. For example the Transfer from a Wallet Touchpoint.
       * @example Transfer from a Wallet
       */
      touchpointLabel: string;
      /**
       * @description The id of the Scope associated with the Policy Rule. A UUID.
       * @example 08a3f714-c330-41e6-bd83-bad3a8d37188
       */
      scopeId: string;
      /**
       * @description Label of the Scope associated with the Policy Rule. For example the All Wallets Scope.
       * @example All Wallets
       */
      scopeLabel: string;
      /** @description List of Policy Rule Clauses: a combination of Conditions and Actions. */
      clauses: components['schemas']['Clause'][];
      /** @description List of Filtering Conditions that must trigger for this Policy Rule to be Evaluated. */
      filteringConditions: (
        | components['schemas']['WalletTypeFilteringCondition']
        | components['schemas']['WalletIdsFilteringCondition']
        | components['schemas']['WalletAllFilteringCondition']
        | components['schemas']['RuleAllFilteringCondition']
      )[];
      /**
       * @description true, if the Policy Rule is locked, false otherwise.
       * @example false
       */
      locked: boolean;
      /**
       * @description Indicates how the Policy Rule is locked.
       *
       * * "LOCK_AFTER_DATE" - Will lock after the lockDate set on the Policy Rule.
       * * "PERMANENT" - Is permanently locked.
       *
       * @example PERMANENT
       * @enum {string}
       */
      lockType: 'LOCK_AFTER_DATE' | 'PERMANENT';
      /**
       * Format: date-time
       * @description The date after which the Policy Rule will be locked. Only applicable if the Policy Rule is locked with
       * "LOCK_AFTER_DATE".
       *
       * @example 2023-11-13T14:49:48.830Z
       */
      lockDate?: string;
      /**
       * @description The id of the Enterprise this Policy Rule belongs to.
       * @example 5d1a5f2c8f0a9c001a5f2c8f0ad00000
       */
      enterpriseId?: string;
      /**
       * Format: date-time
       * @description The date when the Policy Rule was last triggered. Only applicable if the Policy Rule is locked with
       * "LOCK_AFTER_DATE".
       *
       * @example 2023-11-13T14:49:48.830Z
       */
      lastTriggeredDate?: string;
      /**
       * @description The id of the Evaluation that last triggered the Policy Rule. A UUID.
       *
       * @example 306258df-dcab-489e-a9fe-ff28ce9fa312
       */
      lastTriggeredEvaluationId?: string;
      /**
       * @description The id of the user who created the Policy Rule or the string \"BitGo\".
       * @example 5d1a5f2c8f0a9c001a5f2c8f0ad00000
       */
      createdBy: string;
      /**
       * @description The id of the user who last modified the Policy Rule or the string \"BitGo\".
       * @example 5d1a5f2c8f0a9c001a5f2c8f0ad00000
       */
      modifiedBy: string;
      /**
       * @description The id of the user who last modified the lock of the Policy Rule.
       * @example 5d1a5f2c8f0a9c001a5f2c8f0ad00000
       */
      lockModifiedBy?: string;
      /**
       * @description The id of the Evaluation that was done when this Policy Rule version was requested to be created, modified
       * or deleted. A UUID.
       *
       * @example 306258df-dcab-489e-a9fe-ff28ce9fa312
       */
      evaluationId?: string;
    };
    /** @description Create or Update Policy Rule Request. */
    CreatePolicyRuleRequest: {
      /**
       * @description Human readable name of the rule.
       * @example Get approval if transferring more than 2 BTC in a minute
       */
      name: string;
      /**
       * @description true, if the Policy Rule is a BitGo internal rule, false otherwise.
       * @example false
       */
      adminOnly: boolean;
      /** @description List of Policy Rule Clauses: a combination of Conditions and Actions. */
      clauses: {
        conditions: (
          | components['schemas']['TransferAmountConditionRequest']
          | components['schemas']['TransferVelocityLimitConditionRequest']
          | components['schemas']['TransferDestinationTypeConditionRequest']
          | components['schemas']['WalletWhitelistExistsConditionRequest']
          | components['schemas']['EnterpriseWhitelistExistsConditionRequest']
        )[];
        actions: (
          | components['schemas']['AlwaysDenyActionRequest']
          | components['schemas']['WalletAdminActionRequest']
          | components['schemas']['FinalApprovalActionRequest']
        )[];
      }[];
      /** @description List of Filtering Conditions that must trigger for the Policy Rule to be Evaluated. */
      filteringConditions: (
        | components['schemas']['WalletIdsFilteringCondition']
        | components['schemas']['WalletTypeFilteringCondition']
        | components['schemas']['WalletAllFilteringCondition']
      )[];
      /**
       * @description Indicates how the Policy Rule is locked.
       *
       * * "LOCK_AFTER_DATE" - Will lock after the lockDate set on the Policy Rule.
       * * "PERMANENT" - Is permanently locked.
       *
       * @example PERMANENT
       * @enum {string}
       */
      lockType?: 'LOCK_AFTER_DATE' | 'PERMANENT';
      /**
       * Format: date-time
       * @description The date after which the Policy Rule will be locked. Only applicable if the Policy Rule is locked with
       * "LOCK_AFTER_DATE".
       *
       * @example 2023-11-13T14:49:48.830Z
       */
      lockDate?: string;
    };
    /** @description Paginated list of Policy Rules. */
    PolicyRulesResults: components['schemas']['PaginatedResultsWithNextBatchPrevId'] & {
      /** @description A list of Policy Rules matching the search criteria. */
      rules?: components['schemas']['PolicyRule1'][];
    };
    /**
     * @description Boolean operators that join Conditions, and/or Actions. Must be null on the last Condition or Action, or if there is only one Condition or Action, must be non-null on all others.
     * @example AND
     * @enum {string}
     */
    OperatorType: 'AND' | 'OR';
    /** @description A Policy Rule Scope. For example the All Wallets Scope. */
    AllWalletsScope: {
      /**
       * @description Unique id of the Scope. A UUID.
       * @example 306258df-dcab-489e-a9fe-ff28ce9fa312
       */
      id: string;
      /**
       * @description Name of the Scope.
       * @example wallet.segregated
       * @enum {string}
       */
      name: 'wallet.segregated';
      /**
       * @description A label for the Scope which can be shown to an end user.
       * @example Wallet
       */
      label: string;
      /**
       * @description A description for the Scope which can be shown to an end user.
       * @example A BitGo Wallet
       */
      description: string;
      /** @description A list of Filtering Conditions the Scope supports. For example the Wallet Type Filtering Condition. */
      conditions: (
        | components['schemas']['WalletTypeCondition']
        | components['schemas']['WalletIdsCondition']
        | components['schemas']['WalletAllCondition']
      )[];
    };
    /** @description Wrapper object for a list of Scopes. Not paginated. */
    Scopes: {
      /** @description A list of Scopes available on your Enterprise. */
      scopes?: components['schemas']['AllWalletsScope'][];
    };
    /** @description A Touchpoint. For example the Transfer from a Wallet Touchpoint. */
    Touchpoint: {
      /**
       * @description Id of the Touchpoint. A UUID.
       * @example 306258df-dcab-489e-a9fe-ff28ce9fa312
       */
      id: string;
      /**
       * @description Name of the Touchpoint.
       * @example wallet.segregated.transfer
       * @enum {string}
       */
      name: 'wallet.segregated.transfer' | 'policies.management.edit';
      /**
       * @description A label for the Touchpoint which can be shown to an end user.
       * @example Transfer from a Segregated Wallet
       */
      label: string;
      /**
       * @description A description for the Touchpoint which can be shown to an end user.
       * @example When transferring from a BitGo Segregated Wallet
       */
      description: string;
      /**
       * @description Status of the Touchpoint. Indicates if the Touchpoint is usable "ACTIVE" or not "INACTIVE".
       *
       * * "ACTIVE" - The Touchpoint is available for use.
       * * "INACTIVE" - The Touchpoint is NOT available for use.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE';
      /**
       * @description true, if this is an internal Touchpoint, false otherwise.
       * @example false
       */
      adminOnly: boolean;
    };
    /** @description A paginated list of Touchpoints */
    TouchpointsResults: components['schemas']['PaginatedResults'] & {
      touchpoints?: components['schemas']['Touchpoint'][];
    };
    GeneralError: {
      code?: string;
      message?: string;
      status?: number;
    };
    ValidationError: components['schemas']['GeneralError'] & {
      failedValidations?: Record<string, never>;
    };
    /**
     * @example {
     *   "id": "a253c86c-1f0f-42cc-bcd0-2dcc5040b204",
     *   "firstName": "Uncle",
     *   "lastName": "MoneyPenny",
     *   "email": "uncle.moneypenny@bitgo.com"
     * }
     */
    PortfolioUser: {
      /** Format: uuid */
      id: string;
      firstName: string;
      lastName: string;
      /** Format: email */
      email: string;
    };
    InstrumentPrices: components['schemas']['InstrumentPrice'][];
    /**
     * @example {
     *   "time": "2014-11-07T22:19:28.578Z",
     *   "open": 576.0590066,
     *   "high": 576.0590066,
     *   "low": 575.8330204,
     *   "close": 575.978887,
     *   "base_volume": 296.23,
     *   "quote_volume": 170627.62385
     * }
     */
    InstrumentPrice: {
      /** Format: date-time */
      time: string;
      /** Format: float */
      open: number;
      /** Format: float */
      high: number;
      /** Format: float */
      low: number;
      /** Format: float */
      close: number;
      /** Format: float */
      base_volume: number;
      /** Format: float */
      quote_volume: number;
    };
    Portfolios: components['schemas']['Portfolio'][];
    /**
     * @example {
     *   "id": "c702a0d4-0a09-4d86-bd6a-76540359a497",
     *   "name": "Main Portfolio",
     *   "organization_id": "15e108fd-4ea8-458a-b329-cc4750729e9b",
     *   "organization_name": "Lumina Technologies, Inc."
     * }
     */
    Portfolio: {
      /** Format: uuid */
      id: string;
      name: string;
      /** Format: uuid */
      organization_id: string;
      organization_name: string;
    };
    Connections: components['schemas']['Connection'][];
    /**
     * @example {
     *   "id": "35de9881-731b-475b-ab48-c39e3edd9985",
     *   "name": "CoinbasePro",
     *   "institution_id": "0911b966-3f6a-4320-8d64-a1d310a9d80e",
     *   "institution_name": "Coinbase Pro",
     *   "last_sync": "2018-03-28T16:58:30.000Z",
     *   "sync_status": "idle"
     * }
     */
    Connection: {
      /** Format: uuid */
      id: string;
      name: string;
      /** Format: uuid */
      institution_id: string;
      institution_name: string;
      /** Format: date-time */
      last_sync?: string;
      sync_status?: components['schemas']['SyncStatus'];
    };
    /** @enum {string} */
    SyncStatus: 'idle' | 'scheduled' | 'processing' | 'error';
    PortfolioAccounts: components['schemas']['PortfolioAccount'][];
    /**
     * @example {
     *   "id": "ca0eda2d-0b76-4aba-94dd-88bc06ea5b92",
     *   "name": "Coinbase Pro Main Account",
     *   "type": "exchange"
     * }
     */
    PortfolioAccount: {
      /** Format: uuid */
      id: string;
      name: string;
      type: components['schemas']['PortfolioAccountType'];
    };
    /** @enum {string} */
    PortfolioAccountType:
      | 'checking'
      | 'exchange'
      | 'savings'
      | 'blockchain_wallet'
      | 'custodial_wallet'
      | 'unaccounted_assets'
      | 'blockchain_hd_wallet'
      | 'custom'
      | 'broker'
      | 'blockchain_multisig_wallet'
      | 'trading_wallet';
    InstrumentBalances: components['schemas']['InstrumentBalance'][];
    /**
     * @example {
     *   "instrument_id": "6016e0a9-545a-45fb-8370-caab1680956a",
     *   "instrument_symbol": "BTC",
     *   "quantity": "0.02713510000000001",
     *   "marketPrice": "15659.03",
     *   "marketValue": "424.9093449530002"
     * }
     */
    InstrumentBalance: {
      /** Format: uuid */
      instrument_id: string;
      /** @description Currency symbol */
      instrument_symbol?: string;
      /** Format: decimal */
      quantity: string;
      /** Format: decimal */
      marketPrice: string;
      /** Format: decimal */
      marketValue: string;
    };
    Transactions: {
      data: components['schemas']['PortfolioTransaction'][];
    };
    /**
     * @example {
     *   "id": "7e0c768e-2d16-4c1e-b39d-06fa20009397",
     *   "trade_date": "2014-11-07T22:19:28.578Z",
     *   "settlement_date": "2014-11-07T22:19:28.578Z",
     *   "product": "BTC-USD",
     *   "type": "buy",
     *   "subtype": "deposit",
     *   "transaction_hash": "",
     *   "fees": "0",
     *   "unitPrice": "10000.00",
     *   "quantity": "0.001",
     *   "totalAmount": "1"
     * }
     */
    PortfolioTransaction: {
      /** Format: uuid */
      id: string;
      /** Format: date-time */
      trade_date: string;
      /** Format: date-time */
      settlement_date: string;
      /** @description Product name e.g. BTC-USD */
      product?: string;
      type: components['schemas']['TransactionType'];
      subtype: string;
      transaction_hash?: string;
      /** Format: decimal */
      fees: string;
      /** Format: decimal */
      unitPrice: string;
      /** Format: decimal */
      quantity: string;
      /** Format: decimal */
      totalAmount: string;
    };
    /** @enum {string} */
    TransactionType:
      | 'buy'
      | 'sell'
      | 'cash'
      | 'dividends_interest_fees'
      | 'pending'
      | 'transfer'
      | 'cancel'
      | 'blockchain_action';
    LineItems: {
      data: components['schemas']['LineItem'][];
    };
    /**
     * @example {
     *   "id": "9c9989f1-d9e3-4015-93bf-596396d9543d",
     *   "exchange_order_id": "ca20c088-c10d-440a-8b0d-73763170077f",
     *   "exchange_trade_id": "cb5f1d08-14f6-42a7-a54b-421941702722",
     *   "account_id": "7071983a-3349-4a16-98b5-e4b511aee328",
     *   "connection_id": "c549df20-1517-4308-b8cd-71a70df4ff67",
     *   "transaction_date": "2014-11-07T22:19:28.578Z",
     *   "transaction_completed_date": "2014-11-07T22:19:28.578Z",
     *   "instrument_id": "519824c6-b534-49b4-a636-22dfd0ade5cf",
     *   "instrument_symbol": "USD",
     *   "type": "received",
     *   "source": "api",
     *   "unitPrice": "1",
     *   "quantity": "466.21",
     *   "value": "466.21",
     *   "transaction_hash": "3c0cb5ac1472571e4b196b1d4a774e41628ae165b1bee6685346ef8bf3a550ac",
     *   "block_height": "",
     *   "sent_address": "6bf7dfe3f7b3eaffb91165edb7a81e1523e6490e2497067e7d81600dbbe79ba11e592e5c7fd8",
     *   "received_address": ""
     * }
     */
    LineItem: {
      /** Format: uuid */
      id: string;
      exchange_order_id?: string;
      exchange_trade_id?: string;
      /** Format: uuid */
      account_id: string;
      /** Format: uuid */
      connection_id: string;
      /** Format: date-time */
      transaction_date: string;
      /** Format: date-time */
      transaction_completed_date: string;
      /** Format: uuid */
      instrument_id: string;
      /** @description Currency symbol */
      instrument_symbol: string;
      type: components['schemas']['LineItemType'];
      source: components['schemas']['LineItemSource'];
      /** Format: decimal */
      unitPrice: string;
      /** Format: decimal */
      quantity: string;
      /** Format: decimal */
      value: string;
      transaction_hash?: string;
      /** Format: integer */
      block_height?: string;
      sent_address?: string;
      received_address?: string;
    };
    /** @enum {string} */
    LineItemType: 'sent' | 'received';
    /** @enum {string} */
    LineItemSource: 'api' | 'csv' | 'manual' | 'system' | 'manual_reconciliation' | 'smart_reconciliation';
    /**
     * @example {
     *   "error": "invalid permission",
     *   "errorName": "backend:common:forbidden",
     *   "reqId": "d41d4d21e63d63b293caf55f2a739a79"
     * }
     */
    Error: {
      error: string;
      errorName: string;
      reqId: string;
    };
    /**
     * @example {
     *   "id": "a253c86c-1f0f-42cc-bcd0-2dcc5040b204",
     *   "firstName": "Uncle",
     *   "lastName": "MoneyPenny",
     *   "email": "uncle.moneypenny@bitgo.com"
     * }
     */
    TradeUser: {
      /** Format: uuid */
      id: string;
      firstName: string;
      lastName: string;
      /** Format: email */
      email: string;
    };
    /**
     * @example {
     *   "id": "f230fdebfa084ffebc7e00515f54603f",
     *   "name": "Uncle MoneyPenny's Trading Wallet"
     * }
     */
    Account: {
      /** Format: uuid */
      id: string;
      name: string;
    };
    Accounts: components['schemas']['Account1'][];
    /**
     * @example {
     *   "currencyId": "6016e0a9-545a-45fb-8370-caab1680956a",
     *   "currency": "BTC",
     *   "balance": "100.0",
     *   "heldBalance": "10.0",
     *   "tradableBalance": "90.0"
     * }
     */
    AccountBalance: {
      /** @description Currency symbol */
      currency: string;
      /**
       * Format: decimal
       * @description The total balance in the account
       */
      balance: string;
      /**
       * Format: decimal
       * @description The total balance reserved for some purpose, e.g. a pending withdrawal
       */
      heldBalance: string;
      /**
       * Format: decimal
       * @description The total balance available for trading
       */
      tradableBalance: string;
      /**
       * Format: decimal
       * @description The total balance available for withdrawal
       */
      withdrawableBalance: string;
    };
    AccountBalances: components['schemas']['AccountBalance'][];
    /**
     * @example {
     *   "id": "67fd640c-cb6c-4218-80ae-49e79ec15646",
     *   "accountId": "60e740e7898f7d00064d43769a73dc48",
     *   "clientOrderId": "myorderid1",
     *   "time": "2021-08-05T18:05:23.431Z",
     *   "creationDate": "2021-08-05T18:05:22.286Z",
     *   "scheduledDate": "2021-08-05T18:05:00.000Z",
     *   "lastFillDate": "2021-08-05T18:05:23.302Z",
     *   "completionDate": "2021-08-05T18:05:23.431Z",
     *   "settleDate": "2021-08-05T20:00:00.000Z",
     *   "fundingType": "funded",
     *   "type": "market",
     *   "status": "completed",
     *   "product": "BTC-USD",
     *   "side": "buy",
     *   "quantity": "1000",
     *   "quantityCurrency": "USD",
     *   "filledQuantity": "0.02457152",
     *   "filledQuoteQuantity": "1000",
     *   "averagePrice": "40697.32"
     * }
     */
    Order: {
      /** Format: uuid */
      id: string;
      accountId: string;
      clientOrderId?: string;
      /**
       * Format: date-time
       * @description DEPRECATED
       */
      time: string;
      /** Format: date-time */
      creationDate: string;
      /** Format: date-time */
      scheduledDate?: string;
      /** Format: date-time */
      lastFillDate?: string;
      /** Format: date-time */
      completionDate: string;
      /** Format: date-time */
      settleDate?: string;
      type: string;
      /** @enum {string} */
      fundingType: 'margin' | 'funded';
      status: components['schemas']['OrderStatus'];
      /** @description Product name e.g. BTC-USD */
      product: string;
      side: components['schemas']['Side'];
      /**
       * Format: decimal
       * @description The specified quantity.
       */
      quantity: string;
      /** @description The specified quantity currency. */
      quantityCurrency: string;
      /**
       * Format: decimal
       * @description The base quantity that was filled.
       */
      filledQuantity: string;
      /**
       * Format: decimal
       * @description The quote quantity that was filled.
       */
      filledQuoteQuantity: string;
      /** Format: decimal */
      averagePrice: string;
      /** Format: decimal */
      limitPrice?: string;
      /** @description Duration of the order in minutes. */
      duration?: number;
      /** @description Interval length of the TWAP order in minutes. */
      twapInterval?: number;
      /**
       * @description Reason for order cancellation. 'internalError' indicates an error occurred within the server while processing the order, resulting in an order cancellation. 'insufficientFunds' indicates that the order was cancelled due to shortage of funds to complete the transaction.
       * @example insufficientFunds
       * @enum {string}
       */
      reason?: 'internalError' | 'insufficientFunds';
    };
    Orders: components['schemas']['Order'][];
    NewOrderRequest:
      | components['schemas']['NewMarketOrderRequest']
      | components['schemas']['NewLimitOrderRequest']
      | components['schemas']['NewTWAPOrderRequest'];
    /**
     * @example {
     *   "clientOrderId": "myorder1",
     *   "type": "market",
     *   "product": "BTC-USD",
     *   "side": "buy",
     *   "quantity": "10000",
     *   "quantityCurrency": "USD"
     * }
     */
    NewMarketOrderRequest: {
      /** @description Custom order ID. */
      clientOrderId?: string;
      /** @description Product name e.g. BTC-USD */
      product: string;
      /** @description Must be set to "market" */
      type: string;
      side: components['schemas']['Side'];
      /** Format: decimal */
      quantity: string;
      /** @description The quantity currency must be in quote currency for buy and base currency for sell. e.g. If product is BTC-USD, the base currency will be BTC. */
      quantityCurrency: string;
    };
    /**
     * @example {
     *   "clientOrderId": "myorder1",
     *   "type": "limit",
     *   "product": "BTC-USD",
     *   "side": "buy",
     *   "quantity": "1",
     *   "quantityCurrency": "BTC",
     *   "limitPrice": "10005",
     *   "duration": 60
     * }
     */
    NewLimitOrderRequest: {
      /** @description Custom order ID. */
      clientOrderId?: string;
      /** @description Product name e.g. BTC-USD */
      product: string;
      /** @description Must be set to "limit" */
      type: string;
      side: components['schemas']['Side'];
      /** Format: decimal */
      quantity: string;
      /** @description The quantity currency must be in the base currency for both buy and sell. e.g. If product is BTC-USD, the base currency will be BTC. */
      quantityCurrency: string;
      /** Format: decimal */
      limitPrice: string;
      /** @description Duration of the limit order in minutes. */
      duration?: number;
    };
    /**
     * @example {
     *   "clientOrderId": "myorder1",
     *   "type": "twap",
     *   "product": "BTC-USD",
     *   "side": "buy",
     *   "quantity": "100000",
     *   "quantityCurrency": "USD",
     *   "duration": 60,
     *   "interval": 5
     * }
     */
    NewTWAPOrderRequest: {
      /** @description Custom order ID. */
      clientOrderId?: string;
      /** @description Product name e.g. BTC-USD */
      product: string;
      /** @description Must be set to "twap" */
      type: string;
      side: components['schemas']['Side'];
      /** Format: decimal */
      quantity: string;
      /** @description The quantity currency must be in quote currency for buy unless a limit price is specified, in which case buy orders can only be placed in the base currency. For sell, the quantity currency must be in base. e.g. If product is BTC-USD, the base currency will be BTC. */
      quantityCurrency: string;
      /** Format: decimal */
      limitPrice?: string;
      /** @description Duration of the TWAP order in minutes. */
      duration: number;
      /** @description Interval of the TWAP order in minutes. */
      interval: number;
      /** Format: date-time */
      scheduledDate?: string;
    };
    /**
     * @example {
     *   "id": "7e0c768e-2d16-4c1e-b39d-06fa20009397",
     *   "orderId": "d50ec984-77a8-460a-b958-66f114b0de9b",
     *   "time": "2014-11-07T22:19:28.578Z",
     *   "side": "buy",
     *   "product": "BTC-USD",
     *   "quoteQuantity": "100.50",
     *   "price": "22333.33",
     *   "quantity": "0.0045",
     *   "settled": true
     * }
     */
    PrimeTrade: {
      /** Format: uuid */
      id: string;
      /** Format: uuid */
      orderId: string;
      /** Format: date-time */
      time: string;
      /** @description Product name e.g. BTC-USD */
      product: string;
      side: components['schemas']['Side'];
      /** Format: decimal */
      price: string;
      /**
       * Format: decimal
       * @description Quote quantity, e.g. For BTC-USD product, 100.50 USD
       */
      quoteQuantity: string;
      /**
       * Format: decimal
       * @description Base quantity, e.g. For BTC-USD product, 0.0045 BTC
       */
      quantity: string;
      settled: boolean;
    };
    Trades: components['schemas']['PrimeTrade'][];
    /**
     * @example {
     *   "id": "6016e0a9-545a-45fb-8370-caab1680956a",
     *   "symbol": "BTC",
     *   "name": "Bitcoin"
     * }
     */
    Currency: {
      /** Format: uuid */
      id: string;
      symbol: string;
      name: string;
    };
    Currencies: components['schemas']['Currency'][];
    /**
     * @example {
     *   "id": "86d09911-e58e-4f27-ac1f-91d5f9c79952",
     *   "name": "BTC-USD",
     *   "baseCurrencyId": "6016e0a9-545a-45fb-8370-caab1680956a",
     *   "quoteCurrencyId": "7d5d1e8d-e6e1-4676-99af-190012515418",
     *   "baseCurrency": "BTC",
     *   "quoteCurrency": "USD",
     *   "baseMinSize": "0.001",
     *   "baseMaxSize": "10000.00",
     *   "quoteIncrement": "0.01"
     * }
     */
    Product: {
      /** Format: uuid */
      id: string;
      /** @description Product name e.g. BTC */
      name: string;
      /** Format: uuid */
      baseCurrencyId: string;
      /** @description Currency name e.g. BTC */
      baseCurrency: string;
      /** Format: uuid */
      quoteCurrencyId: string;
      /** @description Currency name e.g. USD */
      quoteCurrency: string;
      /** Format: decimal */
      baseMinSize: string;
      /** Format: decimal */
      baseMaxSize?: string;
      /** Format: decimal */
      baseIncrement?: string;
      /** Format: decimal */
      quoteMinSize: string;
      /** Format: decimal */
      quoteIncrement: string;
      isTradeDisabled: boolean;
    };
    Products: components['schemas']['Product'][];
    /**
     * @example {
     *   "time": "2020-01-14T00:00:00.123Z",
     *   "product": "BTC-USD",
     *   "bidPrice": "7090.96",
     *   "bidSize": "1.253433",
     *   "askPrice": "7090.97",
     *   "askSize": "25.23881"
     * }
     */
    Level1OrderBookSnapshot: {
      /** Format: date-time */
      time: string;
      /** @description Product name e.g. BTC */
      product: string;
      /** Format: decimal */
      bidPrice: string;
      /** Format: decimal */
      bidSize: string;
      /** Format: decimal */
      askPrice: string;
      /** Format: decimal */
      askSize: string;
    };
    /**
     * @example {
     *   "time": "2020-01-14T00:00:00.123Z",
     *   "product": "BTC-USD",
     *   "bids": [
     *     [
     *       "7090.96",
     *       "1.253433"
     *     ]
     *   ],
     *   "asks": [
     *     [
     *       "7090.97",
     *       "25.23881"
     *     ]
     *   ]
     * }
     */
    Level2OrderBookSnapshot: {
      /** Format: date-time */
      time: string;
      /** @description Product name e.g. BTC */
      product: string;
      /** @description An array of levels of [price, size] */
      bids: string[];
      /** @description An array of levels of [price, size] */
      asks: string[];
    };
    /** @enum {string} */
    OrderStatus: 'pending_open' | 'open' | 'completed' | 'pending_cancel' | 'canceled' | 'error' | 'scheduled';
    StakingRequestPOSTBody: {
      /** @description Optional user generated identifier to detect duplicated requests. */
      clientId?: string;
      /**
       * @description Amount to stake in “base units” (i.e. Wei for ETH) For Ethereum the amounts need to be a multiple of 32 Eth (32000000000000000000 Wei). For Testnet the 32 Eth multiple restriction does not apply.
       * @example 32000000000000000000
       */
      amount: string;
      /**
       * @description Staking Request type = 'STAKE'
       * @example STAKE
       */
      type: string;
    };
    AvaxPStakingRequestPOSTBody: WithRequired<
      {
        /**
         * @description Amount to stake in “base units”.
         * @example 1000
         */
        amount: string;
        /**
         * @description The length of time in seconds to complete a staking period.
         * @example 604800
         */
        durationSeconds: number;
      } & components['schemas']['StakingRequestPOSTBody'],
      'amount' | 'type' | 'durationSeconds'
    >;
    EthStakingRequestPOSTBody: {
      /** @description User overridden gas price to apply for the generated transactions for this request.  GasPrice is in “base units”. */
      gasPrice?: string;
    } & components['schemas']['StakingRequestPOSTBody'];
    MaticStakingRequestPOSTBody: {
      /** @description User overridden gas price to apply for the generated transactions for this request.  GasPrice is in “base units”. */
      gasPrice?: string;
    } & components['schemas']['StakingRequestPOSTBody'];
    NearStakingRequestPOSTBody: {
      /**
       * @description Amount to stake in “base units”.
       * @example 12000000000000000000
       */
      amount?: string;
    } & components['schemas']['StakingRequestPOSTBody'];
    SolStakingRequestPOSTBody: {
      /**
       * @description Amount to stake in “base units”.
       * @example 1000
       */
      amount?: string;
    } & components['schemas']['StakingRequestPOSTBody'];
    DotStakingRequestPOSTBody: {
      /**
       * @description Amount to stake in “base units”.
       * @example 10000000000
       */
      amount?: string;
    } & components['schemas']['StakingRequestPOSTBody'];
    CosmosLikeStakingRequestPOSTBody: WithRequired<
      {
        /**
         * @description The validator to delegate to.
         * @example 017234b285929170324e1051ccd887dc08adf049650ecf5d383985b0b0048ab39b
         */
        validator: string;
      } & components['schemas']['StakingRequestPOSTBody'],
      'validator'
    >;
    AtomStakingRequestPOSTBody: components['schemas']['StakingRequestPOSTBody'];
    UnStakingRequestPOSTBody: {
      /** @description Optional user generated identifier to detect duplicated requests. */
      clientId?: string;
      /**
       * @description Staking Request type = 'UNSTAKE'
       * @example UNSTAKE
       */
      type: string;
    };
    MaticUnStakingRequestPOSTBody: {
      /** @description User overridden gas price to apply for the generated transactions for this request.  GasPrice is in “base units”. */
      gasPrice?: string;
    } & components['schemas']['UnStakingRequestPOSTBody'];
    NearUnStakingRequestPOSTBody: WithRequired<
      {
        /**
         * @description Amount to stake in “base units”.
         * @example 12000000000000000000
         */
        amount: string;
      } & components['schemas']['UnStakingRequestPOSTBody'],
      'amount' | 'type'
    >;
    SolUnStakingRequestPOSTBody: WithRequired<
      {
        /** @description The delegation Id representing the delegation to unstake. */
        delegationId?: string;
      } & components['schemas']['UnStakingRequestPOSTBody'],
      'type'
    >;
    DotUnStakingRequestPOSTBody: WithRequired<
      {
        /** @description The delegation Id representing the delegation to unstake. */
        delegationId?: string;
        /**
         * @description Amount to unstake in “base units”.
         * @example 10000000000
         */
        amount?: string;
      } & components['schemas']['UnStakingRequestPOSTBody'],
      'type'
    >;
    CosmosLikeUnStakingRequestPOSTBody: WithRequired<
      {
        /** @description Optional delegation Id representing the delegation to unstake. */
        delegationId?: string;
        /**
         * @description Amount to unstake in “base units”.
         * @example 10000000000
         */
        amount: string;
      } & components['schemas']['UnStakingRequestPOSTBody'],
      'amount'
    >;
    AtomUnStakingRequestPOSTBody: WithRequired<
      {
        /**
         * @description Amount to unstake in “base units”.
         * @example 10000000000
         */
        amount: string;
      } & components['schemas']['UnStakingRequestPOSTBody'],
      'amount'
    >;
    EthStakingRequest: {
      /** @description User overridden gas price to apply for the generated transactions for this request.  GasPrice is in “base units”. */
      gasPrice?: string;
      delegations?: components['schemas']['EthStakingDelegation'][];
      transactions?: components['schemas']['EthStakingTransaction'][];
      /** @description Amount to stake in “base units” (i.e. Wei for ETH) For Ethereum the amounts need to be a multiple of 32 Eth (32000000000000000000 Wei). For Testnet the 32 Eth multiple restriction does not apply. */
      amount?: string;
    } & components['schemas']['StakingRequest'];
    MaticStakingRequest: {
      /** @description User overridden gas price to apply for the generated transactions for this request.  GasPrice is in “base units”. */
      gasPrice?: string;
      delegations?: components['schemas']['MaticStakingDelegation'][];
      transactions?: components['schemas']['MaticStakingTransaction'][];
      /** @description Amount to stake in “base units” (i.e. Wei for MATIC) */
      amount?: string;
    } & components['schemas']['StakingRequest'];
    NearStakingRequest: {
      delegations?: components['schemas']['NearStakingDelegation'][];
      transactions?: components['schemas']['NearStakingTransaction'][];
      /** @description Amount to stake in “base units” */
      amount?: string;
    } & components['schemas']['StakingRequest'];
    CosmosLikeStakingRequest: {
      delegations?: components['schemas']['CosmosLikeStakingDelegation'][];
      transactions?: components['schemas']['CosmosLikeStakingTransaction'][];
      /** @description Amount to stake in “base units” */
      amount?: string;
    } & components['schemas']['StakingRequest'];
    AtomStakingRequest: {
      delegations?: components['schemas']['AtomStakingDelegation'][];
      transactions?: components['schemas']['AtomStakingTransaction'][];
      /** @description Amount to stake in “base units” */
      amount?: string;
    } & components['schemas']['StakingRequest'];
    SolStakingRequest: {
      delegations?: components['schemas']['SolStakingDelegation'][];
      transactions?: components['schemas']['SolStakingTransaction'][];
      /** @description Amount to stake in “base units” */
      amount?: string;
    } & components['schemas']['StakingRequest'];
    DotStakingRequest: {
      delegations?: components['schemas']['DotStakingDelegation'][];
      transactions?: components['schemas']['DotStakingTransaction'][];
      /** @description Amount to stake in “base units” */
      amount?: string;
    } & components['schemas']['StakingRequest'];
    AvaxPStakingRequest: {
      delegations?: components['schemas']['AvaxPStakingDelegation'][];
      transactions?: components['schemas']['AvaxPStakingTransaction'][];
      /** @description Amount to stake in “base units” */
      amount?: string;
      /** @description The length of time in seconds to complete a staking period. */
      durationSeconds?: number;
    } & components['schemas']['StakingRequest'];
    StakingDelegation: {
      /** @description Staking Request Id. */
      id?: string;
      /** @description The staking asset */
      coin?: string;
      /** @description The id of the wallet where the delegation is tied to */
      walletId?: string;
      /** @description Delegation Address */
      delegationAddress?: string;
      /** @description Withdrawal Address */
      withdrawalAddress?: string;
      /** @description Delegation amount */
      delegated?: string;
      /** @description Delegation status */
      status?: string;
      /** @description Lifetime rewards received */
      rewards?: string;
      /** @description Locked rewards received */
      lockedRewards?: string;
      /** @description Amount that is pending unstake */
      pendingUnstake?: string;
      /** @description Amount that is pending stake */
      pendingStake?: string;
      /** @description The estimated reward APY (or APR if rewards are not compounding) */
      apy?: string;
      /** @description Total fees needed in the wallet to unstake an amount from the delegation */
      unstakingFee?: string;
      /** @description Min amount needed to unstake from the delegation */
      unstakingMin?: string;
    };
    EthStakingDelegation: components['schemas']['StakingDelegation'];
    MaticStakingDelegation: {
      /** @description True if unable to unstake */
      unstakeable?: boolean;
    } & components['schemas']['StakingDelegation'];
    NearStakingDelegation: components['schemas']['StakingDelegation'];
    CosmosLikeStakingDelegation: components['schemas']['StakingDelegation'];
    AtomStakingDelegation: components['schemas']['StakingDelegation'];
    SolStakingDelegation: components['schemas']['StakingDelegation'];
    DotStakingDelegation: components['schemas']['StakingDelegation'];
    AvaxPStakingDelegation: components['schemas']['StakingDelegation'];
    DelegationResults: {
      delegations?: (
        | components['schemas']['EthStakingDelegation']
        | components['schemas']['MaticStakingDelegation']
        | components['schemas']['NearStakingDelegation']
        | components['schemas']['CosmosLikeStakingDelegation']
        | components['schemas']['SolStakingDelegation']
        | components['schemas']['DotStakingDelegation']
      )[];
      /** @description Page number for paging purposes */
      page?: number;
      /** @description Total number of pages for paging purposes */
      totalPages?: number;
      /** @description Number of elements per page used for paging purposes */
      totalElements?: number;
    };
    EthStakingTransactionSendRequest: {
      /** @description Half signed transaction object */
      halfSigned?: {
        /** @description Contract SequenceId */
        contractSequenceId?: string;
        /** @description Eip1559 Params */
        eip1559?: {
          maxPriorityFeePerGas?: string;
          maxFeePerGas?: string;
        };
        operationHash?: string;
        expireTime?: string;
        signature?: string;
      };
      comment?: string;
    };
    /** Staking Transaction */
    StakingTransaction: {
      /** @description Staking Transaction Id */
      id?: string;
      /** @description Staking Request Id. */
      stakingRequestId: string;
      /** @description The transaction hash */
      txHash?: string;
      /** @description Transaction type (delegate) */
      transactionType: components['schemas']['StakingTransactionType'];
      /**
       * Format: date-time
       * @description The date the transaction was created
       */
      createdDate: string;
      /** @description The status of the transaction (NEW, READY, INITIATED, CONFIRMED, REJECTED). */
      status: components['schemas']['StakingTransactionStatus'];
      /**
       * Format: date-time
       * @description The last modified date the status changed
       */
      statusModifiedDate: string;
      /** @description Transaction Amount in “base units” (i.e. Wei for ETH) */
      amount: components['schemas']['IntegerString'];
      /** @description The staking delegation the transaction is acting on */
      delegationId: string;
      /** @description Pending Approval Id */
      pendingApprovalId?: string;
      /** @description Transfer Id */
      transferId?: string;
      /** @description Transaction Request Id for the new Transaction Request API */
      txRequestId?: string;
    };
    EthStakingTransaction: {
      buildParams?: components['schemas']['TransactionBuildParams'];
    } & components['schemas']['StakingTransaction'];
    MaticStakingTransaction: {
      /** @description Gas limit in "base units" */
      gasPrice?: string;
    } & components['schemas']['StakingTransaction'];
    NearStakingTransaction: components['schemas']['StakingTransaction'];
    CosmosLikeStakingTransaction: components['schemas']['StakingTransaction'];
    AtomStakingTransaction: components['schemas']['StakingTransaction'];
    SolStakingTransaction: components['schemas']['StakingTransaction'];
    AvaxPStakingTransaction: components['schemas']['StakingTransaction'];
    DotStakingTransaction: components['schemas']['StakingTransaction'];
    DotWalletStakingStateAttributes: {
      spendableAttributes?: components['schemas']['DotWalletStakingSpendableAttributes'];
      permissionAttributes?: components['schemas']['WalletStakingPermissionAttributes'];
      disclaimerAttributes?: components['schemas']['WalletStakingDisclaimerAttributes'];
    };
    WalletStakingStateAttributes: {
      spendableAttributes?: components['schemas']['DotWalletStakingSpendableAttributes'];
      permissionAttributes?: components['schemas']['WalletStakingPermissionAttributes'];
      disclaimerAttributes?: components['schemas']['WalletStakingDisclaimerAttributes'];
    };
    WalletStakingSpendableAttributes: {
      stakingSpendableAttributes?: components['schemas']['StakingSpendableAttributes'];
      unstakingSpendableAttributes?: components['schemas']['UnStakingSpendableAttributes'];
    };
    DotWalletStakingSpendableAttributes: {
      stakingSpendableAttributes?: components['schemas']['StakingSpendableAttributes'];
      unstakingSpendableAttributes?: components['schemas']['UnStakingSpendableAttributes'];
    };
    AvaxpWalletStakingStateAttributes: {
      stakingSpendableAttributes?: {
        /** @description Minimum duration in seconds for staking period */
        minDuration?: number;
        /** @description Maximum duration in seconds for staking period */
        maxDuration?: number;
      } & components['schemas']['StakingSpendableAttributes'];
      unstakingSpendableAttributes?: components['schemas']['UnStakingSpendableAttributes'];
    };
    WalletStakingPermissionAttributes: {
      walletPermissionAttributes?: components['schemas']['WalletPermissionAttributes'];
      stakingPermissionAttributes?: components['schemas']['StakingPermissionAttributes'];
      unstakingPermissionAttributes?: components['schemas']['UnstakingPermissionAttributes'];
    };
    WalletStakingDisclaimerAttributes: {
      stakingDisclaimerAttributes?: components['schemas']['StakingDisclaimerAttributes'];
      unstakingDisclaimerAttributes?: components['schemas']['UnstakingDisclaimerAttributes'];
    };
    StakingSpendableAttributes: {
      /** @description Maximum spendable amount */
      max?: string;
      /** @description Minimum spendable amount */
      min?: string;
      /** @description Blockchain fee to submit the transactions needed to stake */
      fee?: string;
      /** @description Maximum spendable amount minus fees */
      netMax?: string;
      /** @description Net Minimum spendable amount plus fees */
      netMin?: string;
      /** @description True, if staking duration in seconds is required */
      isStakingDurationNeeded?: boolean;
      /** @description Minimum amount required to stake to the same validator */
      minStakeMore?: number;
    };
    UnStakingSpendableAttributes: {
      /** @description Maximum spendable amount */
      max?: string;
      /** @description Minimum spendable amount */
      min?: string;
      /** @description Blockchain fee to submit the transactions needed to unstake */
      fee?: string;
      /** @description True, if more than one active staking delegation exist for a wallet */
      multipleDelegations?: boolean;
    };
    WalletPermissionAttributes: {
      /** @description True, if wallet have enough admins to do a staking request */
      hasEnoughAdmins?: boolean;
      /** @description Number of required admins to do a hot staking request */
      numberOfRequiredAdmin?: number;
    };
    StakingPermissionAttributes: {
      /** @description If the wallet can submit a staking request */
      enabled?: string;
      /** @description Reason for staking request submittal has been disabled */
      disabledReason?: string;
    };
    UnstakingPermissionAttributes: {
      /** @description If the wallet can submit a unstaking request */
      enabled?: string;
      /** @description Reason for unstaking request submittal has been disabled */
      disabledReason?: string;
    };
    StakingDisclaimerAttributes: {
      /** @description Disclaimer info */
      info?: string;
      /** @description Number of transactions needed for a staking request */
      transactionsNeeded?: number;
    };
    UnstakingDisclaimerAttributes: {
      /** @description Disclaimer info */
      info?: string;
      /** @description Number of transactions needed for an unstaking request */
      transactionsNeeded?: number;
    };
    StakingWallet: {
      /** @description The id of the enterprise where the the staking request was created from */
      enterpriseId: string;
      /** @description The id of the wallet where the staking request was created from */
      walletId: string;
      /** @description The type of wallet the staking request was created from (cold, custodial, hot) */
      walletType: string;
      /** @description The label of the wallet the staking request was created from */
      label: string;
      /** @description The staking asset */
      coin: string;
      /** @description Delegated staked amount in “base units” */
      delegated: string;
      /** @description Amount that is actively being unstaked */
      pendingUnstake: string;
      /** @description Amount that is actively being staked */
      pendingStake: string;
      /** @description Spendable attributes */
      spendableAttributes?: Record<string, never>;
      /** @description Rewards received amount in “base units” */
      rewards: string;
      /** @description Rewards locked amount in "base units" */
      lockedRewards: string;
      /** @description Reward accrual annual percentage rate.  Estimated yearly based on the last 7 days.  Same methodology as leading beacon chain validator aggregators (e.g. https://beaconcha.in/validators) */
      apy: string;
      /** @description The date the staking request was created. */
      createdDate: string;
      /** @description The last date staking wallet was modified */
      modifiedDate: string;
    };
    StakingWalletsResponse: {
      /** @description An array of staking wallets */
      stakingWallets: components['schemas']['StakingWallet'][];
      /** @description Page number for paging purposes */
      page: number;
      /** @description Total number of pages for paging purposes */
      totalPages: number;
      /** @description Number of elements per page used for paging purposes */
      totalElements: number;
    };
    StakingEnterprise: {
      /** @description The id of the enterprise where the the staking request was created from */
      enterpriseId?: string;
      /** @description The staking asset */
      coin?: string;
      /** @description Delegated staked amount in “base units” */
      delegated?: string;
      /** @description Reward accrual amount in “base units” */
      rewards?: string;
      /** @description Reward accrual annual percentage rate.  Estimated yearly based on the last 7 days.  Same methodology as leading beacon chain validator aggregators (e.g. https://beaconcha.in/validators) */
      apy?: string;
    };
    StakingRewards: {
      /** @description An array of rewards */
      rewards?: components['schemas']['StakingReward'][];
      /** @description Page number for paging purposes */
      page?: number;
      /** @description Total number of pages for paging purposes */
      totalPages?: number;
      /** @description Number of elements per page used for paging purposes */
      totalElements?: number;
    };
    StakingReward: {
      /** @description The reward in "base units" */
      reward: string;
      /** @description The wallet Id */
      walletId?: string;
      /** @description The enterprise Id */
      enterpriseId?: string;
      /**
       * Format: date-time
       * @description The date time of the reward
       */
      date: string;
    };
    DelegationAccruals: {
      /** @description An array of delegation accruals */
      accruals?: components['schemas']['DelegationAccrual'][];
      /** @description Page number for paging purposes */
      page?: number;
      /** @description Total number of pages for paging purposes */
      totalPages?: number;
      /** @description Number of elements per page used for paging purposes */
      totalElements?: number;
    };
    DelegationAccrual: {
      /** @description Total rewards received over lifetime of the wallet */
      rewardsReceived?: string;
      /** @description Total delegated (staked) */
      delegated?: string;
      /** @description Total pending to be delegated (staked) */
      pendingDelegated?: string;
      /** @description Total pending to be undelegated (unstaked) */
      pendingUndelegated?: string;
      /** @description Total spendable (withdrawable) amount in the wallet */
      spendable?: string;
      /** @description Total amount locked but not delegated (staked).  Example is staking rewards that are not re-staked and compounding */
      locked?: string;
      /** @description The delegation Id */
      delegationId?: string;
      /** @description The delegation Address */
      delegationAddress?: string;
      /** @description The withdrawal address */
      withdrawalAddress?: string;
      /** @description The wallet Id */
      walletId?: string;
      /** @description The enterprise Id */
      enterpriseId?: string;
      /** @description The staking asset */
      coin?: string;
      /**
       * Format: date-time
       * @description The date time of the accrual record
       */
      date?: string;
    };
    TransactionBuildParams: {
      /** @description Recipient build params data */
      recipients?: {
        /** @description Amount to stake in "base units" */
        amount?: string;
        /** @description Address */
        address?: string;
        /** @description Staking data (ABI format) */
        data?: string;
      };
      /** @description Staking params */
      stakingParams?: {
        requestId?: string;
        /** @description Amount to stake in "base units" */
        amount?: string;
        /** @description Validator address */
        validator?: string;
        /** @description Action type (e.g. delegate) */
        actionType?: string;
      };
      /** @description Gas price in "base units" */
      gasPrice?: string;
      /** @description Gas limit in "base units" */
      gasLimit?: string;
    };
    StakingRequestsResponse: {
      requests?: (
        | components['schemas']['EthStakingRequestWithTransactions']
        | components['schemas']['NearStakingRequestWithTransactions']
        | components['schemas']['CosmosLikeStakingRequestWithTransactions']
        | components['schemas']['AtomStakingRequestWithTransactions']
        | components['schemas']['SolStakingRequestWithTransactions']
        | components['schemas']['DotStakingRequestWithTransactions']
        | components['schemas']['MaticStakingRequest']
      )[];
      /** @description Page number for paging purposes */
      page?: number;
      /** @description Total number of pages for paging purposes */
      totalPages?: number;
      /** @description Number of elements per page used for paging purposes */
      totalElements?: number;
    };
    StakingRequestsListResponse: {
      requests?: (
        | components['schemas']['EthStakingRequest']
        | components['schemas']['MaticStakingRequest']
        | components['schemas']['NearStakingRequest']
        | components['schemas']['CosmosLikeStakingRequest']
        | components['schemas']['AtomStakingRequest']
        | components['schemas']['SolStakingRequest']
        | components['schemas']['DotStakingRequest']
      )[];
    };
    EthStakingRequestWithTransactions: components['schemas']['EthStakingRequest'] & {
      transactions?: components['schemas']['EthStakingTransaction'][];
    };
    NearStakingRequestWithTransactions: components['schemas']['NearStakingRequest'] & {
      transactions?: components['schemas']['NearStakingTransaction'][];
    };
    CosmosLikeStakingRequestWithTransactions: components['schemas']['CosmosLikeStakingRequest'] & {
      transactions?: components['schemas']['CosmosLikeStakingTransaction'][];
    };
    AtomStakingRequestWithTransactions: components['schemas']['AtomStakingRequest'] & {
      transactions?: components['schemas']['AtomStakingTransaction'][];
    };
    SolStakingRequestWithTransactions: components['schemas']['SolStakingRequest'] & {
      transactions?: components['schemas']['SolStakingTransaction'][];
    };
    DotStakingRequestWithTransactions: components['schemas']['DotStakingRequest'] & {
      transactions?: components['schemas']['DotStakingTransaction'][];
    };
    StakeableCoinsResult: {
      coins?: components['schemas']['StakeableCoins'][];
      page?: number;
      totalPages?: number;
      totalElements?: number;
    };
    StakingError: {
      code?: string;
      message?: string;
      status?: number;
    };
    ValidationError1: {
      code?: string;
      message?: string;
      status?: number;
      failedValidations?: Record<string, never>;
    };
    CoinsUnauthorizedError: {
      error?: string;
      errorName?: string;
      reqId?: string;
      context?: {
        errorName?: string;
      };
    };
    StakeableCoins: {
      symbol?: string;
      baseUnit?: string;
      isToken?: boolean;
      isTss?: boolean;
      isMultiSig?: boolean;
      l1Chain?: string;
    };
    StakingValidator: {
      /** @description The delegation Address. */
      delegationAddress?: string;
      /** @description The staked coin. */
      coin?: string;
      /** @description Total delegated amount in “base units”. */
      delegated?: string;
      /** @description Reward accrual amount in “base units”. */
      rewards?: string;
      /** @description The annual percentage yield. */
      apy?: string;
      /** @description Validator provider used for staking. */
      type?: string;
    };
    StakingValidatorsResponse: {
      validators?: (components['schemas']['StakingValidator'] & Record<string, never>)[];
      /** @description Page number for paging purposes */
      page?: number;
      /** @description Total number of pages for paging purposes */
      totalPages?: number;
      /** @description Number of elements per page used for paging purposes */
      totalElements?: number;
    };
    StakingPartneredValidator: {
      /** @description The delegation Address. */
      delegationAddress?: string;
      /** @description Validator provider. */
      type?: string;
      /** @description Total staked amount in “base units”. */
      totalStaked?: string;
      /** @description Reward accrual amount in “base units”. */
      rewards?: string;
      /** @description The annual percentage yield. */
      apy?: string;
      /** @description The fee charged by the validator as a percentage. */
      commission?: string;
      /** @description The staked coin. */
      coin?: string;
    };
    StakingPartneredValidatorsResponse: {
      validators?: (components['schemas']['StakingPartneredValidator'] & Record<string, never>)[];
      /** @description Page number for paging purposes */
      page?: number;
      /** @description Total number of pages for paging purposes */
      totalPages?: number;
      /** @description Number of elements per page used for paging purposes */
      totalElements?: number;
    };
    StakingLicense: {
      /** @description The name of the coin. */
      coin?: string;
      /** @description Corresponding fee for coin in current license. */
      fee?: string;
    };
    StakingLicenseResponse: {
      /** @description The enterprise ID */
      enterpriseId?: string;
      /** @description The default fee for the asset */
      defaultFee?: string;
      fees?: (components['schemas']['StakingLicense'] & Record<string, never>)[];
    };
    /**
     * @description An API error returned by the service.
     * @example {
     *   "error": "Missing required parameter: accountId",
     *   "errorName": "MissingRequiredParameter",
     *   "reqId": "3fa3fb673ce950a95fd2d395e245efbe"
     * }
     */
    APIError: {
      /** @description Human-readable error message */
      error: string;
      /** @description Immutable error code for API integration */
      errorName: string;
      /** @description Client request id */
      reqId: string;
    };
    AccelerationIntent: components['schemas']['BaseIntent'] & {
      /** @enum {string} */
      intentType?: 'acceleration';
      txid: string;
    };
    /**
     * @example {
     *   "id": "f230fdebfa084ffebc7e00515f54603f",
     *   "name": "Uncle MoneyPenny's Trading Wallet"
     * }
     */
    Account1: {
      /** Format: uuid */
      id: string;
      name: string;
    };
    Account2: {
      /** @description client id - unique to wallet/broker relationship */
      clientId: components['schemas']['IdString'];
      clientName: components['schemas']['ClientName'];
      /** @description broker book id - unique to wallet/broker relationship */
      bookId?: components['schemas']['BrokerBookId'];
      state: components['schemas']['BookState'];
      lastUpdated: components['schemas']['DateFromISOString'];
      balances?: components['schemas']['AssetAmount'][];
      updates?: components['schemas']['AccountAssetUpdate'][];
    };
    AccountAssetUpdate: {
      /**
       * Format: date-time
       * @description ISO 8601 string representation of first moment of updates
       * @example 2019-05-02T15:27:35.773Z
       */
      since?: string;
      assetUpdates?: components['schemas']['AssetUpdate'][];
    };
    AccountBaseBuildOptions: {
      nonce?: string;
    };
    /** Trading Account Settings */
    AccountSettings: {
      /** @description ID of the trading account for which these settings apply */
      accountId?: components['schemas']['WalletId'];
      /**
       * @description Expiration time for new settlements and affirmations, in milliseconds. If this amount of time passes before a settlement is affirmed, rejected, or canceled, the settlement will be marked as failed
       * @example 86400000
       */
      affirmationExpirationTime?: number;
      feeRates?: components['schemas']['FeeRates'];
      /**
       * @description Referral code of given account
       * @example FC8G
       */
      referralCode?: string;
    };
    /**
     * @description The desired staking action.
     * @example delegate
     * @enum {string}
     */
    ActionType: 'delegate' | 'undelegate' | 'self_staking';
    /** Ada Stake */
    AdaStakeIntent: components['schemas']['StakeIntent'] & {
      /** @description The pool key hash to which the coins will be delegated to. */
      poolKeyHash: string;
    };
    AddEnterpriseUser: {
      /** @enum {string} */
      permission?: 'admin';
      /**
       * Format: email
       * @description The Username of the User that should be added to the Enterprise
       */
      username?: string;
      usernames?: string[];
    };
    AddTradesHttpRequestBody: {
      trades?: components['schemas']['TradeInput'][];
    };
    AdditionalEnterpriseInfo: {
      contact?: components['schemas']['GeographicAddress'];
    };
    Address: {
      /** @description platform public id for an address */
      id?: components['schemas']['Id'];
      address?: components['schemas']['AddressString'];
      chain?: components['schemas']['Chain'];
      index?: number;
      coin?: string;
      /** @default -1 */
      lastNonce?: number;
      /** @description The wallet which contains this address */
      wallet?: components['schemas']['Id'];
      /** @description Properties which are specific to certain coin types */
      coinSpecific?: {
        xlm?: components['schemas']['AddressCoinSpecificXlm'];
        txlm?: components['schemas']['AddressCoinSpecificXlm'];
      };
      /**
       * @description Balance of the address. In case of Eth and Celo, if returnBalancesForToken is passed with includeBalances, then
       * it will return token balance in the address object. This field will be present only when
       * "includeBalances" query param is passed as true.
       */
      balance?: components['schemas']['AddressBalance'];
      label?: components['schemas']['AddressLabel'];
      addressType?: components['schemas']['AddressType'];
    };
    AddressBalance: {
      /**
       * Format: date-time
       * @description The last time a transaction affected the balance of this address
       */
      updated?: string;
      /**
       * @description The cleared balance of the address
       * @example 50000
       */
      balance?: number;
      /**
       * @description String representation of "balance". Guaranteed to not lose precision.
       * @example 50000
       */
      balanceString?: string;
      /** @description The total amount received on this address (in the chain's base unit) */
      totalReceived?: number;
      /** @description The total amount send from this address (in the chain's base unit) */
      totalSent?: number;
      /**
       * @description The total balance of confirmed transactions for the address (in the chain's base unit).
       * Guaranteed to not lose precision.
       *
       * @example 40000
       */
      confirmedBalanceString?: string;
      /**
       * @description The total balance of the address (in the chain's base unit) which may
       * be used as inputs for creating new transactions in string representation.
       * Guaranteed to not lose precision.
       *
       * @example 40000
       */
      spendableBalanceString?: string;
    };
    AddressCoinSpecificXlm: {
      /**
       * @description Latest memo id generated for the wallet
       * @example 1
       */
      memoId?: components['schemas']['IntegerString'];
      /**
       * @description Root address of the wallet
       * @example GCTTCPH4IIDK7P72FFAEJ3ZFN6WDHJH6GGMRPHPM56ZWGIQ7B3XTIJAM
       */
      rootAddress?: string;
    };
    /**
     * @description A human-readable label for the address.
     * @example Bob's Hot Wallet Address
     */
    AddressLabel: string | null;
    /** @example 2MvrwRYBAuRtPTiZ5MyKg42Ke55W3fZJfZS */
    AddressString: string;
    /**
     * @example p2sh
     * @enum {string}
     */
    AddressType: 'p2sh' | 'p2shP2wsh' | 'p2wsh' | 'p2tr';
    AdminCreateEnterprise: {
      accountType?: components['schemas']['EnterpriseAccountType'];
      additionalEnterpriseInfo?: components['schemas']['AdditionalEnterpriseInfo'];
      bitgoOrg: components['schemas']['BitGoOrg'];
      /** @description whether the enterprise has the licence for BitGo Prime Borrowing */
      canAccessBorrowing?: boolean;
      /** @description whether the enterprise has the licence for BitGo Prime Lending */
      canAccessLending?: boolean;
      /** @description whether the enterprise has the licence to utilize settlement functionality - requires a trading account */
      canAccessSettlement?: boolean;
      /** @description whether the enterprise has the licence to access BitGo Trading - requires portfolio and a trading account */
      canAccessTrading?: boolean;
      /** @description whether the enterprise has the license to create cold wallets */
      canCreateColdWallet?: boolean;
      /** @description whether the enterprise has the license to create custodial wallets */
      canCreateCustodialWallet?: boolean;
      /** @description whether the enterprise has the license to create hot wallets */
      canCreateHotWallet?: boolean;
      /** @description whether the enterprise has the license to create trading accounts - only available for BitGo Trust entities with a DAS */
      canCreateOffchainWallet?: boolean;
      cheetahAccountId?: components['schemas']['CheetahAccountId'];
      emergencyPhone?: components['schemas']['EmergencyPhone'];
      /** @description Feature flags to set on the enterprise during creation */
      featureFlags?: components['schemas']['EnterpriseFeatureFlag'][];
      legalIdentifiers?: components['schemas']['LegalIdentifiers'];
      /** @description New licences that are not stored as flags. Tax requires Portfolio Professional or Institutional */
      licenses?: components['schemas']['EnterpriseLicenses'][];
      /** @example Small Company */
      name: string;
      /** @description The pricing plan of the enterprise */
      pricingPlan?: string;
      pricingType?: components['schemas']['AuditableItem'] & components['schemas']['EnterprisePricingType'];
      /** @description The email or user ID of the User who should be the new primary contact */
      primaryContact: components['schemas']['Email'] | components['schemas']['Id'];
      /** @description An Account ID in Salesforce for this enterprise. This is different than an Opportunity Id. The enterprise will be associated with the Salesforce Account corresponding to the given account id. Required for institutional enterprises. */
      salesforceAccountId?: string;
      /** @description An Opportunity ID in Salesforce for this enterprise. The enterprise will be associated with the Salesforce Account that the Opportunity belongs to. Required for institutional enterprises. */
      salesforceOpportunityId?: string;
      /** @description Determines whether the primaryContact receives an email telling them they were invited to the newly created enterprise. */
      skipInvitedToEnterpriseEmail?: boolean;
      /** @description Determines whether additionalEnterpriseInfo should contain street address for the enterprise */
      skipAdditionalEnterpriseInfoAddressCheck?: boolean;
      /**
       * @description The type of the enterprise such as Exchange or OTC
       * @example OTC
       */
      type?: components['schemas']['EnterpriseType'];
      upfrontPaymentStatus?: components['schemas']['EnterpriseUpfrontPaymentStatus'];
      preferredUi?: components['schemas']['EnterpriseAvailableUI'];
      usersViewAllWallets?: components['schemas']['ViewAllWallets'];
      videoIdWaived?: components['schemas']['VideoIdWaived'];
    };
    AdminCreateKey: {
      pub?: components['schemas']['Pub'];
      source: components['schemas']['KeySource'];
      distributedCustodyOptions?: components['schemas']['DistributedCustodyOptions'];
    };
    AdminCreateWalletRequest: {
      /** @description What type of wallet to create, currently only 'backing' */
      type?: string;
      coin: components['schemas']['Coin'];
      /** @description The id of the enterprise to own the backing wallet */
      enterprise: components['schemas']['Id'];
      /** @description The id to create the wallet with. If already used, the request will fail. */
      wallet?: components['schemas']['Id'];
      coinSpecific?: {
        /** @description The id of the bank account connected to the wallet (fiat only) */
        backingBankAccountId?: components['schemas']['Id'];
        /** @description The id of the bank account connected to the wallet (fiat only) */
        backingSENBankAccountId?: components['schemas']['Id'];
        /** @description The number of confirms after which it is safe to credit a deposit to this wallet */
        safeConfirms?: number;
      };
    };
    AdminEnterprise: components['schemas']['Enterprise'] & {
      internal?: components['schemas']['EnterpriseInternal'];
    };
    AdminEnterpriseSummary: {
      enterprise?: components['schemas']['Enterprise'] & {
        /** @description Number of billable users */
        billableUserCount?: number;
        /** @description Billable users on the enterprise, max 500 */
        billableUsers?: components['schemas']['AdminEnterpriseUser'][];
        cheetahAccountId?: components['schemas']['CheetahAccountId'];
        /** @description Identifier for environment variables for a customer's Elliptic API credentials */
        ellipticId?: string;
        /** @description Hot wallet transactions on this enterprise are monitored in Elliptic */
        ellipticHotWallets?: boolean;
        /** @description true if the enterprise has more than 500 users */
        incomplete?: boolean;
        /** @description Enterprise members (users without admin privileges), max 500 */
        members?: components['schemas']['AdminEnterpriseUser'][];
        /** @description The parent organization (customer) to which the enterprise belongs */
        organization?: {
          id?: components['schemas']['Id'];
          /** @description All enterprise IDs that belong to this organization */
          enterprises?: components['schemas']['Id'][];
          /** @description Organization name */
          name?: string;
          salesforceAccountId?: components['schemas']['SalesforceId'];
        };
        /** @description Enterprise owners (users with admin privileges), max 500 */
        owners?: components['schemas']['AdminEnterpriseUser'][];
        primaryContactEmail?: components['schemas']['Email'];
        salesforceAccountId?: components['schemas']['SalesforceId'];
        type?: components['schemas']['EnterpriseType'];
        /** @description true if the enterprise has at least 1 ofc wallet */
        hasOfc?: boolean;
        /** @description Number of wallets per coin */
        walletCounts?: {
          /**
           * @example {
           *   "btc": 2,
           *   "eth": 1,
           *   "v1btc": 1
           * }
           */
          enterpriseWallets?: {
            [key: string]: number;
          };
        };
      };
    };
    AdminEnterpriseUser: {
      email?: components['schemas']['Email'];
      /**
       * @description User first name
       * @example Han
       */
      firstname?: string;
      id?: components['schemas']['Id'];
      isActive?: boolean;
      /**
       * @description User last name
       * @example Solo
       */
      lastname?: string;
      username?: components['schemas']['Email'];
      /**
       * @description User email is verified
       * @example true
       */
      verified?: boolean;
      identity?: {
        kyc?: components['schemas']['UserKyc'];
      };
    };
    AdminMergeAddressesRequest: {
      /** @description Only examine addresses of this coin type */
      coin: components['schemas']['Coin'];
      /**
       * @description Only examine addresses that match this regex
       * @example a.*
       */
      addressRegex?: string;
      /** @description Only examine addresses in this wallet */
      walletId?: components['schemas']['Id'];
      /** @description If true, or not specified, do not actually change the database. */
      dryRun?: boolean;
    };
    AdminMergeAddressesResponse: {
      /** @description number of addresses examined */
      checked?: number;
      /** @description number of address groups fixed */
      fixed?: number;
      /** @description number of address groups that cannot be safely fixed */
      unfixableCount?: number;
      unfixableDetails?: components['schemas']['Address'][][];
      groupDetails?: {
        addresses?: components['schemas']['Address'][];
        /** @description the combined version of all the addreseses */
        union?: components['schemas']['Address'];
        /** @description if true, the first address will be changed to match the union */
        needsUpdate?: boolean;
        /** @description list of address id that will be removed */
        removed?: components['schemas']['AddressString'][];
      }[];
      /** @description Whether or not this was a dry run, meaning no data was actually changed. */
      dryRun?: boolean;
    };
    AdminNotifyCustomerStatements: {
      bitgoOrg: components['schemas']['BitGoOrg'];
      /**
       * @description Frequency of the statement email.
       * @enum {string}
       */
      frequency: 'Monthly' | 'Quarterly';
    };
    AdminPolicy: components['schemas']['Policy'] & {
      /** @description The Enterprise to which this Policy applies */
      enterpriseId?: components['schemas']['Id'];
      /** @description The Wallet to which this Policy applies */
      walletId?: components['schemas']['Id'];
    };
    AdminRecoverFromAddressRequest: {
      /** @description Destination address for the transaction */
      address: string;
      /** @description Whether to sweep the wallet */
      sweep: boolean;
      /** @description Amount to send in base units (i.e. wei) */
      amount?: string;
      /** @description Whether to send the transaction from low priority fee address */
      lowPriority: boolean;
      /** @description Whether to send the transaction as an EIP 1559 transaction */
      isEip1559?: boolean;
      /** @description coin in which bitgo address exist for evm cross chain recovery */
      wrongChainCoin?: string;
      /** @description nonce of the transaction */
      nonce?: number;
      /** @description address(Hop address) from which transaction is sent */
      fromAddress?: string;
      /**
       * @description Recovery type.
       * @enum {string}
       */
      type?: 'hop' | 'evmCrossChain';
      /** @description Whether to skip cross chain check for evm cross chain recovery */
      skipCrossChainCheck?: boolean;
    };
    AdminTransfersReport: {
      bitgoOrg?: components['schemas']['BitGoOrg'];
      /** @description What type of wallet to filter against */
      walletType?: components['schemas']['WalletTypeAll'][];
      /** @description Start date of the transfers you want */
      startDate?: string;
      /** @description End date of the transfers you want */
      endDate?: string;
      /** @description Look up transfers by enterprise id */
      enterpriseId?: string;
      /** @description Type of transfers, send or receive */
      type?: string;
      state?: components['schemas']['TransferState'][];
      /** @description Type of coin to query against */
      coin?: string[] | string;
      /** @description Include trade and settlement transfers */
      includeTrades?: boolean;
      /** @description Annotate the timestamps of trust approvals (slow!) */
      includeApprovals?: boolean;
      /**
       * @description Annotate transfers with their corresponding Transaction Request if it exists (slow!)
       * @default false
       */
      includeTxRequests?: boolean;
      /**
       * @description If true and Transaction Requests are returned they will include the 'transactions' property (for 'full',
       * 'unsignedTxs' for 'lite'), if false the 'transactions' property (or 'unsignedTxs') will not be returned
       *
       * @default false
       */
      includeTxRequestsTransactions?: boolean;
      /** @description Send the transfers to Elliptic for batch screening */
      elliptic?: boolean;
      /** @description Send a notification email for Elliptic sync errors to the Trust */
      ellipticErrorNotification?: boolean;
    };
    AdminTransfersReportResponse: {
      transfers: (components['schemas']['Transfer'] & {
        /** @description Name of the wallet */
        walletLabel?: string;
        /** @description Name of the enterprise */
        enterpriseName?: string;
        /**
         * Format: date-time
         * @description When the transfer was confirmed by the blockchain
         */
        confirmedTime?: string;
        /**
         * Format: date-time
         * @description When the transfer was seen on the blockchain
         */
        unconfirmedTime?: string;
        /**
         * Format: date-time
         * @description When the final pending approval was approved
         */
        approvedTime?: string;
        /**
         * Format: date-time
         * @description When BitGo co-signed the transfer
         */
        signedTime?: string;
        /**
         * Format: date-time
         * @description When the transfer was created
         */
        createdTime?: string;
        /**
         * Format: date-time
         * @description When the customer approved the transfer (state pending resolved)
         */
        customerApprovedTime?: string;
        /**
         * Format: date-time
         * @description When the trust did ID verification with the customer
         */
        idVerificationTime?: string;
        /**
         * Format: date-time
         * @description When the trust signed the transfer in the vault
         */
        trustSignedTime?: string;
        /**
         * Format: date-time
         * @description When the trust did the final custodian approval
         */
        trustFinalApprovalTime?: string;
        /** @description Elliptic scan submission result ("submitted" or error message) */
        elliptic?: string;
      })[];
    };
    AdminUpdateBankAccount: {
      verificationState?: components['schemas']['BankAccountVerificationState'];
      type?: components['schemas']['BankAccountType'];
    };
    AdminUpdateEnterprise: {
      additionalEnterpriseInfo?: components['schemas']['AdditionalEnterpriseInfo'];
      /** @description Enterprise users that can do custodial video approval. Required to have initial video ID done. */
      approvedVideoIdUsers?: components['schemas']['Id'][];
      bitgoOrg?: components['schemas']['BitGoOrg'];
      /** @description whether the enterprise has the licence for BitGo Prime Borrowing */
      canAccessBorrowing?: boolean;
      /** @description whether the enterprise has the licence for BitGo Prime Lending */
      canAccessLending?: boolean;
      /** @description whether the enterprise has the licence to utilize settlement functionality - requires a trading account */
      canAccessSettlement?: boolean;
      /** @description whether the enterprise has the licence to access BitGo Trading - requires Portfolio and a trading account */
      canAccessTrading?: boolean;
      /** @description whether the enterprise has the license to create cold wallets */
      canCreateColdWallet?: boolean;
      /** @description whether the enterprise has the license to create custodial wallets */
      canCreateCustodialWallets?: boolean;
      /** @description whether the enterprise has the license to create hot wallets */
      canCreateHotWallet?: boolean;
      /** @description whether the enterprise has the license to create trading accounts - only available for BitGo Trust entities with a DAS */
      canCreateOffchainWallet?: boolean;
      cheetahAccountId?: components['schemas']['CheetahAccountId'];
      /** @description The contract end date for an enterprise */
      contractEndDate?: string;
      /** @description The contract start date for an enterprise */
      contractStartDate?: string;
      /**
       * @description Number of custodial wallets this enterprise can create for a coin
       * @example { btc: 1 }
       */
      custodialWalletLimit?: Record<string, never>;
      /** @description Identifier for environment variables for a customer's Elliptic API credentials. Recommended to be 10 random uppercase letters */
      ellipticId?: string;
      /** @description Enable Elliptic monitoring for hot wallet transactions of this enterprise */
      ellipticHotWallets?: boolean;
      /** @description Always use hop address for ETH transactions */
      ethAlwaysUseHop?: boolean;
      emergencyPhone?: components['schemas']['EmergencyPhone'];
      /** @example 0 */
      latestSAVersionSigned?: number;
      /** @description New licences that are not stored as flags. Tax requires Portfolio Professional or Institutional */
      licenses?: components['schemas']['EnterpriseLicenses'][];
      /**
       * @description Time in seconds after which policies on this Enterprise cannot be updated
       * @example 172800
       */
      mutablePolicyWindow?: number;
      /** @example Small Company */
      name?: string;
      /** @description The pricing plan of the enterprise */
      pricingPlan?: string;
      primaryContact?: components['schemas']['Email'];
      preferredUi?: components['schemas']['EnterpriseAvailableUI'];
      /** @description Opportunity ID from Salesforce */
      salesforceAccountId?: string;
      usersViewAllWallets?: components['schemas']['ViewAllWallets'];
      videoIdWaived?: components['schemas']['VideoIdWaived'];
      /**
       * @description Total number of wallets this enterprise can create for a coin
       * @example { ofc: 1 }
       */
      walletLimit?: Record<string, never>;
      internal?: {
        /** @description Whether the enterprise has been migrated to the new policy service */
        migratedToNewPolicyService: boolean;
      };
    };
    AdminUpdatePasswordReset: {
      state: components['schemas']['PasswordResetFinalState'];
      resolverId: components['schemas']['Id'];
      resolutionPayload?: components['schemas']['PasswordResetResolutionPayload'];
      resolutionSignature?: components['schemas']['PasswordResetResolutionSignature'];
      /** @description link to a video recording of support doing the id verification with the customer */
      videoLink?: string;
    };
    AdminUpdateTransfer: {
      /**
       * @description the new state of the transfer
       * @example failed
       * @enum {string}
       */
      state?: 'failed';
    };
    AdminUpdateUser: {
      /**
       * @description OTP code to validate
       * @example 000000
       */
      otp: string;
      /** @description Toggles the user's bitgoEmployee state. Requires updateBitGoEmployee admin permission. */
      bitgoEmployee?: boolean;
      /** @description Only allows passport for the user KYC documents step. */
      passportRequired?: boolean;
      /**
       * @description Link to the onboarding Video ID recording with the customer. Required for updating Video ID.
       * @example https://drive.google.com/file/...
       */
      videoLink?: string;
      /**
       * Format: date-time
       * @description Date when the Video ID call was done. Required for updating Video ID.
       * @example 2020-01-31T21:00:00.000Z
       */
      videoDate?: string;
      enterpriseId?: components['schemas']['Id'];
      /** @description Label to apply to Video ID. */
      label?: string;
      /** @description Delete the specified videoId. */
      deleteVideoId?: boolean;
      /** @description Check if we are required to do source verification. */
      sourceVerificationRequired?: boolean;
    };
    AdminUpdateWallet: {
      otp?: string;
      allowBackupKeySigning?: boolean;
      billingEnterprise?: components['schemas']['Id'];
      /**
       * Format: date-time
       * @description This should be a nullable string.  We can't specify the type because
       * lint --json-schema is not working in speccy version 0.8.2
       */
      circuitBreakerResetTime?: unknown;
      custodialWalletId?: components['schemas']['Id'];
      customerWalletId?: components['schemas']['Id'];
      enterpriseId?: components['schemas']['Id'];
      skipCircuitBreakers?: components['schemas']['SkipCircuitBreakers'];
      triggeredCircuitBreaker?: boolean;
      /** @enum {string} */
      gasPriceTier?: 'ludicrous' | 'fastest' | 'fast' | 'standard' | 'safeLow';
      tokenFlushThresholds?: {
        [key: string]: number;
      };
      deployForwardersManually?: boolean;
      flushForwardersManually?: boolean;
      customChangeAddressType?: string;
      enableMMI?: boolean;
      enableNFT?: boolean;
    };
    AdminWallet: components['schemas']['Wallet'] & {
      /**
       * Format: date-time
       * @description The last time that "triggeredCircuitBreaker" was changed from "true"
       * to "false".  Transfers earlier than this timestamp are ignored when
       * circuit breakers are evaluated.
       */
      circuitBreakerResetDate?: string;
      /**
       * @description Wallet user keychain properties which will prevent the wallet from being recovered.
       *
       * If any of these properties are false (missing), then the wallet user key is unable to be recovered.
       * Recovery via a non-bitgo recovery using the backup key may still be possible.
       */
      recoveryProperties?: {
        originalPasscodeEncryptionCode?: boolean;
        originalEncryptedPrv?: boolean;
        path?: boolean;
      };
      skipCircuitBreakers?: components['schemas']['SkipCircuitBreakers'];
      /** @description "true" if a circuit breaker has been triggered for this wallet */
      triggeredCircuitBreaker?: boolean;
    };
    AdvancedListRuleEntry: {
      item: components['schemas']['AddressString'] | components['schemas']['Id'];
      /** @description Any data about this entry that is not used to determine when to enforce the policy */
      metaData?: {
        /** @description A client-specified label for this entry. Label must be unique or not set. */
        label?: string;
        /**
         * @description The legal owner of the address/ wallet/ enterprise
         * @example Legal Owner LLC
         */
        owner?: string;
        [key: string]: unknown;
      };
      type: components['schemas']['ListRuleEntryType'];
    };
    Agreement: {
      /**
       * @description The agreement to target
       * @example termsOfUse
       */
      agreement: string;
    };
    AgreementVersion: {
      /**
       * @description The current agreement version number.
       * @example 1
       */
      version?: number;
    };
    Amount1: {
      /** @description Decimal quantity, limited by designated fixed precision. */
      quantity?: components['schemas']['DecimalString'];
      /** @description Fixed decimal precision. */
      precision?: number;
    };
    Amount2: {
      /**
       * @description The value should be a valid number.
       * @example 100
       */
      value: string;
      /**
       * @description The coin or token the value is referring to.
       * @example usdc
       */
      symbol: string;
    };
    AnnotatedTransfer: components['schemas']['Transfer'] & {
      /** @description The number of blocks that have been confirmed since this Transfer's block was confirmed */
      confirmations?: number;
      entries?: {
        /** @description If this address was labeled by the user, this is the label */
        label?: string;
      }[];
    };
    AnnotatedTransferWithInputsOutputs: components['schemas']['AnnotatedTransfer'] & {
      /** @description If this is a Transfer on a UTXO coin, the array of inputs */
      inputs?: components['schemas']['Unspent'][];
      /** @description If this is a Transfer on a UTXO coin, the array of outputs */
      outputs?: components['schemas']['Unspent'][];
    };
    PlatformError: components['schemas']['PlatformErrorNoName'] & {
      /** @description Properties that apply to a specific error name */
      context?: Record<string, never>;
      /** @description Error code */
      name: string;
    };
    PlatformErrorNoName: {
      /** @description Human-readable error message */
      error: string;
      /** @description Client request id */
      requestId: string;
    };
    /** @example 1 */
    ApprovalsRequired: number;
    /** @description Asset/token identifier. */
    Asset: string;
    AssetAllocationStatus: {
      status?: components['schemas']['JobStatus'];
    };
    AssetAmount: components['schemas']['Amount1'] & {
      asset?: components['schemas']['Asset'];
    };
    AssetDef: {
      /** @description asset/token identifier */
      symbol?: string;
      /** @description number of decimal places for minimum real unit (baseunits) */
      decimalPlaces?: number;
      /** @enum {string} */
      assetType?: 'crypto' | 'fiat';
    };
    /** @description Used for reporting asset updates */
    AssetUpdate: {
      uniqueId: components['schemas']['IdString'];
      updateType: components['schemas']['UpdateType'];
      at: components['schemas']['DateFromISOString'];
      notation?: string;
      amount: components['schemas']['AssetAmount'];
      txId?: string;
    };
    /** @description Used for querying asset updates */
    AssetUpdateQueryFilter: {
      after: components['schemas']['DateFromISOString'];
      before?: components['schemas']['DateFromISOString'];
      type?: components['schemas']['QueryFilterType'];
    };
    AssetUpdateStatus: {
      status?: components['schemas']['JobStatus'];
    };
    AssignAssetsHttpRequestBody: {
      amount?: components['schemas']['AssetAmount'];
      /**
       * Format: uuid
       * @description In the case of deallocation affirmation (of client request), this is the deallocation id. In all other cases it is a unique uuid and may correspond to another id as the broker sees fit. This is used as a unique identifier for idempotency purposes.
       */
      identifier?: string;
    };
    AuditLog: {
      coin?: components['schemas']['Coin'];
      /** @description Properties that apply to the given audit log type */
      data?: Record<string, never>;
      date?: components['schemas']['DateTime'];
      enterpriseId?: components['schemas']['Id'];
      id?: components['schemas']['Id'];
      ip?: components['schemas']['Ip'];
      target?: components['schemas']['Id'];
      type?: components['schemas']['AuditLogType'];
      user?: components['schemas']['Id'];
      walletId?: components['schemas']['Id'];
    };
    /** @enum {string} */
    AuditLogType:
      | 'addPolicy'
      | 'addUser'
      | 'addWebhook'
      | 'adminRenameEnterprise'
      | 'adminUpdateBankAccount'
      | 'adminUpdatePasswordReset'
      | 'approveEnterpriseUser'
      | 'approvePolicy'
      | 'approveTransaction'
      | 'approveUser'
      | 'bitgoSigned'
      | 'changePolicy'
      | 'createAccessToken'
      | 'createBankAccount'
      | 'createEnterprise'
      | 'createPasswordReset'
      | 'createReset2FA'
      | 'createSendLabel'
      | 'createTransaction'
      | 'createWallet'
      | 'deleteAccessToken'
      | 'deletePasswordReset'
      | 'deleteSendLabel'
      | 'freezeEnterprise'
      | 'freezeWallet'
      | 'labelAddress'
      | 'oAuthAuthorize'
      | 'policyUpdated'
      | 'rejectEnterpriseUser'
      | 'rejectPolicy'
      | 'rejectTransaction'
      | 'rejectUser'
      | 'removePolicy'
      | 'removeUser'
      | 'removeWallet'
      | 'removeWebhook'
      | 'renameWallet'
      | 'shareUser'
      | 'shareUserAccept'
      | 'shareUserCancel'
      | 'shareUserDecline'
      | 'supportReset2FA'
      | 'unlabelAddress'
      | 'updateApprovalsRequired'
      | 'updateBankAccount'
      | 'updateComment'
      | 'updateEnterpriseUser'
      | 'updateNotificationSettings'
      | 'updateSendLabel'
      | 'updateTag'
      | 'updateWalletCoinSpecific'
      | 'user2FAAdd'
      | 'user2FARemove'
      | 'userFailedLogin'
      | 'userLogin'
      | 'userPasswordChange'
      | 'userPasswordReset'
      | 'userSettingsChange'
      | 'userSignup'
      | 'userSourceVerified'
      | 'verifyReset2FA';
    AuditLogsResponse: {
      logs: components['schemas']['AuditLog'][];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
    };
    AuditableItem: {
      /** @description Unique identifier for the date range. */
      id?: string;
      /** @description ISO 8601 Datetime (example at https://datatracker.ietf.org/doc/html/rfc3339#section-5.8). If present, will use as the start date of a new auditable item. If not present, will use the current date to create a new auditable item. Start date is inclusive, i.e. we will start billing/functionality at this instant and afterwards. */
      startDate?: string;
      /** @description An optional note describing the reason the auditable item was added/created. */
      startReason?: string;
      /** @description ISO 8601 Datetime (example at https://datatracker.ietf.org/doc/html/rfc3339#section-5.8). If present, will use as the end date of a new auditable item. If not present, we will set the endDate to null, and we will assume an indefinite range. endDate is exclusive, i.e. we will end billing/functionality up to but not at this particular time. */
      endDate?: string;
      /** @description An optional note describing the reason the auditable item was ended. */
      endReason?: string;
    };
    AverageFee: {
      /**
       * @description Calculated by summing the fees of the blocks over the number of blocks.
       * @example 16000000
       */
      averageFee: number;
    };
    /**
     * @description Coin name used to choose correct KRS public key for the given provider. Possible valid values are "btc", "eth", "bitcoin"
     * @example eth
     */
    BackupKeyType: string;
    Balance: {
      /**
       * @description The total balance of all wallets containing the given coin type.  May lose
       * precision for large values.
       *
       * @example 50000
       */
      balance?: number;
      /**
       * @description String representation of "balance".  Guaranteed to not lose
       * precision.
       *
       * @example 50000
       */
      balanceString?: string;
      /**
       * @description The total balance of confirmed transactions for all wallets containing the given
       * coin type.  May lose precision for large values.
       *
       * @example 40000
       */
      confirmedBalance?: number | null;
      /**
       * @description String representation of "confirmedBalance".  Guaranteed to not lose
       * precision.
       *
       * @example 40000
       */
      confirmedBalanceString?: string;
      /**
       * @description The total balance of all wallets containing the given coin which may
       * be used as inputs for creating new transactions.  May lose precision
       * for large values.
       *
       * @example 40000
       */
      spendableBalance?: number | null;
      /**
       * @description String representation of "spendableBalance".  Guaranteed to not lose
       * precision.
       *
       * @example 40000
       */
      spendableBalanceString?: string;
      /**
       * @description The total balance of all wallets containing the given coin which has been staked.
       * May lose precision for large values.
       *
       * @example 40000
       */
      stakedBalance?: number | null;
      /**
       * @description String representation of "stakedBalance".  Guaranteed to not lose
       * precision.
       *
       * @example 40000
       */
      stakedBalanceString?: string;
    };
    BalanceNotAvailable: components['schemas']['PlatformErrorNoName'] & {
      context: {
        coin?: components['schemas']['Coin'];
      };
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'BalanceNotAvailable';
    };
    BalanceReserve: {
      /**
       * @description base fee used in transaction fees
       * @example 100
       */
      baseFee?: string;
      /**
       * @description base reserve used in minimum account balances
       * @example 5000000
       */
      baseReserve?: string;
      /**
       * @description minimum account balance, calculated using base reserve
       * @example 25000000
       */
      reserve?: string;
      /**
       * @description minimum funding balance, calculated using reserve and base fee
       * @example 25000500
       */
      minimumFunding?: string;
      /**
       * @description the height of the block that provides the base values
       * @example 11228504
       */
      height?: number;
    };
    BalanceStaked: {
      /** @description the address of the wallet */
      address?: components['schemas']['AddressString'];
      balances?: {
        /** @description the validator */
        validator?: components['schemas']['AddressString'];
        /**
         * @description the amount delegated to the validator
         * @example 5000000000
         */
        staked_amount?: string;
      }[];
    }[];
    BalanceTotalRewards: {
      /** @description the address of the wallet */
      address?: components['schemas']['AddressString'];
      rewards?: {
        /** @description the receiving address */
        reward_recipient?: components['schemas']['AddressString'];
        /**
         * @description the total rewards received
         * @example 5000000000
         */
        reward_amount?: string;
      }[];
    }[];
    /**
     * @description An external bank account.  "routingNumber" must be set for US bank accounts.
     * "swiftCode" must be set for banks outside the US.
     */
    BankAccount: {
      /**
       * @description Bank account number or IBAN
       * @example 0114584906
       */
      accountNumber: string;
      /** @example 2390 El Camino Real */
      address1: string;
      /** @example Palo Alto, CA 94306 */
      address2?: string;
      /** @example */
      address3?: string;
      enterpriseId?: components['schemas']['Id'];
      id?: components['schemas']['Id'];
      /** @example America California Bank */
      name: string;
      /** @description Bank account owner */
      owner: {
        /** @example Donald E. Knuth */
        name: string;
        /** @example Computer Science Department */
        address1: string;
        /** @example Stanford University */
        address2?: string;
        /** @example Stanford, CA 94305-9045 */
        address3?: string;
      };
      /**
       * @description US bank routing number
       * @example 129131673
       */
      routingNumber?: string;
      shortCountryCode: components['schemas']['ShortCountryCode'];
      /**
       * @description Bank identifier code, as specified by ISO 9362.  Used by banks outside the US.
       * @example DEUTDEFF500
       */
      swiftCode?: string;
      type?: components['schemas']['BankAccountType'];
      /** @default pending */
      verificationState?: components['schemas']['BankAccountVerificationState'];
    };
    /**
     * @description Unique identifier for this account, derived from "accountNumber",
     * "routingNumber", and "swiftCode"
     *
     * @example 5c645791cf8eb19304292a8e3365fee3
     */
    BankAccountIdHash: string;
    /**
     * BankAccountType
     * @description The type of bank account. Generally optional because value is null for normal accounts.
     * Note: sen is special silvergate accounts that support instant and fee-free sending.
     *
     * @example sen
     * @enum {unknown}
     */
    BankAccountType: 'sen' | 'signet' | '';
    /** @enum {string} */
    BankAccountVerificationState: 'pending' | 'approved' | 'rejected';
    BaseIntent: {
      intentType: string;
      /**
       * @description A "sequenceId" is a unique and arbitrary wallet identifier applied to transfers and transactions at creation. It is optional but highly recommended. With a "sequenceId" you can easily reference transfers and transactions&mdash;for example, to safely retry sending. Because BitGo only confirms one send request per "sequenceId" (and fails all subsequent attempts), you can retry sending without the risk of double spending. The "sequenceId" is only visible to users on the wallet and is not shared publicly. It is the responsibility of the caller to keep track of this ID.
       *
       * @example abc123
       */
      sequenceId?: string;
      /** @description The "comment" is only visible to users on the wallet and is not shared publicly. */
      comment?: string;
      /** @description The 'nonce' of a transaction (optional) */
      nonce?: string;
    };
    BaseStakeIntent: components['schemas']['BaseIntent'] & {
      stakingRequestId: string;
    };
    BillableEvent: {
      id?: components['schemas']['Id'];
      /**
       * @description this is an id that will always stay the same for a txid, even if its regenerated
       * txid + '|' + coin + '|' + destination
       */
      deterministicId: string;
      coin: components['schemas']['Coin'];
      /**
       * @description this is the asset, will match the coin unless it is offchain, in that case it will be the base asset
       * eq. ofcbtc --> btc; ofcltc --> ltc
       */
      asset: components['schemas']['Coin'];
      /** @description The total value (in base units) sent by this BillableEvent (may be approximate for ETH and other coins where amounts in base units can exceed 2^53 - 1) */
      amount?: number;
      /** @description The total value (in base units) sent by this BillableEvent represented as a String */
      amountString: components['schemas']['IntegerString'];
      /** @description The total value (in big units) sent by this BillableEvent */
      coinBigUnits: number;
      /** @description The total value (in big units) sent by this BillableEvent represented as a String */
      coinBigUnitsString: components['schemas']['IntegerString'];
      /**
       * Format: date-time
       * @description The date of the Transfer this BillableEvent was created from
       */
      date: string;
      fromWallet: components['schemas']['Id'];
      /** @description the wallet type the BillableEvent was sent from */
      fromWalletType: components['schemas']['WalletTypeAll'];
      fromWalletBillingEnterprise?: components['schemas']['Id'];
      fromWalletBillingEnterpriseType?: string;
      fromWalletBillingEnterpriseBitGoEntity?: components['schemas']['BitGoOrg'];
      fromWalletBillingEnterprisePricingPlan?: string;
      fromEnterprise?: components['schemas']['Id'];
      fromEnterpriseType?: string;
      fromEnterpriseBitGoEntity?: components['schemas']['BitGoOrg'];
      fromEnterprisePricingPlan?: string;
      /** @description whether the BillableEvent is for a blockchain fee */
      isBlockchainFee?: boolean;
      /** @description whether the BillableEvent is for a change output */
      isChange?: boolean;
      /** @description whether the BillableEvent is for a paygo output */
      isPayGo?: boolean;
      /** @description the address the BillableEvent is sending to */
      toAddress?: string;
      toWallet?: components['schemas']['Id'];
      /** @description the wallet type the BillableEvent was sent from */
      toWalletType?: components['schemas']['WalletTypeAll'];
      toWalletBillingEnterprise?: components['schemas']['Id'];
      toWalletBillingEnterpriseType?: string;
      toWalletBillingEnterpriseBitGoEntity?: components['schemas']['BitGoOrg'];
      toWalletBillingEnterprisePricingPlan?: string;
      toEnterprise?: components['schemas']['Id'];
      toEnterpriseType?: string;
      toEnterpriseBitGoEntity?: components['schemas']['BitGoOrg'];
      toEnterprisePricingPlan?: string;
      transferId?: components['schemas']['Id'];
      txid: components['schemas']['TxId'];
      /** @description the usd value of the billable event, calculated by multiplying the usdRate time the amount of coin being sent */
      usd: number;
      /** @description the usd value captured as a string */
      usdString: string;
      /** @description The USD price at the time the Transfer was created */
      usdRate: number;
      /** @description the version of the billable event schema the event was generated with */
      version: number;
    };
    BillableEventGenerationRequest: {
      /** @description array of transfer ids to generate billable events from */
      transferIds?: components['schemas']['Id'][];
      /**
       * Format: date-time
       * @description Fetches transfers with a "date" that is greater than or equal to the given timestamp
       */
      startDate?: string;
      /**
       * Format: date-time
       * @description Fetches transfers with a "date" that is less than the given timestamp
       */
      endDate?: string;
      /** @description a flag to log detailed information about what and where processing is happening */
      shouldLog?: boolean;
    };
    /**
     * @description Available methods for paying an invoice
     * @enum {string}
     */
    BillingPaymentMethodTypes: 'stripePayments' | 'instantOnChain';
    BillingReport: {
      /** @description The report’s public ID */
      id: components['schemas']['Id'];
      /** @description The report’s public ID */
      billingTaskId: components['schemas']['Id'];
      /** @description Public ID of the admin user who created this task */
      userId: components['schemas']['Id'];
      /** @enum {string} */
      type: 'aum' | 'txn' | 'aggregate';
      /**
       * Format: date-time
       * @description Timestamp of when this report was created
       */
      created: string;
      bitgoOrg: components['schemas']['BitGoOrg'];
      /** @description Public ID of the enterprise this report was generated for */
      enterpriseId: components['schemas']['Id'];
      /** @description Public ID of the pricing plan used to generate this report */
      pricingPlanId: components['schemas']['Id'];
      /** @description The billing period month (MM) */
      month: string;
      /** @description The billing period year (YYYY) */
      year: string;
      /** @description The S3 bucket this report was saved to */
      s3Bucket: string;
      /** @description The S3 filename this report was saved as */
      s3File: string;
      /** @description Invoice ID that this report relates to. Will not be set on an aggregate report */
      invoiceId?: string;
      /** @description List of notes that will be attached to each report linked to this billing task */
      notes?: string[];
    };
    BillingTask: {
      /** @description Public ID of the billing task */
      id: components['schemas']['Id'];
      /**
       * @description Current state of the task object
       * @enum {string}
       */
      state: 'pending' | 'started' | 'finished' | 'failed';
      /**
       * Format: date-time
       * @description Date of most recent update to this task
       */
      updatedAt: string;
      /** @description Optional pricing plan to use for all reports generated by this task */
      pricingPlanId?: components['schemas']['Id'];
      /** @description An object containing metadata about this task */
      meta: {
        /** @description Public ID of the admin user who created this task */
        userId: components['schemas']['Id'];
        /** @description The billing period month (MM) */
        month: string;
        /** @description The billing period year (YYYY) */
        year: string;
        /**
         * Format: date-time
         * @description The start date of the billing period
         */
        startDate: string;
        /**
         * Format: date-time
         * @description The end date of the billing period (exclusive)
         */
        endDate: string;
        bitgoOrg: components['schemas']['BitGoOrg'];
        /** @description List of enterprise public IDs to be billed as a part of this task. Defaults to [ ‘all’ ], which indicates the worker will attempt to bill all enterprises that belong to the BitgoOrg. */
        enterpriseIds: components['schemas']['Id'][];
        /** @description List of enterprise public IDs that were originally selected for billing but were not marked to be billed by the worker. This could occur due to newPlans being set to either true or false, or due to errors in the billing workflow. */
        excludedEnterpriseIds: components['schemas']['Id'][];
      };
      /** @description Set to true if email notifications will be sent once this task is complete */
      sendEmail?: boolean;
      /** @description Set to true if the billing worker should only bill enterprises with new pricing plans. Set to false if we should only bill enterprises with old pricing plans. */
      newPlans?: boolean;
      /** @description A list of billing errors, per enterprise to be billed, that were caught asynchronously during bill calculation */
      errors: {
        /** @description The public ID of an enterprise whose billing report was generated with errors */
        enterpriseId?: components['schemas']['Id'];
        /** @description Map of report type to a list of errors raised while generating the report */
        messages?: {
          [key: string]: string[];
        };
      }[];
      /** @description List of notes that will be attached to each report linked to this billing task */
      notes?: string[];
    };
    /**
     * @description BitGo Organization related to this entity
     * @enum {string}
     */
    BitGoOrg:
      | 'BitGo Inc'
      | 'BitGo Trust'
      | 'BitGo New York'
      | 'BitGo Germany'
      | 'BitGo Switzerland'
      | 'Frankfurt DE Trust'
      | 'BitGo Sister Trust 1';
    /** @enum {string} */
    BitGoOrgUrlSafe: 'BitGo%20Inc' | 'BitGo%20Trust' | 'BitGo%20New%20York' | 'BitGo%20Germany' | 'BitGo%20Switzerland';
    /**
     * @description This route is only available for Bitcoin.
     * @enum {string}
     */
    Bitcoin: 'btc' | 'tbtc';
    BlacklistedAddress: {
      coin: components['schemas']['Coin'];
      address: components['schemas']['AddressString'];
      /** Format: date-time */
      date?: string;
      notes?: string;
    };
    /** @example 0000000000000296ed56abee6cb78e40b00c47a03d92e71dd92c4862ca636b95 */
    BlockHash: string;
    /** @enum {string} */
    BookState: 'active' | 'suspended' | 'frozen';
    Broker: {
      id?: components['schemas']['IdString'];
      name?: string;
    };
    BrokerAssetUpdateDetailsApiResponse: {
      updates?: components['schemas']['AccountAssetUpdate'][];
    };
    BrokerAssetUpdateDetailsHttpRequestBody: {
      queryFilter?: components['schemas']['AssetUpdateQueryFilter'];
    };
    BrokerAssetUpdateHttpRequestBody: {
      type?: components['schemas']['UpdateType'];
      at?: components['schemas']['DateFromISOString'];
      amount?: components['schemas']['AssetAmount'];
      /** @description unique identifier for idempotency purposes */
      identifier?: string;
      /** @description memo */
      notation?: string;
    };
    /**
     * Format: uuid
     * @description broker book identifier
     */
    BrokerBookId: string;
    /**
     * Format: uuid
     * @description broker identifier
     */
    BrokerId: string;
    /** @description name of the broker */
    BrokerName: string;
    /** @description There is still some development discussion about where counterparty account ids will be exposed via this output. We may only expose client ids. */
    BrokerTrade: components['schemas']['TradeBase'] & {
      counterpartyA: components['schemas']['BrokerBookId'];
      counterpartyB: components['schemas']['BrokerBookId'];
      clientA?: components['schemas']['ClientId'];
      clientB?: components['schemas']['ClientId'];
      settlementId?: components['schemas']['SettlementId'];
      status: components['schemas']['TradeStatus'];
      effective: components['schemas']['DateFromISOString'];
    };
    BuildParams: {
      /**
       * @description Required for transactions from TSS wallets. "acceleration" speeds up transactions with a certain nonce by adjusting the gas setting. "accountSet" is for XRP AccountSet transactions. "enabletoken" is for SOL. "stakingLock" and "stakingUnlock" are for Stacks delegations. "transfer" is for native-asset transfers. "trustline" is for Stellar trustline transactions. Possible types include: [acceleration, accountSet, enabletoken, stakingLock, stakingUnlock, transfer, transfertoken, trustline]
       * For AVAX only, possible types include: [addValidator, export, import]
       */
      type?: string;
      /** @description (BTC only) Used to estimate the fee rate by targeting confirmation within the given number of blocks. If neither "feeRate" nor "numBlocks" is specified, a block target of 2 is used by default. Can be limited with "maxFeeRate". */
      numBlocks?: number;
      feeRate?: components['schemas']['IntegerOrString'];
      maxFeeRate?: components['schemas']['IntegerOrIntegerString'];
      feeMultiplier?: components['schemas']['NumberOrString'];
      /** @description The unspent selection for the transaction will only consider unspents with at least this many confirmations to be used as inputs. Does not apply to change outputs unless used in combination with "enforceMinConfirmsForChange". */
      minConfirms?: number;
      /**
       * @description When set to true, will enforce minConfirms for change outputs. Defaults to false.
       * @default false
       */
      enforceMinConfirmsForChange?: boolean;
      gasPrice?: components['schemas']['IntegerOrIntegerString'];
      eip1559?: {
        maxPriorityFeePerGas?: components['schemas']['IntegerOrIntegerString'];
        maxFeePerGas?: components['schemas']['IntegerOrIntegerString'];
      };
      gasLimit?: components['schemas']['IntegerOrIntegerString'];
      /**
       * @description Specifies the minimum count of good-sized unspents to maintain in the wallet. Change splitting ceases when the
       * wallet has "targetWalletUnspents" good-sized unspents.
       *
       * **Note**: Wallets that continuously send a high count of transactions will automatically split large change amounts
       * into multiple good-sized change outputs while they have fewer than "targetWalletUnspents" good-sized unspents in
       * their unspent pool. Breaking up large unspents helps to reduce the amount of unconfirmed funds in flight in future
       * transactions, and helps to avoid long chains of unconfirmed transactions. This is especially useful for newly
       * funded wallets or recently refilled send-only wallets.
       *
       * @default 1000
       */
      targetWalletUnspents?: number;
      minValue?: components['schemas']['IntegerOrIntegerString'];
      maxValue?: components['schemas']['IntegerOrIntegerString'];
      /** @description A "sequenceId" is a unique and arbitrary wallet identifier applied to transfers and transactions at creation. It is optional but highly recommended. With a "sequenceId" you can easily reference transfers and transactions&mdash;for example, to safely retry sending. Because the system only confirms one send request per "sequenceId" (and fails all subsequent attempts), you can retry sending without the risk of double spending. The "sequenceId" is only visible to users on the wallet and is not shared publicly. */
      sequenceId?: string;
      nonce?: components['schemas']['IntegerString'];
      /**
       * @description Set "true" to disable automatic change splitting.
       *
       * Also see: "targetWalletUnspents"
       *
       * @default false
       */
      noSplitChange?: boolean;
      /** @description Used to explicitly specify the unspents to be used in the input set in the transaction. Each unspent should be in the form "prevTxId:nOutput". */
      unspents?: string[];
      changeAddress?: components['schemas']['AddressString'];
      /** @description (DASH only) Specifies whether or not to use Dash's "InstantSend" feature when sending a transaction. */
      instant?: boolean;
      /** @description Memo for Stellar or EOS. Type is only required for memos in Stellar transactions. The memo contains optional extra information that can also be used to identify payments in Stellar or EOS. */
      memo?: {
        type?: string;
        value?: string;
      };
      /** @description Optional metadata (only persisted in BitGo) to be applied to the transaction. Use this to add transaction-specific information such as the transaction's purpose or another identifier that you want to reference later. The value is shown in the UI in the transfer listing page. */
      comment?: string;
      /** @description (AVAXC and AVAXP only) Destination chain for an AVAX import/export transaction. One of [P, C]. */
      destinationChain?: string;
      /** @description (AVAXC and AVAXP only) Source chain for an AVAX import/export transaction. One of [P, C]. */
      sourceChain?: string;
      /**
       * @deprecated
       * @description DEPRECATED - use "changeAddressType".
       * The type of address to create for change. One of "p2sh", "p2shP2wsh", "p2wsh", or "p2tr".
       */
      addressType?: string;
      /** @description The type of address to create for change. */
      changeAddressType?: components['schemas']['AddressType'];
      /** @description The start of the validity window for the transaction. Only supported by HBAR */
      startTime?: string;
      /** @description (ALGO/TEZOS only) Consolidation ID of this consolidation transaction. */
      consolidateId?: components['schemas']['Id'];
      /** @description (XRP only) Absolute max ledger the transaction should be accepted in, whereafter it will be rejected */
      lastLedgerSequence?: number;
      /** @description (XRP only) Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected */
      ledgerSequenceDelta?: number;
      /** @description Optional block this transaction is valid from */
      validFromBlock?: number;
      /** @description Optional block this transaction is valid until */
      validToBlock?: number;
      /** @description List of trustlines to manage on the account. Available for Stellar. */
      trustlines?: components['schemas']['Trustline'][];
      /** @description Required object for staking. Only for CSPR and STX. */
      stakingOptions?: components['schemas']['CSPRStakingOptions'] | components['schemas']['STXStakingOptions'];
      /** @description Optional parameter that takes a hexadecimal value to set "messagekey" for an XRP "accountSet" transaction. Recipients field should be empty when "messageKey" is set. */
      messageKey?: string;
      /** @description Optional parameter for UTXO coins to automatically reserve the unspents that are used in the build. Useful for Cold wallets. If using, must set expireTime. */
      reservation?: {
        /**
         * Format: date-time
         * @description Required. The time that the unspent reservations should expire.
         */
        expireTime?: string;
      };
    };
    CSPRStakingOptions: {
      amount?: components['schemas']['IntegerOrIntegerString'];
      validator?: components['schemas']['AddressString'];
    };
    CannotRemoveAdmin: components['schemas']['PlatformErrorNoName'] & {
      context: {
        /**
         * @description Current number of admins on the wallet.  This number must be
         * greater than "approvalsRequired", since an admin cannot approve
         * his/her own operation.
         */
        adminCount: number;
        /** @description Number of admins that must approve a wallet operation */
        approvalsRequired: number;
      };
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'CannotRemoveAdmin';
    };
    /**
     * @example 1
     * @enum {integer}
     */
    Chain: 0 | 1 | 10 | 11 | 20 | 21 | 30 | 31 | 40 | 41;
    ChallengePartyConfig: {
      enterprise: components['schemas']['RangeProofConfig'];
      bitgoNitroHsm: components['schemas']['RangeProofConfig'];
      bitgoInstitutionalHsm: components['schemas']['RangeProofConfig'];
      /**
       * @description The ID of the user who created and verified this config.
       * @example 5d1a61a5c30ae10025f9b2b3
       */
      createdBy: string;
    };
    ChangeFeeRequest: {
      /** @description The transaction id of the transaction for which we are changing fee. */
      txid?: components['schemas']['TxId'];
      /** @description The new fee for the transaction. */
      fee?: number | string;
      eip1559?: {
        /** @description Max priority tip price for EIP1559 transactions. Only for ETH and ERC20 tokens. */
        maxPriorityFeePerGas: number | string;
        /** @description Max total gasPrice for EIP1559 transactions. Only for ETH and ERC20 tokens. */
        maxFeePerGas: number | string;
      };
    };
    ChangeFeeResponse: {
      /** @description Transaction id of the newly created transaction with increased fee rate. */
      txid?: components['schemas']['Id'];
    };
    /**
     * @description CheetahAccountID is the unique ID for a BitGo Trust enterprise in Cheetah, which is the accounting system used by Trust.
     * @example 101013
     */
    CheetahAccountId: string;
    CircuitBreaker: components['schemas']['CreateCircuitBreaker'] & {
      id: components['schemas']['Id'];
    };
    /** @description client id - unique to wallet/broker relationship */
    ClientId: string;
    /** @description client name as provided by the broker */
    ClientName: string;
    ClonedWallet: {
      id?: components['schemas']['Id'];
      /** @description the label that is either expected to be used or used for the cloned wallet */
      label?: string;
      /**
       * @description wallet clone state
       * @enum {string}
       */
      state?: 'proposed' | 'pendingInitialization' | 'initialized' | 'failed';
    };
    /**
     * Coin
     * @description A cryptocurrency or token ticker symbol.
     * @example btc
     */
    Coin: string;
    CoinOperationNotSupported: components['schemas']['PlatformErrorNoName'] & {
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'CoinOperationNotSupported';
    };
    CommitmentShare: {
      /** @description The source of the commitment share. */
      from: components['schemas']['KeyShareSource'];
      /** @description The recipient of the commitment share. */
      to: components['schemas']['KeyShareSource'];
      /** @description The commitment share. */
      share: string;
      /**
       * @description The type of the commitment share.
       * @default commitment
       */
      type: components['schemas']['CommitmentType'];
    };
    /**
     * @example commitment
     * @enum {string}
     */
    CommitmentType: 'commitment';
    ConsolidateAccountBuildRequest: {
      /**
       * @description Optional: restrict the consolidation to the specified receive addresses. If not provided, will consolidate the
       * funds from all receive addresses up to 500 addresses.
       */
      consolidateAddresses?: string[];
      /**
       * @description The Trasaction Request API version to use for MPC EdDSA Hot Wallets.
       * Defaults based on the wallet type and asset curve.
       *
       * @enum {string}
       */
      apiVersion?: 'full' | 'lite';
    };
    ConsolidateAccountBuildResponse: {
      keyDerivationPath?: string;
    };
    ConsolidateCoinAddressWhitelists: {
      /**
       * @description Recipient addresses for the new rule.  All addresses must already
       * be present in the policy.
       *
       * @example [
       *   "0x00EcedB643d7c6B43C7f4Fd2194f7939B4631D51",
       *   "0x050e25a2630b2aee94546589fd39785254de112c"
       * ]
       */
      addresses: components['schemas']['AddressString'][];
      mutabilityConstraint?: components['schemas']['MutabilityConstraint'];
    };
    /** Consolidate Token */
    ConsolidateTokenIntent: components['schemas']['BaseIntent'] &
      components['schemas']['ETHBuildOptions'] & {
        /** @enum {string} */
        intentType: 'consolidateToken';
        recipients: components['schemas']['RecipientEntry'][];
        /** @description Consolidation ID of this consolidation transaction */
        consolidateId?: string;
        /** @description True, if excluding the minimum-funding amounts in an address during consolidation. */
        keepAlive?: string;
      };
    /**
     * @description This route is only available for Algorand, Tezos, and Eth.
     * @enum {string}
     */
    ConsolidationCoins: 'algo' | 'talgo' | 'xtz' | 'txtz' | 'eth' | 'gteth';
    /** Cosmos Contract Call */
    CosmosContractCallIntent: components['schemas']['BaseIntent'] & {
      /** @enum {string} */
      intentType: 'contractCall';
      /** @description The address of the contract to call. */
      contract: string;
      /** @description The binary message data to send to the contract in hex format. */
      msgHex: string;
    };
    CreateAddressRequest: {
      /** @default 1 */
      chain?: components['schemas']['Chain'];
      label?: components['schemas']['AddressLabel'];
      /**
       * @description Whether the deployment of the address forwarder contract should use a low priority fee key (ETH only)
       * @default false
       */
      lowPriority?: boolean;
      /** @description Explicit gas price to use when deploying the forwarder contract (ETH only). If not given, defaults to the current estimated network gas price. */
      gasPrice?: number | string;
      /** @description (ETH forwarderVersion: 0 wallets only) Specify eip1559 fee parameters in forwarder creation transactions. */
      eip1559?: {
        /** @description Max priority tip price for EIP1559 transactions. Only for ETH and ERC20 tokens. */
        maxPriorityFeePerGas: string;
        /** @description Max total gasPrice for EIP1559 transactions. Only for ETH and ERC20 tokens. */
        maxFeePerGas: string;
      };
      /** @description (ETH only) Specify forwarder version to use in address creation. To reduce the cost of creating ETH forwarders, BitGo uses a set  of forwarder contracts that deploy as a simple proxy to a single  implementation (https://eips.ethereum.org/EIPS/eip-1167).  Additionally, forwarders deploy using opcode, CREATE2, enabling  them to deploy only when needed (https://eips.ethereum.org/EIPS/eip-1014).  These forwarders otherwise operate identically to prior ETH forwarders. Use this flag to specify the forwarder contract version when  deploying a forwarder contract. Use 0 for the older forwarder  (https://github.com/BitGo/eth-multisig-v2). Use 1 for the new fee-improved  forwarder (https://github.com/BitGo/eth-multisig-v4). Use 2 for  NFT-supported forwarders and version 2 wallets. Use 3 for TSS wallets. */
      forwarderVersion?: number;
      /**
       * @description Format to use for the new address, if the coin which supports multiple formats for an address.
       * Currently, Bitcoin Cash is the only coin which has support for multiple address formats. For Bitcoin Cash, BitGo supports both the base58 (legacy) address format, as well as the newer CashAddr format. The default address format is base58. To request a CashAddr formatted address instead, use the value "cashaddr" as the format.
       * @example cashaddr
       */
      format?: string;
    };
    CreateBillingTaskRequest: {
      /**
       * @description The BitGo Organization to bill
       * @enum {string}
       */
      bitgoOrg:
        | 'BitGo Inc'
        | 'BitGo Trust'
        | 'BitGo New York'
        | 'BitGo Germany'
        | 'BitGo Switzerland'
        | 'BitGo Sister Trust 1';
      /** @description The billing period month (MM) */
      month: string;
      /** @description The billing period year (YYYY) */
      year: string;
      /** @description A list of enterprise IDs to bill. Bills all enterprises linked to the organization by default. Entries must be valid and belong to the organization, otherwise the request will fail. If left blank, will default to [‘all’], indicating that a billing attempt will be made for all enterprises. */
      enterpriseIds?: components['schemas']['Id'][];
      /**
       * @description Specify a pricing plan override to use instead of the enterprise’s default plan.
       * Applies to all selected enterpriseIds.
       */
      pricingPlanId?: components['schemas']['Id'];
      /** @description If set to true, an email notification will be sent to the admin user who created this task once bills are ready to download */
      sendEmail?: boolean;
      /** @description Will filter out enterpriseIds by the startDate of their attached pricing plan. If set to true, this task will only generate reports/bills for enterprises whose pricing plan is set to start on/after the current billing period (a new plan). Setting this attribute to false will have the opposite effect: this task will only generate reports/bills for enterprises whose plans are not “new.” If this attribute is not set, this task will bill all enterprises regardless of their pricing plan start-date. */
      newPlans?: boolean;
      /** @description Attach notes to all reports generated by this task. */
      notes?: string[];
    };
    CreateBlockWebhook: {
      type: components['schemas']['WebhookTypeBlock'];
      /**
       * Format: uri
       * @description URL to fire the webhook to.
       * @example http://your.server.com/webhook
       */
      url: string;
      /** @description Label of the new webhook. */
      label?: string;
      /**
       * @description Number of confirmations before triggering the webhook. If 0 or unspecified, requests will be sent to the callback endpoint when the transfer is first seen and when it is confirmed.
       * @example 6
       */
      numConfirmations?: number;
    };
    CreateCircuitBreaker: {
      enforced: boolean;
      /** @description If set, this circuit breaker applies to wallets in the given enterprise */
      enterpriseId?: components['schemas']['Id'];
      name?: string;
      usdLimit: {
        /** @description USD limit for all transfers out of a wallet within the given time window */
        value: number;
        window: components['schemas']['Duration'];
      };
      /** @description If set, this circuit breaker applies to a single wallet */
      walletId?: components['schemas']['Id'];
    };
    CreateCustodialKey: {
      /**
       * @description Which bitgo org will provide custody with this key
       * @enum {string}
       */
      bitgoOrg: 'BitGo Inc' | 'BitGo Trust';
      curve: components['schemas']['KeyCurve'];
      pub: components['schemas']['Pub'];
      source: components['schemas']['CustodialKeySource'];
    };
    CreateEnterprise: {
      name: string;
      emergencyPhone?: components['schemas']['EmergencyPhone'];
      /**
       * Format: uri
       * @description The URL the enterprises web site
       */
      url?: string;
      distributedCustody?: components['schemas']['DistributedCustodyCreateEnterprise'];
    };
    CreateHalfSignedWalletRecoveryTx: {
      /** @description Signatures of support engineers for wallet recovery transaction in PGP format. */
      aokSignatures: unknown[];
      /** @description Set to true if forwarding the half signed to KRS (Key recovery service) - default false. */
      sendKrs?: boolean;
    };
    CreateHalfSignedWalletRecoveryTxResponse: {
      /** @description The email associated with the wallet recovery. */
      userEmail: string;
      /** @description The coin of the wallet being recovered. */
      coin: string;
      /** @description The xpub of the backup key of the wallet being recovered. */
      backupKeyXPub: string;
      /** @description The hex of the half signed transaction that was built in hex format. */
      encodedTransaction: string;
      /** @description The response from the KRS provider if applicable. */
      krsResponse: Record<string, never>;
    };
    CreateHoldingsReportRequest: {
      /** @enum {string} */
      type?: 'wallets' | 'transactions' | 'trades';
      /** @enum {string} */
      format?: 'pdf' | 'csv';
      holdings?: {
        /** @description ID of the enterprise */
        enterprise: components['schemas']['Id'];
        /**
         * Format: date-time
         * @description Date of the snapshot
         */
        snapshotDate: string;
        byWallet?: boolean;
      };
    };
    CreateInvoiceRequest: {
      /**
       * @description The value of the invoice in satoshis
       * @example 50000
       */
      value: number;
      /**
       * @description A memo or description to include in the invoice
       * @example Latte macchiato
       */
      memo?: string;
      /**
       * @description The number of seconds before the invoice expires
       * @default 3600
       */
      expiry?: number;
    };
    CreateKey: {
      /** @description Private part of this key pair, encrypted with a passphrase that only the client knows. Required for all sources except "bitgo". */
      encryptedPrv?: string;
      source?: components['schemas']['KeySource'];
      /** @description The Enterprise that will own this key */
      enterprise?: components['schemas']['Id'];
      /** @description Create a new keychain instead of fetching enterprise key (only for Ethereum) */
      newFeeAddress?: boolean;
      pub?: components['schemas']['Pub'];
      /**
       * @description Set to true if you want to create a key for distributed custody. This parameter is only valid if you have the distributed custody enterprise license enabled and are creating a BitGo key. Otherwise it will throw an error.
       * @example false
       */
      isDistributedCustody?: boolean;
      /** @description The commonPub for the key. This value is necessary for BLS keys when the source is either “user” or “backup”. Setting this indicates to BitGo that the owner of the key has received all key shares they needed for generating their key. */
      commonPub?: string;
      /** @description The commonKeychain for the key if this is a TSS key. This value is required to be set when the type is set to “tss” and when the source is either “user” or “backup”. Setting this indicates to BitGo that the owner of the key has received all key shares they needed for generating their key. This value is the common pub concatenated with the common chaincode. */
      commonKeychain?: string;
      /** @description Only required for BitGo TSS keys. Those will be the shares from the user and the backup provider that BitGo will end up generating the BitGo key (share) from. */
      keyShares?: components['schemas']['KeyShare'][];
      type?: components['schemas']['BackupKeyType'];
      /** @default tss */
      keyType?: components['schemas']['KeyType'];
      /** @description User's public key in ASCII armored format. Only required for BitGo TSS keys. */
      userGPGPublicKey?: string;
      /** @description Backup public key in ASCII armored format (may be managed by user or KRS). Only required for BitGo TSS keys. */
      backupGPGPublicKey?: string;
    };
    CreateOrganizationEnterpriseRequest: {
      email: string;
      /**
       * Format: uuid
       * @description A unique identifier for the enterprise creation request. Multiple enterprises with the same organizationId and idempotencyKey will not be created.
       */
      idempotencyKey: string;
      additionalAdmins: components['schemas']['Id'][];
    };
    CreateOrganizationEnterpriseResponse: {
      enterpriseId?: components['schemas']['Id'];
      userId?: components['schemas']['Id'];
    };
    CreatePasswordReset: {
      keyPub: components['schemas']['Pub'];
      walletId: components['schemas']['Id'];
      creatorId: components['schemas']['Id'];
      /** @enum {string} */
      state: 'pending';
    };
    CreatePolicyRule: {
      /**
       * @description If set, the rule will only apply to the given coin or ERC20 token in an
       * Ethereum wallet. It is generally recommended to not set a coin for policy rules of the following types:
       * "advancedWhitelist", "allTx", "coinAddressWhitelist", "coinAddressBlacklist", "webhook".
       *
       * @example zrx
       */
      coin?: string;
      /** @description The id of the rule, must be unique among rules in the policy */
      id: string;
      type: components['schemas']['CreatePolicyRuleTriggers'];
      condition?: components['schemas']['PolicyRuleUpdateConditions'];
      action: components['schemas']['PolicyRuleActions'];
    };
    /**
     * @description What causes this rule to trigger
     * @enum {string}
     */
    CreatePolicyRuleTriggers:
      | 'advancedWhitelist'
      | 'allTx'
      | 'allTxNoFiat'
      | 'coinAddressWhitelist'
      | 'coinAddressBlacklist'
      | 'velocityLimit'
      | 'webhook';
    CreateSchema: {
      database?: components['schemas']['Database'];
      /** @example wallet */
      coll?: string;
      type?: components['schemas']['Type'];
      query?: components['schemas']['Query'];
      field?: string;
      limit?: components['schemas']['Limit'];
    };
    CreateSendLabel: {
      coin: components['schemas']['Coin'];
      address: components['schemas']['AddressString'];
      enterpriseId: components['schemas']['Id'];
      label: string;
    };
    CreateSignatureShareRequest: {
      /** @description A user-provided share to be used in the ECDSA or EDDSA TSS signing flow. Please use signatureShares instead */
      signatureShare?: components['schemas']['SignatureShare'];
      /** @description User-provided shares to be used in the ECDSA or EDDSA TSS signing flow. */
      signatureShares?: components['schemas']['SignatureShare'][];
      /**
       * @description An openPGP ascii armored message (encrypted to the known HSM public key) containing the
       * previous signer’s offset secret share as a 128 character hex string (64 bytes) consisting of
       * the new offset “u” private component from the user [or backup] new offset Y-share as a 64 character
       * hex string (32 bytes) concatenated with the new offset “chaincode” component of the new offset Y-share
       * as a 64 character hex string (32 bytes). Must be provided when uploading an R share.
       */
      signerShare?: string;
      /** @description User’s public key of the gpg key. */
      userPublicGpgKey?: string;
    };
    CreateStakingTransactionRequest: {
      /**
       * Format: uuid
       * @description UUID used to identify a staking request.
       * @example c37088a8-a11d-4a63-9de4-6579b0f99401
       */
      stakingRequestID: string;
      walletID: components['schemas']['WalletId'];
      /**
       * @description BitGo user ID.
       * @example 5f8f84fd47afbb0032528432c9c755d8
       */
      userID: string;
      /**
       * Format: float
       * @description Desired amount of the asset for the staking action.
       * @example 7.77
       */
      quantity: number;
      /**
       * @description BitGo coins instrument symbol for the staking request (case insensitive).
       * @example GTETH
       */
      instrumentSymbol: string;
      creationDate: components['schemas']['DateFromISOString'];
      actionType: components['schemas']['ActionType'];
    };
    CreateTSSBackupKey: {
      /** @description The id of the enterprise the keys and wallet will be created under. */
      enterprise: string;
      /** @description GPG public key of the user creating the wallet. */
      userGPGPublicKey: string;
    };
    CreateTradesReportRequest: {
      /** @enum {string} */
      type?: 'wallets' | 'transactions' | 'trades';
      /** @enum {string} */
      format?: 'pdf' | 'csv';
      trades?: {
        /** @description ID of the enterprise */
        enterprise: components['schemas']['Id'];
        /**
         * Format: date-time
         * @description Date of the snapshot
         */
        startDate: string;
        /**
         * Format: date-time
         * @description Date of the snapshot
         */
        endDate: string;
        assets?: string[];
        isFillsReport?: boolean;
      };
    };
    CreateTransactionRequest: {
      /** @description The combination of the idempotencyKey, version and walletId has to be unique. If no idempotencyKey is specified then it remains undefined for the txRequest. Note, version is an internal field that is auto incremented on every update to a txRequest. */
      idempotencyKey?: string;
      intent: components['schemas']['TransactionRequestIntent'];
      /** @description (Custodial) Specify who should perform the Video ID with Trust if one should be required. */
      videoApprovers?: components['schemas']['IdArray'];
      /**
       * @description Full or Light to differentiate between the different transaction request flows.
       * @default full
       * @enum {string}
       */
      apiVersion?: 'lite' | 'full';
      /**
       * @description When set to true, the transaction request is returned without being stored in the DB.
       *
       * @default false
       */
      preview?: boolean;
    };
    CreateTransactionsReportRequest: {
      /** @enum {string} */
      type?: 'wallets' | 'transactions' | 'trades';
      /** @enum {string} */
      format?: 'pdf' | 'csv';
      transactions?: {
        /** @description ID of the enterprise */
        enterprise: components['schemas']['Id'];
        /**
         * Format: date-time
         * @description Date of the snapshot
         */
        startDate: string;
        /**
         * Format: date-time
         * @description Date of the snapshot
         */
        endDate: string;
        wallets?: components['schemas']['Id'][];
        walletTypes?: string[];
        assets?: string[];
        isDetailed?: boolean;
      };
    };
    CreateTxRequestChallengeRequest: {
      /** @description The 'n' value from an ECDSA wallets paillier public key. Retrieved from xShare.n. */
      paillierModulus: string;
    };
    CreateTxRequestChallengeResponse: {
      /**
       * @description Range proof challenge value.
       * @example f6219cfbe968bfb4284ba393f7e01447a70a9b7ef364eb1036248c1cd3098ef10fbf2e5cbf6edf89796b2ea90faa96628d6b3495782ea523d9cc7eaf5738090a44ce96eb0d18741e7f0bf9b43a950521e915785a86e2938e5ba578e36a2619bc4b101c5e29f567ce916ab8f5bba67877354d9dcc390955a404965021ae12d3dbcc1d6836c8e5ad2056a28fda4d6316e35cf1870cf9053d804c23eba8e2e1509fb840a1e1ff9556b3d95bd47ab9fd795fc0ad5caf2d1e1a58b08e4dbf45ce25d27d8c653c3a2b3085db02ea0ef14170a625572c345609beaddd198350ec76a26db79c003cfd697171b21d4c6e49c03ffdc93ff2738175a6456083e77b18b5655357f406e24432c190c9b7ad7b4507ee339c7e5130ba354df1284a0477b375d07955849024761d07a3e1ee42bf71c9975c13b533313c0c3cd5ad9533d14481c4216a60bdb7f17c0614e85836c6d2f0ee4abaa4f9afc97d1b0e7cf5b22a65f237c1d36d5ae5e5d8e1d9aca4d67fd3fda7933fe09eb37b7c327948c1c4b8cdc99e85
       */
      ntilde: string;
      /**
       * @description Range proof challenge value.
       * @example 71efca979802ceb98d3b1f8642ff1705b41e7d2e4178cf953a201c8ef1459ee7c66e6eba30a685b8a31f6dc1249118cd689efadd85079c7040ef6003503275ffec8b1e04d972ebddb77020230ba84fdbeb0fe0b9668c8e0f87897cfc519c88e625ab9baab803355e795bc327a4ed8d7192658eecf76be62f05dfc50ca99d016acbe11f2dc94060fbbbb472321b7ea63b88542ae1e8ab7b745ca2cbec9eb39a138c90032833f3902de4ec35d4523b0aa43c119e35c2d920d46d59ce7a6fa383747727d54115ce62b64500f2c2e8a3c434cdc49168c620653f37b95de0dd2720e8a16360eafb2884021c9c414f55ace77362b0a8840bdd64f262b880231a097ea5318c9bd6f8d8943359b5019ac8ae4e42a4cd4e9352a5b98f5899c317366ae0b135eec932422e886ec6ce3766b80762ed1e0ed07cd2be48adf6b7b61352268f17ad6de567a8636445bfea2af721ba9165bfc3e8514df9b3596769ce9f13472a95566bfdfcfffc42fc9267af02a9b9201826982a43d2222a6d9e0729e729df8ec0
       */
      h1: string;
      /**
       * @description Range proof challenge value.
       * @example e8be92b67d852d83c4e57a4c25139cbab1801654408c4260ca21d480ea5425a7a7778b30d52c24eed11363a6f7bf1efa986747a2016b91e84b9a7d49b723644f4488ec15c64d83289b1fa73a6607544a2c1964d31931ae9c0f4b5c66a0099f82d52a73d4d7a251a29f279c7f053cc0064989479d9b6d900e92641555683efadad5f08a68a6763102a7a14d4d5aecc6620587ceedb28db338858326fdad35e1b2db54b8a7679d8cad36d88c63c61aff15121c6ec06a724e16980fd334cdbbea8885f88e8a509a42b093361e3152bcf391e3a723ceb4786362fcad9c4945a372d617bebe077e1c7ee49ac81701c06ef126e1178b779f1f4be4b1a3616c3c1821b26ead5cc7b1442216162077fb125a4c9250001797e3a224c79f5cd5a78226a9192000bc584bf479aa1dd83d56628860619778a0c6d9801e2680349ccde39e604af6f1e75226c58d6f608c420eb8091def8d3c7a9a59414e9b9a1df542929c81165a46555f5f51c1cb080f04a9ccc74a5d1e3b053e1e2e4b8566d1a7995478a589
       */
      h2: string;
      /**
       * @description Paillier proof challenge value.
       * @example [
       *   "82a9623ab0333061ebb44f322e9b1d2403cc7e402e6d8c30127fd267608278b2fe76571c76656e7d63a1d190d2e2130ed7f9b2625274e80ee2b3d3976ade4e746ff637340e38b87251a0aa3d1e31337d7e941108d6123306a61ef99868fc47050bc3dc653bb8b69fc629383b5978555ca3b7a1e8b71583c1f073d0702575e85e81131cf78e41740721321b59a32127a4aa3954415a68502d29f84b0e07e5d816732d791e6ce34f17dc5d7902a4e26b2e8b8e7789fe962653c6e6ac8fa1dbe28dcb9b74e897470816274a4b06c2c2759e745d15c92cb44918feb0581054745c1c4185dcc74d51882f83028751cfc685fe2c665d3afae8feb3677c1791b056db6df20d840289066023010c75251192342113e8779c82711e93cb0dac8c8627d68e88b38edbe17f65546143a492857d0d2c0816ebfa65ce4dc9914f8726fbe43526154f9bcb884021a3ca716d9481395db23fe1a51cf9af7cc1ac6cf85eb2b736d08e750121f2fcb03e4ca53a2aabfcebdfc573f2b0efd5d5f06d8f2a4be0964a5b",
       *   "81b8d1ee66fc771f69e3b676b57f0b4a858de83a6651c5a2de2b2c75d505b3be9eca5fb1285f4158a2ec7175c184de642e3c978fb1229bed3e1db67346921978512836e8a6acbf20cdae48580b78317d8500a779d907cbf6ae34a1961d98bab677ac71b357d34b78edd36e75ceac89c304c3e361740201e37e59c7966116080317e321dbe3632df829b8284b0753cd9aefa1cfd391bc1d51124b59c1bfb7e376172da683a6456b7d994a1f26c6ab68a8c75e4c381cb016c70e8e89f26bbf3204617874cf9e06d725f7b25836325de6967389d4780b28b14dfd3cf7a70f01c630209ba3beb47761a1cfc754744d34ff4188f35adae96dacf8904463dac38631e65cf6d6b0f85f4a1edad1ba7015ef4af4ca498a2cdb18225d849d3ac22f544077bf88e7ee6d23c516c7832c4cc84ba24e82c0418feafcaada88817b557e842ae0c9134c3d5a8500faf3b84d412752a6d2bdaf77d290bc1c9c10b270aedbbb574fecad8ead1969f8485554212d35c3a590d4313767a985625ea0db7345ccb6c3c9",
       *   "a7e27178a41e0b963daf47b651376b1079427ef491d744f479d5fa892427b6b38b767850188b1814457416546999bcebadd6867e70c7010622827ee7562d9c77a8ea676dfa1ec9732705ddaa332aea51b4ae0b04ad33e9911c0386518119d000b48bb8506cf268578cb06ad4966d46f40be59277119a3b03fe3759ca872b558fd4a963f89624912c6b177cec4210f01e1c1adfc4c4b3dbe6a10d7046c6a2ad4d22e8661127edfa89247b07c8137b3f016709c0107c54887cb654ae2daadce4182909d831328604878f28e23cdbbec44224e7400cde0824ebc11243b34ca9f0796ad7bd8035ed1dd4450c5bbdd56f8c35aa422787f828c432ca1349e2229f225bd65029863a043d6c00c6a0a73829f459c318d5fbee9f1537b10230a6d0ea7eddd1006048233edbaf5cb092099ffe9e5a2dfaa45cf8cef88d9eb532757b646b98f5141323e74b6778b842050041076b713112b39fc246d3c94068d6b19d7f3ca4dbe6e29d8530a65986f63d7b526ca66f6a624e0e3e39b5c61e515b173f44b234",
       *   "a0f0294b52d644cbc7365bf35ede3eeed09fc6e1e7dc7bc8ae0f4e14ff817eea36d49d76e4405bc7f2b85cb332dd09b2362fed9f208405283de0d679e48a2d193545cefe0f398333ceb5e41d106520a528cc8242e52e938b21739e3f046d32417ab6135ee9605e295dfd0c652e1a01269253f2cd12576d3b6e0629416102c00f47756a01da1c4bd6291e884736e512da41b140884460a44bb85607d53cc52f86804282dfca69e7241b7d0b997e5cade4a009c623d0d6bcd976c004112a9f9c5445afe21d85844601438fec53aad659f8325c8c803d4b10b91aceb9d16880744acee98dc844344374160e56a98d0149f96524e33735cb7cd413c26af849a36f7f743eb27b186ec2bd0617628267004bda7b668b38e75c3106b9ad3d2d335a2c030644a135a537ceb6e883b62f5a7e83ed80e277e1c8cd4a3c9fec03bb88c3d9d3ac14fea4db75680d083f69fc904d1948004b0a55fa426527da0f9f8dd82236efd65d3836248a9a51df30e5969aba1f9c584ca2191e9413b2e292c37e0f624cb2",
       *   "8930619d2a903f298f675c647e193d8c9bb51922e6c2f76fb3e634d9d84ee65bdffda2d67573b59394df3834fe54c87e1e6df12ecc31f3886dd2f079e22d011f461c65566b38e2d8ab9ebb7a197e10d08bbaf4e9d0d95b447346135655a8e8551351745a1c35626be56149cec943bf5de1669cb18750ec2597ca4900e1ac174784fca5e25e5e0141a71ebf901c36557635935314318f94cfcc3a45c1aecb221b321232b26d95704d3aa3fc091696857240311b2fb477eda3b725d8a380f69b851ee47c8c754be3ca2b4ed626248e3dd8be52fdefe46443bd60ef12ed0fd8c3e98fab13e6534e2edd8ce3ad411e6cb56900cda74823937a35c6c24e37fb62a77e7f93f113173b52987cfe6f125a550a39d094d4921371d0f7bfbfead92d0d210e5529d4393a8813dda9e89fbd66bf9912f8f1623ea3fd3f5cdc965024268b4c5096cc1536f451afcaf766740a65eec0679e6f5c67400cbb7dfd914e36e12ec521e1bf6ef64e9714a545cafcf87a305de496cddd841b10950eb69a0d6fbe913fc0",
       *   "884f1998a21c39a165fb91edca0068dd8fefe6c7846d276426fdf23abe846392c32b45549a4d244c9ae0350d98dcf0e3016d9eef4a13a4c2e953832f4dd29628ecdb18c18cb461c647f4aafe88b59ddb5ecb9607a4a8f279783219c4278375b19c952b77aaacd3dc508e83f1336f07f1b4a326976f32b19788813a504deb78ca36a747788c42d4bd2ec6af351f98ff065ef05314fd68423517c260542818d0130bf26c5384b4b09fda0285dee434fea5c1a9e61dd3c858332fa7cbafe2bb1d192ea36d5a0c1090a6eee02231c88e4d3e43942fc2869ba6e58931fb4943454b652c4917e384346ef655a32cd20a1dfee3e24da052eb1489f3e0bb099501017ab1f279a944fe54b9c3e53cb9852eb0e1a0ee548948ba3cfe4b5c8cb5418fff49cc71ce737fe2018ea99e94241470fe3bf3328729247ade26cda8be2c60c1f1137ecf1f837d6e977b29d752e2bb5acc341243c3f82c8f56f078f1c3a1fe4d58d851e3ccdd93804b0d57979fc177a18cc10a6c5f4b3e0906a6343ec9d33b43346285",
       *   "a763ec91e12354c75f3b3ec8c04591e8b23f4e6e053644f56fd7f47af338883e8a4d49e9f5425d4000dc42d0e8c20644fe840eb70d16148676ece54b9cd85742402de08bbc7736a153792c34d1bfd685ff158cd4b329bf606ef49e14e0b5c335b8491a8dcfd0b48a6ba850bd5421c2eb20f26973cfea267ba4d45f30465ccc6b200b5a8879acd0aff60b65637a16f47248498d23489471ca2d72bfb7ea954679f54d38c870de9be3446331107bde1950ccbf59b5a4bda9bcf7266a39dc085f843f563f3075d9f81ea39ad5ed9997eb09fb521baf14b4f872d4c67eeac92cfb47729bbfa916898273d895dab9cb74fc873553df9ee8062969076c26b014decff58d02569de3bfd763a54977dcc8909e69e353678e9f02becd95cb4735b9d0dc8c08e4bdbb271d0f66ccf4be48a0a98ed40353e1d5266e558d51622e938adf8bd15f884fe68c6715b6b2964edfa2b2582f70327d8f682691370ed32e3ba3675695a380f4f95235a4ad595a8f7928e4ea5b09ed2a7558a370e78d1e5d9b80aed222"
       * ]
       */
      p: string[];
      /**
       * @description BitGo's paillier modulus 'n'.
       * @example aaf19cbfb67436e12bd77080ceb98a2d38bbbd6739da5c9bb76a41f6e6f8d04544e28dbb21d7930a6e15ae62fe84d17ac91bd84cfa24dc81dc98b2e91f07fdc6e7346ff31fe794d75652a17cd84fb817caade116bacfa7aee324d5881f44f616b5270c39b849dba0da9aaa740275c5416224d1f0cd1af776c8d709f65f72e7ffde5cefab0b6559fb96f04f8fe3a0d48197446b3ec47db82963f78bf25f71ec7883e5eda7dd2d74f683e8c6570be5eed060190d17d1b5236ed72567bee35a7e0cf5463e839db22e632b4ccc49cab3d2d9d86f0740d983115b078693847a8160eb2bed70bb0c8946d35e10f9d03cedab1afe95489ccf3414ba7e72471266b6c1950a09c723d84251f400ca3a3998c670d8352b968c9a6582709617d1157e4667fe3728ba6f329183334fb69e3f2f0e31037761dc8a547f8676f702f3670e9631c8d14c2b6acf8a83646d61d817955d8898e60fe74e4f2eb4a8a3112cd457960efb240f5b78e7f41b14f16127929502c72b3b239f0daa27b3901d6fbdb62d834ff9
       */
      n: string;
    };
    CreateUnsignedCrosschainRecovery: {
      /** @description The blockchain where the funds were mistakenly sent to. */
      wrongChainCoin: string;
      /** @description The address where the funds were sent to on the wrong chain. */
      wrongChainAddress: string;
      /** @description The amount of funds that were mistakenly sent. */
      amount: string;
      /** @description The nonce of the transaction that sent the funds to the wrong chain. */
      nonce: number;
      /** @description The address where the funds should be recovered to. */
      destinationAddress: string;
      /** @description The token contract address if the funds were sent to a token contract. Optional field. */
      tokenContractAddress?: string;
    };
    CreateUnsignedCrosschainRecoveryResponse: {
      /** @description The unsigned transaction hex for the crosschain recovery. */
      txHex: string;
    };
    CreateUnsignedWalletRecoveryTx: {
      /** @description Email of the user who wants to recover their wallet. */
      userEmail: string;
      /** @description Blockchain address where the funds want to be recovered to. */
      destAddress: string;
      /** @description Set to true if recovering to a non-bitgo address. */
      allowExternal?: boolean;
      /** @description Fee estimate for UTXO recoveries. */
      utxoFeePerKb?: number;
    };
    CreateUnsignedWalletRecoveryTxResponse: {
      /** @description The unsigned transaction that was built in hex or base64 format. */
      encodedTransaction: string;
      /** @description ID of the the recovery record tracked by BitGo. */
      recoveryId: string;
    };
    CreateWallet: {
      coinSpecific?: components['schemas']['WalletCreateCoinSpecific'];
      /** @description This is required for Ethereum wallets since they can only be created as part of an enterprise. */
      enterprise?: components['schemas']['Id'];
      /** @description This is required for all wallets where the client supplies the keys to be used. The only case where this is not required is when the type is set to "custodial". */
      keys?: components['schemas']['Keys'];
      keySignatures?: {
        /** @description a signature of the backup pub key using the user key (useful for change address verification) */
        backup?: string;
        /** @description a signature of the bitgo pub key using the user key (useful for change address verification) */
        bitgo?: string;
      };
      label: components['schemas']['WalletLabel'];
      multisigType?: components['schemas']['WalletMultisigType'];
      address?: components['schemas']['WalletCustomAddress'];
      /** @description This is required for all wallets where the client supplies the keys to be used. The only case where this is not required is when the type is set to "custodial". */
      m?: components['schemas']['NumSignatures'];
      /** @description This is required for all wallets where the client supplies the keys to be used. The only case where this is not required is when the type is set to "custodial". */
      n?: components['schemas']['NumKeychains'];
      tags?: components['schemas']['Id'][];
      type?: components['schemas']['WalletTypePublic'];
      /**
       * @description (ETH only) Specify the wallet creation contract version used when creating a wallet contract. Use 0 for the old wallet creation, 1 for the new wallet creation, where it is only deployed upon receiving funds. 2 for wallets with the same functionality as v1 but with NFT support. 3 for TSS wallets.
       * @default 1
       */
      walletVersion?: number;
      /** @description (ETH walletVersion: 0 wallets only) Specify eip1559 fee parameters in wallet creation transactions. */
      eip1559?: {
        /** @description Max priority tip price for EIP1559 transactions. Only for ETH and ERC20 tokens. */
        maxPriorityFeePerGas: string;
        /** @description Max total gasPrice for EIP1559 transactions. Only for ETH and ERC20 tokens. */
        maxFeePerGas: string;
      };
    };
    CreateWalletWebhook: OneOf<
      [
        {
          type: components['schemas']['WebhookTypeWallet'];
          /**
           * @description Triggers on coin transfers and token transfers for ETH and Stellar.
           * @default false
           */
          allToken?: boolean;
          /**
           * Format: uri
           * @description URL to fire the webhook to.
           * @example http://your.server.com/webhook
           */
          url: string;
          /** @description Label of the new webhook. */
          label?: string;
          /**
           * @description Number of confirmations before triggering the webhook. If 0 or unspecified, requests will be sent to the callback endpoint when the transfer is first seen and when it is confirmed.
           * @example 6
           */
          numConfirmations?: number;
          /** @description Whether or not to listen to failed transactions on chain. */
          listenToFailureStates?: boolean;
        },
        {
          /**
           * @description Subscribe to Transaction Request State Changes
           * @enum {string}
           */
          type: 'txRequest';
          /**
           * Format: uri
           * @description URL to fire the webhook to.
           * @example http://your.server.com/webhook
           */
          url: string;
          /**
           * @description Label of the new webhook.
           * @example My Transaction Request Webhook
           */
          label?: string;
          /** @description If supplied, only transaction request state changes from the provided list will trigger notifications. If not provided, all transaction request state changes will trigger notifications. */
          txRequestStates?: components['schemas']['TransactionRequestState'][];
        },
        {
          /**
           * @description Subscribe to Transaction Request Transaction State Changes
           * @enum {string}
           */
          type: 'txRequestTransaction';
          /**
           * Format: uri
           * @description URL to fire the webhook to.
           * @example http://your.server.com/webhook
           */
          url: string;
          /**
           * @description Label of the new webhook.
           * @example My Transaction Request Transaction Webhook
           */
          label?: string;
          /** @description If supplied, only transaction request transaction state changes from the provided list will trigger notifications. If not provided, all transaction request transaction state changes will trigger notifications. */
          txRequestTransactionStates?: components['schemas']['TransactionState'][];
        }
      ]
    >;
    CrossChainUnspent: {
      unspent?: {
        /**
         * @description Type ID for this output.
         * @example 7
         */
        outputID?: number;
        /**
         * @description Amount as a BigNumber string.
         * @example 2000000
         */
        amount?: string;
        /**
         * @description Transaction ID of this unspent.
         * @example 2WW4Z9R9jdUSR1uheJ1rGuLUNXjipXESGknGWrkqx7KUU1YKV5
         */
        txid?: string;
        /**
         * @description Number of signatures required to unlock UTXO.
         * @example 1
         */
        threshold?: number;
        /**
         * @description Addresses tied to the UTXO for the signatures.
         * @example [
         *   "C-fuji167u3leuup654jdea3euggkhh82ta53jer3ttf4",
         *   "C-fuji19vy09dn76mvt55r0x2d3ch2jrr8z6lgp80vzlj",
         *   "C-fuji1dynny22nx9l7mujpwadmyj930yjqa040zdjh0w"
         * ]
         */
        addresses?: string[];
        /**
         * @description Index of the output in the transaction.
         * @example 1
         */
        outputidx?: string;
        /**
         * @description Time that the UTXO is unlocked.
         * @example 0
         */
        locktime?: string;
      };
      /**
       * @description Public ID of the wallet (in the source chain) that created the cross-chain output.
       * @example 6386565affdf48cb812ca1f0ed49a621
       */
      fromWallet?: string;
      /**
       * @description Public ID of the wallet (in the destination chain) that's the target recipient of the cross-chain transfer.
       * @example 6386565affdf48cb812ca1f0ed49a621
       */
      toWallet?: string;
      /**
       * @description Addresses (in the destination chain) that are target recipients of the cross-chain transfer.
       * @example 0x125c4451c870f753265b0b1af3cf6ab88ffe4657
       */
      toAddresses?: string;
    };
    /**
     * @description A unit of currency for a report
     * @default USD
     * @enum {string}
     */
    CurrencyUnit: 'ZAR' | 'USD' | 'GBP' | 'EUR' | 'CNY' | 'CAD' | 'AUD';
    CustodialKey: {
      /**
       * @description Which bitgo org will provide custody with this key
       * @enum {string}
       */
      bitgoOrg: 'BitGo Inc' | 'BitGo Trust';
      curve: components['schemas']['KeyCurve'];
      id: components['schemas']['Id'];
      pub: components['schemas']['Pub'];
      source: components['schemas']['CustodialKeySource'];
    };
    /** @enum {string} */
    CustodialKeySource: 'backup' | 'user';
    CustodialKeysResponse: {
      custodialKeys: components['schemas']['CustodialKey'][];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
    };
    CustodianSnapshot: {
      broker: components['schemas']['Broker'];
      accounts?: components['schemas']['Account2'][];
      currencies?: components['schemas']['AssetDef'][];
    };
    /**
     * @description Signatures for the keys which will be used to derive custom change addresses.
     *
     * **Note:** These signatures may only be set once for each wallet and are not modifiable after being set.
     */
    CustomChangeKeySignatures: {
      user?: string;
      backup?: string;
      bitgo?: string;
    };
    CustomNodeRequest: {
      name?: string;
      description?: string;
      url: string;
      accessToken?: string;
    };
    CustomNodeResponse: {
      /** @description platform public id for a custom node */
      id?: components['schemas']['Id'];
      coin?: string;
      name?: string;
      description?: string;
      url?: string;
    };
    CustomReportFields: 'fromAddresses'[];
    DOTBuildOptions: components['schemas']['AccountBaseBuildOptions'] & {
      fee?: components['schemas']['DOTFeeOptions'];
    };
    /** Dot Claim Unstake */
    DOTClaimIntent: components['schemas']['DOTBuildOptions'] & components['schemas']['WithdrawIntent'];
    DOTFeeOptions: {
      amount: string;
      /** @enum {string} */
      unit?: 'baseUnit' | 'cpu' | 'ram';
      /** @enum {string} */
      formula?: 'fixed' | 'feeRate' | 'perKB' | 'custom';
      /** @enum {string} */
      type?: 'base' | 'max' | 'tip';
    };
    /** Dot Payment */
    DOTPaymentIntent: components['schemas']['DOTBuildOptions'] &
      components['schemas']['PaymentIntent'] & {
        proxy?: string;
      };
    /** Dot Stake */
    DOTStakeIntent: WithRequired<
      components['schemas']['DOTBuildOptions'] &
        components['schemas']['StakeIntent'] & {
          /** @description Amount, in planks, to stake. */
          amount?: components['schemas']['Amount2'];
          /** @description Address to add as a staking proxy for the controller account. */
          stakingProxy?: string;
          /** @description True, if adding an amount, using 'bondExtra', to an existing stake account.  False, if initializing an amount, using 'bond', to a new stake account. */
          addToStake?: boolean;
        },
      'amount' | 'stakingProxy'
    >;
    /** Dot Unstake */
    DOTUnstakeIntent: WithRequired<
      components['schemas']['DOTBuildOptions'] &
        components['schemas']['UnstakeIntent'] & {
          /** @description Amount, in lamports, to unstake. If this amount causes the staked amount to drop below the staking minimum, set 'stopStaking' to true. */
          amount?: components['schemas']['Amount2'];
          /** @description Staking-proxy address of the controller account when the stake was created. */
          stakingProxy?: string;
          /** @description True, if chilling the stake and removing the staking proxy. */
          stopStaking?: boolean;
        },
      'amount' | 'stakingProxy'
    >;
    /**
     * @example bitgo2
     * @enum {string}
     */
    Database: 'bitgo' | 'bitgo2' | 'btcHistory' | 'send2' | 'ledger2';
    /**
     * Format: date-time
     * @description ISO 8601 string representation of date
     * @example 2019-05-02T15:27:35.773Z
     */
    DateFromISOString: string;
    /**
     * Format: date-time
     * @example {}
     */
    DateTime: string;
    DecimalString: string;
    /** Decoded Transaction */
    DecodedTransaction: {
      protocolAddress: string;
      protocolName?: string;
      methodSignature: string;
      decoderType: string;
      methodParameters: components['schemas']['MethodParameter'][];
    };
    /** Decorated Message Details */
    DecoratedMessageDetails: components['schemas']['MessageDetails'] & {
      /** @enum {string} */
      payloadType?: 'message';
    };
    /** Decorated Transaction Details */
    DecoratedTransactionDetails: components['schemas']['TransactionDetails'] & {
      /** @enum {string} */
      payloadType?: 'transaction';
    };
    DeleteEnterpriseUser: {
      /** Format: email */
      username: string;
    };
    DeployForwarderAndForwardTokenResponse: {
      txId?: string;
    };
    DeployForwarderRequest: {
      /** @description Default: false Use forceDeploy: true to deploy the forwarder even if pendingDeployment flag is set as false */
      forceDeploy?: boolean;
      /** @description Explicit gas price to use when deploying the forwarder contract (ETH only). If not given, defaults to the current estimated network gas price. */
      gasPrice?: number;
      /** @description Specify eip1559 fee parameters in forwarder creation transactions. */
      eip1559?: {
        /** @description Max priority tip price for EIP1559 transactions. Only for ETH and ERC20 tokens. */
        maxPriorityFeePerGas: number;
        /** @description Max total gasPrice for EIP1559 transactions. Only for ETH and ERC20 tokens. */
        maxFeePerGas: number;
      };
    };
    Deposit: {
      /**
       * @description The address the deposit will be received at
       * @example 1234567890ABCDEF-XJBCOEF
       */
      toAddress: string;
      /** @description The value (in cents/base units) of the deposit */
      valueString?: components['schemas']['IntegerString'];
      /**
       * @description If this is a token entry, the token's symbol
       * @example ousd
       */
      token: string;
      toBankAccount?: components['schemas']['BankAccount'];
    };
    DeveloperOverageFee: {
      limit: number;
      percentAmount: number;
      flatAmount: number;
      flatAmountUnits: number | null;
    };
    DeveloperProductFee: {
      feeType?: components['schemas']['PricingFeeType'];
      feeName?: string;
      occurrence?: components['schemas']['PricingFeeOccurrence'];
      percentAmount?: number;
      flatAmount?: number;
      flatAmountUnits?: number | null;
      paymentMethod?: components['schemas']['BillingPaymentMethodTypes'];
      overage?: components['schemas']['DeveloperOverageFee'][];
    };
    DeveloperPromotions: {
      name: string;
      percentOff: number | null;
      amountOff: number | null;
      overagePercentOff: number | null;
      overageAmountOff: number | null;
      currency: components['schemas']['CurrencyUnit'];
      applicableKit: components['schemas']['EnterpriseKitName'];
      applicableFee: components['schemas']['PricingFeeType'];
      /** Format: date */
      expiry: string | null;
      active?: boolean;
    };
    /** @description These parameters are needed on the enterprise if you are planning on creating distributed custody wallets on this enterprise. */
    DistributedCustodyCreateEnterprise: {
      signingBitgoOrg?: components['schemas']['BitGoOrg'];
    };
    DistributedCustodyOptions: {
      /**
       * @description The BitGoOrg that will be used to create the key
       * @example BitGo Trust
       */
      bitgoOrg?: components['schemas']['BitGoOrg'];
    };
    /** @description Parameters associated with distributed custody enterprises. If you want to remove 'signingBitgoOrg', set it to null. */
    DistributedCustodyUpdateEnterprise: {
      signingBitgoOrg?: null | components['schemas']['BitGoOrg'];
    };
    /**
     * @description RFC 3339 time duration
     * @example P1D
     */
    Duration: string;
    EIP1559FeeOptions: {
      gasLimit?: number;
      maxFeePerGas?: number;
      maxPriorityFeePerGas?: number;
    };
    /** Eth Acceleration */
    ETHAccelerationIntent: components['schemas']['AccelerationIntent'] &
      components['schemas']['ETHBuildOptions'] & {
        feeOptions: components['schemas']['FeeOption'] | components['schemas']['EIP1559FeeOptions'];
      };
    ETHBuildOptions: components['schemas']['AccountBaseBuildOptions'] & {
      feeOptions?: components['schemas']['FeeOption'] | components['schemas']['EIP1559FeeOptions'];
      hopParams?: components['schemas']['HopParams'];
      receiveAddress?: string;
    };
    /** Eth Fill Nonce */
    ETHFillNonceIntent: components['schemas']['FillNonceIntent'] & components['schemas']['ETHBuildOptions'];
    /** Eth Payment */
    ETHPaymentIntent: components['schemas']['PaymentIntent'] &
      components['schemas']['ETHBuildOptions'] & {
        selfSend?: boolean;
        custodianTransactionId?: string;
      };
    /** Eth sign message */
    ETHSignMessageIntent: components['schemas']['BaseIntent'] & {
      /** @enum {string} */
      intentType: 'signMessage';
    };
    /** Eth Stake */
    ETHStakingIntent: WithRequired<
      components['schemas']['StakeIntent'] &
        components['schemas']['ETHBuildOptions'] & {
          /** @description The ETH2 validator public key */
          pubkey?: string;
          /** @description The withdrawal credentials, a commitment to a public key used for future withdrawals */
          withdrawalCredentials?: string;
          /** @description A signature produced by the ETH2 validator as proof it accepts to stake on behalf of the account identified by the withdrawal credentials */
          signature?: string;
          /** @description The deposit data root, used to verify the validity of the deposit information */
          depositDataRoot?: string;
        },
      'pubkey' | 'withdrawalCredentials' | 'signature' | 'depositDataRoot'
    >;
    /**
     * Format: email
     * @example user@example.com
     */
    Email: string;
    /**
     * @description Phone number for emergencies
     * @example +11234567890
     */
    EmergencyPhone: string;
    EnableTokenIntent: components['schemas']['BaseIntent'] & {
      /** @enum {string} */
      intentType: 'enableToken';
      enableTokens: components['schemas']['TokenEnablement'][];
    };
    EncryptedShare: {
      /** @description The source of the encrypted signer share. */
      from: components['schemas']['KeyShareSource'];
      /** @description The recipient of the encrypted signer share. */
      to: components['schemas']['KeyShareSource'];
      /** @description The encrypted signer share. */
      share: string;
      /**
       * @description The type of share.
       * @default encryptedSignerShare
       */
      type: components['schemas']['ShareType'];
    };
    EncryptedToken: {
      id?: components['schemas']['Id'];
      client?: string;
      user?: string;
      scope?: components['schemas']['Scope'];
      created?: string;
      expires?: string;
      ip?: string;
      ipRestrict?: string[];
      origin?: string;
      label?: string;
      isExtensible?: boolean;
      ecryptedToken?: string;
      derivationPath?: string;
    };
    Enterprise: {
      accountType?: components['schemas']['EnterpriseAccountType'];
      additionalEnterpriseInfo?: components['schemas']['AdditionalEnterpriseInfo'];
      admin?: {
        policy?: components['schemas']['Policy'];
      };
      /** @description IDs of users on the enterprise that are approved for custodial video ID */
      approvedVideoIdUsers?: components['schemas']['Id'][];
      /**
       * @description How many Enterprise Admins are required for action to fire
       * @example 1
       */
      approvalsRequired?: number;
      /** @description The public portion of the ethererum key generated for the enterprise fee address */
      bitgoEthKey?: string;
      bitgoOrg?: components['schemas']['BitGoOrg'];
      /** @description whether the enterprise has the licence for BitGo Prime Borrowing */
      canAccessBorrowing?: boolean;
      /** @description whether the enterprise has the licence for BitGo Prime Lending */
      canAccessLending?: boolean;
      /** @description whether the enterprise has the licence to utilize settlement functionality */
      canAccessSettlement?: boolean;
      /** @description whether the enterprise has the licence to access BitGo Trading */
      canAccessTrading?: boolean;
      /** @description whether the enterprise has the license to create cold wallets */
      canCreateColdWallet?: boolean;
      /** @description whether the enterprise has the license to create custodial wallets */
      canCreateCustodialWallets?: boolean;
      /** @description whether the enterprise has the license to create hot wallets */
      canCreateHotWallet?: boolean;
      contract?: components['schemas']['EnterpriseContract'];
      emergencyPhone?: components['schemas']['EmergencyPhone'];
      /** @description The eth fee address used to pay for network transaction fees of this enterprise */
      ethFeeAddress?: string;
      freeze?: components['schemas']['Freeze'];
      id: components['schemas']['Id'];
      /**
       * @description Time in seconds after which policies on this Enterprise cannot be updated
       * @example 172800
       */
      mutablePolicyWindow?: number;
      /** @example Small Company */
      name?: string;
      pricingTypes?: components['schemas']['EnterprisePricingTypes'];
      activePricingType?: components['schemas']['EnterpriseActivePricingType'];
      kits?: components['schemas']['EnterpriseKits'];
      activeKits?: components['schemas']['EnterpriseActiveKits'];
      /** @description The Id of the User who is the primary contact */
      primaryContact?: components['schemas']['Id'];
      /** @description The UI that this enterprise prefers to use */
      preferredUi?: components['schemas']['EnterpriseAvailableUI'];
      /**
       * @description The total number of wallets in the enterprise
       * @example 1
       */
      totalWalletsCount?: number;
      usersViewAllWallets?: components['schemas']['ViewAllWallets'];
      videoIdWaived?: components['schemas']['VideoIdWaived'];
    };
    /**
     * @description Indicates which type of KYC process the enterprise has to complete
     * @enum {string}
     */
    EnterpriseAccountType: 'individual' | 'entity';
    EnterpriseActiveKits: (components['schemas']['AuditableItem'] & components['schemas']['EnterpriseKitName'])[];
    EnterpriseActivePricingType: components['schemas']['AuditableItem'] &
      components['schemas']['EnterprisePricingType'];
    /** @enum {string} */
    EnterpriseAvailableUI: 'bg23';
    EnterpriseBalance: components['schemas']['Balance'] & {
      coin?: components['schemas']['Coin'];
      enterpriseName?: string;
      enterpriseId?: components['schemas']['Id'];
    };
    EnterpriseContract: {
      /** @description The contract start date for an enterprise */
      startDate?: string;
      /** @description The contract end date for an enterprise */
      endDate?: string;
    };
    /** @enum {string} */
    EnterpriseFeatureFlag:
      | 'avaxcAlwaysUseHop'
      | 'reactOnly'
      | 'enableBG23'
      | 'btcHSMv3'
      | 'enableMMI'
      | 'ethHSMv3'
      | 'nftWallets'
      | 'checkPendingBalanceOnBuild'
      | 'enableEcdsaWallets'
      | 'specialVideoInstructions'
      | 'blockTransactionIfPending'
      | 'monthlyTrustReports'
      | 'nitroHSM'
      | 'snowflakeReports'
      | 'useEcdsaTssPaillierBlum'
      | 'useEcdsaTssPhase5'
      | 'sendTxRequestFullNotification';
    EnterpriseInternal: {
      /** @description Whether this enterprise has been migrated to the new policy service */
      migratedToNewPolicyService?: boolean;
    };
    EnterpriseKitName: {
      /** @enum {string} */
      name?: 'default' | 'wallet' | 'custody' | 'liquidity' | 'cryptoCompare';
    };
    EnterpriseKits: {
      name?: components['schemas']['EnterpriseKitName'];
      datesActive?: components['schemas']['AuditableItem'][];
    }[];
    /** @enum {string} */
    EnterpriseKycState: 'unverified' | 'approved' | 'rejected';
    /** @enum {string} */
    EnterpriseLicenseFlags:
      | 'canAccessBorrowing'
      | 'canAccessLending'
      | 'canAccessSettlement'
      | 'canAccessTrading'
      | 'canCreateColdWallet'
      | 'canCreateCustodialWallet'
      | 'canCreateHotWallet'
      | 'canCreateOffchainWallet';
    /** @enum {string} */
    EnterpriseLicenses:
      | 'bitgoNetwork'
      | 'marginTrading'
      | 'mtGox'
      | 'portfolioAPI'
      | 'portfolioBasic'
      | 'portfolioProfessional'
      | 'portfolioInstitutional'
      | 'tax'
      | 'tradeAPI'
      | 'staking'
      | 'metaMaskInstitutional'
      | 'cryptoCompare'
      | 'elliptic'
      | 'instantFeeHotWallet'
      | 'bitgoTrustAsKrs'
      | 'escrow'
      | 'distributedCustodyWallet';
    /** @enum {string} */
    EnterprisePermission: 'admin';
    EnterprisePricingType: {
      /** @enum {string} */
      name?: 'starter' | 'growth';
    };
    EnterprisePricingTypes: {
      name?: components['schemas']['EnterprisePricingType'];
      datesActive?: components['schemas']['AuditableItem'][];
    }[];
    EnterpriseResponse: components['schemas']['Enterprise'] & {
      tags?: components['schemas']['EnterpriseTag'][];
    };
    EnterpriseTag: {
      name?: string;
      id?: components['schemas']['Id'];
    };
    /** @enum {string} */
    EnterpriseType:
      | 'Asset Management (i.e. pension fund)'
      | 'Bank'
      | 'Broker/Dealer'
      | 'Casinos and Gambling Establishments'
      | 'Charity/NGO/Non-Profit/Foundation/Endowment'
      | 'Commodities/Futures Commission Merchant'
      | 'Crypto ATM'
      | 'Crypto Exchange'
      | 'Crypto Lending/Borrowing'
      | 'Custodian'
      | 'Family Office'
      | 'Foreign Correspondent Banks'
      | 'Government/State owned/Political Org. (i.e. Sovereign Wealth Fund)'
      | 'Individual'
      | 'Import/export companies'
      | 'Insurance Company'
      | 'Miner / Mining Pool'
      | 'Money Service Business'
      | 'Mutual Funds'
      | 'Non-Banking Financial Institution (NBFI) (ETF Issuer, Forex, Index Fund, Hedge Fund, RIA, Prime Brokerage)'
      | 'OTC'
      | 'Payment Platforms'
      | 'Private Equity / Venture Capital'
      | 'Private Investment Companies/International Business Corporations'
      | 'Professional Service Providers (lawyers, accountants, etc.)'
      | 'Real estate brokers, developers, and appraisers'
      | 'Retail Lender'
      | 'Software or Technology Company'
      | 'Tokens / Coins'
      | 'Traders / Trading (High Frequency, Proprietary, Market Maker)'
      | 'Agriculture'
      | 'Art dealer / Auctioneer'
      | 'Computer programmer/ administrator / software engineer / IT'
      | 'Education / Teacher'
      | 'Extractive industry (oil, gas, iron, steel, copper, earth metals)'
      | 'Film / TV / Entertainment (not adult)'
      | 'Healthcare'
      | 'Jewels / gemstones / precious metals'
      | 'Recreation / hospitality'
      | 'Student'
      | 'Unemployed / Retired'
      | 'High Net Worth Individual'
      | 'Law Enforcement / Military / Protective Services'
      | 'Weapons dealers'
      | 'Leveraged Investor'
      | 'Institutional Investors'
      | 'Financial Institution'
      | 'Execution Services'
      | 'Other';
    /** @enum {string} */
    EnterpriseUpfrontPaymentStatus: 'received' | 'waived' | 'pending' | 'overdue' | 'delinquent';
    EnterpriseUser: {
      id?: components['schemas']['Id'];
      username?: components['schemas']['Email'];
      /**
       * @description User first name
       * @example Jane
       */
      firstName?: string;
      /**
       * @description User last name
       * @example Doe
       */
      lastName?: string;
      /**
       * @description User full name
       * @example Jane Doe
       */
      fullName?: string;
      isActive?: boolean;
      email?: {
        email?: components['schemas']['Email'];
        /** @description User has verified their email */
        verified?: boolean;
      };
      /** @description User has verified their email */
      verified?: boolean;
      identity?: {
        kyc?: {
          /**
           * @description User has done initial video ID
           * @example true
           */
          hasVideoID?: boolean;
          overallState?: components['schemas']['UserKycState'];
          /**
           * @description Sanction screening is required for this User
           * @example true
           */
          required?: boolean;
        };
      };
    };
    EnterpriseUserSigningKey: {
      userId?: components['schemas']['Id'];
      userEmail?: components['schemas']['Email'];
      /**
       * @description The derived public key of the user.
       * @example 0205f47704d137205ba32560e01ed182428c758760d9a05ae58cf2f66069f5d717
       */
      derivedPubkey?: string;
      /**
       * @description The derivation path used to derive derivedPubkey. Returned only if you're fetching your own signing key.
       * @example m/999999/51550848/191290384
       */
      derivationPath?: string;
      /**
       * @description The bip32 public key that you can use to fetch a v1 keychain. Returned only if you're fetching your own signing key.
       * @example xpub661MyMwAqRbcFm7W87Qcns2ybFoSHsHEkGzNQj1KhPeLNUtV7KKiQvtLVLwPpWFaohqXrCBqCit9sM6G5kmtZHaJYSvMC65ge9HATFShe1S
       */
      ecdhKeychain?: string;
    };
    EnterpriseUsersResponse: {
      adminUsers?: components['schemas']['EnterpriseUser'][];
      nonAdminUsers?: components['schemas']['EnterpriseUser'][];
      /** @description The total number of Users returned. */
      count?: number;
      /** @description Set to true if the Enterprise has at least 500 v1 or v2 wallets. If there are more than 500 wallets (either v1 or v2) it could mean that some Wallets were not considered for finding all Users. */
      incomplete?: boolean;
    };
    EnterprisesResponse: {
      enterprises?: (components['schemas']['Enterprise'] & {
        /** @description In what way(s) the user is associated with the enterprise */
        tags?: ('user' | 'wallet' | 'pending' | 'walletV2' | 'pendingV2')[];
      })[];
    };
    EstimateTransactionFees: {
      /**
       * @description Fee per kilobyte for a transaction to be confirmed across two or more blocks. Defaults to 2 if "numBlocks" is not provided in the request query.
       * @example 15902
       */
      feePerKb: number;
      /** @description Child pays for parent (CPFP) fee per kilobyte where the fee includes the fees for all unconfirmed transactions dependent on this transaction. */
      cpfpFeePerKb?: number;
      /**
       * @description The target block confirmation.
       * @example 2
       */
      numBlocks: number;
      /**
       * @description (BTC only) Confidence, as a percentage, in the accuracy of the fee estimate.
       * @example 80
       */
      confidence?: number;
      /**
       * @description (BTC only) Fee estimates are stored as a key-value pair where the key is the block target (between 1 and 1000) and the value is the corresponding fee estimate (in baseunits per kilobyte).
       * @example {
       *   "1": 50536,
       *   "2": 15902,
       *   "3": 1579
       * }
       */
      feeByBlockTarget?: Record<string, never>;
    };
    EstimateTransactionFeesAccountCoin: {
      /** @description fee estimate for a transaction for the given account-based coin, denominated in the base units of that coin (i.e. Drops for XRP, Stroops for XLM, etc) */
      feeEstimate: components['schemas']['IntegerString'];
    };
    EstimateTransactionFeesAlgo: {
      /**
       * @description Calculated by transaction size. Fee rate is in microAlgo (base unit).
       * @example 1
       */
      feeRate: number;
      /**
       * @description Always 1000.
       * @default 1000
       * @example 1000
       */
      minimumFee: number;
    };
    EstimateTransactionFeesEth: {
      /** @description fee estimate for a transaction for the given account-based coin, denominated in base units (i.e. Wei) */
      feeEstimate: components['schemas']['IntegerString'];
      /** @description The amount of gas that the transaction will use, if recipient is provided in the request */
      gasLimitEstimate?: components['schemas']['IntegerString'];
      /** @description minimum gas price that can be provided in base units */
      minGasPrice: components['schemas']['IntegerString'];
      /** @description minimum gas limit that can be provided in base units */
      minGasLimit: components['schemas']['IntegerString'];
      /** @description maximum gas limit that can be provided in base units */
      maxGasLimit: components['schemas']['IntegerString'];
      /** @description gas price must not be increased by less than this after being introduced to the network */
      minGasIncreaseBy: components['schemas']['IntegerString'];
      /** @description EIP 1559 fee estimates */
      eip1559?: components['schemas']['EstimateTransactionFeesEthEip1559'];
    };
    EstimateTransactionFeesEthEip1559: {
      baseFee: components['schemas']['IntegerString'];
      /** @description Block gas used ratio. Calculated as the ratio of gasUsed and gasLimit */
      gasUsedRatio: string;
      safeLowMinerTip?: components['schemas']['IntegerString'];
      normalMinerTip?: components['schemas']['IntegerString'];
      standardMinerTip?: components['schemas']['IntegerString'];
      fastestMinerTip?: components['schemas']['IntegerString'];
      ludicrousMinerTip?: components['schemas']['IntegerString'];
    };
    EstimateTransactionFeesTrx: {
      /**
       * @description Maximum fee for a payment transaction, denominated in base units (i.e. sun). It varies for TRX and TRC20 Token based on the coin parameter
       * @example 100000000
       */
      fee: number;
      /**
       * @description Fee for wallet initialization
       * @example 100000000
       */
      newAccountFee: number;
      /**
       * @description Fee rate per unit of tx size. Not used currently ("fee" is a maximum limit, the network charges the cost of the transaction)
       * @example 1000
       */
      netFee: number;
    };
    EthereumFeeAddressReport: {
      /** @example data":"Date(UTC),Type,Wallet ID,TXID,From,To,Amount (Wei),Amount (USD) Fri Aug 31 2018 22:22:36 GMT+0000,Incoming,N/A,0xc80d6db35e12df7cc8e7cd71e453e7d906deea2e4891e59ebc7e11c2761e4e2c,0xf7aba9b064a12330a00eafaa930e2fe8e76e65f0,0x85381b885ef2d04b6bfbf5e565dbc635b7520193,250000000000000000,$70.56755 */
      data?: string;
      /** @example csv */
      format?: string;
    };
    EvmWallet: {
      /** @example eth */
      coin?: string;
      /** @example 0x62fab8f6a2c5921f072ea17b112516481ec2d939c0cd6a7b102a0e961ef44bc8 */
      address?: string;
      /** @example 11c881596ed89d1d4c189fd066b33aaa */
      walletId?: string;
    };
    EvmWalletRes: {
      /** @example 79ea3345-90ce-46d5-931b-79cac77bba23 */
      id?: string;
      /** @example 11c881596ed89d1d4c189fd066b33aaa */
      userId?: string;
      /** @example ecdsa */
      curve?: string;
      keys?: string[];
      wallets?: {
        /** @example eth */
        coin?: string;
        /** @example 0x62fab8f6a2c5921f072ea17b112516481ec2d939c0cd6a7b102a0e961ef44bc8 */
        address?: string;
        /** @example 11c881596ed89d1d4c189fd066b33aaa */
        walletId?: string;
      }[];
    };
    ExpressAccelerateTxRequest: {
      /**
       * @description txids of the transactions to bump
       *
       * **Notes**:
       * Each target unconfirmed transaction must be sending funds to the calling wallet.
       * Accepts only a single txid at this stage.
       */
      cpfpTxIds?: components['schemas']['TxId'][];
      /** @description Desired effective feerate of the bumped transactions and the CPFP transaction in satoshi per kilobyte */
      cpfpFeeRate?: number;
      /**
       * @description Maximum allowed fee for the CPFP transaction in satoshi
       *
       * **Note**:
       * A CPFP transaction accelerates the target transactions and all of the unconfirmed transactions the target transactions depends on.
       * As it can be difficult to discern the complete transaction ancestry at times, we recommend limiting the total fee for each CPFP attempt as a safety net to prevent CPFP transactions that exceed your cost expectations.
       */
      maxFee?: number;
    };
    ExpressAcceptShareRequest: {
      /** @description User's password to decrypt the shared wallet (required if the wallet was shared with spend permission) */
      userPassword?: string;
      /** @description New wallet passphrase for saving the shared wallet private key If not provided and the wallet was shared with spend permission, then the userPassword is used */
      newWalletPassphrase?: string;
      /** @description Encrypted private key received out-of-band */
      overrideEncryptedPrv?: string;
    };
    ExpressAcceptShareResponse: {
      state?: string;
      /** @description Indicates if the share changed */
      changed?: boolean;
    };
    ExpressCalculateMinerFeeInfoRequest: {
      feeRate?: components['schemas']['IntegerOrString'];
      /**
       * @description Number of P2SH (multi-signature) inputs
       * @example 2
       */
      nP2shInputs?: number;
      /**
       * @description Number of P2PKH (single-signature) inputs
       * @example 0
       */
      nP2pkhInputs?: number;
      /**
       * @description Number of P2SH_P2WSH (wrapped segwit multi-signature) inputs
       * @example 1
       */
      nP2shP2wshInputs?: number;
      /**
       * @description Number of outputs
       * @example 2
       */
      nOutputs: number;
    };
    ExpressCalculateMinerFeeInfoResponse: {
      /**
       * @description Estimated size of the transaction in bytes
       * @example 776
       */
      size?: number;
      /**
       * @description Estimated fee in base units for the transaction
       * @example 38800
       */
      fee?: number;
      /**
       * @description The fee rate in base units per kB used to estimate the fee for the transaction
       * @example 50000
       */
      feeRate?: number;
    };
    ExpressCanonicalAddressRequest: {
      /** @description Address to canonicalize */
      address?: string;
      version?: ('base58' | 'bech32') | (1 | 2);
    };
    ExpressConsolidateAccountRequest: {
      /**
       * @description Optional: restrict the consolidation to the specified receive addresses. If not provided, will consolidate the
       * funds from all receive addresses up to 500 addresses.
       */
      consolidateAddresses?: string[];
      /**
       * @description Passphrase to decrypt the user key on the wallet.
       * Required if External Signer is not used to sign the transactions.
       */
      walletPassprase?: string;
      /**
       * @description The un-encrypted user private key in string form.
       * If the key is a JSON object it must be stringified.
       * Required if "walletPassphrase" is not available or encrypted private key is not stored by BitGo.
       */
      prv?: string;
      /**
       * @description The Trasaction Request API version to use for MPC EdDSA Hot Wallets.
       * Defaults based on the wallet type and asset curve.
       *
       * @enum {string}
       */
      apiVersion?: 'full' | 'lite';
    };
    ExpressConsolidateUnspentsRequest: {
      /** @description Passphrase to decrypt the user key on the wallet */
      walletPassphrase?: string;
      /** @description Private key in string form, if walletPassphrase is not available */
      xprv?: string;
      feeRate?: components['schemas']['IntegerOrString'];
      maxFeeRate?: components['schemas']['IntegerOrIntegerString'];
      /** @description Maximum relative portion that can be spent towards fees */
      maxFeePercentage?: number;
      /** @description Block target for fee estimation */
      feeTxConfirmTarget?: number;
      minValue?: components['schemas']['IntegerOrIntegerString'];
      maxValue?: components['schemas']['IntegerOrIntegerString'];
      /** @description Minimum height of unspents on the block chain to use */
      minHeight?: number;
      /** @description Minimum confirmation threshold for external inputs */
      minConfirms?: number;
      /** @description Flag for enforcing minConfirms for change inputs */
      enforceMinConfirmsForChange?: boolean;
      /** @description Maximum number of unspents to use in the transaction */
      limit?: number;
      /** @description Number of new unspents to make */
      numUnspentsToMake?: number;
      /** @description address to use for generated outputs. Must be wallet address. */
      targetAddress?: string;
      txFormat?: components['schemas']['UtxoTransactionFormat'];
    };
    /** @description Generated key pair */
    ExpressCreateKeychainResponse: {
      /**
       * @description Private key
       * @example xprv9s21ZrQH143K2Y4th5Bn8sCRCMNjVr3sm9TLj9yw9SRKxYbJdB18bpc7cZFHKKWKuWZUBATfbDVE26u7w2iUhmWD8Gsp8UkaemhLEfopC35
       */
      prv?: string;
      pub?: components['schemas']['Pub'];
    };
    ExpressDecryptRequest: {
      /** @description Ciphertext to decrypt */
      input?: string;
      /** @description Key which is used for decryption */
      password?: string;
    };
    ExpressDecryptResponse: {
      decrypted?: string;
    };
    ExpressEncryptRequest: {
      /** @description Plaintext message which should be encrypted */
      input?: string;
      /** @description Password which should be used to encrypt message */
      password?: string;
    };
    ExpressEncryptResponse: {
      encrypted?: string;
    };
    ExpressFanOutUnspentsRequest: {
      /** @description Passphrase to decrypt the user key on the wallet */
      walletPassphrase?: string;
      /** @description Private key in string form, if walletPassphrase is not available */
      xprv?: string;
      feeRate?: components['schemas']['IntegerOrString'];
      maxFeeRate?: components['schemas']['IntegerOrIntegerString'];
      /** @description Maximum relative portion that can be spent towards fees */
      maxFeePercentage?: number;
      /** @description Block target for fee estimation */
      feeTxConfirmTarget?: number;
      minValue?: components['schemas']['IntegerOrIntegerString'];
      maxValue?: components['schemas']['IntegerOrIntegerString'];
      /** @description Minimum height of unspents on the block chain to use */
      minHeight?: number;
      /** @description Minimum confirmation threshold for external inputs */
      minConfirms?: number;
      /** @description Flag for enforcing minConfirms for change inputs */
      enforceMinConfirmsForChange?: boolean;
      /** @description Maximum number of unspents to use in the transaction */
      maxNumInputsToUse?: number;
      /** @description Number of new unspents to make */
      numUnspentsToMake?: number;
      /** @description address to use for generated outputs. Must be wallet address. */
      targetAddress?: string;
      txFormat?: components['schemas']['UtxoTransactionFormat'];
    };
    ExpressGenerateWalletRequest: {
      label: components['schemas']['WalletLabel'];
      /**
       * @description If absent, BitGo uses the default wallet type for the asset.
       * @enum {string}
       */
      multisigType?: 'onchain' | 'tss' | 'blsdkg';
      /**
       * @description The type of wallet, defined by key management and signing protocols. 'hot' and 'cold' are both self-managed wallets. If absent, defaults to 'hot'.
       * @enum {string}
       */
      type?: 'hot' | 'cold' | 'custodial';
      /** @description Passphrase to be used to encrypt the user key on the wallet */
      passphrase?: string;
      /** @description User provided public key */
      userKey?: string;
      backupXpub?: components['schemas']['Pub'];
      /**
       * @description Optional key recovery service to provide and store the backup key
       * @enum {string}
       */
      backupXpubProvider?: 'keyternal';
      /** @description Enterprise id. This is required for Ethereum wallets since they can only be created as part of an enterprise */
      enterprise?: components['schemas']['Id'];
      /** @description Flag for disabling wallet transaction notifications */
      disableTransactionNotifications?: boolean;
      /** @description The passphrase used for decrypting the encrypted user private key during wallet recovery */
      passcodeEncryptionCode?: string;
      /** @description Seed that derives an extended user key or common keychain for a cold wallet. */
      coldDerivationSeed?: string;
      /** @description Gas price to use when deploying an Ethereum wallet */
      gasPrice?: number;
      /** @description Flag for preventing KRS from sending email after creating backup key */
      disableKRSEmail?: boolean;
      /**
       * @description (ETH only) Specify the wallet creation contract version used when creating a wallet contract. Use 0 for the old wallet creation, 1 for the new wallet creation, where it is only deployed upon receiving funds. 2 for wallets with the same functionality as v1 but with NFT support. 3 for TSS wallets.
       * @default 1
       */
      walletVersion?: number;
      /** @description True, if the wallet type is a distributed-custodial. If passed, you must also pass the 'enterprise' parameter. */
      isDistributedCustody?: boolean;
      /** @description BitGo key ID for self-managed cold TSS wallets. */
      bitgoKeyId?: components['schemas']['Id'];
      /** @description Common keychain for self-managed cold TSS wallets. */
      commonKeychain?: string;
    };
    ExpressGenerateWalletResponse: OneOf<
      [
        components['schemas']['ExpressWallet'],
        {
          wallet?: components['schemas']['ExpressWallet'];
          /** @description User keychain */
          userKeychain?: {
            id?: components['schemas']['Id'];
            /**
             * @description User private key encrypted with the user passphrase
             * @example {"iv":"TEd5eouui6hKashuVi5WHQ==","v":1,"iter":10000,"ks":256,"ts":64,"mode":"ccm","adata":"","cipher":"aes","salt":"dHu4PWoX2M8=","ct":"fYr9Y/6kU40AosONkV0xi+fWsyhpYSew0L2YKH/qEZjOlxeDjpC2aTJ0Yc/KdmXheUGolcAxGSx93ykN21Zim1DGc/UGa25IUA/3ARgX7gBsYnYEy5e5Ol0YZYb9pa7KFeaDZSLMXrxxoahg5zL4AJsUx90Pwcg="}
             */
            encryptedPrv?: string;
            /**
             * @description User private key
             * @example xprv9s21ZrQH143K3e1981rUcbKjJ9G57SDCDZ9HY4Sqhx5ZqMoyK1j49kAf1vuM1G9nhRr6kzqbUQb3gj5zuzrsvNRQ84tYf32EcyapRgBNpp4
             */
            prv?: string;
            pub?: components['schemas']['Pub'];
            /**
             * @description Ethereum address corresponding to this keychain
             * @example 0xf5b7cca8621691f9dde304cb7128b6bb3d409363
             */
            ethAddress?: string;
            /**
             * @description Party that created the key
             * @example user
             */
            source?: string;
            /** @description Coin specific key data */
            coinSpecific?: Record<string, never>;
          };
          /** @description Backup keychain */
          backupKeychain?: {
            id?: components['schemas']['Id'];
            /**
             * @description Backup private key
             * @example xprv9s21ZrQH143K47iEnAFZRJz36E5ZxuEDBJETFYxJTsTVxuPc9z7oGWADUK6icX5P3ruoe244yxMt9uZ2LjWhddvnJJ4zB7zK93qBtxYrmN6
             */
            prv?: string;
            pub?: components['schemas']['Pub'];
            /**
             * @description Party that created the key
             * @example backup
             */
            source?: string;
            /**
             * @description Ethereum address corresponding to this keychain
             * @example 0xf5b7cca8621691f9dde304cb7128b6bb3d409363
             */
            ethAddress?: string;
            /** @description Coin specific key data */
            coinSpecific?: Record<string, never>;
          };
          /** @description BitGo keychain */
          bitgoKeychain?: {
            id?: components['schemas']['Id'];
            pub?: components['schemas']['Pub'];
            /**
             * @description Flag for identifying keychain as created by BitGo
             * @example true
             */
            isBitGo?: boolean;
            /**
             * @description Party that created the key
             * @example bitgo
             */
            source?: string;
            /**
             * @description Ethereum address corresponding to this keychain
             * @example 0xa487900d0de75107b1cc7ade0e2662980e5ce940
             */
            ethAddress?: string;
            /** @description Coin specific key data */
            coinSpecific?: Record<string, never>;
          };
          /**
           * @description If the backup key is held by the user, this is a message warning the user to securely backup their backup keychain.
           * @example Be sure to backup the backup keychain -- it is not stored anywhere else!
           */
          warning?: string;
        }
      ]
    >;
    ExpressPingResponse: {
      status?: string;
    };
    ExpressResolvePendingApprovalRequest: {
      /**
       * @description New state for the pending approval
       * @enum {string}
       */
      state?: 'approved' | 'rejected';
      /** @description Passphrase to decrypt the user key on the wallet */
      walletPassphrase?: string;
      /** @description Private key in string form, if walletPassphrase is not available */
      xprv?: string;
      otp?: components['schemas']['Otp'];
    };
    ExpressSendCoinsRequest: {
      address?: components['schemas']['AddressString'];
      amount?: components['schemas']['IntegerOrIntegerString'];
      /** @description Passphrase to decrypt the user key on the wallet */
      walletPassphrase?: string;
      /** @description Optional, private key in string form, if "walletPassphrase" is not available or encrypted private key is not stored by BitGo. */
      prv?: string;
    } & components['schemas']['BuildParams'] & {
        /** @description (ETH only) Optional data to pass to the transaction */
        data?: string;
        /** @description (ETH, AVAXC and POLYGON) Set to true if funds to destination need to come from single sig address */
        hop?: boolean;
      };
    ExpressSendCoinsResponse: {
      transfer?: components['schemas']['Transfer'];
      /** @description Unique transaction identifier */
      txid?: string;
      tx?: string | components['schemas']['PsbtHex'];
      /**
       * @description Transfer status
       * @enum {string}
       */
      status?: 'signed' | 'signed (suppressed)' | 'pendingApproval';
    };
    ExpressSendConsolidationResponse: {
      /** @description An Array of TransactionRequest or Transfers. */
      success: (
        | components['schemas']['TransactionRequestLite']
        | components['schemas']['TransactionRequestFull']
        | components['schemas']['Transfer']
      )[];
      /** @description An Array of Error messages. */
      failure: string[];
    };
    ExpressSendManyRequest: {
      /** @description A list of recipient addresses and amounts. Must be present but empty for CPFP transactions. */
      recipients?: {
        address?: components['schemas']['AddressString'];
        amount?: components['schemas']['IntegerOrIntegerString'];
        tokenData?: components['schemas']['RecipientTokenData'];
      }[];
      /** @description Two factor auth code to enable sending the transaction. Not necessary if using a long lived access token within the spending limit. */
      otp?: string;
      /**
       * @description Passphrase to decrypt the user key on the wallet.
       * Required if External Signer is not used to sign the transactions.
       */
      walletPassphrase?: string;
      /**
       * @description The un-encrypted user private key in string form.
       * If the key is a JSON object it must be stringified.
       * Required if "walletPassphrase" is not available or encrypted private key is not stored by BitGo.
       */
      prv?: string;
    } & components['schemas']['BuildParams'] & {
        /** @description (ETH only) Optional data to pass to the transaction */
        data?: string;
      };
    ExpressShareWalletRequest: {
      /**
       * @description Email address of the user being invited
       * @example foo@bar.com
       */
      email: string;
      /** @example spend,view */
      permissions: string;
      /** @description Wallet passphrase of the user sharing the wallet */
      walletPassphrase?: string;
      /** @description User readable message to display to the share recipient */
      message?: string;
      /** @description Flag for reinviting a user to the wallet <br/> This is required if the invitee has already been invited to the wallet, but has changed their password and needs a new invite */
      reshare?: boolean;
      /** @description If true, skips using a shared key (for when the wallet is shared without spend permission). */
      skipKeychain?: boolean;
      /** @description Flag for disabling invite notification email */
      disableEmail?: boolean;
    };
    ExpressSignTssTx: components['schemas']['TransactionRequestLite'] | components['schemas']['ExpressSignTssTxFull'];
    ExpressSignTssTxFull: {
      /**
       * @description The transaction request ID.
       * This is the ID returned by the Create Transaction Request API.
       */
      txRequestId: string;
      /**
       * @description The wallet passphrase.
       * Required if External Signer is not used to sign the transactions.
       */
      walletPassprase?: string;
      /**
       * @description The un-encrypted user private key of the wallet.
       * If the key is a JSON object it must be stringified.
       * Required for Self-Managed Cold wallets when External Signer is not used to sign the transactions.
       */
      prv?: string;
    };
    ExpressSignTxRequest: {
      /**
       * @description user private key
       * @example xprv9s21ZrQH143K3xQwj4yx3fHjDieEdqFDweBvFxn28qGvfQGvweUWuUuDRpepDu6opq3jiWHU9h3yYTKk5vvu4ykRuGA4i4Kz1vmFMPLTsoC
       */
      prv?: string;
      txPrebuild?: {
        wallet?: components['schemas']['Id'];
        /** @description Serialized transaction hex */
        txHex?: string;
        /** @description Serialized transaction base64 (applies to XLM only) The request must include this or a txHex */
        txBase64?: string;
        txInfo?: components['schemas']['UtxoTxInfo'] | components['schemas']['XlmTxInfo'];
        feeInfo?: {
          /**
           * @description Estimated size of the transaction in bytes
           * @example 776
           */
          size?: number;
          /**
           * @description Estimated fee in base units for the transaction
           * @example 38800
           */
          fee?: number;
          feeRate?: components['schemas']['IntegerOrString'];
          /**
           * @description BitGo fee of the transaction (in base units)
           * @example 0
           */
          payGoFee?: number;
          /**
           * @description BitGo fee of the transaction (in base units) represented as a String
           * @example 0
           */
          payGoFeeString?: number;
        };
      };
      /** @description Should be set to true if you are signing the second time, attaching the final signature. Default to false. */
      isLastSignature?: boolean;
      /**
       * @description Public Keys (user, backup, bitgo) for the wallet (UTXO coins only)
       * @example [
       *   "string",
       *   "string",
       *   "string"
       * ]
       */
      pubs?: string[];
    };
    ExpressSignTxResponse: {
      txInfo?: OneOf<
        [
          {
            txHex?: components['schemas']['TxHex'];
          },
          {
            halfSigned?: {
              txBase64?: components['schemas']['TxBase64'];
            };
          }
        ]
      >;
    };
    ExpressSweepRequest: {
      /** @description The destination address for the sweep transaction */
      address?: string;
      /** @description Passphrase to decrypt the user key on the wallet */
      walletPassphrase?: string;
      /** @description Private key in string form, if walletPassphrase is not available */
      xprv?: string;
      /** @description Two factor auth code to enable sending the transaction */
      otp?: string;
      /** @description Number of blocks to wait to confirm the transaction */
      feeTxConfirmTarget?: string;
      feeRate?: components['schemas']['IntegerOrString'];
      maxFeeRate?: components['schemas']['IntegerOrIntegerString'];
      /**
       * @description Use "allowPartialSweep: true" to sweep part of a wallet when there are too many unspents to empty the wallet in a
       * single transaction. While the expected outcome of a single sweep call would usually be an empty wallet, using the
       * allowPartialSweep option may leave some funds in the wallet. Making repeated calls with the allowPartialSweep
       * option allows emptying wallets with many unspents without consolidating first.
       *
       * @default false
       */
      allowPartialSweep?: boolean;
      txFormat?: components['schemas']['UtxoTransactionFormat'];
    };
    ExpressVerifyCoinAddressRequest: {
      address?: string;
    };
    ExpressWallet: {
      id?: components['schemas']['Id'];
      /** @description Ids of users with access to the wallet */
      users?: {
        user?: components['schemas']['Id'];
        /** @description Array of permissions for the user */
        permissions?: string[];
      }[];
      /**
       * @description Name of the blockchain the wallet is on
       * @example tbtc
       */
      coin?: string;
      /**
       * @description Name the user assigned to the wallet
       * @example My TBTC Wallet
       */
      label?: string;
      /**
       * @description Number of signatures required for the wallet to send
       * @example 2
       */
      m?: number;
      /**
       * @description Number of signers on the wallet
       * @example 3
       */
      n?: number;
      /** @description Ids of wallet keys */
      keys?: components['schemas']['Id'][];
      /** @description Signatures for the backup and BitGo public keys signed by the user key */
      keySignatures?: {
        /**
         * @description Signature for the backup pub
         * @example 1fe81d0c91457d89993b01475bfb9e5809067ae046926faeab6e63beea009d8dd460387e0c3843034570798a9c2bcc1dbbea2988ee5a36979e0bbe6e02f7840af2
         */
        backupPub?: string;
        /**
         * @description Signature for the BitGo pub
         * @example 209d0e9a6d4352b66fae0a35ce62c1059bcc4db9e2883abc4f1b3d20481c5cebb7299c581efd9e0151abaf2496da7c6d75d276de36ed3de37c94e9cc5a2ea77e59
         */
        bitgoPub?: string;
      };
      /** @description Tags set on the wallet */
      tags?: components['schemas']['Id'][];
      receiveAddress?: components['schemas']['Address'];
      /**
       * @description Wallet balance as number
       * @example 0
       */
      balance?: number;
      /**
       * @description Wallet balance as string
       * @example 0
       */
      balanceString?: string;
      /**
       * @description Confirmed wallet balance as number
       * @example 0
       */
      confirmedBalance?: number;
      /**
       * @description Confirmed wallet balance as string
       * @example 0
       */
      confirmedBalanceString?: string;
      /**
       * @description Spendable wallet balance as number
       * @example 0
       */
      spendableBalance?: number;
      /**
       * @description Spendable wallet balance as string
       * @example 0
       */
      spendableBalanceString?: string;
      /**
       * @description Flag which indicates the wallet has been deleted
       * @example false
       */
      deleted?: boolean;
      /**
       * @description Flag for identifying cold wallets
       * @example false
       */
      isCold?: boolean;
      /**
       * @description Freeze state (used to stop the wallet from spending)
       * @example {}
       */
      freeze?: {
        /**
         * Format: date-time
         * @description Time when the wallet becomes frozen
         */
        time?: string;
        /**
         * Format: date-time
         * @description Time when the wallet is unfrozen and allowed to spend
         */
        expires?: string;
      };
      /**
       * @description Flag for disabling wallet transaction notifications
       * @example false
       */
      disableTransactionNotifications?: boolean;
      /**
       * @description Admin data (wallet policies)
       * @example {}
       */
      admin?: Record<string, never>;
      /**
       * @description Number of admin approvals required for an action to fire
       * @example 1
       */
      approvalsRequired?: number;
      /**
       * @description Pending approvals on the wallet
       * @example []
       */
      pendingApprovals?: components['schemas']['PendingApproval'][];
      /**
       * @description Flag for allowing signing with backup key
       * @example false
       */
      allowBackupKeySigning?: boolean;
      /** @description Coin-specific data */
      coinSpecific?: Record<string, never>;
      clientFlags?: string[];
      /** @description Flag indicating whether this wallet's user key is recoverable with the passphrase held by the user. */
      recoverable?: boolean;
      /**
       * Format: date-time
       * @description Time when this wallet was created
       */
      startDate?: string;
      /**
       * @description Flag indicating that this wallet is large (more than 100,000 addresses). If this is set, some APIs may omit
       * properties which are expensive to calculate for wallets with many addresses (for example, the total address
       * counts returned by the List Addresses API).
       */
      hasLargeNumberOfAddresses?: boolean;
      /** @description Custom configuration options for this wallet */
      config?: Record<string, never>;
    };
    ExpressWalletRecoverTokenRequest: {
      /** @description Contract address of the unsupported token */
      tokenContractAddress?: string;
      /** @description Destination address recovered tokens should be sent to */
      recipient?: string;
      /** @description Wallet passphrase */
      walletPassphrase?: string;
      /** @description User private key */
      prv?: string;
    };
    ExpressWalletRecoverTokenResponse: {
      halfSigned?: {
        /** @example 1101 */
        contractSequenceId?: number;
        /** @example 1550088020 */
        expireTime?: number;
        /** @example 500000 */
        gasLimit?: number;
        /** @example 20000000000 */
        gasPrice?: number;
        /** @example 9.44792020725999e+76 */
        operationHash?: string;
        recipient?: {
          /** @example 4.7261295088313645e+47 */
          address?: string;
          /** @example 2400 */
          amount?: string;
        };
        /** @example 1.9519588812712557e+156 */
        signature?: string;
        /** @example 3.8941146273864216e+46 */
        tokenContractAddress?: string;
        walletId?: components['schemas']['Id'];
      };
    };
    ExpressWalletSignTxRequest: {
      /** @description The user's keychain object with an "encryptedPrv" property. The "walletPassphrase" parameter is required when using "keychain". Any request must include either "keychain" or "prv". */
      keychain?: {
        /** @description Encrypted user private key */
        encryptedPrv?: string;
      };
      /**
       * @description User private key
       *
       * Note: The request must include either "prv" or "keychain"
       *
       * @example xprv9s21ZrQH143K3xQwj4yx3fHjDieEdqFDweBvFxn28qGvfQGvweUWuUuDRpepDu6opq3jiWHU9h3yYTKk5vvu4ykRuGA4i4Kz1vmFMPLTsoC
       */
      prv?: string;
      /** @description The transaction description object as created by 'Build Transaction' */
      txPrebuild?: {
        wallet?: components['schemas']['Id'];
        /** @description Serialized transaction hex */
        txHex?: string;
        /** @description Serialized transaction base64 (applies to XLM only). <br/> The request must include this or a txHex */
        txBase64?: string;
        txInfo?: components['schemas']['UtxoTxInfo'] | components['schemas']['XlmTxInfo'];
        feeInfo?: components['schemas']['UtxoFeeInfo'] | components['schemas']['XlmFeeInfo'];
      };
      /** @description A seed used to create a deterministic BIP-32 path which is then used to derive a private key. This is useful when one wants to create multiple BitGo cold wallets but only protect a single master private key. Using the seed one can create a child key for a specific wallet, for instance an Ethereum wallet could use the "eth" seed while an XRP wallet could use "xrp" as a seed. Both of these child keys would be derived from a single master key and so only the master key needs to be stored and protected. */
      coldDerivationSeed?: string;
      /** @description Passphrase to decrypt the user keychain. "walletPassphrase" is a required parameter when the parameter "keychain" is provided. */
      walletPassphrase?: string;
      /** @description Array of objects describing the recipients. See buildTransaction for more detail. Required on ETH. */
      recipients?: Record<string, never>[];
    };
    FederationError: {
      /** @description HTTP status code */
      status: number;
      /** @description Human-readable error message */
      detail: string;
      /** @description Human-readable error message */
      error: string;
      /** @description Error code */
      name: string;
      /** @description Client request id */
      requestId: string;
    };
    FeeAddressBalanceResponse: {
      /** @description Total balance in enterprise gas tank. */
      balance?: string;
    };
    FeeOption: {
      /** @enum {string} */
      unit?: 'baseUnit' | 'cpu' | 'ram';
      /** @enum {string} */
      formula?: 'fixed' | 'feeRate' | 'perKB' | 'custom' | 'perVKB';
      /** @enum {string} */
      feeType?: 'base' | 'max' | 'tip';
      gasLimit?: number;
      gasPrice?: number;
    };
    /**
     * FeeRate
     * @description Fee rates set for a given account
     */
    FeeRates: {
      /**
       * @description Fee rate for settlements. This value is specified in basis points (hundredths of a percent)
       * @example 5
       */
      settlement?: number;
    };
    /** @description Fee parameters used to build transaction (depends on coin type) */
    FeesUsed: {
      maxFeePerGas?: number;
      maxPriorityFeePerGas?: number;
      gasPrice?: number;
      gasLimit?: number;
    };
    FiatIMSTransaction: {
      /** @example 1 */
      blockHeight?: number;
      /** @example null */
      confirmations?: number;
      /**
       * Format: date-time
       * @example 2018-10-26T20:20:55.000Z
       */
      date?: string;
      entries?: {
        address?: string;
        value?: number;
        valueString?: string;
        wallet?: string;
      }[];
      /** @example 1000 */
      fee?: number;
      /** @example 1000 */
      feeString?: string;
      inputs?: Record<string, never>;
      outputs?: Record<string, never>;
      isDeposit?: boolean;
      /** @example txid123 */
      id?: string;
      /** @example txid123 */
      normalizedTxHash?: string;
    };
    FiatTransaction: {
      /** @example 50100 */
      amount?: number;
      /** @example 23 */
      blockHeight?: number;
      type?: components['schemas']['FiatTransactionTypeEnum'];
      /** @example 4325436435 */
      fromAccountNumber?: string;
      /** @example ABC12345 */
      fromBankIdentifier?: string;
      /** @example 4264325434 */
      toAccountNumber?: string;
      /** @example BCD22345 */
      toBankIdentifier?: string;
      /** @example 1200 */
      fee?: number;
      /** @example ASEDS */
      memoId?: string;
      /** @example transactiontxidlonghash */
      txid?: string;
      /**
       * @description transaction is a deposit/withdraw to BitGo
       * @example false
       */
      isDeposit?: boolean;
      /** Format: date-time */
      date?: string;
      /** @description transaction notes from BitGo partner bank */
      description?: string;
      /**
       * Format: date-time
       * @description datetime when fiat indexer first "see" transaction
       */
      createdAt?: string;
      state?: components['schemas']['FiatTransactionStateEnum'];
      /** @description normally fiat indexer record new coming transaction first to das and then platform */
      recorded?: components['schemas']['FiatTransactionRecordStateEnum'];
    };
    /** @enum {unknown} */
    FiatTransactionRecordStateEnum: 'none' | 'das' | 'platform';
    /** @enum {unknown} */
    FiatTransactionStateEnum: 'complete' | 'incomplete';
    /** @enum {unknown} */
    FiatTransactionTypeEnum: 'domestic' | 'international' | 'sen' | 'internal' | 'onlineBanking';
    /**
     * @description transaction unique id that generated by bank, identifier of the transaction
     * @example eyJBY2NvdW50TnVtYmVyIjoiNTA5MDAxMDU0NiIsIlRyYW5zYWN0aW9uRGF0ZSI6IjIwMTkwMTEwIiwiVHJhbnNhY3Rpb25BbW91bnQiOiIxMC4wMCIsIlRyYW5zYWN0aW9uQ29kZSI6IjkwNzMiLCJEZXNjcmlwdGlvbiI6Ik9VVEdPSU5HIFdJUkUgRkVFLVAyMDE5MDExMDAwMzMxODEiLCJFeHRlbmRlZERlc2NyaXB0aW9uTGluZTIiOiIifQ
     */
    FiatTxId: string;
    FillNonceIntent: components['schemas']['BaseIntent'] & {
      /** @enum {string} */
      intentType?: 'fillNonce';
      nonce: string;
    };
    FlushCoinRequest: {
      /** @description The wallet ID of the base wallet */
      walletId: string;
      /** @description The forwarder addresses to retrieve tokens from */
      addresses: string[];
      /** @description The fee address nonce for evmBasedCrossChainFlushing */
      nonce?: number;
    };
    FlushCoinResponse: {
      /** @description The forwarder address from which flushing is performed */
      address?: string;
      /** @description The transaction id of the flushing transaction */
      txid?: string;
    }[];
    FlushTokenRequest: {
      /** @description The wallet ID of the base wallet */
      walletId: string;
      /** @description The forwarder addresses to retrieve tokens from */
      addresses: string[];
      /** @description The address that hosts the token contract */
      tokenAddress: string;
      /** @description The fee address nonce for evmBasedCrossChainFlushing */
      nonce?: number;
    };
    FlushTokenResponse: {
      /** @description The transaction ids of the flushing transaction */
      txids?: string[];
    };
    /**
     * @description A report format
     * @enum {string}
     */
    Format: 'csv';
    ForwardTokenRequest: {
      /** @description Name of token that needs to be forwarded from the address */
      tokenName?: string;
      /** @description Default: false Use forceFlush: true to flush the tokens from forwarder irrespective of the balance of the forwarders */
      forceFlush?: boolean;
      /** @description Explicit gas price to use when forwarding token from the forwarder contract (ETH and Celo only). If not given, defaults to the current estimated network gas price. */
      gasPrice?: number;
      /** @description Specify eip1559 fee parameters in token forwarding transaction. */
      eip1559?: {
        /** @description Max priority tip price for EIP1559 transactions. Only for ETH and ERC20 tokens. */
        maxPriorityFeePerGas: number;
        /** @description Max total gasPrice for EIP1559 transactions. Only for ETH and ERC20 tokens. */
        maxFeePerGas: number;
      };
    };
    Freeze: {
      /**
       * Format: date-time
       * @description When the freeze started
       */
      time?: string;
      /**
       * Format: date-time
       * @description When the freeze will end
       */
      expires?: string;
    };
    FreezeEnterprise: {
      /**
       * @description seconds to freeze the enterprise for
       * @default 3600
       */
      duration?: number;
    };
    FrontTransfer: {
      /** @description Public ID of the ofc transfer creator (Only returned for Backing wallet transactions) */
      ofcCreator?: string;
      /** @description Username of the ofc transfer creator (Only returned for Backing wallet transactions) */
      ofcCreatorUserName?: string;
      /** @description Public ID of the enterprise associated with the ofc transfer (Only returned for Backing wallet transactions) */
      ofcEnterprise?: string;
      /** @description Name of the enterprise associated with the ofc transfer (Only returned for Backing wallet transactions) */
      ofcEnterpriseName?: string;
      /** @description Public ID of the wallet associated with the ofc transfer (Only returned for Backing wallet transactions) */
      ofcWallet?: string;
    };
    FundForwardersRequest: {
      forwarders?: {
        /** @description Address of the forwarder to send funds to. */
        forwarderAddress: string;
        /** @description Amount to send to the forwarder. If not given, defaults to sending an estimate of the amount needed for a fund recovery. */
        amount?: string;
      }[];
    };
    FundForwardersResponse: {
      failed?: {
        /** @description Failed forwarder address. */
        forwarderAddress?: string;
        errMsg?: string;
      }[];
      successTxIds?: {
        /** @description Successful forwarder address. */
        forwarderAddress?: string;
        /** @description On-chain transaction ID. */
        txId?: string;
      }[];
    };
    GenerateReferralCodeHttpRequestBody: {
      clientName?: components['schemas']['ClientName'];
    };
    /**
     * @example {
     *   "name": "Jane Doe",
     *   "street": "1",
     *   "street2": "Wall Street",
     *   "suite": "3",
     *   "city": "New York",
     *   "state": "NY",
     *   "postalCode": "10005",
     *   "country": "USA"
     * }
     */
    GeographicAddress: {
      /** @description Legal name of the enterprise, not neccessarily the enterprise name */
      name?: string;
      /** @description Address line */
      street?: string;
      /** @description Optional 2nd address line */
      street2?: string | null;
      /** @description Optional suite number */
      suite?: string;
      /** @description City name */
      city?: string;
      /** @description State or region */
      state?: string;
      /** @description Postcal code */
      postalCode?: string;
      /** @description ISO 3166-1 Alpha-3 country code */
      country?: string;
    };
    /** @description Proof of address ownership */
    GetAddressProofResponse: {
      /** @description The address */
      address?: string;
      /** @description The coin name ('BITCOIN' or 'ETHEREUM') */
      chain?: string;
      /** @description True if this is an IOU */
      iou?: boolean;
      /** @description The proof signature */
      signature?: string;
      /** @description A 64-character random string used to generate the proof */
      prefix?: string;
      /** @description The type of proof */
      proofType?: string;
      auxProofData?: {
        /** @description The type of data */
        type?: string;
        data?: {
          /** @description The REDEEM_SCRIPT or WITNESS_SCRIPT associated with the address */
          script?: string;
        };
      }[];
    };
    GetAddressesResponse: {
      coin?: string;
      /**
       * @description Total number of addresses which match the provided query parameters.
       * **Note:** for wallets with many addresses (100,000 or more), this property may be omitted for performance reasons.
       * If the total address count is needed for a large wallet, the "includeTotalAddressCount" query parameter can be used to
       * force an address count to be returned with the initial page of addresses.
       */
      totalAddressCount?: number;
      /**
       * @description Total number of addresses pending on-chain initialization on this wallet
       * **Note:** for wallets with many addresses (100,000 or more), this property may be omitted for performance reasons.
       * If the pending address count is needed for a large wallet, the "includeTotalAddressCount" query parameter can be
       * used to force an address count to be returned with the initial page of addresses.
       */
      pendingAddressCount?: number;
      addresses?: components['schemas']['Address'][];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
    };
    GetForwardersBalanceResponse: {
      /** @description The forwarder address. */
      address?: string;
      /** @description Current balance of the forwarder address. */
      balance?: string;
    }[];
    /** GetInquiryListItem */
    GetInquiryListItem: {
      inquiryId: string;
      /** @enum {string} */
      inquiryType: 'developerIndividual' | 'developerInstitution' | 'starterSignup' | 'kyc';
      referenceId: string;
      /** @enum {string} */
      status: 'approved' | 'completed' | 'created' | 'declined' | 'expired' | 'failed' | 'needs_review' | 'pending';
      id?: string;
      createdAt?: string;
      updatedAt?: string;
      kits?: ('custody' | 'liquidity' | 'default' | 'wallet' | 'cryptoCompare')[];
      enterpriseId?: string;
      inquiryAssigneeId?: string;
    };
    /** GetInquiryListResponse */
    GetInquiryListResponse: {
      inquiries: components['schemas']['GetInquiryListItem'][];
    };
    GetPotentialStuckTxsResponse: {
      /** @description The nonce value of the potentially stuck transaction. */
      nonce?: components['schemas']['IntegerString'];
      /**
       * @description The reason this transaction is potentially stuck.
       * @enum {string}
       */
      cause: 'nonce hole' | 'fee acceleration' | 'locked nonce' | 'earlier problem nonce' | 'other';
      /** @description Fee required to remediate a stuck transaction when the cause is 'fee acceleration'. */
      gasAccelerationFee?: {
        gasPrice?: components['schemas']['IntegerString'];
        maxFeePerGas?: components['schemas']['IntegerString'];
        maxPriorityFeePerGas?: components['schemas']['IntegerString'];
      };
      /** @description Possible steps to remediate the stuck transaction. */
      message: string;
      txHex?: components['schemas']['TxHex'];
      txId?: components['schemas']['TxId'];
      transferIds?: components['schemas']['Id'][];
      /** @description True, if manual user action is disabled on this stuck transaction */
      userActionDisabled?: boolean;
      sendTransfer?: components['schemas']['Transfer'];
    }[];
    GetSequenceIdsResponse: {
      sequenceIds: {
        txid?: components['schemas']['TxId'];
        /** @description The contract sequence id of the transaction */
        contractSequenceId?: number;
      }[];
    };
    GetSingleAddressResponse: components['schemas']['Address'] & {
      balance?: {
        /**
         * Format: date-time
         * @description The last time a transaction affected the balance of this address
         */
        updated?: string;
        /** @description The cleared balance */
        balance?: number;
        /** @description The total amount received on this address (in the chain's base unit) */
        totalReceived?: number;
        /** @description The total amount send from this address (in the chain's base unit) */
        totalSent?: number;
      };
    };
    GetTSSPubkeyByCoin: {
      /** @description Enterprise id for the intended operation (if present in the request) */
      enterpriseId?: string;
      /** @description Name of the key, used for simple identification. Matches TSS key namess in client constants */
      name: string;
      /** @description BitGo TSS public key */
      publicKey: string;
    };
    GetTransactionRequestsAwaitingSignatureResponse: {
      txRequests: components['schemas']['TransactionRequestFull'][];
      bitgoRangeProofChallenge?: components['schemas']['RangeProofChallengeWithProofs'];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
      totalCount?: number;
    };
    GetTransactionRequestsAwaitingTrustSignatureResponse: {
      txRequests: (components['schemas']['TransactionRequest'] & {
        walletLabel?: string;
        walletCoin?: string;
        enterpriseName?: string;
      })[];
      bitgoRangeProofChallenge?: components['schemas']['RangeProofChallengeWithProofs'];
      errors: {
        enterpriseId?: string;
        enterpriseName?: string;
        walletId?: string;
        walletLabel?: string;
        coin?: string;
        pendingApprovalId?: string;
        transactions?: components['schemas']['Transaction'][];
      }[];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
      totalCount?: number;
    };
    GetTransactionRequestsResponse: {
      txRequests: components['schemas']['TransactionRequest'][];
      nextBatchPrevId?: string;
    };
    GetV1SingleAddressResponse: {
      address?: components['schemas']['AddressString'];
      chain?: components['schemas']['Chain'];
      index?: number;
      /** @description The wallet which contains this address */
      wallet?: components['schemas']['Id'];
      /** @description The total amount sent from this address */
      sent?: number;
      /** @description The total amount received on this address */
      received?: number;
      /** @description The total number of transactions */
      txCount?: number;
      /** @description The cleared balance */
      balance?: number;
    };
    /** @description Requirements for providing group approval. */
    GroupApprovalRequirement: {
      /**
       * @description Use 'and' if all items are required. The 'or' operator is not supported yet.
       * @enum {string}
       */
      operator: 'and';
      /** @description Requirements. */
      items: components['schemas']['GroupApprovalRequirementItem'][];
    };
    /** @description Requirements for providing group approval. */
    GroupApprovalRequirementItem: {
      /** @enum {string} */
      type: 'user' | 'group';
      /** @description user id or group id */
      id: unknown;
      /**
       * @description If this is a group requirement, specify how many users of the group should approve. 0 if all users are required.
       * @example 1
       */
      minimumApprovals?: number;
    };
    /**
     * @example {
     *   "time": "2014-11-07T22:19:28.578Z",
     *   "open": 576.0590066,
     *   "high": 576.0590066,
     *   "low": 575.8330204,
     *   "close": 575.978887,
     *   "base_volume": 296.23,
     *   "quote_volume": 170627.62385
     * }
     */
    HistoricalPrice: {
      /** Format: date-time */
      time: string;
      /** Format: float */
      open: number;
      /** Format: float */
      high: number;
      /** Format: float */
      low: number;
      /** Format: float */
      close: number;
      /** Format: float */
      base_volume: number;
      /** Format: float */
      quote_volume: number;
    };
    /**
     * @example {
     *   "data": {
     *     "prices": {
     *       "BTC-USD": [
     *         {
     *           "time": "2014-11-07T22:19:28.578Z",
     *           "open": 576.0590066,
     *           "high": 576.0590066,
     *           "low": 575.8330204,
     *           "close": 575.978887,
     *           "base_volume": 296.23,
     *           "quote_volume": 170627.62385
     *         }
     *       ]
     *     },
     *     "nextBatchPrevId": "a0dbb6aad06d9a37c9882231d8dc32ef"
     *   }
     * }
     */
    HistoricalPriceResult: {
      data?: {
        prices?: {
          [key: string]: components['schemas']['HistoricalPrice'][];
        };
        nextBatchPrevId?: string;
      };
    };
    HoldingsReport: {
      id?: components['schemas']['Id'];
      /**
       * @description Type of report
       * @enum {string}
       */
      type?: 'holdings' | 'transactions' | 'trades';
      /**
       * @description Format of report
       * @enum {string}
       */
      format?: 'pdf' | 'csv';
      /**
       * @description Status of report
       * @enum {string}
       */
      status?: 'pending' | 'processing' | 'completed' | 'failed';
      /**
       * Format: date-time
       * @description Date report was created
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description Date report was completed
       */
      completedAt?: string;
      /** @description Name of the report document */
      documentName?: string;
      /** @description ID of the user who requested the report */
      user?: components['schemas']['Id'];
      holdings?: {
        /** @description ID of the enterprise */
        enterprise: components['schemas']['Id'];
        /**
         * Format: date-time
         * @description Date of the snapshot
         */
        snapshotDate: string;
        byWallet?: boolean;
      };
    };
    HopParams: {
      paymentId?: string;
      userReqSig?: string;
      gasPriceMax?: number;
    };
    IMSTx: {
      id?: components['schemas']['TxId'];
      normalizedTxHash?: components['schemas']['TxId'];
      /** @example 2017-08-10T18:02:35.000Z */
      date?: string;
      blockHash?: components['schemas']['BlockHash'];
      /** @example 10 */
      blockHeight?: number;
      /**
       * @description This is a computed field. E.g. "head - tx.blockHeight + 1"
       * @example 6
       */
      confirmations?: number;
      /**
       * @description fee paid by the transaction as a Number (Deprecated)
       * @example 1260
       */
      fee?: number;
      /**
       * @description fee paid by the transaction as a numeric string
       * @example 1260
       */
      feeString?: number;
      /**
       * @description the data size of the transaction in bytes
       * @example 492
       */
      size?: number;
      inputs?: components['schemas']['IMSTxItem'][];
      outputs?: components['schemas']['IMSTxItem'][];
      entries?: components['schemas']['IMSTxItem'][];
      /** @description (ETH) sequence ID on this transaction */
      nonce?: string;
      /** @description (ETH) If true, the transaction is an ERC20 token flush transaction from a forwarder contract to a wallet contract */
      isTokenFlushTx?: boolean;
      /** @description (ETH, AVAXC and POLYGON) If this exists, it is the height at which this tx's corresponding hop transaction was confirmed */
      hopConfirmationHeight?: number;
      /** @description (ALGO) Transaction free form field to send extra data to the network */
      data?: string;
      /**
       * @description (ALGO) format the data is encoded with
       * @example base64
       */
      dataFormat?: string;
      /** @description (DASH) Did this TX used Dash Instant Send feature? Unrelated to the v1 BitGo-Instant feature that was never ported to v2. */
      instant?: boolean;
      /** @description (XLM/XRP) sequence ID on this transaction */
      sequenceId?: number;
      /** @description (XLM) sequence ID on this transaction as string */
      sequenceIdString?: string;
      /** @description (XRP) optional destination tag for the txn */
      destinationTag?: string;
    };
    IMSTxItem: {
      /**
       * @description (ETH and OFC only) The asset that this entry is describing.
       * @example terc
       */
      token?: string;
      /**
       * @description (ETH only) The hash identifying the token
       * @example 4.884479154412911e+47
       */
      tokenContractHash?: string;
      /** @description (ETH only) Returns true if this token is some unknown contract */
      isUnsupportedToken?: boolean;
      /** @example QfHdUgHtAokPqANYkUnsLcQDFBFbuJML3j */
      address: string;
      /** @example 59790979e8df24b807efbe58c261aa60 */
      wallet?: string;
      /**
       * @description Deprecated. Amount in base units changed for this address. Use valueString instead.
       * @example 1000
       */
      value?: number;
      /**
       * @description Amount in base units changed for this address.
       * @example 1000
       */
      valueString: string;
      /** @description (ALGO only) Whether or not this entry represents a staking reward */
      isReward?: boolean;
      /** @description (ALGO/EOS) */
      type?: string;
      /** @description (EOS) */
      memo?: string;
      /** @description (XLM) */
      seqIdString?: string;
      /** @description (OFC only) Indicate that this entry was a fee charged and collected on chain by BitGo */
      isBitGoFee?: boolean;
    };
    IMSTxRequest: {
      /** @description Return only transactions with these txids */
      ids?: components['schemas']['TxId'][];
      /** @description List of block ids to filter by */
      blocks?: components['schemas']['BlockHash'][];
      /** @description Filter by transactions that include this address */
      address?: string;
      wallet?: components['schemas']['WalletId'];
      /** @description Filter by block height */
      height?: number;
      /** @description Filter where block height is at least this amount */
      minHeight?: number;
      /** @description Filter where block height is at most this amount */
      maxHeight?: number;
      /** @description For pagination. Only return results with lower id. */
      prevId?: string;
      /** @description If true, return only the count of matching transactions. */
      count?: boolean;
      /** @description Number of transactions to return (max value is 2000) */
      limit?: number;
      fields?: (
        | 'id'
        | 'nHash'
        | 'date'
        | 'hex'
        | 'fromWallet'
        | 'blockHash'
        | 'blockHeight'
        | 'blockPosition'
        | 'fee'
        | 'size'
        | 'inputs'
        | 'inputIds'
        | 'outputs'
        | 'failed'
      )[];
      /**
       * @description (ETH only) Returns only entries for given token name
       * @example terc
       */
      token?: string;
      /** @description (ETH only) Returns entries for all supported ERC20 tokens */
      allTokens?: boolean;
    };
    /** @example 59cd72485007a239fb00282ed480da1f */
    Id: string;
    /**
     * @example [
     *   "585951a5df8380e0e3063e9f",
     *   "585951a5df8380e0e304a553"
     * ]
     */
    IdArray: components['schemas']['Id'][];
    /** @description Key ID or pub */
    IdOrPub: components['schemas']['Id'] | components['schemas']['Pub'];
    /** @description general identifier, non-empty string */
    IdString: string;
    IndexerNotificationResponse: {
      processed?: number;
      uploadedTxs?: number;
      invalidTxs?: number;
    };
    InitiateTokenSupportParams: {
      /**
       * @description Allowed transaction types for Token Support Transactions.
       *
       * @enum {string}
       */
      type: 'enabletoken' | 'disabletoken';
      feeRate?: components['schemas']['IntegerOrIntegerString'];
      /** @description This address must be specified for disabling token transactions. This address is where all remaining funds will be transferred after disabling a token in an account. */
      closeRemainderTo?: string;
      /** @description A list of recipient addresses and amounts. */
      recipients?: {
        amount?: components['schemas']['IntegerOrIntegerString'];
        address?: components['schemas']['AddressString'];
      }[];
    };
    InitiateTrustlineParams: {
      /** @description The memo contains optional extra information that can also be used to identify payments in Stellar. */
      memo?: {
        type?: string;
        value?: string;
      };
      /** @description Optional metadata (only persisted in BitGo) to be applied to the transaction. Use this to add transaction-specific information such as the transaction's purpose or another identifier that you want to reference later. The value is shown in the UI in the transfer listing page. */
      comment?: string;
      /** @description List of trustlines to manage on the account. */
      trustlines: components['schemas']['Trustline'][];
    };
    Inscription: {
      id?: components['schemas']['InscriptionId'];
      /**
       * @description Type of inscription.
       * @enum {string}
       */
      contentType?:
        | 'application/json'
        | 'application/pdf'
        | 'application/pgp-signature'
        | 'application/yaml'
        | 'audio/flac'
        | 'audio/mpeg'
        | 'audio/wav'
        | 'image/apng'
        | 'image/avif'
        | 'image/gif'
        | 'image/jpeg'
        | 'image/png'
        | 'image/svg+xml'
        | 'image/webp'
        | 'model/gltf-binary'
        | 'model/stl'
        | 'text/html'
        | 'text/plain'
        | 'video/mp4'
        | 'video/webm';
      /**
       * @description Number of bytes the inscription is.
       * @example 530
       */
      contentLength?: number;
      /**
       * @description Exact satoshi on the unspent where the inscription is.
       * Has the format \<txid\>:\<vin\>:\<sat\>
       * @example 003f688cc349f1fca8ac5ffa21671ca911b6ef351085c60733ed8c2ebf162cb8:2:0
       */
      satpoint?: string;
    };
    /**
     * @description The ID of the inscription in the form \<txid\>i\<vin\>
     * @example 003f688cc349f1fca8ac5ffa21671ca911b6ef351085c60733ed8c2ebf162cb8i2
     */
    InscriptionId: string;
    InscriptionResponse: {
      unspentId?: components['schemas']['UnspentId'];
      inscriptions?: components['schemas']['Inscription'][];
    };
    IntegerOrIntegerString: string | number;
    IntegerOrString: string | number;
    /** @example 2000000 */
    IntegerString: string;
    InternalAddTotpDeviceRequest: {
      email: string;
      hmac: string;
      key: string;
      label: string;
      otp: string;
    };
    InternalCoin: {
      fullName?: string;
      name?: string;
      baseUnit?: string;
      kind?: string;
      family?: string;
      isToken?: boolean;
      features?: string[];
      network?: {
        name?: string;
        type?: string;
        family?: string;
        explorerUrl?: string;
      };
      decimalPlaces?: number;
      asset?: string;
      primaryKeyCurve?: string;
      prefix?: string;
      suffix?: string;
      alias?: string;
    };
    InternalCoinsResponse: {
      coins: components['schemas']['InternalCoin'][];
    };
    InternalCreateUserRequest: {
      /** @description The email address of the new user to be created. */
      email: string;
      /** @description The first name of the user to be created. */
      firstName: string;
      /** @description The last name of the user to be created. */
      lastName: string;
      /** @description The Id of the enterprise the user belongs to. */
      enterpriseId: string;
      /** @description The Id of the user who is inviting the new user. */
      inviterUserId?: string;
      /** @description Whether the user is a beneficial owner on the enterprise. */
      isBeneficialOwner?: boolean;
      /** @description Whether to notify the user of their new account. Currently, it only notifies if the user is a beneficial owner. */
      notifyUser?: boolean;
    };
    InternalGetTransfersResponse: {
      transfers: components['schemas']['InternalTransfer'][];
    };
    InternalNewTotpKeyResponse: {
      /** @description Key used to create HMAC. */
      key?: string;
      /** @description True, if hashed secret used to verify key comes from BitGo. */
      hmac?: string;
      /** @description TOTP URL that generates QR code. */
      url?: string;
    };
    InternalTransfer: {
      coin: components['schemas']['Coin'];
      id: components['schemas']['Id'];
      wallet: components['schemas']['Id'];
      txid: string;
      /** @description The height of the block this Transfer was confirmed in (999999999 if unconfirmed) */
      height: number;
      /**
       * Format: date-time
       * @description The date this Transfer was last updated
       */
      date: string;
      /**
       * @description Defines whether or not this Transfer was sent or received by the user
       * @enum {string}
       */
      type: 'send' | 'receive';
      /** @description The total value (in base units) sent by this Transfer (may be approximate for ETH and other coins where amounts in base units can exceed 2^53 - 1) */
      value?: number;
      /** @description The total value (in base units) sent by this Transfer represented as a String */
      valueString: components['schemas']['IntegerString'];
      /** @description The Transfer's fee (in base units) represented as a String */
      feeString?: string;
      /** @description The Transfer's BitGo fee (in base units) */
      payGoFee?: number;
      /** @description The Transfer's BitGo fee (in base units) represented as a String */
      payGoFeeString?: string;
      /** @description The USD price at the time this Transfer was created */
      usdRate: number;
      state: components['schemas']['TransferState'];
      /** @description The tags to be used on this Transfer (used in Policies) */
      tags: components['schemas']['Id'][];
      /** @description An audit log of events that have happened to the Transfer during its lifecycle */
      history: {
        /**
         * Format: date-time
         * @description The date of this history object
         */
        date?: string;
        user?: components['schemas']['Id'];
        /** @enum {string} */
        action?:
          | 'created'
          | 'signed'
          | 'unconfirmed'
          | 'confirmed'
          | 'approved'
          | 'commented'
          | 'removed'
          | 'failed'
          | 'rejected';
        /** @description If this history object is of action "commented", this is the comment from the user */
        comment?: string;
      }[];
      /** @description A comment from the user */
      comment: string;
      /** @description The size of the transaction */
      vSize?: number;
      /** @description A user-supplied String for Transfers sent from the wallet which they can later use to ID the Transfer */
      sequenceId?: string;
      /** @description Address labels (if any) from entries concatenated. */
      label?: string;
      /** @description An array of objects describing the change in address balances made as a result of this Transfer */
      entries?: {
        /**
         * @description An address affected by this Transfer
         * @example 2NAUwNgXaoFj2VVnSEvNLGuez8CfdU2UCMZ
         */
        address?: string;
        wallet?: components['schemas']['Id'];
        /** @description The change (in base units) in the address's balance */
        value?: number;
        /** @description The change (in base units) in the address's balance represented as a String */
        valueString?: components['schemas']['IntegerString'];
        /** @description True if this address is a change address (only exists for UTXO coins) and if this is a "sent" Transfer */
        isChange?: boolean;
        /** @description True if this address is the BitGo PayGo wallet */
        isPayGo?: boolean;
        /**
         * @description If this is a token entry, the token's symbol
         * @example omg
         */
        token?: string;
        /** @description Name of an address given by the user. */
        label?: string;
      }[];
    };
    InternalTransfersResponse: {
      transfers: components['schemas']['InternalTransfer'][];
      coin: components['schemas']['Coin'];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
    };
    InternalUpdateEnterprise: {
      internal: {
        /** @description Whether this enterprise has been migrated to the new policy service */
        migratedToNewPolicyService: boolean;
      };
    };
    InternalUpdatePendingApprovalRequest: {
      /**
       * @description New state for the pending approval
       * @enum {string}
       */
      state?: 'rejected';
      /**
       * @description a message regarding the resolution of the pending approval
       * @example test message
       */
      resolutionMemo?: string;
    };
    InternalV1WalletListResponse: {
      wallets?: components['schemas']['V1Wallet'][];
      /** @description total number of wallets */
      walletCount?: number;
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
    };
    InternalWalletUserDetails: {
      users?: (components['schemas']['WalletUser'] & {
        userObject?: components['schemas']['User'];
      })[];
    };
    InvalidAddress: components['schemas']['PlatformErrorNoName'] & {
      context: {
        address: string;
        coin: components['schemas']['Coin'];
      };
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'InvalidAddress';
    };
    InvalidBankAccountId: components['schemas']['PlatformErrorNoName'] & {
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'InvalidBankAccountId';
    };
    InvalidCustomNodeId: components['schemas']['InvalidId'] & {
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'InvalidCustomNodeId';
    };
    InvalidEnterpriseId: components['schemas']['InvalidId'] & {
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'InvalidEnterpriseId';
    };
    InvalidId: components['schemas']['PlatformErrorNoName'] & {
      context: {
        id?: components['schemas']['Id'];
      };
    };
    InvalidOFAC: components['schemas']['PlatformErrorNoName'] & {
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'AddressError';
      /**
       * @description Human-readable error message
       * @example Address cannot be used
       */
      error?: string;
    };
    InvalidTransferId: components['schemas']['InvalidId'] & {
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'InvalidTransferId';
    };
    InvalidUserId: components['schemas']['InvalidId'] & {
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'InvalidUserId';
    };
    InvalidWalletId: components['schemas']['InvalidId'] & {
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'InvalidWalletId';
    };
    /**
     * Format: ipv4
     * @example 127.0.0.1
     */
    Ip: string;
    /**
     * @example confirmed
     * @enum {string}
     */
    JobStatus: 'pending' | 'scheduled' | 'confirmed' | 'canceled' | 'failed';
    Key: WithRequired<
      components['schemas']['KeyCommon'] & {
        pub?: components['schemas']['Pub'];
      },
      'id' | 'type'
    >;
    KeyCommon: {
      /** @description The encrypted private key */
      encryptedPrv?: string;
      id: components['schemas']['Id'];
      /**
       * @description "true" if this key is owned by BitGo
       * @example false
       */
      isBitGo?: boolean;
      source?: components['schemas']['KeySource'];
      type: components['schemas']['KeyType'];
    };
    /**
     * @description The name of a cryptographic curve. "secp256k1" is used for most of our coins, "ed25519" is used for XLM
     * @enum {string}
     */
    KeyCurve: 'secp256k1' | 'ed25519';
    KeyShare: {
      /** @description The source of the key share. */
      from: components['schemas']['KeyShareSource'];
      /** @description The recipient of the key share. */
      to: components['schemas']['KeyShareSource'];
      /** @description Public part of the share concatenated with chain code (64+64 characters hex string). */
      publicShare: string;
      /** @description Private part of the share concatenated with chain code (64+64 characters hex string). Depending on who the source and the recipient are, the share might be encrypted against the recipient's public key. */
      privateShare: string;
      /** @description The certificate of the private share, signed by the source of the key share. */
      privateShareProof?: string;
      /** @description The verifiable shamir share verification value */
      vssProof?: string;
    };
    KeyShareResponse: WithRequired<
      components['schemas']['KeyShare'] & {
        /** @description openPGP ASCII armored public key format string. Can be used to ensure that the "u" value came from the HSM. This contains the HSM signature/certification (signed by bitgo GPG key pair) of the public form of the "u" value and notation packets that indicate the commonPublicKey and the key ids of the two GPG keys used to share wrapping (userGPGPublicKey and backupGPGPublicKey). */
        hsmSig?: string;
      },
      'hsmSig'
    >;
    /**
     * @example user
     * @enum {string}
     */
    KeyShareSource: 'user' | 'backup' | 'bitgo';
    /**
     * @example user
     * @enum {string}
     */
    KeySource: 'backup' | 'bitgo' | 'cold' | 'user';
    KeyTSS: WithRequired<
      components['schemas']['KeyCommon'] & {
        /** @description The commonKeychain for the key if this is a TSS key. This value is required to be set when the type is set to “tss” and when the source is either “user” or “backup”. Setting this indicates to BitGo that the owner of the key has received all key shares they needed for generating their key. This value is the concatenation of the common public key (32-byte) with the common chaincode (32-byte) as a hex string. */
        commonKeychain?: string;
        /** @description The common public key. This value is required to be set for BLS keys when the source is either "user" or "backup". Setting this indicates to BitGo that the owner of the key has received all key shares they needed for generating their key. */
        commonPub?: string;
      },
      'id' | 'type' | 'source'
    >;
    /** @description This schema contains KeyTSS attributes and several ephemeral fileds which are only available during the key creation since they are not stored. */
    KeyTSSCreated: WithRequired<
      components['schemas']['KeyTSS'] & {
        /** @description openPGP ASCII armored pubkey format string. This contains the HSM signature/certification (signed by BitGo TSS GPG key pair) of the commonKeychain. This is necessary for verification purposes to ensure that the commonKeychain value came from BitGo's HSM. Used for full custody/OVC operations. */
        commonKeychainSig?: string;
        /** @description OpenPGP ASCII pubkey armoured string containing HSM signature certification. Allows to ensure that commonPublicKey came from the HSM */
        commonPublicKeySig?: string;
        keyShares?: components['schemas']['KeyShareResponse'][];
        /** @description GPG ASCII armored public key format that consists of HSM signature/certification and GPG notation data appended to the key signature subpackets */
        walletHSMGPGPublicKeySigs?: string;
      },
      'id' | 'type' | 'source'
    >;
    /**
     * @description A value from a string enum denoting what kind of key this is. Defaults to “independent” indicating an on-chain key is requested. If set to “tss” this tells us that a “tss” key is requested.
     * @default independent
     * @example tss
     * @enum {string}
     */
    KeyType: 'tss' | 'independent' | 'blsdkg';
    /**
     * @example [
     *   "585951a5df8380e0e304a553",
     *   "585951a5df8380e0e30d645c",
     *   "585951a5df8380e0e30b6147"
     * ]
     */
    Keys: components['schemas']['Id'][];
    KeysResponse: {
      keys: (components['schemas']['Key'] | components['schemas']['KeyTSS'])[];
    };
    /**
     * @example {
     *   "legalPersonName": "Pineapple Capital Inc"
     * }
     */
    LegalIdentifiers: Record<string, never>;
    LightningAddressResponse: {
      address?: components['schemas']['AddressString'];
    };
    LightningBalanceResponse: {
      /**
       * @description The lightning balance for the wallet in satoshis
       * @example 25000000
       */
      balance?: number;
      /**
       * @description The available lightning balance in satoshis minus holds
       * for pending payments or withdrawals.
       *
       * @example 24000000
       */
      availableBalance?: number;
    };
    LightningGetInvoicesResponse: {
      invoices?: {
        /**
         * @description The payment hash of the invoice
         * @example 63d9ce82e09d16761a85116ed8b65407db4fb22f85d03573de09c480f2c6d175
         */
        paymentHash?: string;
        /**
         * @description The value of the invoice in satoshis
         * @example 50000
         */
        value?: number;
        /**
         * @description ISO-8601 string representing when the invoice will expire
         * @example 2022-04-01T18:46:24.677Z
         */
        expiresAt?: string;
        /**
         * @description ISO-8601 string representing when the invoice was created
         * @example 2022-04-01T17:46:24.677Z
         */
        createdAt?: string;
        /**
         * @description ISO-8601 string representing when the invoice was updated last
         * @example 2022-04-01T18:16:24.677Z
         */
        updatedAt?: string;
        /**
         * @description The status of the invoice
         * @enum {string}
         */
        status?: 'open' | 'settled' | 'canceled';
        /** @description The wallet to which this invoice belongs */
        walletId?: components['schemas']['Id'];
        /**
         * @description The actual amount paid to the invoice in satoshis
         * @example 50000
         */
        amtPaidSats?: number;
      }[];
    };
    LightningInvoice: {
      /**
       * @description The BOLT \#11 encoded invoice
       * @example lnbc500n1p3zv5vkpp5x0thcaz8wep54clc2xt5895azjdzmthyskzzh9yslggy74qtvl6sdpdg3hkuct5d9hkugrxdaezqjn0dphk2fmnypkk2mtsdahkccqzpgxqyz5vqsp5v80q4vq4pwakq2l0hcqgtelgajsymv4ud4jdcrqtnzhvet55qlus9qyyssquqh2wl2m866qs5n72c5vg6wmqx9vzwhs5ypualq4mcu76h2tdkcq3jtjwtggfff7xwtdqxlnwqk8cxpzryjghrmmq3syraswp9vjr7cqry9l96
       */
      invoice?: string;
      /**
       * @description The payment hash of the invoice
       * @example 63d9ce82e09d16761a85116ed8b65407db4fb22f85d03573de09c480f2c6d175
       */
      paymentHash?: string;
      /**
       * @description The value of the invoice in satoshis
       * @example 50000
       */
      value?: number;
      /**
       * @description A memo or description for the invoice
       * @example Latte macchiato
       */
      memo?: string;
      /**
       * @description ISO-8601 string representing when the invoice will expire
       * @example 2022-04-01T18:46:24.677Z
       */
      expiresAt?: string;
      /**
       * @description The status of the invoice
       * @enum {string}
       */
      status?: 'open' | 'settled' | 'canceled';
      /** @description The wallet to which this invoice belongs */
      walletId?: components['schemas']['Id'];
    };
    LightningInvoicePaymentRequest: WithRequired<
      components['schemas']['LightningPaymentRequest'] & {
        /**
         * @description The BOLT \#11 encoded invoice to pay
         * @example lnbc500n1p3zv5vkpp5x0thcaz8wep54clc2xt5895azjdzmthyskzzh9yslggy74qtvl6sdpdg3hkuct5d9hkugrxdaezqjn0dphk2fmnypkk2mtsdahkccqzpgxqyz5vqsp5v80q4vq4pwakq2l0hcqgtelgajsymv4ud4jdcrqtnzhvet55qlus9qyyssquqh2wl2m866qs5n72c5vg6wmqx9vzwhs5ypualq4mcu76h2tdkcq3jtjwtggfff7xwtdqxlnwqk8cxpzryjghrmmq3syraswp9vjr7cqry9l96
         */
        invoice?: string;
        /**
         * @description A specific amount of satoshis to pay for this request. This is used to
         * pay more than the amount requested by the invoice, such as for zero
         * value invoices that will accept any size payment. Must be greater than
         * or equal to any amount specified by the invoice.
         */
        amount?: number;
      },
      'invoice'
    >;
    LightningLnurlPaymentRequest: WithRequired<
      components['schemas']['LightningPaymentRequest'] & {
        /**
         * @description The encoded LNURL pay request
         * @example lnurl1dp68gurn8ghj7mrww4exctt5dahkccn00qhxget8wfjk2um0veax2un09e3k7mf0w5lhz0fhve3nsdenxejkzdenxscxxv33x93kxc3evymkycesvymxxdfj8qcrgdfkv93nxvfev9jngcejv9nxxvpevgergepnxa3xgep58qukyakqmda
         */
        lnurl?: string;
        /**
         * @description A specific amount of satoshis to pay for this request. This is used
         * when an LNURL pay request offers a range of acceptable payment sizes.
         */
        amount?: number;
        /**
         * @description The maximum amount in satoshis that should be paid for this LNURL-pay
         * request. This may prevent overpaying when the LNURL-pay request requires
         * more than expected for a given payment.
         *
         * @default 1000000
         */
        maxAmount?: number;
      },
      'lnurl'
    >;
    LightningPaymentRequest: {
      /** @description An optional memo for the transaction. */
      comment?: string;
      /** @description Your own unique ID */
      sequenceId?: string;
      /**
       * @description The maximum fee in proportion to the payment amount that may be paid as a
       * fee for the payment. This number is multiplied by the value of the
       * invoice to determine the fee limit. Only one of feeLimit or feeLimitRatio
       * should be specified, if neither is specified then the greater of 25
       * satoshis or 5% of the invoice amount is used for the fee limit.
       *
       * @example 0.03
       */
      feeLimitRatio?: number;
      /**
       * @description The maximum number of satoshis that may be paid as a fee for the payment.
       * Only one of feeLimit or feeLimitRatio should be specified, if neither is
       * specified then the greater of 25 satoshis or 5% of the invoice amount is
       * used for the fee limit.
       *
       * @example 200
       */
      feeLimit?: number;
    };
    LightningPaymentResponse: {
      transfer?: components['schemas']['Transfer'];
      status?: components['schemas']['TransferState'];
      /**
       * @description The unique payment hash used for this payment..
       * @example 63d9ce82e09d16761a85116ed8b65407db4fb22f85d03573de09c480f2c6d175
       */
      paymentHash?: string;
    };
    LightningWithdrawRequest: {
      /**
       * @description The amount to withdraw denominated in satoshis
       * @example 50000000
       */
      value: number;
      /**
       * @description An address that will receive the on-chain funds. This address must belong
       * to the BitGo wallet for which the withdrawal request is being made.
       *
       * @example bc1q2la002q4rylgx9luzlv7dyr5ykeh0n46xnf02w
       */
      destination: string;
      /**
       * @description Your own unique ID for this withdrawal. This acts as a unique identifier
       * for the withdrawal. Requests with the same values as a previous request
       * will be rejected to prevent duplicate withdrawals.
       */
      sequenceId: string;
    };
    LightningWithdrawResponse: {
      /**
       * @description The on-chain transaction id of the withdrawal
       * @example 10dd35bf2a97388287e156f17f96cddb16e21eb77d1bf2ba2020ef04bee89fd6
       */
      txid: string;
    };
    Limit: number;
    /**
     * @example {
     *   "liquiditySourceAccountId": "37617d48-9cd5-4d0a-8f41-b2d0bec2229b",
     *   "liquiditySourceLabel": "Some label",
     *   "fundCurrency": "BTC",
     *   "createdAt": "2019-05-03T00:37:49.196Z",
     *   "fundAmount": "10000",
     *   "memo": "Memo",
     *   "txid": "37617d48-9cd5-4d0a-8f41-b2d0bec2229b",
     *   "reconciledFundTransferId": "37617d48-9cd5-4d0a-8f41-b2d0bec2229b"
     * }
     */
    LiquiditySourceTransfer: {
      /** @description Liquidity source accountId */
      liquiditySourceAccountId?: string;
      /** @description Currency of the transfer */
      fundCurrency?: components['schemas']['TradingSupportedCurrency'];
      /** @description Amount to fund in the transfer */
      fundAmount?: string;
      /** @description Memo for the transfer */
      memo?: string;
      /** @description txIid associated with the transfer */
      txid?: string;
      /** @description Reconciliation fund transfer ID */
      reconciledFundTransferId?: string;
    };
    /**
     * @example {
     *   "accountId": "37617d48-9cd5-4d0a-8f41-b2d0bec2229b",
     *   "label": "Some label",
     *   "creditLimit": "string;",
     *   "createdAt": "2019-05-03T00:37:49.196Z",
     *   "updatedAt": "2022-05-03T00:37:49.196Z",
     *   "currencies": {
     *     "btc": {
     *       "available": "1",
     *       "borrowed": "0"
     *     },
     *     "usd": {
     *       "available": "100",
     *       "borrowed": "20"
     *     }
     *   }
     * }
     */
    LiquiditySourceWithBalances: {
      /** @description Liquidity source accountId */
      accountId?: string;
      /** @description Any note about the Liquidity Source */
      label?: string;
      /** @description The credit limit of the Liquidity Source */
      creditLimit?: string;
      /** @description When the Liquidity Source was created */
      createdAt?: string;
      /** @description When the Liquidity Source was last updated */
      updatedAt?: string;
      /** @description A mapping of the currency to the available and borrowed quantities */
      currencies?: Record<string, never>;
    };
    ListAddressesResponse: {
      addresses: components['schemas']['Address'][];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
    };
    ListBankAccountsResponse: {
      bankAccounts?: components['schemas']['BankAccount'][];
    };
    ListCircuitBreakersResponse: {
      circuitBreakers?: components['schemas']['CircuitBreaker'][];
    };
    /**
     * @description the kind of resource a list rule entry refers to
     * @enum {string}
     */
    ListRuleEntryType: 'address' | 'walletId' | 'enterpriseId';
    ListV1WalletSharesResponse: {
      incoming?: components['schemas']['V1WalletShare'][];
      outgoing?: components['schemas']['V1WalletShare'][];
    };
    ListWalletRebalanceEventsResponse: {
      walletRebalanceEvents?: components['schemas']['WalletRebalanceEvent'][];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
    };
    ListWalletSharesResponse: {
      incoming?: components['schemas']['WalletShare'][];
      outgoing?: components['schemas']['WalletShare'][];
    };
    LockedSession: {
      /** Format: date-time */
      created: string;
      /** Format: date-time */
      expires: string;
      id: components['schemas']['Id'];
      /** @description IP address of the client that requested this access token */
      ip?: components['schemas']['Ip'];
      /** @description IP addresses of clients that are allowed to use this token */
      ipRestrict?: string[];
      /**
       * @description BitGo environment that issued this token.  The token is only valid in this environment.
       * @example test.bitgo.com
       */
      origin: string;
      /** @description Session permissions */
      scope: components['schemas']['Scope'];
      user: components['schemas']['Id'];
    };
    LoginRequest: {
      email: components['schemas']['Email'];
      otp?: components['schemas']['Otp'];
      /** @example secret */
      password: string;
    };
    LoginResponse: {
      /** @example 9b72c68ef394f5146f0f3efc1feafb7a971752cb00e79fafcfd8c1d2db83639c */
      access_token: string;
      /**
       * @description Unix timestamp
       * @example 1534201288
       */
      expires_at: number;
      scope: components['schemas']['Scope'];
      user: components['schemas']['User'];
    };
    MMIBalanceEventRequest: {
      /** @description for mmi events, should be 'MMI' */
      type: string;
      /** @description for mmi events, should be 'TRANSACTION', 'BALANCE', or 'ROLLUP' */
      subtype: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the actual mmi rollup calculation occured. Should stay consistent even if event needs to be resent. */
      timeEventOccurred: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the client sent the event. */
      timeEventSent: string;
      /** @description the name of the service sending the event */
      source: string;
      /** @description the address of the user sending crypto to or receiving crypto from the defi network */
      walletId: string;
      /** @description a hash that can be consistently generated from the same event. */
      idempotencyKey: string;
      /**
       * @description a unique identifier that connects the events generated
       * from a single consensys API response. To clarify, when
       * Defi-Service grabs the consensys JSON response, breaks it down
       * into separate ROLLUP and BALANCE events, then sends it to this API in a single call,
       * all of the events in that call should share the same AUDGroupId, but each event should
       * have a different uuid.
       */
      AUDGroupId: string;
      /** @description the chain id of the balance, i.e. 1 */
      chainId: string;
      /** @description alias for 'symbol' */
      asset: string;
      /** @description alias for 'rawBalance' */
      amountDelta: string;
      /** @description the total AUD for the time period */
      totalAUD: string;
      /** @description the currency in which the totalAUD value is represented */
      totalAUDCurrency: string;
      /** @description the type of asset being aggregated, i.e. 'token' */
      object: string;
      /** @description the address of the object */
      objectAddress: string;
      /** @description the name of the object */
      objectName: string;
      /** @description the token ticker or symbol */
      symbol: string;
      /** @description the number of decimals the object takes up */
      decimals: number;
      /** @description the url of an icon graphic for the object */
      iconUrl: string;
      /** @description the coingecko id for the object */
      coingeckoId: string;
      /** @description the raw string balance for the object */
      rawBalance: string;
      /** @description the decimal value of the balance */
      balance: number;
      /** @description Alias for 'date' from consensys balance object. Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the balance was calculated. */
      valueBalanceDate: string;
      /** @description The object block number */
      valueBlockNumber: string;
      /** @description the currency being used in the balance calculation */
      valueVsCurrency: string;
      /** @description the name of the token */
      valueTokenName: string;
      /** @description a unix timestamp representing the time at which the balance was calculated */
      valueTimestamp: number;
      /** @description the price used for balance calculation */
      valuePrice: number;
      /** @description whether or not there was an error when consensys tried to calculate the balance */
      valueError: boolean;
      /** @description if an error is present, this is the description of the error */
      valueErrorMessage: string;
    };
    MMIBalanceEventResponse: {
      /** @description Object id in mongo. */
      id?: string;
      /** @description for mmi events, should be 'MMI' */
      type?: string;
      /** @description for mmi events, should be 'TRANSACTION', 'BALANCE', or 'ROLLUP' */
      subtype?: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the actual mmi rollup calculation occured. Should stay consistent even if event needs to be resent. */
      timeEventOccurred?: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the client sent the event. */
      timeEventSent?: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the api received the event. */
      timeEventReceived?: string;
      /** @description the name of the service sending the event */
      source?: string;
      /** @description the address of the user sending crypto to or receiving crypto from the defi network */
      walletId?: string;
      /** @description a hash that can be consistently generated from the same event. */
      idempotencyKey?: string;
      /**
       * @description a unique identifier that connects the events generated
       * from a single consensys API response. To clarify, when
       * Defi-Service grabs the consensys JSON response, breaks it down
       * into separate ROLLUP and BALANCE events, then sends it to this API in a single call,
       * all of the events in that call should share the same AUDGroupId, but each event should
       * have a different uuid.
       */
      AUDGroupId?: string;
      /** @description the chain id of the balance, i.e. 1 */
      chainId?: string;
      /** @description alias for 'symbol' */
      asset?: string;
      /** @description alias for 'rawBalance' */
      amountDelta?: string;
      /** @description the total AUD for the time period */
      totalAUD?: string;
      /** @description the currency in which the totalAUD value is represented */
      totalAUDCurrency?: string;
      /** @description the type of asset being aggregated, i.e. 'token' */
      object?: string;
      /** @description the address of the object */
      objectAddress?: string;
      /** @description the name of the object */
      objectName?: string;
      /** @description the token ticker or symbol */
      symbol?: string;
      /** @description the number of decimals the object takes up */
      decimals?: number;
      /** @description the url of an icon graphic for the object */
      iconUrl?: string;
      /** @description the coingecko id for the object */
      coingeckoId?: string;
      /** @description the raw string balance for the object */
      rawBalance?: string;
      /** @description the decimal value of the balance */
      balance?: number;
      /** @description Alias for 'date' from consensys balance object. Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the balance was calculated. */
      valueBalanceDate?: string;
      /** @description The object block number */
      valueBlockNumber?: string;
      /** @description the currency being used in the balance calculation */
      valueVsCurrency?: string;
      /** @description the name of the token */
      valueTokenName?: string;
      /** @description a unix timestamp representing the time at which the balance was calculated */
      valueTimestamp?: number;
      /** @description the price used for balance calculation */
      valuePrice?: number;
      /** @description whether or not there was an error when consensys tried to calculate the balance */
      valueError?: boolean;
      /** @description if an error is present, this is the description of the error */
      valueErrorMessage?: string;
    };
    MMIRollupEventRequest: {
      /** @description for mmi events, should be 'MMI' */
      type: string;
      /** @description for mmi events, should be 'TRANSACTION', 'BALANCE', or 'ROLLUP' */
      subtype: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the actual mmi rollup calculation occured. Should stay consistent even if event needs to be resent. */
      timeEventOccurred: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the client sent the event. */
      timeEventSent: string;
      /** @description the name of the service sending the event */
      source: string;
      /** @description for MMI rollup events, should be 'daily' or 'monthly' */
      rollupPeriod: string;
      /** @description ISO-8601 string representing the date at which the aggregation calculations start (for 'daily', should be the day of calculation, i.e., if we want data for the 1st, the fromDate should be 2021-12-01. For 'monthly', should be the first day of the month). */
      fromDate: string;
      /** @description ISO-8601 string representing the date at which the aggregation calculations end (for 'daily', should be one day later, for 'monthly', should be the start day of the next month). */
      toDate: string;
      /** @description alias for totalAUDCurrency, redundant for wallet aggregation purposes. */
      asset: string;
      /** @description Alias for totalAUD, redundant for wallet aggregation purposes. */
      amountDelta: string;
      /**
       * @description a unique identifier that connects the events generated
       * from a single consensys API response. To clarify, when
       * Defi-Service grabs the consensys JSON response, breaks it down
       * into separate ROLLUP and BALANCE events, then sends it to this API in a single call,
       * all of the events in that call should share the same AUDGroupId, but each event should
       * have a different uuid.
       */
      AUDGroupId: string;
      /** @description the total AUD for the time period */
      totalAUD: string;
      /** @description the currency in which the totalAUD value is represented */
      totalAUDCurrency: string;
      /** @description the total AUD for the time period */
      averageAUD: string;
      /** @description the currency in which the totalAUD value is represented */
      averageAUDCurrency: string;
      /** @description the address of the user sending crypto to or receiving crypto from the defi network */
      usersAddress: string;
      /** @description the address of the user sending crypto to or receiving crypto from the defi network */
      walletId: string;
      /** @description a hash that can be consistently generated from the same event. */
      idempotencyKey: string;
      /** @description the chain id of the rollup -- we do rollups per asset per chain */
      chainId: string;
    };
    MMIRollupEventResponse: {
      /** @description Object id in mongo. */
      id?: string;
      /** @description for mmi events, should be 'MMI' */
      type?: string;
      /** @description for mmi events, should be 'TRANSACTION', 'BALANCE', or 'ROLLUP' */
      subtype?: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the actual mmi rollup calculation occured. Should stay consistent even if event needs to be resent. */
      timeEventOccurred?: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the client sent the event. */
      timeEventSent?: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the api received the event. */
      timeEventReceived?: string;
      /** @description the name of the service sending the event */
      source?: string;
      /** @description for MMI rollup events, should be 'daily' or 'monthly' */
      rollupPeriod?: string;
      /** @description ISO-8601 string representing the date at which the aggregation calculations start (for 'daily', should be the day of calculation, i.e., if we want data for the 1st, the fromDate should be 2021-12-01. For 'monthly', should be the first day of the month). */
      fromDate?: string;
      /** @description ISO-8601 string representing the date at which the aggregation calculations end (for 'daily', should be one day later, for 'monthly', should be the start day of the next month). */
      toDate?: string;
      /** @description alias for totalAUDCurrency, redundant for wallet aggregation purposes. */
      asset?: string;
      /** @description Alias for totalAUD, redundant for wallet aggregation purposes. */
      amountDelta?: string;
      /** @description A unique identifier that connects the events generated from a single consensys API response. To clarify, when Defi-Service grabs the consensys JSON response, breaks it down into separate ROLLUP and BALANCE events, then sends it to this API in a single call, all of the events in that call should share the same AUDGroupId, but each event should have a different uuid. */
      AUDGroupId?: string;
      /** @description the total AUD for the time period */
      totalAUD?: string;
      /** @description the currency in which the totalAUD value is represented */
      totalAUDCurrency?: string;
      /** @description the total AUD for the time period */
      averageAUD?: string;
      /** @description the currency in which the totalAUD value is represented */
      averageAUDCurrency?: string;
      /** @description the address of the user sending crypto to or receiving crypto from the defi network */
      usersAddress?: string;
      /** @description the address of the user sending crypto to or receiving crypto from the defi network */
      walletId?: string;
      /** @description a hash that can be consistently generated from the same event. */
      idempotencyKey?: string;
      /** @description the chain id of the rollup -- we do rollups per asset per chain */
      chainId?: string;
    };
    MMITransactionEventRequest: {
      /** @description for mmi events, should be 'MMI' */
      type: string;
      /** @description for mmi events, should be 'TRANSACTION', 'BALANCE', or 'ROLLUP' */
      subtype: string;
      /** @description date-time in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the actual mmi transaction occured. */
      timeEventOccurred: string;
      /** @description date-time in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the event was sent to wallet platform */
      timeEventSent: string;
      /** @description the name of the service sending the event */
      source: string;
      /** @description A cryptocurrency or token ticker symbol. */
      asset: string;
      /** @description Signed number represented as string indicating the quantity of asset leaving (negative) or entering (positive) the address. Zero values indicating no change accepted. */
      amountDelta: string;
      /** @description The number of decimals used to represent the amountDelta */
      decimals: number;
      /** @description Nonzero number representing the consensys point in time price for the asset */
      marketPrice: number;
      /** @description the address sending crypto to or receiving crypto from the defi network */
      usersAddress: string;
      /** @description a hash that can be consistently generated from the same event. */
      idempotencyKey: string;
      /** @description the wallet id with which the transaction takes place */
      walletId: string;
      /** @description the mongo id of the enterprise that the transaction falls under */
      enterpriseId: string;
      /** @description The on-chain transaction id */
      txid: string;
      /** @description The state of the transaction on-chain. Can be 'CONFIRMED' or 'REMOVED' */
      txState: string;
    };
    MMITransactionEventResponse: {
      /**
       * @description object id in mongo
       * @example 59cd72485007a239fb00282ed480da1f
       */
      id?: string;
      /**
       * @description date-time in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the actual mmi transaction occured.
       * @example 2022-01-10T17:30:30.000Z
       */
      timeEventOccurred?: string;
      /**
       * @description date-time in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the event was sent to wallet platform
       * @example 2022-01-10T17:31:30.000Z
       */
      timeEventSent?: string;
      /**
       * @description date-time in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which wallet platform received the event
       * @example 2022-01-10T17:33:30.000Z
       */
      timeEventReceived?: string;
      /**
       * @description for mmi events, should be 'MMI'
       * @example MMI
       */
      type?: string;
      /**
       * @description for mmi events, should be 'TRANSACTION', 'BALANCE', or 'ROLLUP'
       * @example BALANCE
       */
      subtype?: string;
      /**
       * @description the name of the service sending the event
       * @example indexer
       */
      source?: string;
      /**
       * @description A cryptocurrency or token ticker symbol.
       * @example ETH
       */
      asset?: string;
      /**
       * @description The number of decimals used to represent the amountDelta
       * @example 18
       */
      decimals?: number;
      /**
       * @description Signed number represented as string indicating the quantity of asset leaving (negative) or entering (positive) the address
       * @example -60000003247
       */
      amount?: string;
      /** @description Nonzero number representing the consensys point in time price for the asset */
      consensysPrice?: number;
      /**
       * @description the address sending crypto to or receiving crypto from the defi network
       * @example 0x71C7656EC7ab88b098defB751B7401B5f6d8976F
       */
      address?: string;
      /**
       * @description a hash that can be consistently generated from the same event.
       * @example f28e44259cf048638a293e7850594e39
       */
      idempotencyKey?: string;
      /**
       * @description the wallet id with which the transaction takes place
       * @example 48dd72485007a239fb00282ed480da1f
       */
      walletId?: string;
      /**
       * @description the mongo id of the enterprise that the transaction falls under
       * @example 61b8e0043daafc65a85d4bd36b4649d4
       */
      enterpriseId?: string;
      /**
       * @description The on-chain transaction id
       * @example b8a828b98dbf32d9fd1875cbace9640ceb8c82626716b4a64203fdc79bb46d26
       */
      txid?: string;
      /**
       * @description The state of the transaction on-chain. Can be 'CONFIRMED' or 'REMOVED'
       * @example CONFIRMED
       */
      txState?: string;
    };
    MalwareAddress: {
      address: components['schemas']['AddressString'];
      /** Format: date-time */
      date?: string;
      notes?: string;
    };
    MalwareAddressResponse: components['schemas']['MalwareAddress'] & {
      /** @enum {string} */
      type?: 'bitcoin';
    };
    /**
     * @description Market Data Error
     * @example {
     *   "errorName": "backend:common:invalidArgument",
     *   "error": "backend:common:invalidArgument key=instrument"
     * }
     */
    MarketDataError: {
      error: string;
      errorName: string;
    };
    /** @description Memo for Stellar or EOS. Type is only required for memos in Stellar transactions. The memo contains optional extra information that can also be used to identify payments in Stellar or EOS. */
    MemoObject: {
      type?: string;
      value?: string;
    };
    /** @description A memo for this specific transaction. This format is only available for Stacks. */
    MemoString: string;
    /**
     * @example {
     *   "btc": {
     *     "balance": 50000,
     *     "balanceString": "50000"
     *   },
     *   "eth": {
     *     "balance": 0,
     *     "balanceString": "2000000"
     *   }
     * }
     */
    MergedWalletBalancesAcrossCoins: {
      [key: string]: components['schemas']['TotalBalance'];
    };
    Message: {
      /** @description The coin associated with the wallet. */
      coin?: string;
      combineSigShare?: string;
      /**
       * Format: date-time
       * @description The date the message was created.
       */
      createdDate?: string;
      /** @description The message encoded as a hex string. */
      messageEncoded?: string;
      /** @description The message as human readable text. */
      messageRaw: string;
      signatureShares?: components['schemas']['SignatureShare'][];
      state: components['schemas']['TransactionRequestState'];
      /** @description The signed hex of the message. */
      txHash?: string;
      /**
       * Format: date-time
       * @description The date when the message state was updated.
       */
      updatedDate?: string;
    };
    /** Transaction Details */
    MessageDetails: {
      id?: string;
      user?: string;
      coin?: string;
      address?: string;
      message?: string;
      signatureVersion?: string;
      state?: components['schemas']['MessageStatus'];
      wallet?: string;
      createdTime?: components['schemas']['DateTime'];
      signature?: string;
      modifyTime?: components['schemas']['DateTime'];
      enterprise?: string;
    };
    /**
     * Message Status
     * @enum {string}
     */
    MessageStatus: 'created' | 'signed';
    /** Method Parameter */
    MethodParameter: {
      name: string;
      type: string;
      value: Record<string, never>;
    };
    MigrationInProgressEnterprises: {
      enterprises?: (components['schemas']['Enterprise'] & {
        migrationInProgressWallets?: string[];
      })[];
    };
    MigrationResponse: {
      v1WalletId?: components['schemas']['AddressString'];
      v2WalletId?: components['schemas']['Id'];
    };
    /**
     * @description Specifies whether a BitGo admin can change "lockDate"
     * * "managed" - Not locked, but requires approval from a BitGo admin to change
     * * "permanent" - "lockDate" cannot be changed
     * * "sticky" - Not included in bulk unlock, but "lockDate" can be individually changed
     *
     * @enum {string}
     */
    MutabilityConstraint: 'managed' | 'permanent' | 'sticky';
    Name: {
      /** @example Jane */
      first?: string;
      /** @example Jane Doe */
      full?: string;
      /** @example Doe */
      last?: string;
    };
    /** Near Stake */
    NearStakeIntent: components['schemas']['StakeIntent'] & {
      recipients: components['schemas']['RecipientEntry'][];
    };
    /** Near Unstake */
    NearUnstakeIntent: components['schemas']['UnstakeIntent'] & {
      recipients: components['schemas']['RecipientEntry'][];
    };
    /** Near Claim Unstake */
    NearWithdrawIntent: components['schemas']['WithdrawIntent'] & {
      recipients: components['schemas']['RecipientEntry'][];
    };
    /**
     * Format: uuid
     * @description When a result set is truncated, this field returns the id of the last object in the previous batch.  To get the next batch of results, pass this value via the "prevId" query parameter.
     * @example 585951a5df8380e0e3063e9f
     */
    NextBatchPrevId: string;
    NonParticipationTransactionBuildRequest: components['schemas']['BuildParams'] & {
      nonParticipation: boolean;
    };
    /** @enum {string} */
    NotificationUpdateType: 'broker_book' | 'broker_lines';
    /**
     * @description Number of keys provided.  This value must be 3 for hot wallets,
     * 1 for **ofc** wallets, and not specified for custodial wallets.
     *
     * @example 3
     */
    NumKeychains: number;
    /**
     * @description Number of signatures required.  This value must be 2 for
     * hot wallets, 1 for **ofc** wallets, and not specified for custodial
     * wallets.
     *
     * @example 2
     */
    NumSignatures: number;
    NumberOrString: string | number;
    /**
     * @description Second factor authentication token
     * @example 123456
     */
    Otp: string;
    PaillierBlumProofs: {
      /** @description The w value of the paillier blum proof. */
      w: string;
      /** @description The x value of the paillier blum proof is an array of 80 hex strings. */
      x: string[];
      /** @description The z value of the paillier blum proof is an array of 80 hex strings. */
      z: string[];
    };
    PasscodeRecoveryResponse: {
      recoveryInfo?: {
        /** @description Derivation path for the wallet's user key */
        path?: string;
        /** @description Encryption key which was used to encrypt the wallet passphrase at the time of wallet creation. This can be used to decrypt Box D on the wallet keycard. */
        passcodeEncryptionCode?: string;
        /** @description The wallet's user private key, encrypted with the user's wallet passphrase. In the event of a loss of the user's wallet passphrase, this private key can be decrypted by using the passcodeEncryptionCode to decrypt Box D from the wallet keycard, then using that decrypted wallet passphrase to decrypt the encryptedPrv. This works even if the wallet passphrase has been changed since the creation of the wallet keycard. */
        encryptedPrv?: string;
        /** @description V1 wallet's user private key, encrypted with the user's wallet passphrase. In the event of a loss of the user's wallet passphrase, this private key can be decrypted by using the passcodeEncryptionCode to decrypt Box D from the wallet keycard, then using that decrypted wallet passphrase to decrypt the encryptedPrv. This works even if the wallet passphrase has been changed since the creation of the wallet keycard. */
        encryptedXprv?: string;
      };
    };
    PasswordReset: {
      id: components['schemas']['Id'];
      keyPub: components['schemas']['Pub'];
      walletId: components['schemas']['Id'];
      creatorId: components['schemas']['Id'];
      state: components['schemas']['PasswordResetState'];
      resolverId?: components['schemas']['Id'];
      resolutionPayload?: components['schemas']['PasswordResetResolutionPayload'];
      resolutionSignature?: components['schemas']['PasswordResetResolutionSignature'];
      /** @description link to a video recording of support doing the id verification with the customer */
      videoLink?: string;
    };
    /** @enum {string} */
    PasswordResetFinalState: 'approved' | 'rejected';
    /**
     * @description A stringified JSON object containing the data that the resolutionSignature is a signature of. The JSON object has to have three properties: "tradingAccountId", "pubkey" and "timestamp". The "tradingAccountId" and the "pubkey" properties are the "walletId" and "keyPub" properties respectively that are stored on the password reset object. The "timestamp" is the timestamp of when the signature was made, formatted in ISO 8601 format.
     * @example {"tradingAccountId":"59cd72485007a239fb00282ed480da1f","pubkey":"xpub561MyMwAqRbcFbeauo22gtu3GKsUnSfZCUkKSrruJkkBotwVXWgKukkJnnovwE3izN488U8fHuFgG5VXVgJQASXHT5Rti6Zr1yN8TrqGDjt","timestamp":"2018-10-26T20:20:55.000Z"}
     */
    PasswordResetResolutionPayload: string;
    /**
     * @description A cryptographic signature of the public id of the wallet and the pub of the key referenced in this object. Is set by a BitGo Admin when approving the password reset.
     * @example 20276562f1a5237e84a1831951a3ccc613f45bedc4f2edc000f8b631e891389c984544b8308912e2bedbdd13b5680d5e898053e90123fe1b5275d8aa6d507ccf7b
     */
    PasswordResetResolutionSignature: string;
    /** @enum {string} */
    PasswordResetState: 'pending' | 'approved' | 'rejected';
    PasswordResets: {
      passwordResets?: components['schemas']['PasswordReset'][];
    };
    PaymentIntent: components['schemas']['BaseIntent'] & {
      /** @enum {string} */
      intentType?: 'payment';
      recipients?: components['schemas']['RecipientEntry'][];
      amount?: {
        /** @description The value of the transaction in base units of the asset. */
        value?: string;
        /** @description A cryptocurrency or token ticker symbol. */
        symbol?: string;
      };
    };
    PendingApproval: {
      id?: components['schemas']['Id'];
      coin?: components['schemas']['Coin'];
      wallet?: components['schemas']['Id'];
      enterprise?: components['schemas']['Id'];
      creator?: components['schemas']['Id'];
      /** Format: date-time */
      createDate?: string;
      info?:
        | components['schemas']['PendingApprovalTransactionRequest']
        | components['schemas']['PendingApprovalTransactionRequestFull']
        | components['schemas']['PendingApprovalUserChangeRequest']
        | components['schemas']['PendingApprovalPolicyRuleRequest']
        | components['schemas']['PendingApprovalUpdateApprovalsRequiredRequest']
        | components['schemas']['PendingApprovalEnterpriseModificationResponse'];
      state?: components['schemas']['PendingApprovalState'];
      /**
       * @description What kind of entity the Pending Approval is tied to
       * @enum {string}
       */
      scope?: 'enterprise' | 'wallet';
      /** @description All the Users who should see this Pending Approval */
      userIds?: components['schemas']['Id'][];
      approvalsRequired?: components['schemas']['ApprovalsRequired'];
      walletLabel?: string;
      resolvers?: {
        user: string;
        date: string;
        /** @enum {string} */
        resolutionType:
          | 'approved'
          | 'awaitingSignature'
          | 'pending'
          | 'pendingBitGoAdminApproval'
          | 'pendingCryptographicApproval'
          | 'pendingCustodianApproval'
          | 'pendingFinalApproval'
          | 'pendingIdVerification'
          | 'pendingVideoApproval'
          | 'processing'
          | 'rejected';
        signatures: string[];
        videoApprover?: string;
        videoLink?: string;
        videoException?: string;
      }[];
      addressLabels?: components['schemas']['PendingApprovalAddressLabel'][];
    };
    /** @description Address labels of recipients in this Pending Approval */
    PendingApprovalAddressLabel: {
      address: components['schemas']['AddressString'];
      label: components['schemas']['AddressLabel'];
      walletLabel?: components['schemas']['WalletLabel'];
    };
    PendingApprovalAwaitingSignature: {
      address?: string;
      amount?: components['schemas']['IntegerString'];
      coin?: string;
      comment?: string;
      /** Format: date-time */
      createDate?: string;
      creatorEmail?: components['schemas']['Email'];
      creatorId?: components['schemas']['Id'];
      enterpriseId?: components['schemas']['Id'];
      enterpriseName?: string;
      enterpriseFeatureFlags?: components['schemas']['EnterpriseFeatureFlag'][];
      primaryContactId?: components['schemas']['Id'];
      primaryContactEmail?: string;
      feeInfo?: components['schemas']['UtxoFeeInfo'] | components['schemas']['XlmFeeInfo'];
      /** @description Public wallet keys with their derivationPath */
      xpubsWithDerivationPath?: {
        backup?: {
          xpub?: string;
          derivedFromParentWithSeed?: string;
        };
        bitgo?: {
          xpub?: string;
        };
        user?: {
          xpub?: string;
          derivedFromParentWithSeed?: string;
        };
      };
      pendingApprovalId?: components['schemas']['Id'];
      /** @description Wallet key xpub triple (user, backup, bitgo) */
      pubs?: string[];
      txBase64?: components['schemas']['TxBase64'];
      txInfo?: components['schemas']['UtxoTxInfo'] | components['schemas']['XlmTxInfo'];
      videoId?: {
        approver?: components['schemas']['Id'];
        /** Format: date-time */
        date?: string;
        /** Format: uri */
        link?: string;
        waived?: boolean;
      };
      walletId?: components['schemas']['Id'];
      walletLabel?: string;
      chain?: number;
      index?: number;
    } & components['schemas']['FrontTransfer'];
    PendingApprovalAwaitingSignatureError: {
      pendingApprovalId?: components['schemas']['Id'];
      walletId?: components['schemas']['Id'];
      message?: string;
      stack?: string;
      enterpriseId?: components['schemas']['Id'];
      enterpriseName?: string;
      primaryContactId?: components['schemas']['Id'];
      primaryContactEmail?: string;
      coin?: string;
      buildResult?: components['schemas']['PendingApprovalAwaitingSignature'];
    };
    PendingApprovalEnterpriseModificationResponse: {
      policyRuleRequest?: {
        action?: string;
        updateEnterpriseRequest?: {
          /** @enum {string} */
          type?: 'updateEnterpriseRequest';
          /** @enum {string} */
          action?: 'add' | 'remove';
          /** @enum {string} */
          permission?: 'admin';
          userId?: string;
          /** @description E-Mail address of newly added users */
          email?: components['schemas']['Email'];
        };
      };
      /** @enum {string} */
      type?: 'policyRuleRequest';
    };
    PendingApprovalPolicyRuleRequest: {
      policyRuleRequest?: {
        action?: string;
        update?: {
          action?: components['schemas']['PolicyRuleActions'];
          coin?: components['schemas']['Coin'];
          condition?: {
            excludeTags?: components['schemas']['IdArray'];
            groupTags?: components['schemas']['IdArray'];
            [key: string]: unknown;
          };
          /** @description the id of the rule that is being updated */
          id?: string;
          type?: components['schemas']['PolicyRuleTriggers'];
        };
      };
      /** @enum {string} */
      type?: 'policyRuleRequest';
    };
    PendingApprovalSlaReportResponse: {
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
      pendingApprovals?: {
        enterpriseId?: components['schemas']['Id'];
        enterpriseName?: string;
        walletId?: components['schemas']['Id'];
        walletLabel?: string;
        coinType?: components['schemas']['Coin'];
        coinAmount?: string;
        coinUsdValue?: string;
        /** Format: date-time */
        withdrawalTimestamp?: string;
        /** Format: date-time */
        approvalTimestamp?: string;
        /** Format: date-time */
        broadcastTimestamp?: string;
        elapsedTime?: string;
      }[];
    };
    PendingApprovalState:
      | components['schemas']['PendingApprovalStatePending']
      | components['schemas']['PendingApprovalStateResolved'];
    /** @enum {string} */
    PendingApprovalStatePending:
      | 'pending'
      | 'awaitingSignature'
      | 'pendingFinalApproval'
      | 'pendingCustodianApproval'
      | 'pendingVideoApproval'
      | 'pendingIdVerification';
    /** @enum {string} */
    PendingApprovalStateResolved: 'approved' | 'processing' | 'rejected';
    PendingApprovalTransactionRequest: {
      transactionRequest?: {
        buildParams?: Record<string, never>;
        coinSpecific?: Record<string, never>;
        comment?: string;
        fee?: components['schemas']['IntegerOrString'];
        isUnsigned?: boolean;
        recipients?: {
          address?: components['schemas']['AddressString'];
          amount?: components['schemas']['IntegerOrIntegerString'];
          data?: string;
        }[];
        requestedAmount?: components['schemas']['IntegerOrIntegerString'];
        sourceWallet?: components['schemas']['Id'];
        triggeredPolicy?: components['schemas']['Id'];
        validTransaction?: string;
        validTransactionHash?: string;
      };
      /** @enum {string} */
      type?: 'transactionRequest';
    };
    PendingApprovalTransactionRequestFull: {
      transactionRequestFull?: {
        txRequestId: string;
        policyUniqueId?: components['schemas']['Id'];
        verificationItems?: string[];
        verificationRuleId?: string;
        videoApprovers?: components['schemas']['IdArray'];
        walletRebalanceEventId?: components['schemas']['Id'];
        txRequest?: components['schemas']['TransactionRequest'];
      };
      /** @enum {string} */
      type?: 'transactionRequestFull';
    };
    PendingApprovalTrustReportResponse: {
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
      pendingApprovals?: (components['schemas']['PendingApproval'] & {
        approvedVideoUsers?: {
          id?: components['schemas']['Id'];
          username?: components['schemas']['Email'];
        }[];
        creatorPermissions?: components['schemas']['WalletPermission'][];
        creatorUserName?: components['schemas']['Email'];
        /**
         * @description the name of the enterprise that is associated with the pending approval
         * @example Small Company
         */
        enterpriseName?: string;
        enterpriseFeatureFlags?: components['schemas']['EnterpriseFeatureFlag'][];
        /**
         * @description the label of the wallet associated with the pending approval
         * @example BTC Custodial Wallet
         */
        walletLabel?: string;
      })[];
    } & components['schemas']['FrontTransfer'];
    PendingApprovalUpdateApprovalsRequiredRequest: {
      /** @enum {string} */
      type?: 'updateApprovalsRequiredRequest';
      updateApprovalsRequiredRequest?: {
        requestedApprovalsRequired?: number;
      };
    };
    PendingApprovalUserChangeRequest: {
      /** @enum {string} */
      type?: 'userChangeRequest';
      userChangeRequest?: {
        action?: string;
        permissions?: string;
        userChanged?: components['schemas']['Id'];
      };
    };
    PendingApprovals: {
      pendingApprovals?: components['schemas']['PendingApproval'][];
    };
    PendingApprovalsCount: {
      /** @description Total number of pending approvals, per enterprise, for the current user. */
      pendingApprovalsCount: number;
    };
    PendingApprovalsCountByEnterprise: {
      enterprises: {
        [key: string]: components['schemas']['PendingApprovalsCount'];
      };
    };
    /**
     * @description A time period for a report
     * @enum {string}
     */
    Period: 'day' | 'month' | 'all';
    /**
     * Persona case status
     * @description The status of the Persona case.
     * @enum {string}
     */
    PersonaCaseStatusEnum: 'created' | 'approved' | 'rejected' | 'failed';
    PersonaInquiryReq: {
      data?: {
        type?: string;
        id?: string;
        attributes?: {
          name?: string;
          payload?: {
            data?: {
              type?: string;
              id?: string;
              attributes?: {
                status?: string;
                'reference-id'?: string;
                /** Format: date-time */
                'created-at'?: string;
                /** Format: date-time */
                'completed-at'?: string;
                /** Format: date-time */
                'expired-at'?: string;
              };
            };
          };
        };
      };
    };
    /** @description A list of basic information about all the transactions the rebalance would create. */
    PlannedTransaction: {
      coin?: components['schemas']['Coin'];
      valueString?: string;
      walletId?: components['schemas']['Id'];
    };
    Policy: {
      id: components['schemas']['Id'];
      /** Format: date-time */
      date?: string;
      label?: string;
      latest: boolean;
      rules: components['schemas']['PolicyRule2'][];
      version: number;
    };
    /**
     * @description A Policy Rule, the combination of a Scope, a Touchpoint, Conditions, and Actions. It allows you to define what
     * needs to happen (Actions) before a user can execute a sensitive operation (Touchpoint) on a Scope (e.g. a Wallet)
     * depending on the specific details of the operation (Conditions). See Concepts.
     */
    PolicyRule1: {
      /**
       * @description Id of the Policy Rule. This identifier is not unique in isolation, it must be paired with an specific Policy Rule Version number to uniquely identified a particular version of a Policy Rule. A UUID.
       * @example 306258df-dcab-489e-a9fe-ff28ce9fa312
       */
      id: string;
      /**
       * @description The uniqueId of the Policy Rule version. A UUID.
       * @example cb4e0a0a-2768-4024-904a-178ca6d2cd54
       */
      uniqueId: string;
      /**
       * @description Human readable name of the rule.
       * @example My first policy rule
       */
      name: string;
      /**
       * @description Indicates if the Policy Rule is considered in Evaluations.
       *
       * * "ACTIVE" - Will be Evaluated.
       * * "INACTIVE" - Will NOT be Evaluated.
       * * "DENIED" - The requested policy rule change was Denied.
       * * "PENDING_APPROVAL" - This version of the policy rule is Pending Approval before it can be activated.
       *
       * @example ACTIVE
       * @enum {string}
       */
      status: 'ACTIVE' | 'INACTIVE' | 'DENIED' | 'PENDING_APPROVAL';
      /**
       * @description The Policy Rule Version, an integer that is incremented each time the Policy Rule changes.
       * @default 1
       * @example 1
       */
      version?: number;
      /**
       * @description true, if the Policy Rule is a BitGo internal rule. Typically, this allows setting Global Policy Rules across enterprises.
       * @example false
       */
      adminOnly: boolean;
      /**
       * @description The id of the Touchpoint associated with the Policy Rule. A UUID.
       * @example 0a244ae3-26cf-48ed-9854-edd5b9751f3e
       */
      touchpointId: string;
      /**
       * @description Label of the Touchpoint associated with the Policy Rule. For example the Transfer from a Wallet Touchpoint.
       * @example Transfer from a Wallet
       */
      touchpointLabel: string;
      /**
       * @description The id of the Scope associated with the Policy Rule. A UUID.
       * @example 08a3f714-c330-41e6-bd83-bad3a8d37188
       */
      scopeId: string;
      /**
       * @description Label of the Scope associated with the Policy Rule. For example the All Wallets Scope.
       * @example All Wallets
       */
      scopeLabel: string;
      /** @description List of Policy Rule Clauses: a combination of Conditions and Actions. */
      clauses: components['schemas']['Clause'][];
      /** @description List of Filtering Conditions that must trigger for this Policy Rule to be Evaluated. */
      filteringConditions: (
        | components['schemas']['WalletTypeFilteringCondition']
        | components['schemas']['WalletIdsFilteringCondition']
        | components['schemas']['WalletAllFilteringCondition']
        | components['schemas']['RuleAllFilteringCondition']
      )[];
      /**
       * @description true, if the Policy Rule is locked, false otherwise.
       * @example false
       */
      locked: boolean;
      /**
       * @description Indicates how the Policy Rule is locked.
       *
       * * "LOCK_AFTER_DATE" - Will lock after the lockDate set on the Policy Rule.
       * * "PERMANENT" - Is permanently locked.
       *
       * @example PERMANENT
       * @enum {string}
       */
      lockType: 'LOCK_AFTER_DATE' | 'PERMANENT';
      /**
       * Format: date-time
       * @description The date after which the Policy Rule will be locked. Only applicable if the Policy Rule is locked with
       * "LOCK_AFTER_DATE".
       *
       * @example 2023-11-13T14:49:48.830Z
       */
      lockDate?: string;
      /**
       * @description The id of the Enterprise this Policy Rule belongs to.
       * @example 5d1a5f2c8f0a9c001a5f2c8f0ad00000
       */
      enterpriseId?: string;
      /**
       * Format: date-time
       * @description The date when the Policy Rule was last triggered. Only applicable if the Policy Rule is locked with
       * "LOCK_AFTER_DATE".
       *
       * @example 2023-11-13T14:49:48.830Z
       */
      lastTriggeredDate?: string;
      /**
       * @description The id of the Evaluation that last triggered the Policy Rule. A UUID.
       *
       * @example 306258df-dcab-489e-a9fe-ff28ce9fa312
       */
      lastTriggeredEvaluationId?: string;
      /**
       * @description The id of the user who created the Policy Rule or the string \"BitGo\".
       * @example 5d1a5f2c8f0a9c001a5f2c8f0ad00000
       */
      createdBy: string;
      /**
       * @description The id of the user who last modified the Policy Rule or the string \"BitGo\".
       * @example 5d1a5f2c8f0a9c001a5f2c8f0ad00000
       */
      modifiedBy: string;
      /**
       * @description The id of the user who last modified the lock of the Policy Rule.
       * @example 5d1a5f2c8f0a9c001a5f2c8f0ad00000
       */
      lockModifiedBy?: string;
      /**
       * @description The id of the Evaluation that was done when this Policy Rule version was requested to be created, modified
       * or deleted. A UUID.
       *
       * @example 306258df-dcab-489e-a9fe-ff28ce9fa312
       */
      evaluationId?: string;
    };
    PolicyRule2: {
      id: string;
      /**
       * Format: date-time
       * @description The time at which this rule becomes immutable
       */
      lockDate: string;
      mutabilityConstraint?: components['schemas']['MutabilityConstraint'];
      coin?: components['schemas']['Coin'];
      type: components['schemas']['PolicyRuleTriggers'];
      condition?: components['schemas']['PolicyRuleConditions'];
      action: components['schemas']['PolicyRuleActions'];
    };
    /** @description What happens when this rule is triggered */
    PolicyRuleActions: {
      /** @enum {string} */
      type:
        | 'deny'
        | 'getApproval'
        | 'getGroupApproval'
        | 'getFinalApproval'
        | 'getCustodianApproval'
        | 'getIdVerification'
        | 'noop';
      approvalsRequired?: components['schemas']['ApprovalsRequired'];
      /** @description For a final approver action, who can approve */
      userIds?: components['schemas']['Id'][];
    };
    /** @description Parameters for the type */
    PolicyRuleConditions: OneOf<
      [
        {
          /** @description The amount for the limit */
          amountString?: components['schemas']['IntegerString'];
          /** @description Time window in seconds for a velocity limit, between 1 and a month */
          timeWindow?: number;
        },
        {
          /** @description The amount for the limit, specified in USD */
          amountString?: components['schemas']['IntegerString'];
          /** @description Time window in seconds for a velocity limit, between 1 and 30 days */
          timeWindow?: number;
        },
        {
          /** @description Addresses allowed/restricted for a whitelist/blacklist */
          addresses?: (string | components['schemas']['Id'])[];
        },
        {
          /** @description Entries specifying which addresses/ wallets/ enterprises are on the whitelist */
          entries?: components['schemas']['AdvancedListRuleEntry'][];
        },
        {
          /** @description the url to query for the webhook */
          url?: string;
        }
      ]
    >;
    /**
     * @description What causes this rule to trigger
     * @enum {string}
     */
    PolicyRuleTriggers:
      | 'advancedWhitelist'
      | 'allTx'
      | 'bitcoinAddressWhitelist'
      | 'coinAddressWhitelist'
      | 'coinAddressBlacklist'
      | 'transactionLimit'
      | 'velocityLimit'
      | 'webhook';
    /** @description Parameters for the type */
    PolicyRuleUpdateConditions:
      | {
          /** @description The amount for the limit */
          amountString: components['schemas']['IntegerString'];
          /** @description Time window in seconds for a velocity limit, between 1 and a month */
          timeWindow?: number;
        }
      | {
          add: components['schemas']['AdvancedListRuleEntry'];
        }
      | {
          /** @description Address to add to the list */
          add: string | components['schemas']['Id'];
          /** @description An object with arbitrary metadata about the added address. */
          metaData?: {
            /** @description Text indicating who added this address to the whitelist */
            addedBy?: string;
            [key: string]: unknown;
          };
        }
      | {
          /** @description Address to remove from the list */
          remove: string | components['schemas']['Id'] | components['schemas']['AdvancedListRuleEntry'];
        }
      | {
          /** @description the url to query for the webhook */
          url: string;
        }
      | Record<string, never>;
    PostEnterpriseBatchResponse: {
      count?: number;
      events?: components['schemas']['ResponseEntityEntry'][];
    };
    PostEventBatchResponse: {
      count?: number;
      events?: components['schemas']['ResponseEventEntry'][];
    };
    PostInstrumentBatchResponse: {
      count?: number;
      events?: components['schemas']['ResponseInstrumentEntry'][];
    };
    PostUserBatchResponse: {
      count?: number;
      events?: components['schemas']['ResponseEntityEntry'][];
    };
    PostWalletRebalanceEventResponse: {
      walletRebalanceEvent?: components['schemas']['WalletRebalanceEvent'];
      coinSpecific?: {
        feeBalance?: string;
        feeAddress?: string;
      };
    };
    PreparedReport: {
      /** @description Report ID */
      id?: string;
      /**
       * @description Type of report
       * @enum {string}
       */
      type?: 'wallet';
      /**
       * @description State of the report
       * @enum {string}
       */
      state?: 'pending' | 'started' | 'finished';
      /** @description User ID */
      user?: string;
      /** @description Array of wallet ID strings relevant to this report */
      wallets?: components['schemas']['WalletId'][];
      /** @description Coin */
      coin?: string;
      /** @description The report can be downloaded from this URL */
      url?: string;
      /** @description Name of the report file */
      filename?: string;
      /**
       * @description The format of the report
       * @enum {string}
       */
      format?: 'pdf' | 'csv' | 'json';
      /** @description Wallet label */
      label?: string;
      /**
       * Format: date-time
       * @description Start date of the report
       * @example 11-01-2019
       */
      start?: string;
      /**
       * @description The period in time of the report
       * @enum {string}
       */
      period?: 'day' | 'month' | 'all';
      /**
       * Format: date-time
       * @description The timestamp when the report was generated
       */
      date?: string;
    }[];
    /**
     * @description Intervals in which we assess fees on our invoices
     * @enum {string}
     */
    PricingFeeOccurrence: 'monthly' | 'oneTime' | 'payPerUse';
    /**
     * @description Various types of fees that we invoice our clients
     * @enum {string}
     */
    PricingFeeType: 'auc' | 'utxoTx' | 'nonUtxoTx' | 'withdrawal' | 'subscription' | 'apiCall';
    PrimeAccount: {
      /** @description Account ID of the view */
      account_id?: string;
      /** @description If the view is frozen */
      frozen?: boolean;
      /** @description Currency of the transfer */
      currencies?: Record<string, never>;
    };
    /**
     * @description BIP174 serialization of a PSBT
     * @example 70736274ff0100530100000001ccf3d1b853dcff06a939afef91d8b178d74028516bb831d77fcfd5b1ce6715f00000000000ffffffff01f0b9f5050000000017a914567cd7b44f9f3a07c3138f37bf984b60fbbaf24387000000004f010488b21e0000000000000000003a922e29f0c8eb0db2a60484cbdcb631f6b107c9caae3ffdcf3e7d2ec1f6bcd00312148715f361dab685a669d42431e5d6d3f973404dab9c9fd1b950b279ad763404cc18ae084f010488b21e0000000000000000006d1d656d3ddd91c194c04565a3603702a21016ced14a265f38982d6275e67b6403d3bac2313a7c6b21cbb11b14b0d10341f922c0a403a8bd8c87f0dc820f35af6e04f65cd8694f010488b21e000000000000000000cb04fd63ab34d90fe6466b880e2a02ccf8a863374312991af8911b1aaab443340336ef228ffe9b8efffba052c32d334660dd1f8366cf8fe44ae5aa672b6b62909504f2ef0389000100c00100000000010101010101010101010101010101010101010101010101010101010101010101010000000000ffffffff0100e1f5050000000017a914d909474404c124a3d04c3fbff61faa49cf43c58b87024730440220360d495738071ed6930084713724262ef55d710e06d85f90b56727ab83c91b5702200ae452a812717ef0ac8866989ffc963d88c14f9694fa57ef046dd699bea1d5da01210247496797efe8b56780cd9bee19ac3d916624829cacd3f1236fa608000193e54d0000000001012000e1f5050000000017a914d909474404c124a3d04c3fbff61faa49cf43c58b87010469522102cc4d0fa411cac244486f8eb2c08e035ff7410f460a359ca7f8810991bd3b42092102d72fd0d0d90293434ad5fca160f278e03c614497aa4e425cf454e2c1330f96ab210344d884136df550202865ffbc6218c7f9c88fe6ce39c945798190badb38a752f153ae220602cc4d0fa411cac244486f8eb2c08e035ff7410f460a359ca7f8810991bd3b420914f2ef038900000000000000000000000000000000220602d72fd0d0d90293434ad5fca160f278e03c614497aa4e425cf454e2c1330f96ab14cc18ae080000000000000000000000000000000022060344d884136df550202865ffbc6218c7f9c88fe6ce39c945798190badb38a752f114f65cd8690000000000000000000000000000000000010069522103f6f40764bd5d63f200a2778883acf75e96f15095c998263c087270d0c97e7e7f21035ffb7abc70159e0469f4b989a6d5e1785a2904169ff050b2f468fe5d3d5dbbf22103e1524d7f6fc57ab3eacbb659b787106780a475d1db483952c2310b7e9a38975b53ae2202035ffb7abc70159e0469f4b989a6d5e1785a2904169ff050b2f468fe5d3d5dbbf214cc18ae0800000000000000000100000000000000220203e1524d7f6fc57ab3eacbb659b787106780a475d1db483952c2310b7e9a38975b14f65cd86900000000000000000100000000000000220203f6f40764bd5d63f200a2778883acf75e96f15095c998263c087270d0c97e7e7f14f2ef03890000000000000000010000000000000000
     */
    PsbtHex: string;
    /**
     * @description public part of a key pair
     * @example xpub661MyMwAqRbcGMVhmc7wqQRYMtcX9LAvSj1pjB213y5TsrkV2uuzJjWnjBrT1FUeNWGPjaVm5p7o6jdNcQJrV1cy3a1R8NQ9m7LuYKA8RpH
     */
    Pub: string;
    /**
     * @example {
     *   "type": "cold"
     * }
     */
    Query: Record<string, never>;
    /** @enum {string} */
    QueryFilterType: 'all' | 'settled' | 'unsettled';
    /** @enum {string} */
    QueryState: 'pending' | 'approved' | 'rejected';
    RangeProofChallenge: {
      /** @description Range proof challenge value. */
      ntilde: string;
      /** @description Range proof challenge value. */
      h1: string;
      /** @description Range proof challenge value. */
      h2: string;
    };
    RangeProofChallengeProof: {
      /** @description The alpha value of the range proof challenge proof is an array of 128 hex strings. */
      alpha: string[];
      /** @description The t value of the range proof challenge proof is an array of 128 hex strings. */
      t: string[];
    };
    RangeProofChallengeProofs: {
      h1WrtH2: components['schemas']['RangeProofChallengeProof'];
      h2WrtH1: components['schemas']['RangeProofChallengeProof'];
    };
    RangeProofChallengeWithProofs: components['schemas']['RangeProofChallenge'] & {
      ntildeProof?: components['schemas']['RangeProofChallengeProofs'];
      paillierBlumProof?: components['schemas']['PaillierBlumProofs'];
    };
    RangeProofConfig: components['schemas']['RangeProofChallenge'] & {
      verifiers: components['schemas']['Verifiers'];
      /** @description The ntildeProof value is only required when creating the initial config. */
      ntildeProof?: components['schemas']['RangeProofChallengeProofs'];
      /** @description The paillierBlumProof value is only required when creating the initial config. */
      paillierBlumProof?: components['schemas']['PaillierBlumProofs'];
    };
    RebalanceError: {
      /**
       * @description step in which the error occured
       * @enum {string}
       */
      errorType?: 'walletCreate' | 'walletInit' | 'txInit';
      /** @description the error message */
      errorMessage?: string;
      /** @description The api request id */
      reqId?: string;
      /** @description A record of the error */
      errorObject?: Record<string, never>;
    };
    /**
     * @description The state of the document
     * @enum {string}
     */
    RebalanceState:
      | 'created'
      | 'pendingWalletCreation'
      | 'pendingWalletInitialization'
      | 'pendingUpdate'
      | 'pendingTransactionInitiation'
      | 'done'
      | 'cancelled';
    RebuildMultipleTxRequests: {
      /** @description Rebuilds all transaction requests for the given txRequestIds. */
      txRequestIds: string[];
    };
    RecipientEntry: {
      address: components['schemas']['TxAddress'];
      amount: components['schemas']['Amount2'];
      data?: string;
      tokenData?: components['schemas']['TokenData'];
    };
    RecipientTokenData: {
      /** @description Name of token, as represented in BitGoJS Statics package. */
      tokenName?: string;
      /** @description Address of token or smart contract. Required if token is unsupported by BitGo. Not required if passing "tokenName". */
      tokenContractAddress?: string;
      /** @description Relevant for fungible tokens. Not required if passing "tokenName". Defaults to smallest base unit. */
      decimalPlaces?: number;
      /**
       * @description Token standard
       * @enum {string}
       */
      tokenType?: 'ERC20' | 'ERC721' | 'ERC1155';
      /** @description ID of token to use when constructing transaction or calldata. Required for NFTs. */
      tokenId?: string;
      /** @description Quantity of token to use when constructing calldata (amount to transfer). */
      tokenQuantity?: string;
    };
    RecreateWalletStatsSummary: {
      /**
       * @description Count of how many wallet stats of the type 'all' were modified
       * @example 0
       */
      allCount?: number;
      /**
       * @description Count of how many wallet stats of the type 'enterprise' were modified
       * @example 0
       */
      enterpriseCount?: number;
      /**
       * @description Count of how many wallet stats of the type 'wallet' were modified
       * @example 10
       */
      walletCount?: number;
    };
    RedeemReferralCodeHttpRequestBody: {
      referralCode?: components['schemas']['ReferralCode'];
      walletId?: components['schemas']['WalletId'];
    };
    RedeemReferralCodeResponse: {
      brokerId?: components['schemas']['BrokerId'];
      brokerName?: components['schemas']['BrokerName'];
      brokerBookId?: components['schemas']['BrokerBookId'];
      clientId?: components['schemas']['ClientId'];
      referralCode?: components['schemas']['ReferralCode'];
      /**
       * @description Text detailing the clientId value
       * @example Your client id when communicating with the broker about your broker account is ...
       */
      note?: string;
      walletId?: components['schemas']['WalletId'];
    };
    ReferralApiResponse: {
      clientId: components['schemas']['ClientId'];
      clientName: string;
      redeemed: boolean;
      referralCode: components['schemas']['ReferralCode'];
    };
    /**
     * Format: byte
     * @description Alphanumeric code used for referral
     */
    ReferralCode: string;
    ReferralCodesHttpRequestBody: {
      after?: components['schemas']['DateFromISOString'];
      before?: components['schemas']['DateFromISOString'];
      clientId?: components['schemas']['ClientId'];
      redeemed?: boolean;
    };
    RejectReshare: {
      userId: components['schemas']['Id'];
    };
    Report: {
      /** @description The report data. PDF reports will be encoded as a base64 string */
      data?: string;
      /**
       * @description Status of the report
       * @enum {string}
       */
      status?: 'pending' | 'started' | 'finished';
      /** @description Format of report ("pdf", "csv", or "json") */
      format?: string;
    };
    /**
     * @description the type of report
     * @enum {string}
     */
    ReportType: 'allWallets' | 'withdrawal';
    /**
     * @description A three character timezone code
     * @example UTC
     */
    ReportsTimezone: string;
    ResendShareEmailResponse: {
      resent?: boolean;
    };
    /**
     * Format: date-time
     * @description When set, reserve all unspents used in transactions for this amount of time
     * @example 2199-12-31T23:59:59.000Z
     */
    ReservationExpireTime: string;
    /** @description a ReservedUnspent object */
    ReservedUnspent: {
      /**
       * @description The id of the unspent in the form \<txid\>:\<tx_index\>
       * @example 003f688cc349f1fca8ac5ffa21671ca911b6ef351085c60733ed8c2ebf162cb8:2
       */
      id: string;
      walletId: components['schemas']['Id'];
      /** Format: date-time */
      expireTime: string;
      userId: components['schemas']['Id'];
      /**
       * @description the type of the unspent
       * @example undefined, ordinal, inscription
       */
      type?: string;
      /** @description the array of inscription ids inscribed to the unspent */
      inscriptionIds?: string[];
    };
    ResponseEntityEntry: {
      entity_id: string;
      previously_existed: boolean;
      unit21_id: string;
      ignored?: boolean;
    };
    ResponseEventEntry: {
      event_id?: string;
      previously_existed?: boolean;
      unit21_id?: string;
    };
    ResponseInstrumentEntry: {
      instrument_id: string;
      previously_existed: boolean;
      unit21_id: string;
      ignored?: boolean;
    };
    RunBody: {
      results?: Record<string, never>[];
      count?: number;
    };
    SOLBuildOptions: components['schemas']['AccountBaseBuildOptions'] & {
      memo?: string;
    };
    /** Sol Claim Unstake */
    SOLClaimIntent: WithRequired<
      components['schemas']['SOLBuildOptions'] &
        components['schemas']['WithdrawIntent'] & {
          /** @description The staking account. */
          stakingAddress?: string;
          /** @description The amount, in lamports, to claim. */
          amount?: components['schemas']['Amount2'];
        },
      'stakingAddress' | 'amount'
    >;
    /** Sol Create ATA */
    SOLCreateAssociatedTokenAccountIntent: components['schemas']['SOLBuildOptions'] &
      components['schemas']['EnableTokenIntent'];
    /** Sol Payment */
    SOLPaymentIntent: components['schemas']['SOLBuildOptions'] & components['schemas']['PaymentIntent'];
    /** Sol Stake */
    SOLStakeIntent: WithRequired<
      components['schemas']['SOLBuildOptions'] &
        components['schemas']['StakeIntent'] & {
          /** @description The validator to which the coins will be delegated to. */
          validatorAddress?: string;
          /** @description The amount, in lamports, to delegate. */
          amount?: components['schemas']['Amount2'];
        },
      'validatorAddress' | 'amount'
    >;
    /** Sol Unstake */
    SOLUnstakeIntent: WithRequired<
      components['schemas']['SOLBuildOptions'] &
        components['schemas']['UnstakeIntent'] & {
          /** @description The staking account. */
          stakingAddress?: string;
          /** @description Amount, in lamports, to unstake. If empty, the entire stake will unstake. */
          amount?: components['schemas']['Amount2'];
          /** @description The amount that continues staking after the unstaking transaction completes. To unstake the entire stake, pass 0 or leave empty. To create a partial unstake, pass a value greater than 0 (this amount that remains staking). Note: the staking delegation balance must be equal to the "amount" value plus the "remainingStakingAmount" value. */
          remainingStakingAmount?: components['schemas']['Amount2'];
        },
      'stakingAddress'
    >;
    STXStakingOptions: {
      /**
       * @description The STX staking contract name. Use pox-3.
       * @default pox-3
       */
      contractName?: string;
      /** @description STX staking contract function. */
      functionName?: string;
      /** @description The 4 Objects are required and in the order expressed. See staking examples in [Stacks](#section/Stacks) under Coin-specific implementation. */
      functionArgs?: (
        | {
            /**
             * @description Type of argument. Use the default.
             * @default uint128
             */
            type?: string;
            /** @description Amount in micro-stx */
            val?: string;
          }
        | {
            /**
             * @description Type of argument. Use the default.
             * @default principal
             */
            type?: string;
            /** @description Address of the validator */
            val?: string;
          }
        | {
            /**
             * @description Type of argument. Use the default.
             * @default optional
             */
            type?: string;
            /** @description The number of cycles that the delegation will last. This is a mandatory field that must be greater than 1. */
            val?: string;
          }
        | {
            /**
             * @description Type of argument. Use the default.
             * @default optional
             */
            type?: string;
            val?: {
              /**
               * @description Type of argument. Use the default.
               * @default tuple
               */
              type?: string;
              /** @description The 2 objects are required and in the order expressed. */
              val?: (
                | {
                    /**
                     * @description Type of argument. Use the default.
                     * @default hashbytes
                     */
                    key?: string;
                    /**
                     * @description Type of argument. Use the default.
                     * @default buffer
                     */
                    type?: string;
                    /** @description The BTC Address hash. See staking examples in [Stacks](#section/Stacks) under Coin-specific implementation. */
                    val?: string;
                  }
                | {
                    /**
                     * @description Type of argument. Use the default.
                     * @default version
                     */
                    key?: string;
                    /**
                     * @description Type of argument. Use the default.
                     * @default buffer
                     */
                    type?: string;
                    /** @description The BTC Address version. See staking examples in [Stacks](#section/Stacks) under Coin-specific implementation. */
                    val?: string;
                  }
              )[];
            };
          }
      )[];
    };
    /** @description A salesforce Account object. All of the visible fields in the given account will be returned */
    SalesforceAccount: Record<string, never>;
    /**
     * @description a salesforce id
     * @example 0011D00000a7KuaQAE
     */
    SalesforceId: string;
    /** @description A salesforce Opportunity object with an added field called accountDetails that contains the salesforce Account object */
    SalesforceJoinedAccountAndOpportunity: components['schemas']['SalesforceOpportunity'] & {
      accountDetails?: components['schemas']['SalesforceAccount'];
    };
    /** @description A salesforce Opportunity object. All of the visible fields in the given opportunity will be returned */
    SalesforceOpportunity: Record<string, never>;
    Schema: {
      id?: components['schemas']['Id'];
      database?: components['schemas']['Database'];
      /** @example wallet */
      coll?: string;
      type?: components['schemas']['Type'];
      query?: components['schemas']['Query'];
      field?: string;
      state?: components['schemas']['QueryState'];
      limit?: components['schemas']['Limit'];
      creator?: components['schemas']['Id'];
      executionCount?: number;
    };
    /**
     * @example [
     *   "crypto_compare",
     *   "user_manage",
     *   "openid",
     *   "profile",
     *   "wallet_create",
     *   "wallet_manage_all",
     *   "wallet_approve_all",
     *   "wallet_spend_all",
     *   "wallet_edit_all",
     *   "wallet_view_all"
     * ]
     */
    Scope: string[];
    SendLabel: {
      id: components['schemas']['Id'];
      coin: components['schemas']['Coin'];
      address: components['schemas']['AddressString'];
      enterpriseId: components['schemas']['Id'];
      label: string;
    };
    SendQueue: {
      id: components['schemas']['Id'];
      user: components['schemas']['Id'];
      coin: components['schemas']['Coin'];
      wallet?: components['schemas']['Id'];
      enterprise?: components['schemas']['Id'];
      txid: components['schemas']['TxId'];
      /** @description Raw transaction (hex) */
      tx: string;
      createTime?: components['schemas']['TimestampMs'];
      modifyTime?: components['schemas']['TimestampMs'];
      state?: components['schemas']['SendQueueState'];
      /** @description Indicates that the transaction was held at some point */
      held: boolean;
      uniqueDoubleSpendPreventionIds?: components['schemas']['Id'][];
      /** @description Number of transmission attempts */
      attempts: number;
      nextAttempt: components['schemas']['DateTime'];
      /** @description Max number of times to try transmitting */
      targetAttempts: number;
      /** @description The total value (in base units) sent by this sendq transaction */
      value?: number;
      valueString: components['schemas']['IntegerString'];
      /** @description The Transfer's BitGo fee (in base units) */
      payGoFee?: number;
      /** @description The Transfer's BitGo fee (in base units) represented as a String */
      payGoFeeString: string;
      /** @description Use instant sending (coin-specific) method if available */
      instant?: boolean;
      /** @description User agent used to submit the request */
      agent?: string;
      /** @description Error regarding the transaction */
      error?: string;
      /** @description Transaction fields specific to each coin type */
      coinSpecific: Record<string, never>;
      /** @description Fees (depending on the coin) used for the tx */
      feesUsed?: Record<string, never>;
    };
    /** @example 59cd72485007a239fb00282ed480da1f */
    SendQueueId: string;
    SendQueueJSON: {
      id?: components['schemas']['SendQueueId'];
      user?: components['schemas']['Id'];
      deployment?: boolean;
      coin?: components['schemas']['Coin'];
      createTime?: number;
      modifyTime?: number;
      state?: components['schemas']['SendQueueState'];
      held?: boolean;
      uniqueDoubleSpendPreventionIds?: string[];
      txid?: components['schemas']['TxId'];
      /** @description Raw txHex broadcast to fullnode */
      tx?: string;
      attempts?: number;
      /**
       * Format: date-time
       * @description Next date this sendq will be attempted to broadcast
       */
      nextAtttempt?: string;
      /** @description Max number of attempts this sendq will be attempted to brodcast */
      targetAttempts?: number;
      value?: number;
      valusString?: string;
      payGoFee?: number;
      payGoFeeString?: string;
      agent?: string;
      feesUsed?: components['schemas']['FeesUsed'];
      /** @description Properties which are specific to certain coin types */
      coinSpecific?: Record<string, never>;
      wallet?: components['schemas']['Id'];
      enterprise?: components['schemas']['Id'];
      pendingApprivalId?: string;
      address?: string;
      expireTime?: string;
      submitHeight?: number;
      confirmHeight?: number;
      comment?: string;
      instantId?: string;
      instant?: boolean;
      /** @description Response from fullnode after attempting to broadcast or a comment set during state change */
      error?: string;
      firstValidBlock?: number;
      lastValidBlock?: number;
      customNode?: Record<string, never>;
      txRequestId?: string;
      lightning?: boolean;
    };
    /**
     * @description The status of this SendQueue item
     * @example done
     * @enum {string}
     */
    SendQueueState: 'pending' | 'attempted' | 'failed' | 'done' | 'reverted' | 'held' | 'replaced' | 'abandoned';
    /**
     * Sent Transaction
     * @description This endpoint broadcasts half-signed transactions.
     */
    SendTransaction: {
      /** @description An optional memo for the transaction. */
      comment?: string;
      /** @description The half-signed transaction. The request must include this or a txHex. */
      halfSigned?: {
        txHex?: string;
      };
      /** @description The half-signed, serialized transaction hex. Alternative to sending halfSigned. */
      txHex?: string;
      /** @description Your own unique ID */
      sequenceId?: string;
      videoApprovers?: components['schemas']['VideoApprovers'];
    } & components['schemas']['BuildParams'] &
      Record<string, never>;
    Session: {
      /** Format: date-time */
      created: string;
      /** Format: date-time */
      expires: string;
      id: components['schemas']['Id'];
      /** @description IP address of the client that requested this access token */
      ip?: components['schemas']['Ip'];
      /** @description IP addresses of clients that are allowed to use this token */
      ipRestrict?: string[];
      /**
       * @description BitGo environment that issued this token
       * @example test.bitgo.com
       */
      origin: string;
      /** @description Session permissions */
      scope: components['schemas']['Scope'];
      /** @description The Unlock object, returned if this session is currently unlocked. */
      unlock?: components['schemas']['Unlock'];
      user: components['schemas']['Id'];
    };
    SettlementDetails: {
      id: components['schemas']['SettlementId'];
      settlementId?: components['schemas']['IdString'];
      brokerId: components['schemas']['BrokerId'];
      status: components['schemas']['SettlementStatus1'];
      at: components['schemas']['DateFromISOString'];
      /** @description True if the settlement request is validated/reconciled. Trades and transfers (realized netting) will only be attached to "reconciled" settlements. */
      reconciled?: boolean;
      trades: components['schemas']['BrokerTrade'][];
      netting: components['schemas']['SettlementTransferAmount'][];
    };
    /**
     * Format: uuid
     * @description settlement identifier
     */
    SettlementId: string;
    /** @description Settlement amount to transfer from one client to another */
    SettlementNetAmount: {
      toClientId: components['schemas']['ClientId'];
      fromClientId: components['schemas']['ClientId'];
      amount: components['schemas']['AssetAmount'];
    };
    SettlementNetting: components['schemas']['SettlementTransferAmount'][];
    SettlementReport: {
      at?: components['schemas']['DateFromISOString'];
      brokerId?: components['schemas']['BrokerId'];
      brokerName?: string;
      accounts?: components['schemas']['Account2'][];
      settlements?: components['schemas']['SettlementDetails'][];
    };
    /** @description Request a settlement report for the specified ids (either BitGo side or broker side ids ids). May also be filtered by a date (all settlements requested/confirmed at or after). */
    SettlementReportRequest: {
      ids?: components['schemas']['SettlementId'];
      after?: components['schemas']['DateFromISOString'];
    };
    SettlementRequest: {
      /** @description BitGo side id for settlement, broker can use it too */
      id?: components['schemas']['SettlementId'];
      /** @description Broker side id for settlement, could be same as id. Must be unique for the broker. */
      settlementId?: components['schemas']['IdString'];
      /** @description human readable notation, could be custom to broker */
      notation: string;
      /** @description time of settlement (cutoff), like end of trading day */
      at: components['schemas']['DateFromISOString'];
      settlement: components['schemas']['SettlementTrades'] | components['schemas']['SettlementNetting'];
      settlementType: components['schemas']['SettlementType'];
    };
    /** @enum {string} */
    SettlementStatus1: 'pending' | 'canceled' | 'failed' | 'confirmed';
    /**
     * @description The current status of the settlement
     * @example pending
     * @enum {string}
     */
    SettlementStatus2: 'canceled' | 'pending' | 'rejected' | 'settled' | 'failed';
    SettlementTrades: components['schemas']['TradeInput'][];
    SettlementTransferAmount: components['schemas']['SettlementNetAmount'] & {
      txId?: string;
      /** @description timestamp of transfer issuance */
      at?: components['schemas']['DateFromISOString'];
    };
    /** @enum {string} */
    SettlementType: 'gross' | 'net';
    /**
     * @example encryptedSignerShare
     * @enum {string}
     */
    ShareType: 'encryptedSignerShare';
    ShareWalletRequest: {
      /**
       * @description Comma-separated list of permissions (view, spend, admin) which are granted by this share. Required if "reshare" is false.
       * @example spend,view
       */
      permissions?: string;
      /** @description User readable message to display to the share recipient */
      message?: string;
      /** @description Flag for reinviting a user to the wallet <br/> This is required if the invitee has already been invited to the wallet, but has changed their password and needs a new invite */
      reshare?: boolean;
      /** @description Flag for disabling invite notification email */
      disableEmail?: boolean;
      user: components['schemas']['Id'];
      keychain?: components['schemas']['WalletShareKeychain'];
      /** @description If true, allows creating wallet shares without a sharing a key (keychain) when the wallet is shared with spend permission. */
      skipKeychain?: boolean;
    };
    /** @description Wallet share object */
    ShareWalletResponse: {
      id?: components['schemas']['Id'];
      coin?: components['schemas']['Coin'];
      wallet?: components['schemas']['Id'];
      walletLabel?: components['schemas']['WalletLabel'];
      fromUser?: components['schemas']['Id'];
      toUser?: components['schemas']['Id'];
      /** @example spend,view */
      permissions?: string;
      /** @description Message for the user receiving the share */
      message?: string;
      state?: string;
      enterprise?: components['schemas']['Id'];
      pendingApprovalId?: components['schemas']['Id'];
      keychain?: components['schemas']['WalletShareKeychain'];
    };
    /**
     * @description Two-letter country code, as specified by ISO 3166-1 alpha-2
     * @example US
     * @enum {string}
     */
    ShortCountryCode:
      | 'AD'
      | 'AE'
      | 'AF'
      | 'AG'
      | 'AI'
      | 'AL'
      | 'AM'
      | 'AO'
      | 'AQ'
      | 'AR'
      | 'AS'
      | 'AT'
      | 'AU'
      | 'AW'
      | 'AX'
      | 'AZ'
      | 'BA'
      | 'BB'
      | 'BD'
      | 'BE'
      | 'BF'
      | 'BG'
      | 'BH'
      | 'BI'
      | 'BJ'
      | 'BL'
      | 'BM'
      | 'BN'
      | 'BO'
      | 'BQ'
      | 'BR'
      | 'BS'
      | 'BT'
      | 'BV'
      | 'BW'
      | 'BY'
      | 'BZ'
      | 'CA'
      | 'CC'
      | 'CD'
      | 'CF'
      | 'CG'
      | 'CH'
      | 'CI'
      | 'CK'
      | 'CL'
      | 'CM'
      | 'CN'
      | 'CO'
      | 'CR'
      | 'CU'
      | 'CV'
      | 'CW'
      | 'CX'
      | 'CY'
      | 'CZ'
      | 'DE'
      | 'DJ'
      | 'DK'
      | 'DM'
      | 'DO'
      | 'DZ'
      | 'EC'
      | 'EE'
      | 'EG'
      | 'EH'
      | 'ER'
      | 'ES'
      | 'ET'
      | 'FI'
      | 'FJ'
      | 'FK'
      | 'FM'
      | 'FO'
      | 'FR'
      | 'GA'
      | 'GB'
      | 'GD'
      | 'GE'
      | 'GF'
      | 'GG'
      | 'GH'
      | 'GI'
      | 'GL'
      | 'GM'
      | 'GN'
      | 'GP'
      | 'GQ'
      | 'GR'
      | 'GS'
      | 'GT'
      | 'GU'
      | 'GW'
      | 'GY'
      | 'HK'
      | 'HM'
      | 'HN'
      | 'HR'
      | 'HT'
      | 'HU'
      | 'ID'
      | 'IE'
      | 'IL'
      | 'IM'
      | 'IN'
      | 'IO'
      | 'IQ'
      | 'IR'
      | 'IS'
      | 'IT'
      | 'JE'
      | 'JM'
      | 'JO'
      | 'JP'
      | 'KE'
      | 'KG'
      | 'KH'
      | 'KI'
      | 'KM'
      | 'KN'
      | 'KP'
      | 'KR'
      | 'KW'
      | 'KY'
      | 'KZ'
      | 'LA'
      | 'LB'
      | 'LC'
      | 'LI'
      | 'LK'
      | 'LR'
      | 'LS'
      | 'LT'
      | 'LU'
      | 'LV'
      | 'LY'
      | 'MA'
      | 'MC'
      | 'MD'
      | 'ME'
      | 'MF'
      | 'MG'
      | 'MH'
      | 'MK'
      | 'ML'
      | 'MM'
      | 'MN'
      | 'MO'
      | 'MP'
      | 'MQ'
      | 'MR'
      | 'MS'
      | 'MT'
      | 'MU'
      | 'MV'
      | 'MW'
      | 'MX'
      | 'MY'
      | 'MZ'
      | 'NA'
      | 'NC'
      | 'NE'
      | 'NF'
      | 'NG'
      | 'NI'
      | 'NL'
      | 'NO'
      | 'NP'
      | 'NR'
      | 'NU'
      | 'NZ'
      | 'OM'
      | 'PA'
      | 'PE'
      | 'PF'
      | 'PG'
      | 'PH'
      | 'PK'
      | 'PL'
      | 'PM'
      | 'PN'
      | 'PR'
      | 'PS'
      | 'PT'
      | 'PW'
      | 'PY'
      | 'QA'
      | 'RE'
      | 'RO'
      | 'RS'
      | 'RU'
      | 'RW'
      | 'SA'
      | 'SB'
      | 'SC'
      | 'SD'
      | 'SE'
      | 'SG'
      | 'SH'
      | 'SI'
      | 'SJ'
      | 'SK'
      | 'SL'
      | 'SM'
      | 'SN'
      | 'SO'
      | 'SR'
      | 'SS'
      | 'ST'
      | 'SV'
      | 'SX'
      | 'SY'
      | 'SZ'
      | 'TC'
      | 'TD'
      | 'TF'
      | 'TG'
      | 'TH'
      | 'TJ'
      | 'TK'
      | 'TL'
      | 'TM'
      | 'TN'
      | 'TO'
      | 'TR'
      | 'TT'
      | 'TV'
      | 'TW'
      | 'TZ'
      | 'UA'
      | 'UG'
      | 'UM'
      | 'US'
      | 'UY'
      | 'UZ'
      | 'VA'
      | 'VC'
      | 'VE'
      | 'VG'
      | 'VI'
      | 'VN'
      | 'VU'
      | 'WF'
      | 'WS'
      | 'YE'
      | 'YT'
      | 'ZA'
      | 'ZM'
      | 'ZW';
    /**
     * @description Side of a trade, from the perspective of the requesting user
     * @example buy
     * @enum {string}
     */
    Side: 'buy' | 'sell';
    SignatureShare: {
      /** @description The source of the signature share. */
      from: components['schemas']['KeyShareSource'];
      /** @description The recipient of the signature share. */
      to: components['schemas']['KeyShareSource'];
      /** @description The signature share. */
      share: string;
    };
    SimulateWalletWebhookRequestBody: OneOf<
      [
        {
          /** @description The ID of a transfer on the specified wallet. This must be provided if the webhook is of type "transfer". */
          transferId: components['schemas']['Id'];
        },
        {
          /** @description The ID of a pending approval on the specified wallet. This must be provided if the webhook is of type "pendingApproval". */
          pendingApprovalId: components['schemas']['Id'];
        },
        {
          /** @description The txRequestId of a transaction request on the specified wallet. This must be provided if the webhook is of type "txRequest" or "txRequestTransaction". */
          txRequestId: components['schemas']['Id'];
        }
      ]
    >;
    /**
     * @description When set to true, transactions that are exclusively sent to whitelisted
     * addresses on the same enterprise will skip circuit breaker evaluations.
     */
    SkipCircuitBreakers: boolean;
    StakeIntent: components['schemas']['BaseStakeIntent'] & {
      /** @enum {string} */
      intentType: 'stake';
    };
    StakingEventRequest: {
      /** @description For staking events, should be 'STAKING'. */
      type: string;
      /**
       * @description For staking events.
       * @enum {unknown}
       */
      subtype: 'AUTHORIZE' | 'CLAIM' | 'DELEGATE' | 'PENALTY' | 'REWARD' | 'SLASH' | 'UNDELEGATE';
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the actual staking event occured. */
      timeEventOccurred: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the client sent the event. */
      timeEventSent: string;
      /** @description The name of the service sending the event. */
      source: string;
      /** @description A cryptocurrency or token ticker symbol. */
      asset: string;
      /** @description The unit in which the asset is being represented. For staking, should be 'wei'. */
      unit: string;
      /** @description Signed number represented as string indicating the quantity of asset leaving (negative) or entering (positive) the bitgo wallet. Zero values indicating no change accepted. */
      amountDelta: string;
      /** @description Signed number represented as string indicating the quantity of asset being subtracted (negative) or added (positive) to the staking balance. Zero values indicating no change accepted. */
      stakedDelta: string;
      /** @description Nonnegative number represented as string indicating the quantity of asset currently staked, irrespective of any accured rewards or slashing penalties, i.e. even if there are no rewards accrued and a slashing penalty occurs, totalStaked should remain unchanged unless a client delagetes or undelegates more asset. Zero values indicating zero staking balance accepted. */
      totalStaked: string;
      /** @description Signed number represented as string indicating the sum of rewards and slashing penalties. If slashing penalties occur, they should be entirely reflected in rewardsBalance, even if the number must go negative. This way, we can more accurately keep track of the amount staked. Zero values indicating no change accepted. */
      rewardsBalance: string;
      /** @description The annual percentage yield, representage as a percentage. */
      apy?: string;
      /** @description The bitgo wallet address sending crypto to or receiving crypto in the staking transaction. Can be empty in the case of 'REWARD', 'SLASH', or 'UNDELEGATE'. */
      address?: string;
      /** @description The validator address sending crypto to or receiving crypto in the staking transaction. */
      validatorAddress?: string;
      /** @description The mongo id of the walletId sending crypto to or receiving crypto in the staking transaction. */
      walletId: string;
      /**
       * Format: uuid
       * @description An id used to tie together staking requests from start to finish.
       */
      stakingRequestId?: string;
      /** @description A unique identifier for the event. */
      idempotencyKey: string;
      /**
       * Format: uuid
       * @description A unique identifier for the particular delegation.
       */
      delegationId?: string;
      /** @description An identifier that links a transaction from request to completion. */
      txRequestId?: string;
      /** @description The on-chain transaction id. */
      txid?: string;
    };
    StakingEventResponse: {
      /** @description Object id in mongo. */
      id?: string;
      /** @description For staking events, should be 'STAKING'. */
      type?: string;
      /** @description For staking events, should be 'DELEGATE', 'UNDELEGATE', 'SLASH','REWARD', 'PENALTY' or 'CLAIM'. */
      subtype?: unknown;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the actual staking event occured. */
      timeEventOccurred?: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the client sent the event. */
      timeEventSent?: string;
      /** @description Datetime in accordance with https://datatracker.ietf.org/doc/html/rfc3339#section-5.6 representing the time at which the api received the event. */
      timeEventReceived?: string;
      /** @description The name of the service sending the event. */
      source?: string;
      /** @description A cryptocurrency or token ticker symbol. */
      asset?: string;
      /** @description The unit in which the asset is being represented. For staking, should be 'wei'. */
      unit?: string;
      /** @description Signed number represented as string indicating the quantity of asset leaving (negative) or entering (positive) the bitgo wallet. Zero values indicating no change accepted. */
      amountDelta?: string;
      /** @description Signed number represented as string indicating the quantity of asset being subtracted (negative) or added (positive) to the staking balance. Zero values indicating no change accepted. */
      stakedDelta?: string;
      /** @description Nonnegative number represented as string indicating the quantity of asset currently staked, irrespective of any accured rewards or slashing penalties, i.e. even if there are no rewards accrued and a slashing penalty occurs, totalStaked should remain unchanged unless a client delagetes or undelegates more asset. Zero values indicating zero staking balance accepted. */
      totalStaked?: string;
      /** @description Signed number represented as string indicating the sum of rewards and slashing penalties. If slashing penalties occur, they should be entirely reflected in rewardsBalance, even if the number must go negative. This way, we can more accurately keep track of the amount staked. Zero values indicating no change accepted. */
      rewardsBalance?: string;
      /** @description The annual percentage yield, representage as a percentage. */
      apy?: string;
      /** @description The bitgo wallet address sending crypto to or receiving crypto in the staking transaction. Can be empty in the case of 'REWARD', 'SLASH', or 'UNDELEGATE'. */
      address?: string;
      /** @description The validator address sending crypto to or receiving crypto in the staking transaction. */
      validatorAddress?: string;
      /** @description The mongo id of the walletId sending crypto to or receiving crypto in the staking transaction. */
      walletId?: string;
      /**
       * Format: uuid
       * @description A unique identifier for the event.
       */
      uuid?: string;
      /** @description The on-chain transaction id. */
      txid?: string;
    };
    /** Staking Request */
    StakingRequest: {
      /** @description Staking Request Id. */
      id: string;
      /** @description Optional clientId if passed into the request. */
      clientId?: string;
      /** @description The id of the user that created the staking request */
      requestingUserId: string;
      /** @description The id of the enterprise where the the staking request was created from */
      enterpriseId: string;
      /** @description The id of the wallet where the staking request was created from */
      walletId: string;
      /** @description Withdrawal Address */
      withdrawalAddress: string;
      /** @description The type of wallet the staking request was created from (cold, custodial, hot) */
      walletType: string;
      type: components['schemas']['StakingRequestType'];
      /** @description The coin to be staked (ETH, MATIC, NEAR, SOL) */
      coin: string;
      /**
       * Format: date-time
       * @description The date the staking request was created
       */
      createdDate: string;
      status: components['schemas']['StakingRequestStatus'];
      /** @description The last modified date the status changed */
      statusModifiedDate: string;
      /** @description The sum of the amounts of all confirmed staking transactions in this request */
      totalStaked?: components['schemas']['IntegerString'];
    };
    /**
     * Staking Request Status
     * @description The status of the staking request. For Eth the status will change from NEW to READY when a validator has been assigned to a the wallet's address.
     * @enum {string}
     */
    StakingRequestStatus:
      | 'NEW'
      | 'PENDING_VALIDATORS'
      | 'READY'
      | 'PENDING_APPROVAL'
      | 'PENDING_BITGO_TRUST_APPROVAL'
      | 'PENDING'
      | 'FAILED'
      | 'REJECTED'
      | 'VALIDATOR_ACTIVATING'
      | 'PARTIAL_CONFIRMED'
      | 'CONFIRMED'
      | 'COOLDOWN'
      | 'WARMUP';
    /**
     * Staking Request Type
     * @description The type of staking request.
     * @enum {string}
     */
    StakingRequestType: 'STAKE' | 'UNSTAKE' | 'CLAIM_REWARDS' | 'UNSUPPORTED';
    /**
     * Staking Transaction Status
     * @description The status of the transaction (NEW, READY, INITIATED, CONFIRMED, REJECTED).
     * @enum {string}
     */
    StakingTransactionStatus:
      | 'WAITING'
      | 'READY'
      | 'SENDING'
      | 'PENDING_APPROVAL'
      | 'PENDING_BITGO_TRUST_APPROVAL'
      | 'REJECTED'
      | 'PENDING'
      | 'FAILED'
      | 'CONFIRMED'
      | 'VALIDATOR_ACTIVATING';
    /**
     * Staking Transaction Type
     * @description Type of staking transaction
     * @enum {string}
     */
    StakingTransactionType: 'delegate' | 'reward' | 'undelegate' | 'withdraw_undelegated' | 'authorize' | '';
    StripeSetupResponse: {
      /** @description Public ID of the Enterprise */
      enterpriseId: components['schemas']['Id'];
      /** @description Stripe Client Secret required for setting up customer details */
      clientSecret: string;
    };
    SubmitCrosschainRecoveryTx: {
      /** @description The admin signatures for the crosschain recovery. Must reach a threshold number of signatures. */
      aokSignatures: unknown[];
      /** @description The unsigned transaction hex for the crosschain recovery. */
      txHex: string;
      /** @description The amount of funds that were mistakenly sent. */
      amount: string;
      /** @description The blockchain where the funds were mistakenly sent to. */
      wrongChainCoin: string;
      /** @description The address where the funds were sent to on the wrong chain. */
      wrongChainAddress: string;
    };
    SubmitCrosschainRecoveryTxResponse: {
      /** @description The transaction id of the crosschain recovery transaction. */
      txid: string;
    };
    TSSBackupKey: {
      commonKeychain?: string;
      id: components['schemas']['Id'];
      keyShares: components['schemas']['KeyShare'][];
      /** @enum {string} */
      status: 'created' | 'finalized';
    };
    /**
     * @description Number of milliseconds since January 1, 1970
     * @example 1537289808000
     */
    TimestampMs: number;
    TokenData: {
      /**
       * @description The type of standard of the token.
       * @example ERC721
       */
      tokenType?: string;
      /**
       * @description The quantity of token to transfer (should be 1 for ERC721).
       * @example 101
       */
      tokenQuantity?: string;
      /**
       * @description Address of the token contract which is necessary if the token is not supported on WP.
       * @example 0x3d8e90d5F403a0A18dfeeAd36E30EF95D5E1ad3a
       */
      tokenContractAddress?: string;
      /**
       * @description Name of the token as it is supported on WP.
       * @example tpolygon:name
       */
      tokenName?: string;
      /**
       * @description Id of the token to be transferred which is required for NFTs.
       * @example 123
       */
      tokenId?: string;
      /**
       * @description Number of decimal places the token uses (for fungible tokens unsupported in WP).
       * @example 18
       */
      decimalPlaces?: number;
    };
    TokenEnablement: {
      name: string;
      address?: string;
    };
    TotalBalance: {
      /**
       * @description The total balance of all wallets containing the given coin type.  May lose
       * precision for large values.
       *
       * @example 50000
       */
      balance?: number;
      /**
       * @description String representation of "balance".  Guaranteed to not lose
       * precision.
       *
       * @example 50000
       */
      balanceString?: string;
    };
    TotalBalances: {
      balances?: {
        balanceString?: components['schemas']['IntegerString'];
        coin?: components['schemas']['Coin'];
      }[];
    };
    TradeBase: {
      id?: components['schemas']['TradeId'];
      tradeAwayAmountA: components['schemas']['AssetAmount'];
      tradeAwayAmountB: components['schemas']['AssetAmount'];
      tradeValueA: components['schemas']['AssetAmount'];
      tradeValueB: components['schemas']['AssetAmount'];
      booked: components['schemas']['DateFromISOString'];
    };
    /**
     * Format: uuid
     * @description trade identifier
     */
    TradeId: string;
    TradeInput: {
      clientA?: components['schemas']['ClientId'];
      clientB?: components['schemas']['ClientId'];
    } & components['schemas']['TradeBase'];
    TradeList: {
      trades?: components['schemas']['BrokerTrade'][];
    };
    TradeSettlement: {
      /** @description Settlement ID */
      id?: string;
      /** @description status */
      status?: string;
      /** @description memo */
      memo?: string;
      /** @description Starting time of the settlement */
      startTime?: string;
      /** @description End time of the settlement */
      endTime?: string;
      /** @description Date staged at */
      stagedAt?: string;
      /** @description Date finialized at */
      finalizedAt?: string;
      /** @description Date created at */
      createdAt?: string;
      /** @description Aggregated balances */
      aggregatedBalances?: components['schemas']['TradeSettlementBalance'];
      /** @description Balances */
      balances?: components['schemas']['TradeSettlementBalance'];
      /** @description Trading orders */
      orders?: components['schemas']['TradingOrder'];
    };
    TradeSettlementBalance: {
      /** @description Settlement ID */
      id?: string;
      /** @description Account ID */
      accountId?: string;
      /** @description Currency */
      currency?: components['schemas']['TradingSupportedCurrency'];
      /** @description Staged amount */
      stagedAmount?: string;
      /** @description Settled amount */
      settledAmount?: string;
    };
    /**
     * @example pending
     * @enum {string}
     */
    TradeStatus: 'pending' | 'confirmed' | 'failed';
    TradesDefinition: components['schemas']['CustodianSnapshot'] & components['schemas']['TradeList'];
    TradesReport: {
      id?: components['schemas']['Id'];
      /**
       * @description Type of report
       * @enum {string}
       */
      type?: 'holdings' | 'transactions' | 'trades';
      /**
       * @description Format of report
       * @enum {string}
       */
      format?: 'pdf' | 'csv';
      /**
       * @description Status of report
       * @enum {string}
       */
      status?: 'pending' | 'processing' | 'completed' | 'failed';
      /**
       * Format: date-time
       * @description Date report was created
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description Date report was completed
       */
      completedAt?: string;
      /** @description Name of the report document */
      documentName?: string;
      /** @description ID of the user who requested the report */
      user?: components['schemas']['Id'];
      trades?: {
        /** @description ID of the enterprise */
        enterprise: components['schemas']['Id'];
        /**
         * Format: date-time
         * @description Date of the snapshot
         */
        startDate: string;
        /**
         * Format: date-time
         * @description Date of the snapshot
         */
        endDate: string;
        assets?: string[];
        isFillsReport?: boolean;
      };
    };
    /**
     * @description The status of the trading fill
     * @example RECORDED
     * @enum {string}
     */
    TradingFillStatus: 'IN_PROGRESS' | 'RECORDED' | 'FAILED';
    /**
     * @example {
     *   "id": "37617d48-9cd5-4d0a-8f41-b2d0bec2229b",
     *   "accountId": "37617d48-9cd5-4d0a-8f41-b2d0bec2229b",
     *   "externalClientOrderId": "37617d48-9cd5-4d0a-8f41-b2d0bec2229b",
     *   "status": "OPEN",
     *   "baseCurrency": "usd",
     *   "quoteCurrency": "usd",
     *   "side": "buy",
     *   "baseAmount": "10000",
     *   "quoteAmount": "10000",
     *   "createdAt": "2019-05-03T00:37:49.196Z"
     * }
     */
    TradingOrder: {
      /**
       * Format: uuid
       * @description The unique id of the order object
       * @example 37617d48-9cd5-4d0a-8f41-b2d0bec2229b
       */
      id?: number;
      /**
       * Format: uuid
       * @description Id generated by external source
       * @example 37617d48-9cd5-4d0a-8f41-b2d0bec2229b
       */
      externalClientOrderId?: string;
      /**
       * @description The user's account that initiated the trade
       * @example 37617d48-9cd5-4d0a-8f41-b2d0bec2229b
       */
      accountId?: string;
      /** @description Indicates the overall status of the Order */
      status?: components['schemas']['SettlementStatus2'];
      /** @description Currency type listed first in a trading pair */
      baseCurrency?: components['schemas']['TradingSupportedCurrency'];
      /** @description Currency type listed first in a trading pair */
      quoteCurrency?: components['schemas']['TradingSupportedCurrency'];
      /** @description Side of the trade the user is on */
      side?: components['schemas']['Side'];
      /**
       * @description Base currency amount to buy or sell
       * @example 100000
       */
      baseAmount?: string;
      /**
       * @description Quote currency amount to buy or sell
       * @example 100000
       */
      quoteAmount?: string;
      /**
       * Format: date-time
       * @description ISO date string
       */
      createdAt?: string;
    };
    /**
     * @example {
     *   "id": "37617d48-9cd5-4d0a-8f41-b2d0bec2229b",
     *   "orderId": "37617d48-9cd5-4d0a-8f41-b2d0bec2229b",
     *   "status": "RECORDED",
     *   "externalOrderId": "101",
     *   "externalFillId": "102",
     *   "liquiditySourceOrderId": "103",
     *   "liquiditySourceFillId": "203",
     *   "baseAmount": "10000",
     *   "quoteAmount": "10000",
     *   "liquiditySourceAccountId": "37617d48-9cd5-4d0a-8f41-b2d0bec2229b",
     *   "feeRevenueCurrency": "usd",
     *   "feeExpenseCurrency": "usd",
     *   "feeRevenueAmount": "10000",
     *   "feeExpenseAmount": "10000",
     *   "executionTime": "2019-05-03T00:37:49.196Z",
     *   "createdAt": "2019-05-03T00:37:49.196Z"
     * }
     */
    TradingOrderFill: {
      /**
       * Format: uuid
       * @description The unique id of the fill object
       * @example 37617d48-9cd5-4d0a-8f41-b2d0bec2229b
       */
      id?: string;
      /**
       * Format: uuid
       * @description The unique id of the order this fill belongs to
       * @example 37617d48-9cd5-4d0a-8f41-b2d0bec2229b
       */
      orderId?: string;
      /** @description Status of the fill */
      status?: components['schemas']['TradingFillStatus'];
      /**
       * @description Order id generated from the external source
       * @example 101
       */
      externalOrderId?: string;
      /**
       * @description Fill id generated by the external source
       * @example 101
       */
      externalFillId?: string;
      /**
       * @description Order id generated by the liquidity source
       * @example 101
       */
      liquiditySourceOrderId?: string;
      /**
       * @description Fill id generated by the liquidity source
       * @example 101
       */
      liquiditySourceFillId?: string;
      /**
       * @description Base amount that is either being bought or sold
       * @example 100000
       */
      baseAmount?: string;
      /**
       * @description Quote currency amount that is either being bought or sold
       * @example 100000
       */
      quoteAmount?: string;
      /**
       * Format: uuid
       * @description The DAS account id of the liquidity source
       * @example 37617d48-9cd5-4d0a-8f41-b2d0bec2229b
       */
      liquiditySourceAccountId?: string;
      /** @description Currency in which BitGo is taking fees */
      feeRevenueCurrency?: components['schemas']['TradingSupportedCurrency'];
      /** @description Currency in which the liquidity source is taking fees */
      feeExpenseCurrency?: components['schemas']['TradingSupportedCurrency'];
      /**
       * @description Amount of fees taken by BitGo
       * @example 100000
       */
      feeRevenueAmount?: string;
      /**
       * @description Amount of fees taken by the liquidity source
       * @example 100000
       */
      feeExpenseAmount?: string;
      /**
       * Format: date-time
       * @description ISO date string
       */
      executionTime?: string;
      /**
       * Format: date-time
       * @description ISO date string
       */
      createdAt?: string;
      order?: components['schemas']['TradingOrderFill'];
    };
    /**
     * @description The status of the trading order
     * @example CANCELED
     * @enum {string}
     */
    TradingOrderStatus: 'OPEN' | 'CANCELED' | 'FAILED' | 'COMPLETED';
    /**
     * @example {
     *   "id": "456ed60d-3fd7-4463-88ba-1e489a48c530",
     *   "primaryEnterpriseName": "Trading Partner Co.",
     *   "primaryAccountId": "585cf0c85573c3a8416ac85f",
     *   "secondaryEnterpriseName": "Requester Co.",
     *   "secondaryAccountId": "585ci0c855g3c3a8416ac85g",
     *   "status": "accepted",
     *   "type": "direct",
     *   "updatedAt": "2019-05-03T00:37:49.196Z",
     *   "requesterAccountId": "585ci0c855g3c3a8416ac85g"
     * }
     */
    TradingPartner: {
      /**
       * Format: uuid
       * @description unique ID of the trading partnership, used for updating partnerships
       */
      id?: string;
      /** @description primary account ID of the partnership */
      primaryAccountId?: string;
      /** @description enterprise name of the primary account ID */
      primaryEnterpriseName?: string;
      /** @description secondary account ID of the partnership */
      secondaryAccountId?: string;
      /** @description enterprise name of the secondary account ID */
      secondaryEnterpriseName?: string;
      status?: components['schemas']['TradingPartnerStatus'];
      type?: components['schemas']['TradingPartnerType'];
      /**
       * Format: date-time
       * @description ISO date string
       */
      updatedAt?: string;
      /** @description account ID that initiated the trading partner request */
      requesterAccountId?: string;
    };
    /**
     * @description Partnership status between two trading accounts
     * @example accepted
     * @enum {string}
     */
    TradingPartnerStatus: 'accepted' | 'rejected' | 'canceled' | 'pending' | 'unknown';
    /**
     * @description Partnership type between two trading accounts
     * @example direct
     * @enum {string}
     */
    TradingPartnerType: 'direct' | 'agency';
    /**
     * @description Requester is the primary or the secondary account in the trading partnership. e.g. If the requester wants their partner as the agent, then they are secondary account and their partner is the primary account.
     * @example primary
     * @enum {string}
     */
    TradingReferralRequesterSide: 'primary' | 'secondary';
    /**
     * @description Supported currency of a trade
     * @example usd
     * @enum {string}
     */
    TradingSupportedCurrency: 'usd' | 'btc' | 'eth' | 'xrp' | 'ltc' | 'bch';
    Transaction: {
      state: components['schemas']['TransactionState'];
      /** @description Holds the unsigned transaction for this transaction in a tx-request. */
      unsignedTx: components['schemas']['TransactionRequestUnsignedTransaction'];
      signatureShares?: components['schemas']['SignatureShare'][];
      commitmentShares?: components['schemas']['CommitmentShare'][];
      /** @description The hash of the transaction from the TxRequest that has been signed and is pending broadcast. */
      txHash?: string;
      /** @description BitGo-to-user paillier challenge. Required when signing with ECDSA TSS wallets. */
      bitgoPaillierChallenge?: {
        p?: string[];
      };
    };
    TransactionBuildRequest: components['schemas']['BuildParams'] & {
      /** @description A list of recipient addresses and amounts. Must be present but empty for child-pays-for-parent transactions. */
      recipients: {
        amount?: components['schemas']['IntegerOrIntegerString'];
        address?: components['schemas']['AddressString'];
        memo?: components['schemas']['MemoString'] | components['schemas']['MemoObject'];
      }[];
      txFormat?: components['schemas']['UtxoTransactionFormat'];
    };
    TransactionBuildResult: {
      keyDerivationPath?: string;
    };
    /** Transaction Details */
    TransactionDetails: {
      transactionStatus?: components['schemas']['TransactionStatus'];
      transactionHash?: string;
      custodianTransactionId?: string;
      txRequestId?: string;
      from?: string;
      to?: string;
      coin?: string;
      gasPrice?: string;
      maxFeePerGas?: string;
      maxPriorityFeePerGas?: string;
      gasLimit?: string;
      nonce?: string;
      value?: string;
      data?: string;
      decodedData?: components['schemas']['DecodedTransaction'];
      userId?: string;
      createdTime?: components['schemas']['DateTime'];
    };
    TransactionInitiateRequest: components['schemas']['BuildParams'] & {
      /** @description A list of recipient addresses and amounts. Must be present but empty for child-pays-for-parent transactions. */
      recipients?: {
        amount?: components['schemas']['IntegerOrIntegerString'];
        address?: components['schemas']['AddressString'];
        memo?: components['schemas']['MemoString'] | components['schemas']['MemoObject'];
      }[];
    };
    TransactionRequest:
      | components['schemas']['TransactionRequestLite']
      | components['schemas']['TransactionRequestFull'];
    TransactionRequestBase: {
      /** @description A unique ID for the TxRequest document across all wallets. The combination of the txRequestId and version will always be unique. */
      txRequestId: string;
      /** @description The version of the document. Data changes are done only with inserts and incrementing the version. */
      version: number;
      /** @description A boolean flag that indicates whether the document is the latest version of the TxRequest. */
      latest: boolean;
      /** @description The id of the Wallet the TxRequest is for. */
      walletId: string;
      /** @description The type describes who owns the keys to the wallet associated to the TxRequest. */
      walletType?: components['schemas']['WalletTypePublic'];
      /** @description If the wallet that owns the TxRequest is owned by an enterprise then this is the Id of said enterprise. */
      enterpriseId?: string;
      state: components['schemas']['TransactionRequestState'];
      /** @description The date and time this version of the TxRequest document was created. */
      date: components['schemas']['DateTime'];
      /** @description The date and time the version 1 TxRequest document was created. */
      createdDate: components['schemas']['DateTime'];
      /** @description The Id of the User that produced this version of the TxRequest document. Could have created a new document or updated an existing document. */
      userId: string;
      intent?: components['schemas']['TransactionRequestIntent'];
      intents: components['schemas']['TransactionRequestIntent'][];
      /** @description The id of the Pending Approval that was created for the TxRequest if one was required. */
      pendingApprovalId?: string;
      /** @description True, if the transaction request is canceled. */
      isCanceled?: boolean;
    };
    TransactionRequestExchangeCommitmentRequest: {
      /** @description The user or backup to bigo commitment share. */
      commitmentShare: components['schemas']['CommitmentShare'];
      /** @description The encrypted signer share. */
      encryptedSignerShare: components['schemas']['EncryptedShare'];
    };
    TransactionRequestExchangeCommitmentResponse: {
      /** @description The commitment share. */
      commitmentShare: components['schemas']['CommitmentShare'];
    };
    TransactionRequestFull: WithRequired<
      components['schemas']['TransactionRequestBase'] & {
        /** @description Transaction information. */
        transactions?: components['schemas']['Transaction'][];
        /** @description Messages for the transaction request. */
        messages?: components['schemas']['Message'][];
      },
      'txRequestId' | 'version' | 'latest' | 'walletId' | 'state' | 'date' | 'userId' | 'intent' | 'transactions'
    >;
    TransactionRequestIntent:
      | components['schemas']['AdaStakeIntent']
      | components['schemas']['ConsolidateTokenIntent']
      | components['schemas']['CosmosContractCallIntent']
      | components['schemas']['DOTClaimIntent']
      | components['schemas']['DOTPaymentIntent']
      | components['schemas']['DOTStakeIntent']
      | components['schemas']['DOTUnstakeIntent']
      | components['schemas']['ETHAccelerationIntent']
      | components['schemas']['ETHFillNonceIntent']
      | components['schemas']['ETHPaymentIntent']
      | components['schemas']['ETHSignMessageIntent']
      | components['schemas']['ETHStakingIntent']
      | components['schemas']['NearStakeIntent']
      | components['schemas']['NearUnstakeIntent']
      | components['schemas']['NearWithdrawIntent']
      | components['schemas']['SOLClaimIntent']
      | components['schemas']['SOLCreateAssociatedTokenAccountIntent']
      | components['schemas']['SOLPaymentIntent']
      | components['schemas']['SOLStakeIntent']
      | components['schemas']['SOLUnstakeIntent']
      | components['schemas']['TransferTokenIntent']
      | components['schemas']['UnstakeIntent']
      | components['schemas']['WalletRecoveryIntent']
      | components['schemas']['WithdrawIntent'];
    TransactionRequestLite: WithRequired<
      components['schemas']['TransactionRequestBase'] & {
        unsignedTxs?: components['schemas']['TransactionRequestUnsignedTransaction'][];
        signatureShares?: components['schemas']['SignatureShare'][];
        commitmentShares?: components['schemas']['CommitmentShare'][];
        txHashes?: string[];
      },
      'txRequestId' | 'version' | 'latest' | 'walletId' | 'state' | 'date' | 'userId' | 'intent'
    >;
    /** @enum {string} */
    TransactionRequestState:
      | 'initialized'
      | 'pendingApproval'
      | 'pendingUserCommitment'
      | 'pendingUserRShare'
      | 'pendingUserGShare'
      | 'readyToSend'
      | 'pendingUserSignature'
      | 'pendingDelivery'
      | 'signed'
      | 'delivered'
      | 'canceled'
      | 'rejected'
      | 'failed';
    TransactionRequestUnsignedTransaction: {
      /** @description The unsigned transaction as a hex string. */
      serializedTxHex: string;
      /** @description The portion of a transaction used to generate a signature (may or may not be the same as serializedTxHex) as a hex string. */
      signableHex: string;
      /** @description A bip32 path. */
      derivationPath?: string;
      feeInfo?: {
        feeString?: string;
        fee: number;
      };
      /** @description Coin specific information. */
      coinSpecific?: Record<string, never>;
      /** @description The parsed transaction information. */
      parsedTx?: {
        minerFee: string;
        spendAmount?: string;
        spendAmounts?: {
          coinName?: string;
          amountString?: string;
        }[];
        payGoFee?: string;
        outputs: {
          address: string;
          isPayGo?: boolean;
          value?: number;
          wallet?: string;
          walletV1?: string;
          baseAddress?: string;
          enterprise?: string;
          valueString: string;
          data?: string;
          change?: boolean;
          coinName?: string;
        }[];
        inputs: {
          derivationIndex?: number;
          value: number;
          address?: string;
          valueString: string;
          chain?: number;
          index?: number;
        }[];
        type?: string;
        memo?: string;
      };
    };
    TransactionResponse: {
      transfer?: components['schemas']['Transfer'];
      /** @description The transaction's unique identifier */
      txid?: string;
      /** @description The encoded transaction, either base64 for XLM or hex for other coins */
      tx?: string;
      status?: components['schemas']['TransferState'];
    };
    /** @enum {string} */
    TransactionState:
      | 'initialized'
      | 'pendingSignature'
      | 'eddsaPendingCommitment'
      | 'eddsaPendingRShare'
      | 'eddsaPendingGShare'
      | 'readyToCombineShares'
      | 'signed'
      | 'held'
      | 'delivered'
      | 'invalidSignature'
      | 'rejected';
    /**
     * Transaction Status
     * @enum {string}
     */
    TransactionStatus: 'policy_failed' | 'created' | 'submitted' | 'completed' | 'failed';
    TransactionsReport: {
      id?: components['schemas']['Id'];
      /**
       * @description Type of report
       * @enum {string}
       */
      type?: 'holdings' | 'transactions' | 'trades';
      /**
       * @description Format of report
       * @enum {string}
       */
      format?: 'pdf' | 'csv';
      /**
       * @description Status of report
       * @enum {string}
       */
      status?: 'pending' | 'processing' | 'completed' | 'failed';
      /**
       * Format: date-time
       * @description Date report was created
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description Date report was completed
       */
      completedAt?: string;
      /** @description Name of the report document */
      documentName?: string;
      /** @description ID of the user who requested the report */
      user?: components['schemas']['Id'];
      transactions?: {
        /** @description ID of the enterprise */
        enterprise: components['schemas']['Id'];
        /**
         * Format: date-time
         * @description Date of the snapshot
         */
        startDate: string;
        /**
         * Format: date-time
         * @description Date of the snapshot
         */
        endDate: string;
        wallets?: components['schemas']['Id'][];
        walletTypes?: string[];
        assets?: string[];
        isDetailed?: boolean;
      };
    };
    Transfer: {
      coin: components['schemas']['Coin'];
      id: components['schemas']['Id'];
      wallet: components['schemas']['Id'];
      enterprise?: components['schemas']['Id'];
      txid: components['schemas']['TxId'];
      /**
       * @description The type of the transaction id
       * @enum {string}
       */
      txidType?: 'transactionHash' | 'blockHash';
      /** @description The height of the block this Transfer was confirmed in (999999999 if unconfirmed) */
      height: number;
      /** @description The unique height id of the block */
      heightId?: string;
      /**
       * Format: date-time
       * @description The date this Transfer was last updated
       */
      date: string;
      /**
       * @description Defines whether or not this Transfer was sent or received by the user
       * @enum {string}
       */
      type: 'send' | 'receive';
      /** @description The total value (in base units) sent by this Transfer (may be approximate for ETH and other coins where amounts in base units can exceed 2^53 - 1) */
      value?: number;
      valueString: components['schemas']['IntegerString'];
      /** @description A string representation (in base units) of the initial value for the transfer. This is present because when a transaction fails on chain, its value is mutated to be zero. This string is immutable and will always be the intended value of the initial transfer regardless of the final state of the transaction. */
      intendedValueString?: components['schemas']['IntegerString'];
      /** @description The value (in base units) sent by this transfer, excluding network fees. BitGo is deprecating this field in the future. Instead, use baseValueWithoutFees. */
      baseValue?: number;
      baseValueString?: components['schemas']['IntegerString'];
      /** @description The value (in base units) sent by this transfer excluding network fees. */
      baseValueWithoutFees?: number;
      baseValueWithoutFeesString?: components['schemas']['IntegerString'];
      /** @description The Transfer's fee (in base units) represented as a String */
      feeString?: string;
      /** @description The Transfer's BitGo fee (in base units) */
      payGoFee?: number;
      /** @description The Transfer's BitGo fee (in base units) represented as a String */
      payGoFeeString?: string;
      /** @description The amount of USD of this Transfer (will be negative if it's a send) */
      usd: number;
      /** @description The USD price at the time this Transfer was created */
      usdRate: number;
      state: components['schemas']['TransferState'];
      /** @description The tags to be used on this Transfer (used in Policies) */
      tags: components['schemas']['Id'][];
      /** @description An audit log of events that have happened to the Transfer during its lifecycle */
      history: {
        /**
         * Format: date-time
         * @description The date of this history object
         */
        date?: string;
        user?: components['schemas']['Id'];
        /** @enum {string} */
        action?:
          | 'created'
          | 'signed'
          | 'unconfirmed'
          | 'confirmed'
          | 'approved'
          | 'commented'
          | 'removed'
          | 'failed'
          | 'rejected';
        /** @description If this history object is of action "commented", this is the comment from the user */
        comment?: string;
      }[];
      /** @description A comment from the user */
      comment: string;
      /** @description The size of the transaction */
      vSize?: number;
      /** @description Transfer fields specific to each coin type */
      coinSpecific: Record<string, never>;
      /** @description A "sequenceId" is a unique and arbitrary wallet identifier applied to transfers and transactions at creation. It is optional but highly recommended. With a "sequenceId" you can easily reference transfers and transactions&mdash;for example, to safely retry sending. Because the system only confirms one send request per "sequenceId" (and fails all subsequent attempts), you can retry sending without the risk of double spending. The "sequenceId" is only visible to users on the wallet and is not shared publicly. */
      sequenceId?: string;
      /** @description An array of objects describing the change in address balances made as a result of this Transfer */
      entries?: {
        /**
         * @description An address affected by this Transfer
         * @example 2NAUwNgXaoFj2VVnSEvNLGuez8CfdU2UCMZ
         */
        address?: string;
        wallet?: components['schemas']['Id'];
        /** @description The change (in base units) in the address's balance */
        value?: number;
        valueString?: components['schemas']['IntegerString'];
        /** @description True if this address is a change address (only exists for UTXO coins) and if this is a "sent" Transfer */
        isChange?: boolean;
        /** @description True if this address is the BitGo PayGo wallet */
        isPayGo?: boolean;
        /**
         * @description If this is a token entry, the token's symbol
         * @example omg
         */
        token?: string;
        /** @description Names of addresses given by the user. */
        label?: string;
        /** @description true if this entry is failed. */
        failed?: boolean;
      }[];
      /** @description Whether BitGo already sent notifications to the users of the transfer wallet */
      usersNotified?: boolean;
      /** @description Address labels (if any) from entries concatenated. */
      label?: string;
    };
    /**
     * @description The status of this Transfer
     * @example confirmed
     * @enum {string}
     */
    TransferState: 'signed' | 'unconfirmed' | 'confirmed' | 'pendingApproval' | 'removed' | 'failed' | 'rejected';
    /** Transfer Token */
    TransferTokenIntent: components['schemas']['BaseIntent'] & {
      /** @enum {string} */
      intentType?: 'transferToken';
      recipients?: components['schemas']['RecipientEntry'][];
    };
    TransfersResponse: {
      transfers: components['schemas']['AnnotatedTransferWithInputsOutputs'][];
      coin: components['schemas']['Coin'];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
    };
    /** @description Address balance details */
    TrimmedBalance: {
      /** Format: date-time */
      updated?: string;
      balance?: number;
      balanceString?: string;
      confirmedBalanceString?: string;
      spendableBalanceString?: string;
      totalReceived?: number;
      totalSent?: number;
      transferCount?: number;
    };
    Trustline: {
      /**
       * @description One of the supported coin types for Stellar tokens listed in [Coin-specific-implementation](#tag/Coin-specific-implementation)
       * @example txlm:BST-GBQTIOS3XGHB7LVYGBKQVJGCZ3R4JL5E4CBSWJ5ALIJUHBKS6263644L
       */
      token?: string;
      /** @enum {unknown} */
      action?: 'add' | 'remove';
      /** @description String representation of the amount to limit in base units (stroops) */
      limit?: components['schemas']['IntegerString'];
    };
    TssConfig: {
      /**
       * @description The enterprise ID
       * @example 5d1a61a5c30ae10025f9b2b3
       */
      enterpriseId: string;
      ecdsa: {
        challenge: components['schemas']['ChallengePartyConfig'];
      };
    };
    TxAddress: {
      address: string;
      options?: Record<string, never>;
    };
    /**
     * @description Serialized transaction base64 (applies to XLM only)
     * @example AAAAAGRnXg19FteG/7zPd+jDC7LDvRlzgfFC+JrPhRep0kYiAAAAZAB/4cUAAAACAAAAAAAAAAAAAAABAAAAAQAAAABkZ14NfRbXhv+8z3fowwuyw70Zc4HxQviaz4UXqdJGIgAAAAEAAAAAmljT/+FedddnAHwo95dOC4RNy6eVLSehaJY34b9GxuYAAAAAAAAAAAehIAAAAAAAAAAAAUrgwAkAAABAOExcvVJIUJv9HuVfbV0y7lRPRARv4wDtcdhHG7QN40h5wQ2uwPF52OGQ8KY+66a1A/8lNKB75sgj2xj44s8lDQ==
     */
    TxBase64: string;
    /**
     * @description Serialized transaction hex
     * @example 01000000000101d58f82d996dd872012675adadf4606734906b25a413f6e2ee535c0c10aef96020000000000ffffffff028de888000000000017a914c91aa24f65827eecec775037d886f2952b73cbe48740420f000000000017a9149304d18497b9bfe9532778a0f06d9fff3b3befaf870500473044022023d7210ba6d8bbd7a28b8af226f40f7235caab79156f93f9c9969fc459ea7f73022050fbdca788fba3de686b66b3501853695ff9d6f375867470207d233b099576e001000069522103d4788cda52f91c1f6c82eb91491ca76108c9c5f0839bc4f02eccc55fedb3311c210391bcef9dcc89570a79ba3c7514e65cd48e766a8868eca2769fa9242fdcc796662102ef3c5ebac4b54df70dea1bb2655126368be10ca0462382fcb730e55cddd2dd6a53aec8b11400
     */
    TxHex: string;
    /**
     * @description The on-chain transaction id
     * @example b8a828b98dbf32d9fd1875cbace9640ceb8c82626716b4a64203fdc79bb46d26
     */
    TxId: string;
    /** @enum {string} */
    Type: 'find' | 'count' | 'distinct';
    Unlock: {
      /** Format: date-time */
      time?: string;
      /** Format: date-time */
      expires?: string;
      txCount?: number;
      txValue?: number;
    };
    UnlockRequest: {
      /**
       * @description Number of seconds that the session will stay unlocked
       * @default 600
       */
      duration?: number;
      otp?: components['schemas']['Otp'];
    };
    Unspent: {
      id?: components['schemas']['UnspentId'];
      /**
       * @description The address of this unspent
       * @example 2MsKxhhkDo5WaLaYRGA9Cr3iSQPyXsu6Fi2
       */
      address?: string;
      value?: number;
      valueString?: components['schemas']['IntegerString'];
      /** @description The block this Unspent was created in */
      blockHeight?: number;
      /**
       * Format: date-time
       * @description The date this unspent was created
       * @example 2017-03-25T23:01:40.248Z
       */
      date?: string;
      /** @description True if this unspent came from the coinbase transaction */
      coinbase?: boolean;
      wallet?: components['schemas']['Id'];
      fromWallet?: components['schemas']['Id'];
      /**
       * @description The type of this unspent's address (P2SH, P2WSH, etc...)
       * @example 0
       */
      chain?: number;
      /** @description A monotonic counter used when creating new addresses */
      index?: number;
      /**
       * @description The Script program used to cryptographically verify spending this unspent
       * @example 522102f1e990044d2a8be43d5b500bbdcb36277b97a4b07e01c5101ae8ec1568bfd6532103dab7dc82f2fc8c28200c1bdeca9c4cf181e0ca257395829cbd599395048afb57210205422e711827d8356f2fb75334d863941dd7eb45bd5788fa231dc5fa755135b653ae
       */
      redeemScript?: string;
      /**
       * @description The segwit Script program used to cryptographically verify spending this unspent
       * @example 52210351311cd81144e6cbdba561d24dfc22644cb02d053339d4beace03231b3be4f372103a8d0c1a375b9ee1a2411f9f8e18373be7f228b18260f63bbfca48809170ed08b2103c3bd8bd074657bbe9ee6714b31a4a54b6fd5b5cda0e1030122f9bf46b5034f6b53ae
       */
      witnessScript?: string;
      isSegwit?: boolean;
    };
    /**
     * @description The id of the unspent in the form \<txid\>:\<tx_index\>
     * @example 003f688cc349f1fca8ac5ffa21671ca911b6ef351085c60733ed8c2ebf162cb8:2
     */
    UnspentId: string;
    /** Generic Unstake */
    UnstakeIntent: components['schemas']['BaseStakeIntent'] & {
      /** @enum {string} */
      intentType: 'unstake';
    };
    UpdateAddressRequest: {
      /** @description New label which should apply to this address. The caller needs admin permissions for the associated wallet if the label already has a value. Otherwise view or spend permissions are fine because the label has not been set yet. This is due to the fact that customers use address labels to associate addresses with their customers. */
      label?: components['schemas']['AddressLabel'];
    };
    /** @description Updates some fields on a bank account. The server only allows updating of bank accounts that have their verificationState set to "rejected". Does not allow updating of critical fields like accountNumber, enterpriseId, id, routingNumber, swiftCode. */
    UpdateBankAccount: {
      /** @example 2390 El Camino Real */
      address1?: string;
      /** @example Palo Alto, CA 94306 */
      address2?: string;
      /** @example */
      address3?: string;
      /** @example America California Bank */
      name?: string;
      /** @description Bank account owner */
      owner?: {
        /** @example Donald E. Knuth */
        name?: string;
        /** @example Computer Science Department */
        address1?: string;
        /** @example Stanford University */
        address2?: string;
        /** @example Stanford, CA 94305-9045 */
        address3?: string;
      };
      shortCountryCode?: components['schemas']['ShortCountryCode'];
      /**
       * @description Has to be set to "pending" for a the server to process the changes. Any changes will require a new review from an operator.
       * @enum {string}
       */
      verificationState: 'pending';
    };
    /** Request body for update case status */
    UpdateCaseReq: {
      status?: components['schemas']['PersonaCaseStatusEnum'];
      lastStatusProduced?: components['schemas']['PersonaCaseStatusEnum'] | null;
    };
    /** Response body for update case */
    UpdateCaseResponse: {
      caseId: string;
      status: components['schemas']['PersonaCaseStatusEnum'];
      inquiryId?: string;
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      updatedAt?: string;
      lastStatusProduced?: string;
      /** Format: date-time */
      lastStatusProducedAt?: string;
      /** Format: date-time */
      webhookReceivedAt?: string;
    };
    UpdateCircuitBreaker: {
      enforced?: boolean;
      /** @description If set, this circuit breaker applies to wallets in the given enterprise */
      enterpriseId?: unknown;
      name?: string;
      usdLimit?: {
        /** @description USD limit for all transfers out of a wallet within the given time window */
        value?: number;
        window?: components['schemas']['Duration'];
      };
      /** @description If set, this circuit breaker applies to a single wallet */
      walletId?: unknown;
    };
    UpdateCommentRequest: {
      /** @description The new comment for the transfer. */
      comment?: string;
    };
    UpdateEnterprise: {
      legalIdentifiers?: components['schemas']['LegalIdentifiers'];
      additionalEnterpriseInfo?: components['schemas']['AdditionalEnterpriseInfo'];
      /** @description How many Enterprise Admins are required for action to fire */
      approvalsRequired?: number;
      distributedCustody?: components['schemas']['DistributedCustodyUpdateEnterprise'];
      /** @description Allow users to view all wallets */
      usersViewAllWallets?: boolean;
    };
    /** @description If the id is provided for any element, that date range will be updated. If the id is excluded, a new date range will be inserted. */
    UpdateEnterprisePricingTypeKits: {
      activeKits?: components['schemas']['EnterpriseActiveKits'];
      /** @description The list of pricingTypes to update. A maximum of 2 is expected. */
      activePricingTypes?: ({
        /** @description The id of the active date range (activePricingType.id).  If specified the existing date range will be updated.  If excluded a new date range will be inserted. */
        id?: string;
      } & components['schemas']['EnterpriseActivePricingType'])[];
    };
    UpdateEnterprisePricingTypeKitsResponse: {
      pricingTypes?: components['schemas']['EnterprisePricingTypes'];
      kits?: components['schemas']['EnterpriseKits'];
      activePricingType?: components['schemas']['EnterpriseActivePricingType'];
      activeKits?: components['schemas']['EnterpriseActiveKits'];
    };
    UpdateEnterpriseTssEcdsaChallengeConfigRequest: {
      enterprise: components['schemas']['RangeProofConfig'];
      bitgoNitroHsm: {
        verifiers: components['schemas']['Verifiers'];
      };
      bitgoInstitutionalHsm: {
        verifiers: components['schemas']['Verifiers'];
      };
    };
    UpdateEnterpriseTssEcdsaChallengeConfigResponse: {
      enterprise: components['schemas']['RangeProofConfig'];
      bitgoNitroHsm: components['schemas']['RangeProofConfig'];
      bitgoInstitutionalHsm: components['schemas']['RangeProofConfig'];
    };
    /** @description This could be broken down further with updateStatus itemized for each particular updateType. */
    UpdateNotificationBroker: {
      /** @description client id - unique to wallet/broker relationship */
      clientId: components['schemas']['IdString'];
      updateTime: components['schemas']['DateFromISOString'];
      /** @enum {string} */
      updateType: 'accountUpdateToBroker,' | 'assetUpdateToBroker,' | 'deallocationToBroker,';
      /** @enum {string} */
      updateStatus: 'canceled' | 'confirmed' | 'failed' | 'pending' | 'requested';
      referenceId?: string;
    };
    UpdateNotificationsAppsRequest: {
      /** @enum {string} */
      serviceId: 'broker';
      walletId: components['schemas']['WalletId'];
      updateTime: components['schemas']['DateFromISOString'];
      updateType: components['schemas']['NotificationUpdateType'];
      brokerBookId?: components['schemas']['BrokerBookId'];
    };
    UpdateRemovePolicyRule: {
      coin?: components['schemas']['Coin'];
      /** @description The id of the rule. The combination of id and coin must be unique among rules in the policy. */
      id: string;
      type: components['schemas']['PolicyRuleTriggers'];
      condition?: components['schemas']['PolicyRuleUpdateConditions'];
      action: components['schemas']['PolicyRuleActions'];
    };
    UpdateSendLabel: {
      /** @description A human-readable mapping to an address */
      label: string;
    };
    UpdateSession: {
      /** @description Set to true to extend the access token life by half an hour */
      extend?: boolean;
      otp: components['schemas']['Otp'];
    };
    UpdateTSSBackupKey: {
      commonKeychain: string;
      keyShares: components['schemas']['KeyShare'][];
    };
    UpdateTradeHttpRequestBody: {
      trade?: components['schemas']['TradeInput'];
    };
    UpdateTransactionRequest: {
      /**
       * @description For transaction request full, the current state must be "pendingApproval" or "pendingDelivery". For transaction request lite, the current state must be "pendingApproval", "pendingUserCommitment", "pendingUserGShare", "pendingUserRShare", or "pendingUserSignature".
       *
       * @enum {string}
       */
      state: 'canceled';
    };
    /**
     * @example deallocate
     * @enum {string}
     */
    UpdateType: 'deallocate' | 'suspend' | 'unsuspend';
    UpdateUserSettingsRequest: {
      settings?: components['schemas']['UserSettings'];
    };
    UpdateWallet: {
      approvalsRequired?: components['schemas']['ApprovalsRequired'];
      buildDefaults?: components['schemas']['WalletBuildDefaults'];
      disableTransactionNotifications?: boolean;
      label?: components['schemas']['WalletLabel'];
      customChangeKeySignatures?: components['schemas']['CustomChangeKeySignatures'];
      coinSpecific?: components['schemas']['WalletUpdateCoinSpecific'];
    };
    UpdateWalletShareResponse: {
      /** @description New state of the wallet share after update */
      state?: components['schemas']['WalletShareState'];
      changed?: boolean;
    };
    User: {
      id?: components['schemas']['Id'];
      isActive?: boolean;
      name?: components['schemas']['Name'];
      username?: components['schemas']['Email'];
      email?: {
        email?: components['schemas']['Email'];
        /** @example true */
        verified?: boolean;
      };
      phone?: {
        /** @example 408-718-6885 */
        phone?: string;
        /** @example true */
        verified?: boolean;
      };
      /** @example USA */
      country?: string;
      /** @example New York */
      state?: string;
    };
    UserAdminResponse: {
      users: components['schemas']['User'][];
    };
    /**
     * @example {
     *   "password": "9b162742759416251d41b6947b020aacbed02f9d",
     *   "oldPassword": "ec38b1eb8aef049951156f25ff3de31fcd7c7fa5",
     *   "version": 1,
     *   "keychains": {
     *     "xpub661MyMwAqRbcGiQhVk1J7cD1YodF9tc5Y1B8vpTjjB1pcB1J1m1QX8fMtYP2sYqFmW6J2ra69tNoARKjvTGo9cGUrbPbJdjwrSzGGzPzWWS": "{\"iv\":\"lT1Ja0Ww7NRFTE4cvIv7pQ==\",\"v\":1,\"iter\":10000,\"ks\":256,\"ts\":64,\"mode\":\"ccm\",\"adata\":\"\",\"cipher\":\"aes\",\"salt\":\"SADv19qbloE=\",\"ct\":\"7H+itJxJ8/2o+Eg0Mz3ADw==\"}"
     *   },
     *   "v2_keychains": {
     *     "xpub661MyMwAqRbcFPos4Ne5ugVgtpJ8i6KhqR1vcKps1TYQMFKCnsCKbvpEWoxynHLvsdgsX4P3ZRb53T7EEKPsEDiruxFAz3zhLxsk9JXD5Bi": "{\"iv\":\"lT1Ja0Ww7NRFTE4cvIv7pQ==\",\"v\":1,\"iter\":10000,\"ks\":256,\"ts\":64,\"mode\":\"ccm\",\"adata\":\"\",\"cipher\":\"aes\",\"salt\":\"SADv19qbloE=\",\"ct\":\"7H+itJxJ8/2o+Eg0Mz3ADw==\"}",
     *     "GA34NPQ4M54HHZBKSDZ5B3J3BZHTXKCZD4UFO2OYZERPOASK4DAATSIB": "{\"iv\":\"lT1Ja0Ww7NRFTE4cvIv7pQ==\",\"v\":1,\"iter\":10000,\"ks\":256,\"ts\":64,\"mode\":\"ccm\",\"adata\":\"\",\"cipher\":\"aes\",\"salt\":\"SADv19qbloE=\",\"ct\":\"7H+itJxJ8/2o+Eg0Mz3ADw==\"}",
     *     "xpub661MyMwAqRbcGeMfLEMkpjuQ9vuvYgqqsaTMavoCE18KknyGRhtBzhDjbPnMPrTDHm2FisXfm7WLq5vdjEq43VUZeccPdbBmTFUio7g2PkT": "{\"iv\":\"lT1Ja0Ww7NRFTE4cvIv7pQ==\",\"v\":1,\"iter\":10000,\"ks\":256,\"ts\":64,\"mode\":\"ccm\",\"adata\":\"\",\"cipher\":\"aes\",\"salt\":\"SADv19qbloE=\",\"ct\":\"7H+itJxJ8/2o+Eg0Mz3ADw==\"}"
     *   }
     * }
     */
    UserChangePasswordRequest: {
      /**
       * @description The updated user login password. Note that this should **not** be provided in plaintext,
       * and instead should be given as a HMAC using the username as the key, and the password as the input.
       */
      password: string;
      /**
       * @description The current user login password. Note that this should **not** be provided in plaintext,
       * and instead should be given as a HMAC using the username as the key, and the password as the input.
       */
      oldPassword: string;
      /** @description Keychain version counter. */
      version?: number;
      /**
       * @description V1 keychains which match the user login password and should be updated.
       *
       * Each key in this object should be a public key, and each value should be the corresponding encrypted private key.
       */
      keychains?: {
        [key: string]: string;
      };
      /**
       * @description V2 keychains which match the user login password and should be updated.
       *
       * Each key in this object should be a public key, and each value should be the corresponding encrypted private key.
       *
       * **Note:** Public keys are not validated, and if a public key is not found in the database, it will be skipped.
       */
      v2_keychains?: {
        [key: string]: string;
      };
    };
    UserDetails: {
      enterprises?: {
        /** @example Premium Fund 1 */
        name?: string;
        id?: components['schemas']['Id'];
        /** @example legacy10 */
        pricingPlan?: string;
      }[];
    };
    UserIdOrMe: string;
    UserInstitutionalSignupRequest: {
      email: string;
      password: string;
      accountType: string;
      salesforceBitgoOrg: string;
      salesforceAccountId: string;
      salesforceOpportunityId: string;
      salesEmail?: string;
      products?: string[];
      hash?: string;
    };
    UserInstitutionalSignupResponse: {
      user: {
        username?: string;
        userID?: string;
      };
      requestId: string;
    };
    UserKyc: {
      /**
       * @description KYC verification is available for this user
       * @example true
       */
      available?: boolean;
      /** @description Personal user data */
      data?: {
        fields?: {
          address?: string;
          address2?: string;
          city?: string;
          /**
           * @description ISO 3166-1 Alpha-3 country code
           * @example USA
           */
          country?: string;
          /**
           * @description Date of birth
           * @example {}
           */
          dob?: string;
          firstName?: string;
          lastName?: string;
          /**
           * @description ISO 3166-1 Alpha-3 country code
           * @example USA
           */
          nationality?: string;
          /**
           * @description short code of the state (see /api/v2/countries)
           * @example CA
           */
          state?: string;
          /**
           * @description postal code / zip code
           * @example 94306
           */
          zip?: string;
        };
        state?: components['schemas']['UserKycState'];
      };
      /** @description Submitted identity documents */
      documents?: {
        state?: components['schemas']['UserKycState'];
      };
      /**
       * @description Number of failed attempts of automatic KYC verifications
       * @example 1
       */
      failureCount?: number;
      /**
       * @description User has done initial video ID
       * @example true
       */
      hasVideoID?: boolean;
      /** @description Passport verification */
      passport?: {
        /**
         * @description User is required to provide a passport for ID verification
         * @example true
         */
        required?: boolean;
        state?: components['schemas']['UserKycState'];
      };
      overallState?: components['schemas']['UserKycState'];
      /** @description Submitted proof of residency documents */
      residency?: {
        state?: components['schemas']['UserKycState'];
      };
      /**
       * @description Sanction screening is required for this user
       * @example true
       */
      required?: boolean;
      /**
       * @description ID verification and proof of residency is required for this user
       * @example true
       */
      fullyRequired?: boolean;
    };
    /** @enum {string} */
    UserKycState: 'approved' | 'flagged' | 'flagged_retry_allowed' | 'inreview' | 'pending' | 'rejected' | 'unverified';
    /** Reset user password */
    UserResetPasswordRequest: {
      /** @description Random string verification code that gets appended to the link in the email */
      code: string;
      email: components['schemas']['Email'];
      /** @description New user password */
      password: string;
      /** @description Password encryption version */
      version: number;
      /**
       * @description ISO 3166-1 Alpha-3 country code
       * @example USA
       */
      country?: string;
      /**
       * @description date of birth in the format YYYY-MM-DD
       * @example 1994-01-31T00:00:00.000Z
       */
      dob?: string;
      /** @description First name of new user */
      firstName?: string;
      /** @description Last name of new user */
      lastName?: string;
    };
    UserSettings: {
      /**
       * @description A collection of properties that can be set and read by API clients,
       * for the purpose of persisting client-side user settings.
       * These properties do not affect server behavior.
       *
       * @example {
       *   "name": "Joe",
       *   "age": 12,
       *   "parents": [
       *     {
       *       "name": "Jim",
       *       "age": 41
       *     },
       *     {
       *       "name": "Sue",
       *       "age": 38
       *     }
       *   ]
       * }
       */
      client?: Record<string, never>;
    };
    UserSettingsResponse: {
      settings?: components['schemas']['User'] & components['schemas']['UserSettings'];
    };
    UserSharingKey: {
      email: components['schemas']['Email'];
    };
    UserSignUpRequest: {
      password: string;
      email: string;
      signupDomain?: string;
      signupInfo?: string;
      utm_source?: string;
      utm_campaign?: string;
      app_referral?: string;
      source?: string;
    };
    UserSignUpResponse: {
      user: {
        username?: string;
        userID?: string;
      };
      requestId: string;
    };
    UsersResponse: {
      users: components['schemas']['User'][];
    };
    /** @description feeInfo (UTXO) */
    UtxoFeeInfo: {
      /**
       * @description Estimated size of the transaction in bytes
       * @example 776
       */
      size?: number;
      /**
       * @description Estimated fee in base unit for the transaction
       * @example 38800
       */
      fee?: number;
      feeRate?: components['schemas']['IntegerOrString'];
      /**
       * @description BitGo fee of the transaction (in base units)
       * @example 0
       */
      payGoFee?: number;
      /**
       * @description BitGo fee of the transaction (in base units) represented as a String
       * @example 0
       */
      payGoFeeString?: number;
    };
    /**
     * @description Format of the returned transaction hex serialization.
     * "legacy" for serialized transaction in custom bitcoinjs-lib format. "psbt" for BIP174 serialized transaction
     * @default legacy
     * @example legacy
     * @enum {string}
     */
    UtxoTransactionFormat: 'legacy' | 'psbt';
    /** @description txInfo (UTXO) */
    UtxoTxInfo: {
      changeAddresses?: components['schemas']['AddressString'][];
      /**
       * @description Number of outputs
       * @example 2
       */
      nOutputs?: number;
      /** @example 0 */
      nP2SHInputs?: number;
      /** @example 1 */
      nSegwitInputs?: number;
      unspents?: components['schemas']['Unspent'][];
      walletAddressDetails?: components['schemas']['Address'];
    };
    V1Keychain: {
      xpub?: components['schemas']['Pub'];
      /** @example /0/0 */
      path?: string;
      params?: {
        /** @example 02b910dc08af71a28648e4e1efd3bb851587aad7b87fd0ba73ffc50467d0b85b75 */
        pubkey?: string;
        /** @example a7e22c7bb28727f49ccf1c04b4371a8d79cf286ee6a018fb8ea4bc454023e498 */
        chaincode?: string;
        /** @example 0 */
        depth?: number;
        /** @example 0 */
        index?: number;
        /** @example 0 */
        parentFingerprint?: number;
      };
    };
    V1PendingApproval: {
      id?: components['schemas']['Id'];
      /** @description The Id of the associated enterprise */
      enterprise?: components['schemas']['Id'];
      /**
       * @description The base address of the associated wallet
       * @example 1G47mSr3oANXMafVrR8UC4pzV7FEAzo3r9
       */
      walletId?: string;
      /** @description The Id of the User that created the Pending Approval */
      creator?: components['schemas']['Id'];
      /** Format: date-time */
      createDate?: string;
      info?: {
        /** @enum {string} */
        type?:
          | 'bitcoinAddressWhitelistRequest'
          | 'userChangeRequest'
          | 'policyRuleRequest'
          | 'dailyLimitPolicyRequest'
          | 'transactionRequest'
          | 'tagUpdateRequest'
          | 'updateEnterpriseRequest'
          | 'updateApprovalsRequiredRequest';
        updateEnterpriseRequest?: {
          /** @enum {string} */
          action?: 'add' | 'remove';
          permissions?: components['schemas']['EnterprisePermission'][];
          /** @description The Id of the User to be added to or removed from the Enterprise */
          userId?: components['schemas']['Id'];
          /** @description E-Mail address of newly added users */
          email?: components['schemas']['Email'];
        };
        updateApprovalsRequiredRequest?: {
          /** @description the number of approvalsRequired that should be changed to */
          requestedApprovalsRequired?: number;
        };
      };
      /** @enum {string} */
      state?: 'pending' | 'approved' | 'rejected';
      /** @description an array of all the Users on the Wallet who need to see this Pending Approval */
      walletUserIds?: components['schemas']['Id'][];
      approvalsRequired?: number;
      resolvers?: {
        user?: string;
        date?: string;
        /** @enum {string} */
        resolutionType?: 'pending' | 'approved' | 'rejected';
        signatures?: string[];
        videoApprover?: string;
        videoLink?: string;
        videoException?: string;
      }[];
    };
    V1PendingApprovals: {
      pendingApprovals?: components['schemas']['V1PendingApproval'][];
    };
    V1Wallet: {
      id?: components['schemas']['AddressString'];
      label?: components['schemas']['WalletLabel'];
      /**
       * @description Wallet is not deleted
       * @example true
       */
      isActive?: boolean;
      /**
       * @description Wallet type
       * @example safehd
       */
      type?: string;
      /** @description Wallet is frozen */
      freeze?: {
        /** Format: dateTime */
        time?: string;
        /** Format: dateTime */
        expires?: string;
      };
      /**
       * @description Number of admins on the wallet
       * @example 1
       */
      adminCount?: number;
      /**
       * @description Flag for disabling wallet transaction notifications
       * @example false
       */
      disableTransactionNotifications?: boolean;
      /** @description contains summarised version of keychains */
      private?: {
        keychains?: components['schemas']['V1Keychain'][];
      };
      /**
       * @description boolean indicating if wallet is eligible to send instant transactions backed by BitGo’s guarantee against double spends
       * @example true
       */
      canSendInstant?: boolean;
      /**
       * @description user's permissions on this wallet
       * @example admin,spend,view
       */
      permissions?: string;
      /** @description policy information on the wallet's administrators */
      admin?: {
        policy?: components['schemas']['Policy'];
        users?: {
          user?: components['schemas']['Id'];
          permissions?: components['schemas']['WalletPermission'];
        }[];
      };
      tags?: components['schemas']['Id'][];
      approvalsRequired?: components['schemas']['ApprovalsRequired'];
      /** @example true */
      spendingAccount?: boolean;
      pendingApprovals?: components['schemas']['V1PendingApproval'][];
      /**
       * @description the balance, including transactions with 0 confirmations
       * @example 39564772124
       */
      balance?: number;
      /** @example 39564772124 */
      spendableConfirmedBalance?: number;
      /**
       * @description the confirmed balance
       * @example 39564772124
       */
      confirmedBalance?: number;
      /** @example 39564772124 */
      spendableBalance?: number;
      /** @example 0 */
      sent?: number;
      /** @example 39564772124 */
      received?: number;
      /** @example 0 */
      unconfirmedSends?: number;
      /** @example 0 */
      unconfirmedReceives?: number;
    };
    V1WalletAddressLabel: {
      walletId: string;
      address: string;
      /** @description Label for this address. */
      label: string;
    };
    V1WalletShare: {
      id?: components['schemas']['Id'];
      walletId?: components['schemas']['Id'];
      walletLabel?: components['schemas']['WalletLabel'];
      fromUser?: components['schemas']['Id'];
      toUser?: string;
      /** @description Comma-separated list of permissions which are granted by this share. */
      permissions?: string;
      /** @description User readable message to display to the share recipient */
      message?: string;
      state?: components['schemas']['WalletShareState'];
      enterprise?: components['schemas']['Id'];
    };
    V1WalletTx: {
      id?: components['schemas']['Id'];
      walletId?: components['schemas']['AddressString'];
      toAddress?: components['schemas']['AddressString'];
      transactionId?: components['schemas']['TxId'];
      date?: components['schemas']['DateTime'];
      createdDate?: components['schemas']['DateTime'];
      confirmedDate?: components['schemas']['DateTime'];
      /** @description The total value in base units (satoshis) */
      amount?: number;
      /** @description The US Dollar value of the amount at the point of creation */
      btcusd?: number;
      state?: components['schemas']['TransferState'];
      /** @description BitGo instant transaction */
      instant?: boolean;
      /** @description BitGo instant fee in base units (satoshis) */
      instantFee?: number;
      /** @description BitGo fee in base units (satoshis) */
      bitgoFee?: number;
      fee?: number;
      comment?: string;
      creator?: string;
      history?: {
        /**
         * Format: date-time
         * @description The date of this history object
         */
        date?: string;
        user?: components['schemas']['Id'];
        /** @enum {string} */
        action?:
          | 'created'
          | 'signed'
          | 'unconfirmed'
          | 'confirmed'
          | 'approved'
          | 'commented'
          | 'removed'
          | 'failed'
          | 'rejected';
        /** @description If this history object is of action "commented", this is the comment from the user */
        comment?: string;
      }[];
      /** @description pending approval id, if exists */
      pendingApproval?: string;
    };
    V1WalletTxsResponse: {
      transactions?: components['schemas']['V1WalletTx'][];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
    };
    V1WalletsResponse: {
      wallets?: components['schemas']['V1Wallet'][];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
    };
    ValidateReorgedBlock: {
      /** @description Whether the block exists in the IMS */
      exists?: boolean;
      /** @description Whether the block has the correct "reverted" state */
      validState?: boolean;
      /** @description The total number of transactions found in the block */
      txCount?: number;
      /** @description The total number of valid transactions found in the block */
      validTxCount?: number;
      /** @description Invalid transactions found in the block */
      invalidTxns?: {
        /** @description Whether the transaction exists in the IMS */
        exists?: boolean;
        /** @description The transaction hash */
        txHash?: string;
        /** @description The hash of the block that the transaction belongs to */
        blockHash?: string;
        /** @description Whether the transaction has a "reverted" state of "true" */
        reverted?: boolean;
      }[];
      /** @description The block's hash */
      blockHash?: string;
      /** @description The hash of the block's parent */
      parentHash?: string;
    };
    ValidateReorgsRequest: {
      /** @description The height of the reorged block */
      reorgedBlockHeight?: number;
      /** @description The hash of the reorged block */
      blockHash?: string;
      /** @description The depth of the re-org (e.g. 2 for a 2-block re-org) */
      depth?: number;
    };
    ValidateReorgsResponse: {
      /** @description The height of the blocks */
      blockHeight?: number;
      /** @description The distance of the blocks from the furthest blocks in the reorg */
      blockDepth?: number;
      /** @description The state of the reorged block in the IMS */
      reorgedBlock?: components['schemas']['ValidateReorgedBlock'];
      /** @description The state of the canonical block in the IMS */
      canonicalBlock?: components['schemas']['ValidateReorgedBlock'];
    }[];
    Verifiers: {
      /** @description The admin signature is a hex string. Users should verify that the admin signature matches for the range proof challenge. */
      adminSignature: string;
    };
    /** @description A list of public ids of users that should do the video id verification for the transaction that is being sent or initiated. */
    VideoApprovers: components['schemas']['Id'][];
    /**
     * @description Whether the customer has waived the need for Video ID on low risk withdrawals.
     * @example true
     */
    VideoIdWaived: boolean;
    /**
     * @description All users on the enterprise can view all enterprise wallets, even if they are not viewers on the wallet itself
     * @example true
     */
    ViewAllWallets: boolean;
    Wallet: {
      admin?: {
        policy?: components['schemas']['Policy'];
      };
      allowBackupKeySigning?: boolean;
      approvalsRequired: components['schemas']['ApprovalsRequired'];
      balanceString?: components['schemas']['IntegerString'];
      buildDefaults?: components['schemas']['WalletBuildDefaults'];
      coin: components['schemas']['Coin'];
      coinSpecific?: components['schemas']['WalletCoinSpecific'];
      /** @description The associated custodial wallet object */
      custodialWallet?: Record<string, never>;
      custodialWalletId?: components['schemas']['Id'];
      deleted: boolean;
      disableTransactionNotifications: boolean;
      enterprise?: components['schemas']['Id'];
      freeze?: {
        /** Format: dateTime */
        time?: string;
        /** Format: dateTime */
        expires?: string;
      };
      id: components['schemas']['Id'];
      isCold?: boolean;
      keys?: components['schemas']['Keys'];
      label: components['schemas']['WalletLabel'];
      m?: components['schemas']['NumSignatures'];
      n?: components['schemas']['NumKeychains'];
      nodeId?: components['schemas']['Id'];
      receiveAddress?: components['schemas']['Address'];
      recoverable?: boolean;
      tags?: components['schemas']['Id'][];
      spendableBalanceString?: components['schemas']['IntegerString'];
      /**
       * @description Number of unspent outputs present in the wallet
       * @example 100
       */
      unspentCount?: number;
      startDate?: components['schemas']['DateTime'];
      type?: components['schemas']['WalletTypePublic'];
      users?: components['schemas']['WalletUser'][];
      customChangeKeySignatures?: components['schemas']['CustomChangeKeySignatures'];
      multisigType?: components['schemas']['WalletMultisigType'];
    };
    WalletBalance: components['schemas']['Balance'] & {
      /** @description Object of key value pairs where the keys are the token symbols (e.g. omg) and the values are the balance data for that token symbol. */
      tokens?: {
        [key: string]: {
          /** @example 30000 */
          balanceString?: string;
          /** @example 20000 */
          confirmedBalanceString?: string;
          /**
           * @description The difference between the balanceString and the spendableBalanceString.
           * @example 10000
           */
          heldBalanceString?: string;
          /** @example 20000 */
          spendableBalanceString?: string;
          /** @example 20000 */
          stakedBalanceString?: string;
          /** @example 100 */
          transferCount?: number;
        };
      };
      /** @description Object of key value pairs where the keys are the unsupported token contracts (e.g. 0x9928e4046d7c6513326ccea028cd3e7a91c7590a) and the values are the balance data for that token contract. UnsupportedTokens will only be returned for wallets that supports Metamask Institutional and has enableMMI flag turned on */
      unsupportedTokens?: {
        [key: string]: {
          /** @example 30000 */
          balanceString?: string;
          /** @example 20000 */
          confirmedBalanceString?: string;
          /**
           * @description The difference between the balanceString and the spendableBalanceString.
           * @example 10000
           */
          heldBalanceString?: string;
          /** @example 20000 */
          spendableBalanceString?: string;
          /** @example 20000 */
          stakedBalanceString?: string;
          /** @example 100 */
          transferCount?: number;
        };
      };
    };
    WalletBuildDefaults: {
      /**
       * @description (UTXO only) Wallet-level minimum fee rate that must be greater than or equal to the default of 1000 satoshis/kvByte. Per transaction, you can override "minFeeRate" with the "feeRate" parameter.
       *
       * @example 12000
       */
      minFeeRate?: number;
      /**
       * @description (UTXO only) The default script type to use for change for this wallet. Per transaction, you override the default with the "changeAddressType" parameter. If "default" is provided, it will clear the "changeAddressType" default on the wallet. Note that each UTXO coin has different address types available. For example, Only BTC supports "p2tr".
       *
       * @example p2sh
       * @enum {string}
       */
      changeAddressType?: 'p2sh' | 'p2shP2wsh' | 'p2wsh' | 'p2tr' | 'p2trMusig2' | 'default';
    };
    WalletCoinSpecific: OneOf<
      [
        {
          /** @description Includes list of fail initialization txids */
          creationFailure?: components['schemas']['TxId'][];
          /** @description Whether the wallet needs to be initialized on the chain */
          pendingChainInitialization?: boolean;
        },
        components['schemas']['WalletCoinSpecificCosmos'],
        components['schemas']['WalletCoinSpecificXlm']
      ]
    >;
    WalletCoinSpecificCosmos: {
      /**
       * @description Wallet address to send or receive assets.
       * @example cosmos1uvrgkp82dmeks368d7g2ejzm3axhapzveh5uek
       */
      rootAddress: string;
      /**
       * @description Index of last address that was derived.
       * @example 1
       */
      lastChainIndex?: number;
      /**
       * @description A running counter of the last known memo id. The first one is 0.
       * @example 0
       */
      lastMemoId: string;
      /**
       * @description If true, this wallet cannot sign transactions or messages as the enterprise has not finished tss setup.
       * @example false
       */
      pendingEcdsaTssInitialization?: boolean;
    };
    WalletCoinSpecificXlm: {
      /**
       * @description Root address of the wallet
       * @example GCTTCPH4IIDK7P72FFAEJ3ZFN6WDHJH6GGMRPHPM56ZWGIQ7B3XTIJAM
       */
      rootAddress?: string;
      /**
       * @description Username for the user's Stellar address
       * @example foo_bar@baz.com
       */
      stellarUsername?: string;
      /**
       * @description Home domain of a Stellar account
       * @example bitgo.com
       */
      homeDomain?: string;
      /**
       * @description Email-like address associated to a Stellar account
       * @example foo_bar@baz.com*bitgo.com
       */
      stellarAddress?: string;
    };
    WalletConsolidateUnspentsResponse: {
      txHex?: components['schemas']['TxHex'] | components['schemas']['PsbtHex'];
      txInfo?: components['schemas']['UtxoTxInfo'];
      feeInfo?: components['schemas']['UtxoFeeInfo'];
    };
    WalletCountResponse: {
      count: number;
    };
    WalletCreateCoinSpecific: {
      xlm?: components['schemas']['WalletCreateCoinSpecificXlm'];
      txlm?: components['schemas']['WalletCreateCoinSpecificXlm'];
    };
    WalletCreateCoinSpecificXlm: {
      /**
       * @description Username for the user's Stellar address. It's case insensitive, and it can't be changed after it's set.
       * @example foo_bar@baz.com
       */
      stellarUsername?: string;
    };
    WalletCrossChainUnspents: components['schemas']['CrossChainUnspent'][];
    /**
     * @description A custom address can be provided for EOS wallets. It must be exactly 12 alphanumeric characters.
     * @example ivxzn3bdn4uo
     */
    WalletCustomAddress: string;
    WalletCustomNodeRequest: {
      /** @description platform public id for custom node */
      nodeId?: components['schemas']['Id'];
    };
    WalletFlag: {
      /**
       * @description The unique name of the Wallet Flag
       * @example isStaking
       * @enum {string}
       */
      name: 'isStaking' | 'lightning' | 'musigKp' | 'trackingInscriptions' | 'lockedAmount' | 'rbf';
      /**
       * @description The current value of the Wallet Flag
       * @example true
       */
      value: string;
    };
    /** @example 59cd72485007a239fb00282ed480da1f */
    WalletId: string;
    /** @example My Wallet */
    WalletLabel: string;
    WalletLimit: {
      coin: components['schemas']['Coin'];
      limit?: number;
      count: number;
      /** @enum {boolean} */
      isCustodial?: true;
    };
    WalletLimitsResponse: components['schemas']['WalletLimit'][];
    WalletMaximumSpendable: {
      coin?: components['schemas']['Coin'];
      /** @example 19948310 */
      maximumSpendable?: string;
    };
    /** @enum {string} */
    WalletMultisigType: 'onchain' | 'tss' | 'blsdkg';
    WalletNotFound: components['schemas']['PlatformErrorNoName'] & {
      /**
       * @description Error code
       * @enum {string}
       */
      name: 'WalletNotFound';
    };
    /** @enum {string} */
    WalletPermission: 'admin' | 'view' | 'spend';
    WalletRebalanceEvent: {
      id?: components['schemas']['Id'];
      /** @description Trust operator user ID that initiated the creation. */
      creator?: components['schemas']['Id'];
      createDate?: components['schemas']['DateTime'];
      /** @description The ObjectId of the wallet that should be rebalanced. */
      sourceWalletId?: components['schemas']['Id'];
      clonedWallets?: components['schemas']['ClonedWallet'][];
      /**
       * @description The maximum allowed wallet balance in USD that the source and all clone wallets should be under once  the rebalacing.
       * is done.
       */
      targetWalletBalanceUSDString?: string;
      /** @description A list of basic information about all the transactions the rebalance would create. */
      plannedTransactions?: components['schemas']['PlannedTransaction'][];
      /** @description Total fees estimate for initializing all wallets + transaction fees. */
      totalFeeEstimate?: string;
      state?: components['schemas']['RebalanceState'];
      rebalanceErrors?: components['schemas']['RebalanceError'][];
      pendingApprovals?: string[];
    };
    /** Wallet Recovery */
    WalletRecoveryIntent: {
      intentType: string;
      /**
       * @description A "sequenceId" is a unique and arbitrary wallet identifier applied to transfers and transactions at creation. It is optional but highly recommended. With a "sequenceId" you can easily reference transfers and transactions&mdash;for example, to safely retry sending. Because BitGo only confirms one send request per "sequenceId" (and fails all subsequent attempts), you can retry sending without the risk of double spending. The "sequenceId" is only visible to users on the wallet and is not shared publicly. It is the responsibility of the caller to keep track of this ID.
       *
       * @example abc123
       */
      sequenceId?: string;
      /** @description The "comment" is only visible to users on the wallet and is not shared publicly. */
      comment?: string;
    };
    WalletShare: {
      id: components['schemas']['Id'];
      coin: components['schemas']['Coin'];
      wallet: components['schemas']['Id'];
      walletLabel: components['schemas']['WalletLabel'];
      fromUser: components['schemas']['Id'];
      toUser: components['schemas']['Coin'];
      /**
       * @description Comma-separated list of permissions which are granted by this share.
       * @example spend,view
       */
      permissions: string;
      /** @description User readable message to display to the share recipient */
      message: string;
      state: components['schemas']['WalletShareState'];
      enterprise: components['schemas']['Id'];
      /** @description Only set if this wallet share is currently pending approval */
      pendingApprovalId?: components['schemas']['Id'];
      /** @description Only set if this wallet share has an associated keychain */
      keychain?: {
        /** @description Sharing user's root public key */
        pub?: string;
        /** @description Sharing user's private key encrypted under their wallet passphrase */
        encryptedPrv?: string;
        /** @description Sharing user's derived public key which will be used to calculate the wallet sharing secret. */
        fromPubKey?: string;
        /** @description Shared-to user's derived public key which will be used to calculate the wallet sharing secret. */
        toPubKey?: string;
        /**
         * @description BIP32 HD path of the derived public keys (fromPubKey and toPubKey)
         * @example m/1234/1/1
         */
        path?: string;
      };
    };
    /** @description Key passed to the receiving user, included if the wallet was shared with spend permission */
    WalletShareKeychain: {
      /** @description One of wallet pub (onchain), commonPub (BLS) or commonKeychain (TSS) */
      pub?: string;
      /** @description Private key of the user sharing the wallet encrypted under their wallet passphrase */
      encryptedPrv?: string;
      /** @description Derived public key of the user sharing the wallet */
      fromPubKey?: string;
      /** @description Derived public key of the user receiving the share */
      toPubKey?: string;
      /**
       * @description BIP32 HD path of the derived public keys (fromPubKey and toPubKey)
       * @example m/1234/1/1
       */
      path?: string;
    };
    /**
     * @example active
     * @enum {string}
     */
    WalletShareState: 'pendingapproval' | 'active' | 'accepted' | 'canceled' | 'rejected';
    WalletSharesCount: {
      /** @description The total number of wallet shares, per enterprise, that the current user is the receiver */
      walletSharesCount: number;
    };
    WalletSharesCountByEnterprise: {
      enterprises: {
        [key: string]: components['schemas']['WalletSharesCount'];
      };
    };
    WalletSpending: {
      velocityLimitSpending?: {
        coin?: components['schemas']['Coin'];
        timeWindow?: components['schemas']['IntegerString'];
        limitAmountString?: components['schemas']['IntegerString'];
        amountSpentString?: components['schemas']['IntegerString'];
      }[];
    };
    WalletTypeAll: components['schemas']['WalletTypePublic'] | 'backing';
    /**
     * @description The type describes who owns the keys to the wallet and how they are stored. "cold" wallets are wallets where the private key of the user key is stored exclusively outside of BitGo's system. "custodial" means that this wallet is a cold wallet where BitGo owns the keys. Only customers of the BitGo Trust can create this kind of wallet. "custodialPaired" means that this is a hot wallet that is owned by the customer but it will be linked to a cold (custodial) wallet where BitGo owns the keys. This option is only available to customers of BitGo Inc. BitGo stores an encrypted private key for the user key of "hot" wallets. "trading" wallets are trading accounts where the coin is "ofc". "distributedCustody" means You manage one key and another key agent manages the second key. BitGo manages the third key
     * @enum {string}
     */
    WalletTypePublic: 'cold' | 'custodial' | 'custodialPaired' | 'hot' | 'trading' | 'distributedCustody';
    WalletUnspents: {
      coin?: components['schemas']['Coin'];
      unspents?: components['schemas']['Unspent'][];
    };
    WalletUpdateCoinSpecific: {
      eth?: components['schemas']['WalletUpdateCoinSpecificEth'];
      teth?: components['schemas']['WalletUpdateCoinSpecificEth'];
    };
    WalletUpdateCoinSpecificEth: {
      deployForwardersManually?: boolean;
      flushForwardersManually?: boolean;
    };
    /**
     * @example {
     *   "user": "55e8a1a5df8380e0e30e20c6",
     *   "permissions": [
     *     "admin",
     *     "view",
     *     "spend"
     *   ]
     * }
     */
    WalletUser: {
      user?: components['schemas']['Id'];
      permissions?: components['schemas']['WalletPermission'][];
    };
    WalletsInternalResponse: {
      wallets: components['schemas']['Wallet'][];
    };
    WalletsResponse: {
      wallets: components['schemas']['Wallet'][];
      nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
      totalCount?: number;
    };
    WalletsWithCoinResponse: components['schemas']['WalletsResponse'] & {
      coin: components['schemas']['Coin'];
    };
    Webhook: {
      id?: components['schemas']['Id'];
      /** @example Test Webhook */
      label?: string;
      created?: components['schemas']['DateTime'];
      coin?: components['schemas']['Coin'];
      type?: components['schemas']['WebhookTypeWallet'];
      /**
       * Format: uri
       * @example https://your.server.com/webhook
       */
      url: string;
      /**
       * @description 2 for coins running on API v2.
       * @example 2
       */
      version?: number;
      /** @example 6 */
      numConfirmations?: number;
      /**
       * @description If "active", indicates the webhook can trigger and send to the URL. If "suspended", indicates the webhook can't trigger.
       * @example active
       * @enum {string}
       */
      state?: 'active' | 'suspended';
      lastAttempt?: components['schemas']['DateTime'];
      failingSince?: components['schemas']['DateTime'];
      /** @example 0 */
      successiveFailedAttempts?: number;
      walletId?: string;
      allowBlockedHosts?: boolean;
      allToken?: boolean;
      /** @description If present, only transaction request state changes from the list will trigger notifications. If not present, all transaction request state changes will trigger notifications. */
      txRequestStates?: components['schemas']['TransactionRequestState'][];
      /** @description If present, only transaction request transaction state changes from the list will trigger notifications. If not present, all transaction request transaction state changes will trigger notifications. */
      txRequestTransactionStates?: components['schemas']['TransactionState'][];
    };
    WebhookNotification: {
      id?: components['schemas']['Id'];
      webhook?: components['schemas']['Id'];
      updateAt?: components['schemas']['DateTime'];
      coin?: components['schemas']['Coin'];
      type?: components['schemas']['WebhookTypeWallet'];
      /**
       * Format: uri
       * @example https://your.server.com/webhook
       */
      url: string;
      /** @example 2 */
      version?: number;
      /**
       * @description If "failed", webhook notification failed to connect with the target URL. If "new", webhook notification was newly generated, in response to an event. If "pending", webhook notification is awaiting processing by the webhook worker. If "processed", webhook notification successfully sent to target URL. If "unconfirmed", webhook notification is awaiting confirmation on the blockchain.
       * @example new
       * @enum {string}
       */
      state?: 'failed' | 'new' | 'pending' | 'processed' | 'unconfirmed';
    };
    /**
     * @example block
     * @enum {string}
     */
    WebhookTypeBlock: 'block' | 'wallet_confirmation';
    /**
     * @description Event type to listen to.
     * @example transfer
     * @enum {string}
     */
    WebhookTypeWallet:
      | 'txRequest'
      | 'txRequestTransaction'
      | 'transfer'
      | 'transaction'
      | 'pendingapproval'
      | 'address_confirmation'
      | 'lowFee';
    /** Generic claim unstake */
    WithdrawIntent: components['schemas']['BaseStakeIntent'] & {
      /** @enum {string} */
      intentType: 'claim';
    };
    /** @description feeInfo (XLM) */
    XlmFeeInfo: {
      /**
       * @description Height of the ledger that provided the values
       * @example 123456
       */
      height?: number;
      /**
       * @description Base network fee per transaction operation
       * @example 100
       */
      xlmBaseFee?: string;
      /**
       * @description Base reserve used to calculate the minimum balance required by the network
       * @example 5000000
       */
      xlmBaseReserve?: string;
    };
    /** @description txInfo (XLM) */
    XlmTxInfo: {
      /**
       * @description Network fee
       * @example 100
       */
      fee?: number;
      operations?: {
        /**
         * @description Amount in Lumens as string
         * @example 10.5
         */
        amount?: string;
        asset?: {
          /** @example XLM */
          code?: string;
        };
        /** @example GCNFRU774FPHLV3HAB6CR54XJYFYITOLU6KS2J5BNCLDPYN7I3DOMIPY */
        destination?: string;
        /**
         * @example payment
         * @enum {string}
         */
        type?: 'payment' | 'createAccount';
      }[];
      /** @example 35995558267060226 */
      sequence?: string;
      /** @example GBSGOXQNPULNPBX7XTHXP2GDBOZMHPIZOOA7CQXYTLHYKF5J2JDCF7LT */
      source?: string;
    };
    kit: {
      /** @enum {string} */
      kitType?: 'bitGoKit' | 'partnerKit';
      licenses: (components['schemas']['EnterpriseLicenses'] | components['schemas']['EnterpriseLicenseFlags'])[];
      requirements?: {
        kits?: components['schemas']['EnterpriseKitName'][];
        needsKyc?: boolean;
        oneOfPricingType?: components['schemas']['EnterprisePricingType'][];
        bitgoOrg?: {
          oneOf?: components['schemas']['BitGoOrg'][];
          canCreateTradingAccounts?: boolean;
        };
      };
    };
    pricingType: {
      pricingType: components['schemas']['EnterprisePricingType'];
      accountFees: components['schemas']['DeveloperProductFee'][];
      kits: {
        kitName: components['schemas']['EnterpriseKitName'];
        active?: boolean;
        fees: components['schemas']['DeveloperProductFee'][];
      }[];
      promotions: components['schemas']['DeveloperPromotions'];
    }[];
  };
  responses: {
    /** @description Bad Request */
    BadRequest: {
      content: {
        'application/json': components['schemas']['GeneralError'] | components['schemas']['ValidationError'];
      };
    };
    /** @description Forbidden */
    Forbidden: {
      content: {
        'application/json': components['schemas']['GeneralError'];
      };
    };
    /** @description The specified resource was not found */
    NotFound: {
      content: {
        'application/json': components['schemas']['GeneralError'];
      };
    };
    /** @description Server Error - Transient error please try again */
    ServerError: {
      content: {
        'application/json': components['schemas']['GeneralError'];
      };
    };
    /** @description Unauthorized */
    Unauthorized: {
      content: {
        'application/json': components['schemas']['GeneralError'];
      };
    };
  };
  parameters: {
    /** @description Filter by address string */
    address?: components['schemas']['AddressString'];
    /** @description Address or Id which will be used for information lookup */
    addressOrId: string;
    /** @description Filter by AuditLog type */
    auditLogType?: components['schemas']['AuditLogType'][];
    /** @description Filter by bitgoOrg */
    bitgoOrg?: components['schemas']['BitGoOrg'];
    /** @description Filter by bitgoOrg */
    bitgoOrgUrlSafe?: components['schemas']['BitGoOrgUrlSafe'];
    /** @description Filter by address chain. May be given multiple times. */
    chain?: components['schemas']['Chain'];
    /** @description Filter by coin */
    coin?: components['schemas']['Coin'];
    /** @description Filter by coin */
    coinArray?: components['schemas']['Coin'][];
    /** @description Filter by coin(s) */
    coinSingleOrList?: components['schemas']['Coin'][];
    /** @description Filter by key curve */
    keyCurve?: components['schemas']['KeyCurve'];
    pathId: components['schemas']['Id'];
    pathIdOrPub: components['schemas']['IdOrPub'];
    pathBankAccountId: components['schemas']['Id'];
    pathCircuitBreakerId: components['schemas']['Id'];
    pathApprovalId: components['schemas']['Id'];
    pathShareId: components['schemas']['Id'];
    pathUnspentId: components['schemas']['UnspentId'];
    pathWalletId: components['schemas']['Id'];
    pathReportId: components['schemas']['Id'];
    pathSendQueueId: components['schemas']['Id'];
    pathAddressId: components['schemas']['Id'];
    pathChainAddress: components['schemas']['AddressString'];
    pathRecoveryId: components['schemas']['Id'];
    pathEnterpriseId: components['schemas']['Id'];
    pathOrganizationId: components['schemas']['Id'];
    /** @description Filter by enterprise */
    queryEnterpriseIdOrPersonal?: components['schemas']['Id'] | 'personal';
    /** @description Filter by id */
    queryIdArray?: components['schemas']['Id'][];
    /** @description Filter by wallet */
    queryWalletArray?: components['schemas']['Id'][];
    /** @description Filter by address */
    queryAddressArray?: components['schemas']['AddressString'][];
    /** @description Filter by enterprise */
    queryEnterpriseArray?: components['schemas']['Id'][];
    /** @description Filter by enterprise */
    queryEnterpriseIdArray?: components['schemas']['Id'][];
    /** @description Filter by user */
    queryUserArray?: components['schemas']['Id'][];
    /** @description Returns unspents exported from the source chain. If not provided, returns outputs from all chains. */
    querySourceChain?: 'P' | 'C';
    pathUserId: components['schemas']['Id'];
    pathUserIdOrMe: components['schemas']['UserIdOrMe'];
    /**
     * @description a transfer or transaction id
     * @example f5d8ee39a430901c91a5917b9f2dc19d6d1a0e9cea205b009ca73dd04470b9a5 or 585951a5df8380e0e3063e9f12345678
     */
    pathTransferId: components['schemas']['Id'] | components['schemas']['TxId'];
    /** @description A "sequenceId" is a unique and arbitrary wallet identifier applied to transfers and transactions at creation. It is optional but highly recommended. With a "sequenceId" you can easily reference transfers and transactions&mdash;for example, to safely retry sending. Because the system only confirms one send request per "sequenceId" (and fails all subsequent attempts), you can retry sending without the risk of double spending. The "sequenceId" is only visible to users on the wallet and is not shared publicly. */
    pathSequenceId: string;
    pathCoin: components['schemas']['Coin'];
    pathBitcoin: components['schemas']['Bitcoin'];
    pathAlgorand: components['schemas']['ConsolidationCoins'];
    pathAddress: components['schemas']['AddressString'];
    pathV1WalletId: components['schemas']['AddressString'];
    pathWebhookId: components['schemas']['Id'];
    pathCustomNodeId: components['schemas']['Id'];
    /** @example test*bitgo.com */
    queryFederationQ: string;
    /** @example name */
    queryFederationType: 'name' | 'id';
    /** @description Maximum number of results to return.  If the result set is truncated, use the "nextBatchPrevId" value to get the next batch. */
    limit?: number;
    /** @description Number of documents to skip for offset-based pagination. Default is 0. */
    offset?: number;
    /** @description The starting index number to list from. Default is 0. */
    skip?: number;
    /** @description If true, adds "addressLabels" to each returned pending approval associated with recipient's addresses */
    expandAddressLabels?: boolean;
    feeRate?: number;
    /** @description Filter by enterprise */
    enterprise?: components['schemas']['Id'];
    /** @description Filter by enterprise */
    enterpriseId?: components['schemas']['Id'];
    /** @description Sets the target estimated number of blocks for a confirmation */
    numBlocks?: number;
    maxFeeRate?: number;
    /** @description Defines a period of time */
    period?: components['schemas']['Period'];
    /** @description Defines an output format */
    format?: components['schemas']['Format'];
    reportType?: components['schemas']['ReportType'];
    /** @description Defines a timezone to which reports timestamps are converted */
    reportsTimezone?: components['schemas']['ReportsTimezone'];
    /** @description Defines a unit of currency */
    currencyUnit?: components['schemas']['CurrencyUnit'];
    /** @description Defines the symbol prefix for a unit of currency */
    currencySymbol?: string;
    /** @description Defines a start date */
    start?: components['schemas']['TimestampMs'];
    customReportFields?: components['schemas']['CustomReportFields'];
    /** @description Enforces "minConfirms" on change inputs */
    enforceMinConfirmsForChange?: boolean;
    /** @description the state of wallet share object */
    walletShareState?: components['schemas']['WalletShareState'];
    /** @description True, if returning pending approvals that are actionable by the current user. */
    actionable?: boolean;
    /** @description Minimum value of each unspent in base units (e.g. satoshis). For doge, only string is allowed. */
    minValue?: components['schemas']['IntegerOrIntegerString'];
    /** @description Maximum value of each unspent in base units (e.g. satoshis). For doge, only string is allowed. */
    maxValue?: components['schemas']['IntegerOrIntegerString'];
    /** @description Minimum block height of the unspents */
    minHeight?: number;
    /** @description The block or ledger height */
    height?: components['schemas']['IntegerString'];
    /** @description DEPRECATED. Mutually exclusive with "chains". Returns only "p2shP2wsh" unspents/addresses on true. Returns only "p2sh" unspents/addresses on false. Equivalent to passing 10 and 11 as the only value in "chains" on true, 0 and 1 on false. */
    segwit?: boolean;
    /** @description Minimum number of confirmations for the collected inputs. Only applies to external unspents. Use "enforceMinConfirmsForChange" to filter change as well. */
    minConfirms?: number;
    pathPolicyUniqueId: components['schemas']['Id'];
    /** @description Return the next batch of results, based on the "nextBatchPrevId" value from the previous batch. */
    prevId?: components['schemas']['Id'];
    /**
     * @description Query for "Wallets" with a label containing this string
     * @example My very first wallet
     */
    searchLabelWallets?: string;
    /** @description Filter on sending or receiving "Transfers" */
    type?: 'send' | 'receive';
    transactionIdx: string;
    messageIdx: string;
    /** @description Filter by wallet */
    wallet?: components['schemas']['Id'];
    /** @description Filter by wallet */
    walletId?: components['schemas']['Id'];
    /** @description Filter by wallets. */
    walletIds?: components['schemas']['Id'][];
    /** @description Filter by Policy name. */
    name?: string;
    /** @description Only return rules created up to this date. */
    createdDateLte?: string;
    /** @description Only return rules created from this date. */
    createdDateGte?: string;
    /** @description Filter by wallet type. Must not be used in conjunction with walletId. */
    walletType?: components['schemas']['WalletTypePublic'];
    /**
     * @description Scopes of the returned policy rules. One or more may be provided.
     *
     * @example wallet.segregated
     */
    scopeName?: string[];
    /** @description Statuses of the returned policy rules, one or more may be provided. */
    policyRuleStatus?: ('ACTIVE' | 'INACTIVE')[];
    /**
     * @description The touch points of the returned policy rules. One or more may be provided.
     * @example wallet.segregated.transfer
     */
    touchpoints?: string[];
    /**
     * @description How many policy rules to return per page of results. If the result set is truncated, use the "nextBatchPrevId" value to get the
     * next batch. Default: 20, Maximum: 100.
     *
     * @example 20
     */
    psLimit?: number;
    /**
     * @description Return the next batch of results, based on the "nextBatchPrevId" value from the previous batch.
     * @example 20
     */
    psPrevId?: string;
    /** @description If provided, only transaction requests in a particular signing stage will be returned. */
    tssUserSigningStage?: '1-eddsa' | '2-eddsa' | '3-eddsa' | '1-ecdsa' | '2-ecdsa' | '3-ecdsa';
    /** @description If provided, only the latest transaction request version will be returned. */
    txRequestLatest?: boolean;
    /** @description If provided, only transaction requests of the specified state will be returned. */
    txRequestStates?: components['schemas']['TransactionRequestState'][];
    /** @description If provided, only transaction requests specified will be returned. */
    txRequestIds?: string[];
    /** @description Sorts order by field in specified sort direction, default ascending. */
    txRequestSortDirection?: 'ASC' | 'DESC';
    /** @description Sorts by specified field, default sorting by id. */
    txRequestSortBy?: 'id' | 'createdDate';
    /** @description If provided, only transaction requests with the matching idempotencyKeys will be returned. */
    idempotencyKeys?: string[];
    /** @description A "sequenceId" is a unique and arbitrary wallet identifier applied to transfers and transactions at creation. It is optional but highly recommended. With a "sequenceId" you can easily reference transfers and transactions&mdash;for example, to safely retry sending. Because the system only confirms one send request per "sequenceId" (and fails all subsequent attempts), you can retry sending without the risk of double spending. The "sequenceId" is only visible to users on the wallet and is not shared publicly. */
    sequenceIds?: string[];
    /** @description Required when sending to a BitGo wallet. */
    destinationTag?: string;
    /**
     * @description Include data for all subtokens (i.e. ERC20 Tokens, Stellar Tokens)
     * @example true
     */
    allTokens?: boolean;
    /**
     * @description True, if including unspent count for UTXO-based coins.
     * @example true
     */
    unspentCount?: boolean;
    /** @description The status of this Transfer */
    state?: components['schemas']['TransferState'][];
    /** @description Include wallets that have "deleted" or "creationFailed" set to **true** */
    showAllWallets?: boolean;
    /** @description Include v1 wallets which have been migrated to a v2 wallet */
    includeMigrated?: boolean;
    /** @description Return transfers with a "value" that is greater than or equal to the given number */
    valueGte?: number;
    /** @description Return transfers with a "value" that is less than the given number */
    valueLt?: number;
    /** @description Return transfers with a "date" that is greater than or equal to the given timestamp */
    dateGte?: string;
    /** @description Return transfers with a "date" that is less than the given timestamp */
    dateLt?: string;
    /** @description The Wallet Flag name */
    walletFlagName: 'isStaking' | 'lightning';
    /** @description Customize sort order for the transfers by specifying the sort key. */
    sortBy?: 'heightId' | 'id';
    /**
     * @description Your Enterprise Id.
     * @example 63c86bf4555aba000652d5c59aff2866
     */
    Enterprise: string;
    /**
     * @description Id of the Policy Rule.
     * @example c8234a0f-7722-44d7-bedc-bfded7bd24a7
     */
    PolicyRuleId: string;
    /**
     * @description Id of the Policy Rule.
     * @example c8234a0f-7722-44d7-bedc-bfded7bd24a7
     */
    PolicyRuleIdQuery?: string;
    /**
     * @description A string to match the names of the Policy Rules against.
     *
     * @example My Policy Rule
     */
    PolicyRuleName?: string;
    /**
     * @description Version of the Policy Rule to return.
     * @example 3
     */
    PolicyRuleVersion?: number;
    /**
     * @description The id of the Scope.
     * @example c8234a0f-7722-44d7-bedc-bfded7bd24a7
     */
    Scope: string;
    /**
     * @description Scopes of the returned Policy Rules. One or more may be provided. For example, the All Wallets Scope.
     * See also the List Scopes API.
     *
     * @example wallet.segregated
     */
    ScopeName?: 'wallet.segregated' | 'policies.management';
    /** @description Statuses of the returned Policy Rules, one or more may be provided. */
    PolicyRuleStatus?: 'ACTIVE' | 'INACTIVE' | 'DENIED' | 'PENDING_APPROVAL';
    /**
     * @description The Touchpoints of the returned Policy Rules. One or more may be provided. For example, the Transfer from a Wallet Touchpoint. See also the List Scope Touchpoints API.
     * @example wallet.segregated.transfer
     */
    Touchpoints?: string;
    /**
     * @description You can retrieve the Policy Rules that match a given set of Filtering Conditions by providing the parameter name and value of the Filtering Conditions you are interested in. See also Filtering Conditions.
     * @example walletType=custodial
     */
    FilteringConditionParameterNameAndValue?: string;
    /**
     * @description The name of the Filtering Condition to be used when creating or updating a Policy Rule. Not all Touchpoint Actions are compatible with all Filtering Conditions.
     * @example wallet.all
     */
    FilteringConditionName: string;
    /**
     * @description How many Policy Rules to return per page of results. Default: 20, Maximum: 100.
     *
     * @example 20
     */
    Limit?: number;
    /**
     * @description The nextBatchPrevId returned by the last call to the same API. Used to retrieve the next page of results.
     * @example 1
     */
    PrevId?: number;
    /**
     * @description The id of a Touchpoint.
     * @example 0441ea9f-cd66-4d60-a52a-471aecd3e54e
     */
    TouchpointId: string;
    /**
     * @description The name of the Touchpoint.
     * @example wallet.segregated.transfer
     */
    TouchpointName: string;
    /** @description The staking asset. */
    pathCoin1: ('AVAXP' | 'DOT' | 'ETH' | 'MATIC' | 'NEAR' | 'SOL') | string;
    /** @description The wallet id */
    pathWalletId1: components['schemas']['WalletId'];
    /** @description The staking asset */
    queryCoin?: ('AVAXP' | 'DOT' | 'ETH' | 'MATIC' | 'NEAR' | 'SOL') | string;
    /** @description The label of the wallet where the staking request was created from */
    queryLabel?: string;
    /** @description Page number for pagination */
    queryPage?: number;
    /** @description Page size for pagination */
    queryPageSize?: number;
    /** @description Sort By field */
    querySortByCreatedDate?: '-createdDate' | 'createdDate';
    /** @description Sort By field */
    querySortByDate?: '-date' | 'date';
    /**
     * @description The asset or currency to compare to the quote asset or currency (case insensitive).
     * @example btc
     */
    Base: string;
    /** @description End time for the pricing data range. If not provided, defaults to the current time. */
    End?: string;
    /**
     * @description Unit of time.
     * @example hour
     */
    Interval: 'minute' | 'hour' | 'day';
    /**
     * @description maximum number of items to fetch which should be the same for consecutive calls so that the service knows how many items to offset
     * @default 50
     */
    LimitQueryParam?: string;
    /**
     * @description page of results to fetch
     * @default 0
     */
    PageQueryParam?: string;
    /**
     * @description The asset or currency to compare to the base asset or currency (case insensitive).
     * @example eth
     */
    Quote: string;
    /**
     * @description sorting order of items based on creation time
     * @default desc
     */
    SortQueryParam?: 'asc' | 'desc';
    /** @description Start time for the pricing data range. If not provided, defaults to 1 interval before to the current time. */
    Start?: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /**
   * List addresses
   * @description List receive addresses on a wallet
   */
  'v2.wallet.addresses': {
    parameters: {
      query?: {
        /** @description A case-insensitive regular expression which will be used to filter returned addresses based on their address label. */
        labelContains?: string;
        limit?: components['parameters']['limit'];
        /** @description Whether to return only the addresses which the current user has created. */
        mine?: boolean;
        prevId?: components['parameters']['prevId'];
        segwit?: components['parameters']['segwit'];
        /** @description Sorts the order of addresses when comparing their address IDs. For ascending, pass '1'. For descending, pass '-1'. */
        sort?: -1 | 1;
        chains?: components['parameters']['chain'];
        /** @description Whether to include address balances */
        includeBalances?: boolean;
        /** @description Whether to include token addresses */
        includeTokens?: boolean;
        /** @description For large wallets (>100k addresses), include total count of addresses (including addresses pending on-chain) matching the query. */
        includeTotalAddressCount?: boolean;
        /** @description Name of the token that the response should include balances for. (Eth and Celo only) */
        returnBalancesForToken?: string;
        /** @description Filter the addresses based on their deployment status. Return the deployed addresses if this param is passed as false and return undeployed addresses if it is passed as true. (Eth only) */
        pendingDeployment?: boolean;
        /** @description Field by which addresses are sorted. If not provided, defaults to address IDs. */
        sortedField?: 'label' | 'token';
        /** @description Sorts the order of addresses returned on "sortedField". For ascending, pass '1'. For descending, pass '-1'. If addresses have same "sortedField" value, sort by address ID and sort the order using "sort". */
        sortedFieldDirection?: '-1' | '1';
        /** @description Filters by token name. Use only with off-chain (ofc) wallets. If specified multiple times, returns addresses that apply to any of the given tokens. */
        token?: string;
      };
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['GetAddressesResponse'];
        };
      };
      /** @description Wallet is pending on-chain initialization */
      202: {
        content: never;
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Create address
   * @description Creates a new receive address for a wallet. If you create a forwarder address, whenever it receives assets, BitGo automatically deploys a forwarder smart contract to flush the balance to the base address. See [Blockchain Reference](/coins/Algorand) topics to learn more about address management, fees, and consolidations for specific assets.
   *
   * **Note:** New Ethereum addresses require blockchain confirmation before you can consolidate from them.
   */
  'v2.wallet.newaddress': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateAddressRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Address'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Deploy address
   * @description This API call is to manually deploy an ETH address
   */
  'v2.wallet.deployForwarder': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
        addressId: components['parameters']['pathAddressId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['DeployForwarderRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['DeployForwarderAndForwardTokenResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Forward tokens from address
   * @description This API call is to manually forward tokens from an ETH or CELO address
   */
  'v2.wallet.forwardToken': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
        addressId: components['parameters']['pathAddressId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ForwardTokenRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['DeployForwarderAndForwardTokenResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Get address
   * @description Gets a receive address on a wallet
   */
  'v2.wallet.singlewalletaddress': {
    parameters: {
      query?: {
        /** @description For XRP addresses */
        dt?: string;
        /** @description For XLM addresses */
        memoId?: string;
      };
      path: {
        addressOrId: components['parameters']['addressOrId'];
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['GetSingleAddressResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Update address
   * @description Update a receive address on a wallet
   */
  'v2.wallet.updateaddress': {
    parameters: {
      query?: {
        /** @description For XRP addresses */
        dt?: string;
        /** @description For XLM addresses */
        memoId?: string;
      };
      path: {
        addressOrId: components['parameters']['addressOrId'];
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateAddressRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['GetSingleAddressResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get proof of address ownership
   * @description Gets proof of ownership for an address of a TRUST wallet. Returns a unique BTC proof or ETH IOU that you can use with your travel-rule solutions. Only available for BTC and ETH.
   */
  'v2.wallet.addressProof': {
    parameters: {
      path: {
        addressOrId: components['parameters']['addressOrId'];
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['GetAddressProofResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Get list of potentially stuck transactions and their nonces for eth-like coins
   * @description Gets a list of potentially problematic transactions, their nonces, the reason they are stuck, and possible solutions for a given wallet
   */
  'v2.wallet.getpotentialstucktxs': {
    parameters: {
      query?: {
        /** @description True, if expanding the send transfer for each stuck transaction if one is available. */
        expandSendTransferMetadata?: boolean;
      };
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['GetPotentialStuckTxsResponse'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['InvalidWalletId']
            | components['schemas']['CoinOperationNotSupported'];
        };
      };
    };
  };
  /**
   * Send funds to forwarder
   * @description Send funds from a fee address to forwarder. Only supports account-based coins and tokens (like ETH).
   */
  'v2.wallet.fundforwarders': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['FundForwardersRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['FundForwardersResponse'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['CoinOperationNotSupported'];
        };
      };
    };
  };
  /** Get enterprise */
  'enterprise.getById': {
    parameters: {
      query?: {
        /** @description True, if excluding "wallets" field containing v1 wallet addresses from the enterprise */
        excludeV1Wallets?: boolean;
        /** @description True, if returning the total number of wallets for this enterprise */
        expandTotalWalletsCount?: boolean;
      };
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['EnterpriseResponse'] & {
            wallets?: string[];
          };
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
      /** @description "EnterpriseNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /** Update enterprise */
  'enterprise.update': {
    parameters: {
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateEnterprise'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Enterprise'];
        };
      };
      /** @description A Pending Approval for the Update has been created and is waiting for approval */
      202: {
        content: {
          'application/json': components['schemas']['V1PendingApproval'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "NotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get enterprise TSS config
   * @description This api fetches the enterprise TSS config if it exists. The caller of this API must have view permissions on the enterprise.
   */
  'v2.enterprise.tssconfig.get': {
    parameters: {
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['TssConfig'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "NotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Update enterprise ECDSA TSS challenge
   * @description This api is used to upload a new ECDSA challenge for the enterprise. This will replace the existing challenge if one exists.
   */
  'v2.enterprise.tssconfig.ecdsa.challenge.update': {
    parameters: {
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateEnterpriseTssEcdsaChallengeConfigRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['UpdateEnterpriseTssEcdsaChallengeConfigResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "NotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List available assets
   * @description Lists all available assets for a given enterprise. Must have view permissions on the enterprise
   */
  'v2.enterprise.availableassets.get': {
    parameters: {
      query?: {
        /** @description True, if returning tokens. */
        includeTokens?: boolean;
        /** @description True, if excluding off-chain assets. */
        excludeOfcCoins?: boolean;
      };
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Coin'][];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "NotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /** List enterprises */
  'enterprise.list': {
    parameters: {
      query?: {
        /** @description True, if returning the total number of wallets for each enterprise. */
        expandTotalWalletCounts?: boolean;
        /** @description True, if excluding enterprises that the user joined only through wallet memberships. */
        excludeWalletMemberships?: boolean;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['EnterprisesResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "EnterpriseNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /** List enterprise users */
  'enterprise.user.list': {
    parameters: {
      query?: {
        /** @description Whether inactive Users whose emails are unverified should be returned as well */
        allowInactiveUsers?: boolean;
      };
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['EnterpriseUsersResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
      /** @description "EnterpriseNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /** Add user to enterprise */
  'v2.enterprise.user.add': {
    parameters: {
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['AddEnterpriseUser'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      /** @description Pending Approval for adding a user was created and is waiting to be approved */
      202: {
        content: {
          'application/json': components['schemas']['PendingApproval'] | components['schemas']['PendingApprovals'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
      /** @description "EnterpriseNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /** Remove user from enterprise */
  'v2.enterprise.user.remove': {
    parameters: {
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['DeleteEnterpriseUser'];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description A Pending Approval for removing the User has been created and is waiting for approval */
      202: {
        content: {
          'application/json': {
            pendingApprovals?: components['schemas']['PendingApproval'][];
          };
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
      /** @description "UserNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get enterprise user signing key
   * @description Get the signing key for an enterprise user. The signing key is used to sign arbitrary messages, which other enterprise users can verify. The caller of this API must have view permissions on the enterprise.
   */
  'v2.enterprise.user.signingkey.get': {
    parameters: {
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
        userId: components['parameters']['pathUserIdOrMe'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['EnterpriseUserSigningKey'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "NotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /** Freeze the enterprise */
  'enterprise.freeze': {
    parameters: {
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['FreezeEnterprise'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Freeze'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
      /** @description The User needs to unlock with OTP first */
      401: {
        content: never;
      };
    };
  };
  /** Get enterprise's wallet limits */
  'enterprise.walletLimits': {
    parameters: {
      query?: {
        coin?: components['parameters']['coinSingleOrList'];
        /** @description Whether custodial limits should be returned */
        isCustodial?: true;
      };
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['WalletLimitsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
      /** @description "EnterpriseNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get gas tank balance
   * @description Returns gas tank balance for an asset.
   */
  'v2.enterprise.feeAddressBalance': {
    parameters: {
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
        coin: components['parameters']['pathCoin'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['FeeAddressBalanceResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
      /** @description "EnterpriseNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List all transfers on all wallets in an enterprise
   * @description Returns all the transfers without blockchain information (inputs, outputs, confirms). Use the coin specific route
   * to annotate blockchain information.
   */
  'v2.enterprise.listtransfers': {
    parameters: {
      query?: {
        dateGte?: components['parameters']['dateGte'];
        dateLt?: components['parameters']['dateLt'];
        limit?: components['parameters']['limit'];
        prevId?: components['parameters']['prevId'];
        state?: components['parameters']['state'];
        type?: components['parameters']['type'];
      };
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            transfers: components['schemas']['Transfer'][];
            nextBatchPrevId?: components['schemas']['NextBatchPrevId'];
          };
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
      /** @description "EnterpriseNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List transfers on all wallets in an enterprise for a given coin and block height
   * @description Returns all the transfers. Currently requires an enterpriseId and block height.
   */
  'v2.listtransfers': {
    parameters: {
      query: {
        /** @description The enterprise ID */
        enterpriseId: components['schemas']['Id'];
        /** @description The block or ledger height to query */
        height: components['schemas']['IntegerString'];
      };
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['TransfersResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
      /** @description "EnterpriseNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get fee estimate
   * @description Returns the estimated fee for a transaction. UTXO coins will return a fee per kB, while Account-based coins will return a flat fee estimate
   */
  'v2.tx.getfeeestimate': {
    parameters: {
      query?: {
        /** @description target number of blocks */
        numBlocks?: number;
        /** @description Recipient of the tx to estimate for (only for ETH) */
        recipient?: string;
        /** @description ETH data of the tx to estimate for (only for ETH) */
        data?: string;
        /** @description Amount in base units being sent to estimate for (only for ETH) */
        amount?: string;
        /** @description True if we are estimating for a hop tx, false or unspecified for a wallet tx (ETH, AVAXC and POLYGON) */
        hop?: boolean;
      };
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json':
            | components['schemas']['EstimateTransactionFees']
            | components['schemas']['EstimateTransactionFeesAccountCoin']
            | components['schemas']['EstimateTransactionFeesAlgo']
            | components['schemas']['EstimateTransactionFeesEth']
            | components['schemas']['EstimateTransactionFeesTrx'];
        };
      };
      /** @description "CoinUnsupported" or "Invalid" */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get average fee
   * @description Returns the average fee for a specific number of blocks. Only for ETH and TETH.
   */
  'v2.wallet.getaveragefee': {
    parameters: {
      query?: {
        /** @description target number of blocks */
        numBlocks?: number;
      };
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['AverageFee'];
        };
      };
      /** @description "CoinUnsupported" or "Invalid" */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get user
   * @description Returns the associated user
   */
  'user.get': {
    parameters: {
      path: {
        /** @description The user ID, email address, or "me" for the currently authenticated user */
        id: components['schemas']['Id'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['User'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidUserId'];
        };
      };
      404: {
        content: never;
      };
    };
  };
  /** Get another users public key for wallet sharing */
  'user.sharingkey': {
    requestBody?: {
      content: {
        'application/json': components['schemas']['UserSharingKey'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['User'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get key
   * @description Get Key using either the key id or the pub.
   * When using the public key, it will only return the mandatory fields.
   */
  'v2.key.get': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        idOrPub: components['parameters']['pathIdOrPub'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Key'] | components['schemas']['KeyTSS'];
        };
      };
      /** @description Invalid coin */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      404: {
        content: never;
      };
    };
  };
  /** List keys */
  'v2.key.list': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['KeysResponse'];
        };
      };
      /** @description Invalid Coin */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /** Create key */
  'v2.key.add': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateKey'];
      };
    };
    responses: {
      /** @description Returns the new independent or TSS Key */
      200: {
        content: {
          'application/json': components['schemas']['Key'] | components['schemas']['KeyTSSCreated'];
        };
      };
      /** @description Invalid Coin */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Update policy rule
   * @description Updates a rule on the policy attached to a wallet
   */
  'v2.wallet.updatepolicy': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateRemovePolicyRule'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Wallet'];
        };
      };
      /** @description A Pending Approval for the update has been created and is waiting for approval */
      202: {
        content: {
          'application/json': components['schemas']['PendingApproval'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Add policy rule
   * @description Adds a rule to a wallet’s policy. A wallet policy’s rules control the
   * conditions under which BitGo will use its single key to sign a
   * transaction. An email notification will be sent to all wallet users
   * when a policy is updated. This email is NOT sent for the first time
   * policy is added.
   */
  'v2.wallet.createpolicy': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreatePolicyRule'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Wallet'];
        };
      };
      /** @description A Pending Approval for the update has been created and is waiting for approval */
      202: {
        content: {
          'application/json': components['schemas']['PendingApproval'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Delete policy rule
   * @description Deletes a rule from the policy attached to a wallet
   */
  'v2.wallet.removepolicy': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateRemovePolicyRule'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Wallet'];
        };
      };
      /** @description A Pending Approval for the update has been created and is waiting for approval */
      202: {
        content: {
          'application/json': components['schemas']['PendingApproval'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /** List pending approvals */
  'v2.approval.list': {
    parameters: {
      query?: {
        prevId?: components['parameters']['prevId'];
        limit?: components['parameters']['limit'];
        coin?: components['parameters']['coinArray'];
        enterpriseId?: components['parameters']['enterpriseId'];
        /** @description Filter by state.  The default behavior is to return objects where state is "awaitingSignature", "pending", or "pendingFinalApproval" */
        state?: components['schemas']['PendingApprovalStatePending'][];
        walletId?: components['parameters']['walletId'];
        /** @description True, if adding "walletLabel" to each returned pending approval associated with a "wallet" */
        expandWalletLabels?: boolean;
        expandAddressLabels?: components['parameters']['expandAddressLabels'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['PendingApprovals'];
        };
      };
    };
  };
  /** Get pending approval */
  'v2.approval.get': {
    parameters: {
      query?: {
        expandAddressLabels?: components['parameters']['expandAddressLabels'];
      };
      path: {
        id: components['parameters']['pathId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['PendingApproval'];
        };
      };
    };
  };
  /**
   * Update pending approval
   * @description Updates the state of a pending approval to "approved" or "rejected".
   * You can manage pending approvals programmatically by API or with the
   * BigGo web UI. Ensure your authentication token has the proper scope.
   * When creating an access token in the web UI, check the permission,
   * "Update Pending Approvals" (under "Account Settings" &gt; "Developer
   * Options" &gt; "Access Tokens").
   *
   * BitGo recommends that you create a webhook policy so that you can
   * automate approving and rejecting transactions.
   */
  'v2.approval.update': {
    parameters: {
      path: {
        id: components['parameters']['pathId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': {
          otp?: string;
          state?: string;
        };
      };
    };
    responses: {
      /** @description Successfully updated pending approval state */
      200: {
        content: {
          'application/json': components['schemas']['PendingApproval'];
        };
      };
      /** @description Further approvals are required */
      202: {
        content: {
          'application/json': components['schemas']['PendingApproval'];
        };
      };
    };
  };
  /**
   * Login
   * @description Creates a short-lived (1 hour) access token for use with the API.  The token must be specified to subsequent
   * API calls via the "Authorization" HTTP header:
   * """text
   * Authorization: Bearer 9b72c68ef394f5146f0f3efc1feafb7a971752cb00e79fafcfd8c1d2db83639c
   * """
   * We don't recommend using this endpoint for scripting.  The preferred
   * approach is to create a long-lived token in the web UI (see the
   * Developer Options section in User Settings).
   */
  'user.login': {
    requestBody?: {
      content: {
        'application/json': components['schemas']['LoginRequest'];
      };
    };
    responses: {
      /** @description Returns the access token and user */
      200: {
        content: {
          'application/json': components['schemas']['LoginResponse'];
        };
      };
      /** @description Invalid credentials */
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List transfers
   * @description Returns deposits and withdrawals for a wallet.  Transfers are sorted
   * in descending order by "height", then "id". Transfers with "rejected"
   * and "pendingApproval" states are excluded by default.
   */
  'v2.wallet.listtransfers': {
    parameters: {
      query?: {
        allTokens?: components['parameters']['allTokens'];
        dateGte?: components['parameters']['dateGte'];
        dateLt?: components['parameters']['dateLt'];
        height?: components['parameters']['height'];
        limit?: components['parameters']['limit'];
        prevId?: components['parameters']['prevId'];
        state?: components['parameters']['state'];
        type?: components['parameters']['type'];
        valueGte?: components['parameters']['valueGte'];
        valueLt?: components['parameters']['valueLt'];
        sortBy?: components['parameters']['sortBy'];
        /** @description Filter for a transfer by one or more transfer ids */
        id?: components['schemas']['Id'];
        /** @description Filter for a transfer with a matching pendingApprovalId */
        pendingApprovalId?: components['schemas']['Id'];
        /** @description Return transfers with elements in "entries" that have an "address" field set to this value */
        address?: components['schemas']['AddressString'][];
        /** @description Include the raw hex data of the transaction in the response (this may be a large amount of data) */
        includeHex?: boolean;
        /** @description Return transfers with any of the payment identifiers in this array. Available for Stellar and EOS. */
        memoId?: components['schemas']['IntegerString'][];
      };
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['TransfersResponse'];
        };
      };
      /** @description "CoinUnsupported" or "Invalid" */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      /** @description "EnterpriseNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get transfer
   * @description A transfer is a wallet specific object. Each transfer will only output the respective wallet id which the
   * transfer is associated with.
   *
   * If there is a transaction between two BitGo wallets, then two transfers will be created, one for wallet A,
   * and one for wallet B. Transfer A will only annotate the walletId on entries where the address belongs to
   * wallet A. Transfer B will only annotate the walletId on entries where the address belongs to wallet B.
   */
  'v2.wallet.gettransfer': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
        transferId: components['parameters']['pathTransferId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['AnnotatedTransferWithInputsOutputs'];
        };
      };
      /** @description Incomplete data. Transaction inputs and outputs not available yet. */
      206: {
        content: {
          'application/json': components['schemas']['AnnotatedTransfer'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['InvalidTransferId']
            | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /** Get transfer by sequence id */
  'v2.wallet.gettransferbysequenceid': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
        sequenceId: components['parameters']['pathSequenceId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['AnnotatedTransferWithInputsOutputs'];
        };
      };
      /** @description Partial content -- unconfirmed transfer, does not contain inputs or outputs */
      206: {
        content: {
          'application/json': components['schemas']['AnnotatedTransfer'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Logout
   * @description Disables an access token
   */
  'user.logout': {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * Get session
   * @description Returns the session associated with access token passed via the "Authorization" header.
   */
  'user.getsession': {
    responses: {
      200: {
        content: {
          'application/json': {
            session?: components['schemas']['Session'];
          };
        };
      };
    };
  };
  /**
   * Lock session
   * @description Locks the current user session.  This disallows operations that require
   * an unlocked token, such as sending a transaction.
   */
  'user.lock': {
    responses: {
      /** @description Returns the access token and User */
      200: {
        content: {
          'application/json': {
            session?: components['schemas']['LockedSession'];
          };
        };
      };
    };
  };
  /**
   * Unlock session
   * @description Unlocks the current user session, enabling operations that require
   * an unlocked token, such as sending a transaction. Call this endpoint
   * if an API returns a "401" response with the "needsUnlock"
   * body parameter set to "true".
   *
   * **Note:** Unlocking a token with spending limits, removes all spending limits from the token.
   */
  'user.unlock': {
    requestBody?: {
      content: {
        'application/json': components['schemas']['UnlockRequest'];
      };
    };
    responses: {
      /** @description Returns the updated session */
      200: {
        content: {
          'application/json': {
            session?: components['schemas']['Session'];
          };
        };
      };
    };
  };
  /**
   * List wallets by coin
   * @description Get a list of all wallets per coin, for example, all <i>Bitcoin</i> wallets in your enterprise.
   */
  'v2.wallet.listbycoin': {
    parameters: {
      query?: {
        prevId?: components['parameters']['prevId'];
        limit?: components['parameters']['limit'];
        allTokens?: components['parameters']['allTokens'];
        searchLabel?: components['parameters']['searchLabelWallets'];
        showAllWallets?: components['parameters']['showAllWallets'];
      };
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['WalletsWithCoinResponse'];
        };
      };
      /** @description invalid prev id or invalid coin */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Add wallet (advanced only)
   * @description Add Wallet is for advanced API users. It lets you manually create and
   * specify keys. The recommended (and simpler) method is [Generate Wallet](https://developers.bitgo.com/api/express.wallet.generate)
   * with the SDK or BitGo Express. You can also create wallets in the BitGo UI.
   *
   * This API creates a new wallet for the user or enterprise. The keys to
   * use with the new wallet (passed in the 'keys' parameter) must be
   * registered with BitGo prior to using this API.
   *
   * BitGo currently only supports 2-of-3 (e.g., m=2 and n=3) wallets. The
   * third key, and only the third key, must be a BitGo key. The first key
   * is by convention the user key, with its encrypted xprv stored on BitGo.
   *
   * Ethereum and XRP wallets can only be created under an enterprise. Pass in the
   * id of the enterprise to associate the wallet with. Your enterprise id
   * can be seen by clicking on the "Manage Organization" link in the
   * enterprise dropdown. Using the Add Wallet API, you can create a wallet
   * using either the enterprise fee address (used by default for all
   * wallets in the enterprise), or a unique fee address (created manually
   * with the Keychains API). Pass the desired key as the third key ID in
   * the 'keys' array. In either case, the fee address must be funded
   * before creating the wallet.
   *
   * You cannot generate a wallet by passing in a subtoken (i.e. ERC20 token) as the coin.
   * Subtokens use the wallet of their parent coin and it is not possible to create a
   * wallet specific to one token. For example, to create a wallet for an ERC20 token,
   * create an Ethereum wallet. It can hold any ERC20 tokens as well as Ether.
   *
   * BitGo Ethereum wallet is a smart-contract implementing multi-signature scheme.
   * Because contracts itself can not initiate transactions, fee addresses are used
   * for this purpose. Ethereum transactions initiated by a given address, are
   * confirmed by the network in order of creation, so one lower fee transaction can
   * potentially delay all subsequent transactions. To help lower network fee costs,
   * two fee addresses are provided.
   *
   * "feeAddress" is a main fee address usable for all operations.
   * "lowPriorityFeeAddress" is a secondary fee address that can be used to pay
   * lower fee for Create Address operations without risking delaying subsequent
   * higher-priority transactions initiated by main fee address.
   */
  'v2.wallet.add': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateWallet'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Wallet'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
      /** @description "CustodialWalletLimitReachedError", "MustHaveColdWalletLicenseError", "MustHaveCustodialWalletLicenseError", "WalletLimitReachedError" */
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List wallets
   * @description Get a list of all wallets for which you have permission. To narrow your search, use the <b>List wallets</b> parameters below or call <b>List wallets by coin</b>, <b>Get Wallet</b> (by "coin" and "walletId") or <b>Get wallet by address</b> (by "coin" and "address").<br><br>
   * Compare the List/Get wallet APIs&#58; <ul> <li><b>List wallets</b> returns 1 or more wallets for 1 or more coins across 1 or more enterprises (within an array).</li> <li><b>List wallets by coin</b> returns 1 or more wallets <i>for one coin only</i> across 1 or more enterprises (within an array).</li> <li><b>Get wallet</b> and <b>Get wallet by address</b> return one wallet.</li> </ul>
   * Test the List/Get wallet APIs. With the same parameter values, these calls should return the same wallet (with minor differences in the responses)&#58;
   * <table> <tr> <th>API</th> <th>URL</th></tr> <tr> <td><b>List wallets</b></td> <td><code>{{baseUrl}}/api/v2/wallets?coin={coin}&enterprise={enterpriseid}&id={walletId}&expandBalance=true</code></td></tr> <tr> <td><b>List wallets by coin</b></td> <td><code>{{baseUrl}}/api/v2/{coin}/wallet?enterprise={enterpriseid}&searchLabel={wallet name}</code></td></tr> <tr> <td><b>Get wallet</b></td> <td><code>{{baseUrl}}/api/v2/{coin}/wallet/{walletId}</code></td></tr> <tr> <td><b>Get wallet by address</b></td> <td><code>{{baseUrl}}/api/v2/{coin}/wallet/address/{address}</code></td></tr> </table>
   */
  'v2.wallet.list': {
    parameters: {
      query?: {
        coin?: components['parameters']['coinArray'];
        /** @description Filter by deleted state */
        deleted?: boolean[];
        enterprise?: components['parameters']['queryEnterpriseArray'];
        /** @description Filter by whether the enterprise field is null */
        enterpriseIsNull?: boolean;
        /** @description Do not add "receiveAddress" to each wallet */
        skipReceiveAddress?: boolean;
        /** @description Add "balanceString" and "spendableBalanceString" to each wallet */
        expandBalance?: boolean;
        id?: components['parameters']['queryIdArray'];
        /** @description Filter by label substring */
        labelContains?: string;
        limit?: components['parameters']['limit'];
        offset?: components['parameters']['offset'];
        prevId?: components['parameters']['prevId'];
        /** @description Filter by wallet type */
        type?: components['schemas']['WalletTypePublic'][];
        /** @description Whether linked custodial wallets should be expanded inline */
        expandCustodialWallet?: boolean;
        /** @description Return only wallets for which the user has the given permission */
        permission?: components['schemas']['WalletPermission'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['WalletsResponse'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['BalanceNotAvailable']
            | components['schemas']['InvalidEnterpriseId'];
        };
      };
    };
  };
  /**
   * Get wallets count
   * @description Returns a count of all the wallets for which you have any permission (view, spend, admin). If you don't have permission to view all wallets in the enterprise, then returns a count of the wallets only for which the you are a member.
   * You can use this endpoint in conjunction with the [List wallets](https://developers.bitgo.com/api/v2.wallet.list) endpoint to enable paginating a list of wallets. For example, once you get the wallets count, you can use that count to calculate the number of pages you need to display all the wallets.
   */
  'v2.wallet.count': {
    parameters: {
      query?: {
        coin?: components['parameters']['coinArray'];
        /** @description Filter by deleted state */
        deleted?: boolean[];
        enterprise?: components['parameters']['queryEnterpriseArray'];
        /** @description Filter by whether the enterprise field is null */
        enterpriseIsNull?: boolean;
        id?: components['parameters']['queryIdArray'];
        /** @description Filter by label substring */
        labelContains?: string;
        /** @description Filter by wallet type */
        type?: components['schemas']['WalletTypePublic'][];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['WalletCountResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
    };
  };
  /**
   * Get wallet by address
   * @description Get one wallet by its "coin" and receive "address". Multiple receive addresses can map to one "walletId".
   */
  'v2.wallet.getwalletbyaddress': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        address: components['parameters']['pathAddress'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Wallet'];
        };
      };
      /** @description invalid wallet address */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "WalletNotFound" or invalid coin */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get wallet
   * @description Get one wallet by its "coin" and "walletId". One "walletId" can map to multiple receive addresses.
   */
  'v2.wallet.get': {
    parameters: {
      query?: {
        allTokens?: components['parameters']['allTokens'];
        unspentCount?: components['parameters']['unspentCount'];
      };
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Wallet'] & components['schemas']['WalletBalance'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Update wallet
   * @description Update a wallet by its "coin" and "walletId".
   */
  'v2.wallet.update': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateWallet'];
      };
    };
    responses: {
      /** @description Returns the updated wallet */
      200: {
        content: {
          'application/json': components['schemas']['Wallet'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      403: {
        content: never;
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Delete wallet
   * @description Delete one wallet by its "coin" and "walletId". Once removed, you can no longer view or access this wallet, but it does remain accessible to other wallet users. If you are the only user on this wallet, you can only delete it if it has a 0 balance.
   */
  'v2.wallet.remove': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      /** @description Returns the updated wallet */
      200: {
        content: {
          'application/json': components['schemas']['Wallet'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      /** @description "WalletHasNonZeroBalanceError" */
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get wallet by ID
   * @description Get one wallet by its "walletId". One "walletId" can map to multiple receive addresses.
   */
  'v2.wallet.getbyid': {
    parameters: {
      query?: {
        allTokens?: components['parameters']['allTokens'];
      };
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Wallet'] & components['schemas']['WalletBalance'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      404: {
        content: never;
      };
    };
  };
  /**
   * Remove user from wallet
   * @description After a user has accepted a wallet share, they become a party on a
   * wallet and the wallet share is considered “complete”. In order to
   * revoke the share after they have accepted, you can remove the user
   * from the wallet.
   *
   * This operation requires approval by another wallet administrator
   * if there is more than a single administrator on a wallet.
   */
  'v2.wallet.removeuser': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
        userId: components['parameters']['pathUserId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Wallet'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['CannotRemoveAdmin']
            | components['schemas']['InvalidUserId']
            | components['schemas']['InvalidWalletId'];
        };
      };
      /** @description "WalletNotFound" or invalid coin */
      404: {
        content: never;
      };
    };
  };
  /**
   * Freeze wallet
   * @description Lock the wallet, preventing any outgoing transactions for a specified number of seconds
   */
  'v2.wallet.freeze': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': {
          /** @description time in seconds */
          duration?: number;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Freeze'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      /** @description 'needs unlock', 'Access token lacks required scope for this action' */
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "WalletNotFound" or invalid coin */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get unspents
   * @description Returns unspent transaction outputs for a wallet
   */
  'v2.wallet.unspents': {
    parameters: {
      query?: {
        limit?: components['parameters']['limit'];
        maxValue?: components['parameters']['maxValue'];
        minConfirms?: components['parameters']['minConfirms'];
        enforceMinConfirmsForChange?: components['parameters']['enforceMinConfirmsForChange'];
        minHeight?: components['parameters']['minHeight'];
        minValue?: components['parameters']['minValue'];
        prevId?: components['parameters']['prevId'];
        segwit?: components['parameters']['segwit'];
      };
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['WalletUnspents'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      /** @description "Forbidden" when wallet count exceeds limit of 500 */
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "WalletNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get cross-chain unspents
   * @description Returns atomic cross-chain unspents that can be imported by the wallet. Supported coins: AVAX.
   */
  'v2.wallet.crosschainunspents': {
    parameters: {
      query?: {
        sourceChain?: components['parameters']['querySourceChain'];
      };
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['WalletCrossChainUnspents'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      /** @description "Forbidden" when wallet count exceeds limit of 500 */
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "WalletNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get maximum spendable
   * @description Returns the maximum amount that can be spent with a single transaction
   * on the wallet.
   *
   * The maximum spendable amount can differ from a wallet’s total balance.
   * A transaction can only use up to 200 unspents. Wallets that have more
   * than 200 unspents cannot spend the full balance in one transaction.
   * Additionally, the value returned for the maximum spendable amount
   * accounts for the current fee level by deducting the estimated fees.
   * The amount will only be calculated based on the unspents that fit the
   * parameters passed.
   */
  'v2.wallet.maximumspendable': {
    parameters: {
      query?: {
        allTokens?: components['parameters']['allTokens'];
        enforceMinConfirmsForChange?: components['parameters']['enforceMinConfirmsForChange'];
        feeRate?: components['parameters']['feeRate'];
        limit?: components['parameters']['limit'];
        maxFeeRate?: components['parameters']['maxFeeRate'];
        maxValue?: components['parameters']['maxValue'];
        minConfirms?: components['parameters']['minConfirms'];
        minHeight?: components['parameters']['minHeight'];
        minValue?: components['parameters']['minValue'];
        numBlocks?: components['parameters']['numBlocks'];
      };
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['WalletMaximumSpendable'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      /** @description "WalletNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get inscribed satoshis on unspent
   * @description Returns inscribed satoshis (and associated data) for an unspent in a wallet.
   * To use this endpoint, BitGo must enable inscription tracking for your enterprise. Contact support@bitgo.com.
   */
  'v2.wallet.unspent.inscriptions': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
        unspentId: components['parameters']['pathUnspentId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['InscriptionResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get spending limits and current amount spent
   * @description Returns the wallet's currently configured spending limits and the current
   * amount spent during the periods defined by the spending limits.
   */
  'v2.wallet.spending': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['WalletSpending'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      /** @description "WalletNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List unspent reservation
   * @description Query reserved unspents in the wallet.
   */
  'v2.wallet.reservedunspent.list': {
    parameters: {
      query?: {
        /** @description Return the next batch of results, based on the "nextBatchPrevId" value from the previous batch. */
        prevId?: string;
        limit?: components['parameters']['limit'];
        /** @description Returns reserved unspents with an "expireTime" greater than this value. */
        expireTimeGt?: string;
        /** @description Returns reserved unspents with an "expireTime" less than or equal to this value. */
        expireTimeLte?: string;
        /** @description Returns reserved unspents with an "expireTime" equal to this value. If "never", returns unspents without expiration dates. */
        expireTime?: string;
        /** @description Returns reserved unspents of a specific type. */
        type?: 'ordinal' | 'inscription';
      };
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            unspents?: components['schemas']['ReservedUnspent'][];
            nextBatchPrevId?: string;
          };
        };
      };
      /** @description "Invalid" query properties or reservation doesn't exist */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Modifying unspent reservation
   * @description Modify expire time of reserved unspents.
   */
  'v2.wallet.reservedunspent.put': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': {
          unspentIds: components['schemas']['UnspentId'][];
          changes: {
            /** @description Time in date-time format when reservation expires. If 'never', reservation doesn't expire. */
            expireTime?: string;
          };
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            unspents?: components['schemas']['ReservedUnspent'][];
          };
        };
      };
      /** @description "Invalid" query properties or reservation doesn't exist */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Make unspent reservation
   * @description Mark the unspents as reserved and cannot be used in transactions until the given expire time.
   */
  'v2.wallet.reservedunspent.add': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': {
          unspentIds: components['schemas']['UnspentId'][];
          /** @description Time when reservation expires. Use "date-time" format or 'never'. If 'never', reservation doesn't expire. */
          expireTime: string;
          /**
           * @description Type of reservation to make on the unspent.
           * @enum {string}
           */
          type?: 'ordinal' | 'inscription';
          inscriptionIds?: components['schemas']['InscriptionId'][];
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            unspents?: components['schemas']['ReservedUnspent'][];
          };
        };
      };
      /** @description "Invalid" query properties */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Release unspent reservation
   * @description Release unspents from reservation to be accessible for transactions.
   */
  'v2.wallet.reservedunspent.delete': {
    parameters: {
      query: {
        id: components['schemas']['UnspentId'][];
      };
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            unspents?: components['schemas']['ReservedUnspent'][];
          };
        };
      };
      /** @description "Invalid" query properties or reservation doesn't exist */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List total balances
   * @description Selects wallets based on the given filter parameters. Gets all balances for the selected wallets and sums up the
   * balances by coin.
   */
  'v2.wallet.gettotalbalances': {
    parameters: {
      query?: {
        coin?: components['parameters']['coinArray'];
        /** @description Filter by deleted state */
        deleted?: boolean[];
        enterprise?: components['parameters']['queryEnterpriseArray'];
        id?: components['parameters']['queryIdArray'];
        /** @description Filter by label substring */
        labelContains?: string;
        /** @description Filter by wallet type */
        type?: components['schemas']['WalletTypePublic'][];
        /** @description Whether balances of linked custodial wallets should be included */
        expandCustodialWallet?: boolean;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['TotalBalances'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Request wallet reshare
   * @description Indicates that the calling user has lost access to the user key and would like to it to be reshared with them.
   */
  'v2.wallet.sharing.requestreshare': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: never;
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Create a wallet share
   * @description Share wallet with an existing BitGo user
   */
  'v2.wallet.sharing.createshare': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ShareWalletRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ShareWalletResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Request wallet access
   * @description Allow users that are members of an org to send a notification out to admins of a wallet to get access. You must supply either a walletId or a enterpriseId and walletType
   */
  'v2.wallet.requestaccess': {
    parameters: {
      query?: {
        enterprise?: components['parameters']['enterprise'];
        type?: components['schemas']['WalletTypePublic'];
        id?: components['schemas']['Id'];
      };
    };
    responses: {
      200: {
        content: never;
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Reject a wallet reshare request
   * @description If a user requested a reshare, another admin on the wallet can use this endpoint to reject their reshare request.
   */
  'v2.wallet.sharing.rejectreshare': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['RejectReshare'];
      };
    };
    responses: {
      200: {
        content: never;
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List wallet shares
   * @description List shares of all wallets with other BitGo users. Returns only wallets on which the current user has spend permission.
   */
  'v2.wallet.sharing.listallshares': {
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ListWalletSharesResponse'];
        };
      };
    };
  };
  /**
   * List counts of wallet shares
   * @description List counts of wallet shares by enterprises that the current user is the receiver
   */
  'v2.walletshares.count.list': {
    parameters: {
      query?: {
        state?: components['parameters']['walletShareState'];
      };
    };
    responses: {
      /** @description List counts of wallet shares by enterprises that the current user is the receiver */
      200: {
        content: {
          'application/json': components['schemas']['WalletSharesCountByEnterprise'];
        };
      };
      /** @description No or invalid authentication provided */
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get wallet share V1
   * @description Returns a wallet share, requires unlock if the wallet share includes a keychain.
   */
  'v1.wallet.sharing.getshare': {
    parameters: {
      query?: {
        /** @description True, if skipping unlock. Excludes keychain in response. */
        skipUnlock?: boolean;
      };
      path: {
        coin: components['parameters']['pathCoin'];
        shareId: components['parameters']['pathShareId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['WalletShare'];
        };
      };
      /** @description "Unauthorized" when the current user lacks permission to either manage or create wallets */
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get wallet share
   * @description Returns a wallet share, requires unlock if the wallet share includes a keychain.
   */
  'v2.wallet.sharing.getshare': {
    parameters: {
      query?: {
        /** @description True, if skipping unlock. Excludes keychain in response. */
        skipUnlock?: boolean;
      };
      path: {
        coin: components['parameters']['pathCoin'];
        shareId: components['parameters']['pathShareId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['WalletShare'];
        };
      };
      /** @description "Unauthorized" when the current user lacks permission to either manage or create wallets */
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /** Update a wallet share */
  'v2.wallet.sharing.updateshare': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        shareId: components['parameters']['pathShareId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': {
          state?: components['schemas']['WalletShareState'];
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['UpdateWalletShareResponse'];
        };
      };
    };
  };
  /**
   * Cancel a wallet share
   * @description Cancels a pending outgoing wallet share, or rejects an incoming share.
   * The share must not have been accepted yet.
   */
  'v2.wallet.sharing.cancelshare': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        shareId: components['parameters']['pathShareId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['UpdateWalletShareResponse'];
        };
      };
    };
  };
  /**
   * Resend a wallet share invitation email
   * @description Resends the wallet share invitation to the share recipient. The wallet
   * share must not have been accepted yet.
   */
  'v2.wallet.sharing.resendemail': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        shareId: components['parameters']['pathShareId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ResendShareEmailResponse'];
        };
      };
      /** @description "Invalid" when either the share id is invalid or the wallet share is not active */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "Unauthorized" when the current user lacks permission to manage wallets */
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List wallet webhooks
   * @description List webhooks set up on the wallet. Currently, the types of
   * webhooks that can be attached to a wallet are "transfer",
   * "pendingapproval", and "address_confirmation" notifications.
   */
  'v2.wallet.listwebhooks': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            webhooks?: (components['schemas']['Webhook'] & {
              walletId?: components['schemas']['Id'];
              /** @example false */
              allToken?: boolean;
            })[];
          };
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Add wallet webhook
   * @description Add a webhook to a wallet that sends an HTTP callback from BitGo to a specified URL when specific conditions occur. A wallet can have up to 10 webhooks of each wallet-webhook type.
   * Wallet-webhook types:
   * 1. **Address confirmation** - An address initializes on chain (ETH and XRP only).
   * 2. **Pending approval** - A wallet-level policy-triggering event occurs (such as a withdrawal, user change, policy change, pending approval state updates, and so forth).
   * 3. **Transaction request** - A transaction request state changes.
   * 4. **Transfer** - Any transfer occurs.
   *
   * **Note:** Unconfirmed webhook notifications don't trigger for [RBF](https://bitcoinops.org/en/topics/replace-by-fee/) transactions, or if a transaction confirms on chain immediately after it's sent. BitGo doesn't send 'unconfirmed' notifications in these cases.
   */
  'v2.wallet.addwebhook': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateWalletWebhook'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** @example false */
            allToken?: boolean;
          } & components['schemas']['Webhook'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Remove wallet webhook
   * @description Removing a webhook will cause new events of the specified type to no
   * longer trigger HTTP callbacks to your URLs
   */
  'v2.wallet.removewebhook': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': {
          /** @description Type of the webhook (e.g. transfer, pendingapproval). */
          type?: components['schemas']['WebhookTypeWallet'];
          /**
           * Format: uri
           * @example https://your.server.com/user_webhook
           */
          url?: string;
          id?: components['schemas']['Id'];
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /**
             * @description Number of wallet webhooks removed.
             * @example 1
             */
            removed?: number;
          };
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Simulate wallet webhook
   * @description Simulates and tests a webhook so you can view its response. A
   * "transferId", "pendingApprovalId" or "txRequestId" is required.
   */
  'v2.wallet.simulatewebhook': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
        webhookId: components['parameters']['pathWebhookId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['SimulateWalletWebhookRequestBody'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            webhookNotifications?: ({
              wallet?: components['schemas']['Id'];
              transfer?: components['schemas']['Id'];
              hash?: components['schemas']['TxId'];
            } & components['schemas']['WebhookNotification'])[];
          };
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * List block webhooks
   * @description Returns block webhooks. The types of webhooks are "block" and
   * "wallet_confirmation" notifications.
   */
  'v2.webhooks.list': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            webhooks?: ({
              type?: components['schemas']['WebhookTypeBlock'];
              userId?: components['schemas']['Id'];
            } & components['schemas']['Webhook'])[];
          };
        };
      };
    };
  };
  /**
   * Add block webhook
   * @description Adds a webhook that will result in an HTTP callback at the
   * specified URL from BitGo when events are triggered.
   *
   * Types of block webhooks:
   *
   * 1. Block webhooks will fire when a new block is seen on the coin network.
   * 2. Wallet confirmation webhooks will fire when a wallet has been initialized.
   */
  'v2.webhooks.add': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateBlockWebhook'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            type?: components['schemas']['WebhookTypeBlock'];
            userId?: components['schemas']['Id'];
          } & components['schemas']['Webhook'];
        };
      };
      /** @description 'Webhook already exists', 'Invalid url' */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Remove block webhook
   * @description Removing a webhook will cause new events of the specified type to no
   * longer trigger HTTP callbacks to your URLs.
   */
  'v2.webhooks.remove': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    requestBody?: {
      content: {
        'application/json': {
          type: components['schemas']['WebhookTypeBlock'];
          /**
           * Format: uri
           * @example https://your.server.com/user_webhook
           */
          url: string;
          id?: components['schemas']['Id'];
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /**
             * @description Number of block webhooks removed.
             * @example 1
             */
            removed?: number;
          };
        };
      };
    };
  };
  /**
   * Simulate block webhook
   * @description Simulates and tests a block webhook so you can view its response.
   */
  'v2.webhooks.simulate': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        webhookId: components['parameters']['pathWebhookId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': {
          blockId?: components['schemas']['BlockHash'];
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            webhookNotifications?: ({
              hash?: components['schemas']['BlockHash'];
            } & components['schemas']['WebhookNotification'])[];
          };
        };
      };
    };
  };
  /**
   * Generate coin specific report
   * @description Generate a report of transactions across all wallets for the user with the given coin
   */
  'v2.report.coinSpecific.generate': {
    parameters: {
      query?: {
        period?: components['parameters']['period'];
        format?: components['parameters']['format'];
        /** @description Defines a unit of currency */
        currency?: components['schemas']['CurrencyUnit'];
        /** @description Start date for the report */
        startDate?: string;
      };
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    responses: {
      /** @description A wallet report of the selected format */
      200: {
        content: {
          'application/json': components['schemas']['Report'];
        };
      };
      /** @description The report is still being processed. When ready, it will show up at the endpoint /api/v2/reports/preparedReports */
      202: {
        content: never;
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List reports
   * @description Lists generated reports.
   */
  'v2.reports.list': {
    parameters: {
      query?: {
        limit?: number;
        createdAtGt?: string;
        enterprise?: string;
        wallet?: string;
        walletType?: string;
        reportType?: 'holdings' | 'transactions' | 'trades';
        status?: 'pending' | 'processing' | 'completed' | 'failed';
        prevId?: string;
        format?: 'csv' | 'pdf';
        asset?: string;
        'holdings.byWallet'?: boolean;
        'transactions.isDetailed'?: boolean;
        'trades.isFillsReport'?: boolean;
      };
    };
    responses: {
      /** @description A report of the selected params */
      200: {
        content: {
          'application/json': {
            reports?: components['schemas']['HoldingsReport'][];
            /** @description The prevId to use for the next batch of reports */
            nextBatchPrevId?: string;
          };
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Generate report
   * @description Creates a new report in pending status.
   */
  'v2.reports.create': {
    requestBody?: {
      content: {
        'application/json':
          | components['schemas']['CreateHoldingsReportRequest']
          | components['schemas']['CreateTransactionsReportRequest']
          | components['schemas']['CreateTradesReportRequest'];
      };
    };
    responses: {
      /** @description A report of the selected params */
      200: {
        content: {
          'application/json':
            | components['schemas']['HoldingsReport']
            | components['schemas']['TransactionsReport']
            | components['schemas']['TradesReport'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get report
   * @description Returns a single report by report ID.
   */
  'v2.reports.getById': {
    parameters: {
      path: {
        reportId: components['parameters']['pathReportId'];
      };
    };
    responses: {
      /** @description Report Object */
      200: {
        content: {
          'application/json':
            | components['schemas']['HoldingsReport']
            | components['schemas']['TransactionsReport']
            | components['schemas']['TradesReport'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Download report
   * @description Returns binary data encoded based on report format (pdf/csv).
   */
  'v2.reports.getById1': {
    parameters: {
      path: {
        reportId: components['parameters']['pathReportId'];
      };
    };
    responses: {
      /** @description Report Object */
      200: {
        content: {
          oneOf: unknown;
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Generate a wallet report
   * @description Generate a report of transactions for the given wallet
   */
  'v2.report.wallet.generate': {
    parameters: {
      query?: {
        period?: components['parameters']['period'];
        format?: components['parameters']['format'];
        /** @description Defines a unit of currency */
        currency?: components['schemas']['CurrencyUnit'];
        /** @description Start date for the report */
        startDate?: string;
      };
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      /** @description A wallet report of the selected format */
      200: {
        content: {
          'application/json': components['schemas']['Report'];
        };
      };
      /** @description The report is still being processed. When ready, it will show up at the endpoint /api/v2/reports/preparedReports */
      202: {
        content: never;
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Look up user accounts by their Stellar address or id
   * @description Types of searches available:
   *
   * 1. By name: Resolve a Stellar address into an account
   * 2. By id: Resolve an account id into an account
   */
  'v2.federation': {
    parameters: {
      query: {
        q: components['parameters']['queryFederationQ'];
        type: components['parameters']['queryFederationType'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            account_id?: string;
            stellar_address?: string;
            memo_type?: string;
            memo?: string;
          };
        };
      };
      /** @description 'Unsupported type', 'lookup queries not allowed for domain', 'invalid username', 'invalid id' */
      400: {
        content: {
          'application/json': components['schemas']['FederationError'];
        };
      };
    };
  };
  /**
   * Look up material
   * @description Currently available only for Polkadot. Material contains some basic transaction information that is common to all transactions. For Polkadot, this data changes every release.
   */
  'v2.materialData': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            genesisHash?: string;
            chainName?: string;
            specName?: string;
            specVersion?: number;
            txVersion?: number;
            metadata?: string;
          };
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List send labels
   * @description List all send labels for the enterprise. Address and coin parameters optional.
   */
  'v2.sendlabels.list': {
    parameters: {
      query?: {
        coin?: components['parameters']['coin'];
        address?: components['parameters']['address'];
        enterpriseId?: components['parameters']['enterpriseId'];
      };
    };
    responses: {
      /** @description All send labels */
      200: {
        content: {
          'application/json': components['schemas']['SendLabel'][];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Create send label
   * @description Create an address send label for an id
   */
  'v2.sendlabels.create': {
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateSendLabel'];
      };
    };
    responses: {
      /** @description Send label was created */
      200: {
        content: {
          'application/json': components['schemas']['SendLabel'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get send label by id
   * @description Gets an address send label by the specified id
   */
  'v2.sendlabels.get': {
    parameters: {
      path: {
        id: components['parameters']['pathId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['SendLabel'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Update send label
   * @description Updates an address send label by the specified id
   */
  'v2.sendlabels.update': {
    parameters: {
      path: {
        id: components['parameters']['pathId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateSendLabel'];
      };
    };
    responses: {
      /** @description Updated send label */
      200: {
        content: {
          'application/json': components['schemas']['SendLabel'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /** Delete send label */
  'v2.sendlabels.delete': {
    parameters: {
      path: {
        id: components['parameters']['pathId'];
      };
    };
    responses: {
      /** @description Deleted send label */
      200: {
        content: {
          'application/json': components['schemas']['SendLabel'];
        };
      };
      /** @description An error message describing what was incorrect */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get transaction requests by enterprise
   * @description Get a paginated list of transaction requests filtered by enterprise.
   */
  'v2.enterprise.txrequest.get': {
    parameters: {
      query?: {
        prevId?: components['parameters']['prevId'];
        limit?: components['parameters']['limit'];
        latest?: components['parameters']['txRequestLatest'];
        states?: components['parameters']['txRequestStates'];
        txRequestIds?: components['parameters']['txRequestIds'];
        idempotencyKeys?: components['parameters']['idempotencyKeys'];
        sequenceIds?: components['parameters']['sequenceIds'];
        walletIds?: components['parameters']['walletIds'];
        sortBy?: components['parameters']['txRequestSortBy'];
        sortDirection?: components['parameters']['txRequestSortDirection'];
      };
      path: {
        enterpriseId: components['parameters']['pathEnterpriseId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['GetTransactionRequestsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get transaction requests by wallet
   * @description Get a paginated list of transaction requests filtered by wallet. Use only with TSS wallets.
   */
  'v2.wallet.txrequest.get': {
    parameters: {
      query?: {
        prevId?: components['parameters']['prevId'];
        limit?: components['parameters']['limit'];
        latest?: components['parameters']['txRequestLatest'];
        states?: components['parameters']['txRequestStates'];
        txRequestIds?: components['parameters']['txRequestIds'];
        idempotencyKeys?: components['parameters']['idempotencyKeys'];
        sequenceIds?: components['parameters']['sequenceIds'];
        sortBy?: components['parameters']['txRequestSortBy'];
        sortDirection?: components['parameters']['txRequestSortDirection'];
      };
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['GetTransactionRequestsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Create transaction request
   * @description Allows users to create a transaction request given they have spender permissions on the wallet. Use only with TSS wallets. For multisignature wallets, use [Build a transaction](/api/v2.wallet.tx.build).
   */
  'v2.wallet.txrequest.create': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateTransactionRequest'];
      };
    };
    responses: {
      /** @description Transaction Request succesfully returned in preview mode */
      200: {
        content: {
          'application/json': components['schemas']['TransactionRequest'];
        };
      };
      /** @description Transaction Request succesfully created */
      201: {
        content: {
          'application/json': components['schemas']['TransactionRequest'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /** Get transaction requests ready for signature */
  'v2.wallet.txrequest.awaitingsignature.list': {
    parameters: {
      query?: {
        limit?: components['parameters']['limit'];
        txRequestIds?: components['parameters']['txRequestIds'];
        signingStage?: components['parameters']['tssUserSigningStage'];
        sortBy?: components['parameters']['txRequestSortBy'];
        sortDirection?: components['parameters']['txRequestSortDirection'];
        prevId?: components['parameters']['prevId'];
        /** @description If provided, the result will be filtered by the users wallet permissions. */
        walletPermissions?: ('spend' | 'admin')[];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['GetTransactionRequestsAwaitingSignatureResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Update transaction request
   * @description Allows users to update an existing transaction request given they have spender permissions on the wallet. Use only with TSS wallets.
   */
  'v2.wallet.txrequest.update': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
        id: components['parameters']['pathId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateTransactionRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['TransactionRequest'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description Transaction request not found */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Create a signature share for the transaction request
   * @description Allows users to supply their signature share for signing. Use only with TSS wallets.
   */
  'v2.wallet.txrequest.signatureshare.create': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
        id: components['parameters']['pathId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateSignatureShareRequest'];
      };
    };
    responses: {
      201: {
        content: {
          'application/json': components['schemas']['SignatureShare'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description Transaction request not found */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Delete signature shares on a transaction request.
   * @description Allows users to clear the signature shares on a transaction request. This will also set the state to pendingUserSignature. Use only with TSS wallets.
   */
  'v2.wallet.txrequest.signatureshare.delete': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
        id: components['parameters']['pathId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['SignatureShare'][];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description Transaction request not found */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Create a signature share for a transaction on a transaction request
   * @description Allows users to supply their signature share for signing.
   * This route is only valid for transaction request full. Use only with TSS wallets.
   */
  'v2.wallet.txrequest.transaction.signatureshare.create': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
        id: components['parameters']['pathId'];
        transactionIdx: components['parameters']['transactionIdx'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateSignatureShareRequest'];
      };
    };
    responses: {
      201: {
        content: {
          'application/json': components['schemas']['SignatureShare'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description Transaction request not found */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Create ECDSA TSS challenge for transaction
   * @description Create the challenge required for signing ECDSA transactions. You must call this endpoint before calling [Create a signature share for the transaction request](/api/v2.wallet.txrequest.signatureshare.create).
   */
  'v2.wallet.txrequest.transaction.challenge.create': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
        id: components['parameters']['pathId'];
        transactionIdx: components['parameters']['transactionIdx'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateTxRequestChallengeRequest'];
      };
    };
    responses: {
      201: {
        content: {
          'application/json': components['schemas']['CreateTxRequestChallengeResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description Transaction request not found */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Create ECDSA TSS challenge for message
   * @description Create the challenge required for signing ECDSA transactions. You must call this endpoint before calling [Create a signature share for the transaction request](/api/v2.wallet.txrequest.signatureshare.create).
   */
  'v2.wallet.txrequest.message.challenge.create': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
        id: components['parameters']['pathId'];
        transactionIdx: components['parameters']['transactionIdx'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateTxRequestChallengeRequest'];
      };
    };
    responses: {
      201: {
        content: {
          'application/json': components['schemas']['CreateTxRequestChallengeResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description Transaction request not found */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Exchange commitments for EdDSA transactions (lite)
   * @description Exchange commitments for signing EdDSA transactions. This route is only valid for transaction request lite. You must call this endpoint before calling [Create a signature share for the transaction request](/api/v2.wallet.txrequest.signatureshare.create).
   */
  'v2.wallet.txrequest.commitment.exchange': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
        id: components['parameters']['pathId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['TransactionRequestExchangeCommitmentRequest'];
      };
    };
    responses: {
      201: {
        content: {
          'application/json': components['schemas']['TransactionRequestExchangeCommitmentResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description Transaction request not found */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Exchange commitments for EdDSA transactions (full)
   * @description Exchange commitments for signing EdDSA transactions. This route is only valid for transaction request full. You must call this endpoint before calling [Create a signature share for the transaction request](/api/v2.wallet.txrequest.signatureshare.create).
   */
  'v2.wallet.txrequest.transaction.commitment.exchange': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
        id: components['parameters']['pathId'];
        transactionIdx: components['parameters']['transactionIdx'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['TransactionRequestExchangeCommitmentRequest'];
      };
    };
    responses: {
      201: {
        content: {
          'application/json': components['schemas']['TransactionRequestExchangeCommitmentResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description Transaction request not found */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Rebuild transaction requests
   * @description Rebuild multiple transaction requests for a wallet. This is for convenience. The txRequests rebuild in sequential order based on creation date.
   */
  'v2.wallet.txrequests.rebuild': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['RebuildMultipleTxRequests'];
      };
    };
    responses: {
      /** @description All Transaction Requests successfully rebuilt */
      200: {
        content: {
          'application/json': components['schemas']['GetTransactionRequestsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      /** @description "WalletNotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Create transfer for transaction request
   * @description Create a transfer for a transaction request and return that transfer. Use only with TSS wallets.
   */
  'v2.wallet.txrequest.transfers.create': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
        id: components['parameters']['pathId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['Transfer'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Build a transaction
   * @description Build a transaction from the wallet using provided options. Use only with multisignature wallets. For TSS wallets, use [Create transaction request](https://developers.bitgo.com/api/v2.wallet.txrequest.create). If you want to build, sign, and send all in one call, use [Send transaction](https://developers.bitgo.com/api/express.wallet.sendcoins).
   */
  'v2.wallet.tx.build': {
    parameters: {
      query?: {
        destinationTag?: components['parameters']['destinationTag'];
      };
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json':
          | components['schemas']['TransactionBuildRequest']
          | components['schemas']['NonParticipationTransactionBuildRequest'];
      };
    };
    responses: {
      /** @description Successfully built transaction */
      200: {
        content: {
          'application/json': components['schemas']['TransactionBuildResult'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['InvalidAddress']
            | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Consolidate unspents
   * @description Consolidate unspents in a wallet.
   */
  'v2.wallet.consolidateunspents': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressConsolidateUnspentsRequest'];
      };
    };
    responses: {
      /** @description Consolidation transaction successfully built */
      200: {
        content: {
          'application/json': components['schemas']['WalletConsolidateUnspentsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Initiate a transaction
   * @description Initiate an unsigned transaction to create a pending approval. This is useful to request funds to be sent from custodial wallets. Use only with custodial wallets.
   */
  'v2.wallet.tx.initiate': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['TransactionInitiateRequest'] & {
          videoApprovers?: components['schemas']['VideoApprovers'];
        };
      };
    };
    responses: {
      /** @description A Pending Approval for the transaction has been created and is waiting for approval */
      202: {
        content: {
          'application/json': components['schemas']['PendingApproval'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Send a half-signed transaction
   * @description Send a half-signed transaction from the specified wallet.
   * Instead of this endpoint, you likely want to use [send transaction](https://developers.bitgo.com/api/express.wallet.sendcoins)
   * in the SDK.
   */
  'v2.wallet.tx.send': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['SendTransaction'];
      };
    };
    responses: {
      /** @description Transaction successfully sent */
      200: {
        content: {
          'application/json': components['schemas']['TransactionResponse'];
        };
      };
      /** @description A transaction has been created, but will require approval from admins on the wallet. */
      202: {
        content: {
          'application/json': components['schemas']['PendingApproval'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['InvalidWalletId']
            | components['schemas']['InvalidOFAC'];
        };
      };
      /** @description For eth-like coins only. All attempts to acquire nonce have failed, next nonce is locked to another transaction */
      423: {
        content: {
          'application/json': components['schemas']['PlatformErrorNoName'];
        };
      };
    };
  };
  /**
   * Initiate a trustline transaction
   * @description Initiate an unsigned trustline transaction to create a pending approval. Trustline transactions manage trusted tokens on the account. Available for Stellar. Use only with custodial wallets.
   */
  'v2.wallet.trustline.initiate': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['InitiateTrustlineParams'];
      };
    };
    responses: {
      /** @description A Pending Approval for the transaction has been created and is waiting for approval */
      202: {
        content: {
          'application/json': components['schemas']['PendingApproval'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Get balance reserve data
   * @description Returns information about reserve requirements for an account. Currently only available for Stellar.
   */
  'v2.tx.fetchReserve': {
    parameters: {
      path: {
        coin: 'txlm' | 'xlm' | 'tcspr' | 'cspr';
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['BalanceReserve'];
        };
      };
      /** @description "CoinUnsupported" or "Invalid" */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List bank accounts
   * @description This route is potentially useful for finding the "idHash" of the desired account to use for fiat withdrawals. The "idHash" field
   * is used as the recipient address along with an optional hyphen separator and memo (example: "5812dcaa9a285aa6-memohere").
   */
  'v2.bankaccount.list': {
    parameters: {
      query?: {
        enterpriseId?: components['parameters']['queryEnterpriseIdArray'];
        verificationState?: components['schemas']['BankAccountVerificationState'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ListBankAccountsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
    };
  };
  /** Create a bank account */
  'v2.bankaccount.create': {
    requestBody?: {
      content: {
        'application/json': components['schemas']['BankAccount'] & Record<string, never>;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['BankAccount'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidEnterpriseId'];
        };
      };
    };
  };
  /**
   * Get bank account
   * @description This route is potentially useful for finding the "idHash" of the desired account to use for fiat withdrawals. The "idHash" field
   * is used as the recipient address along with an optional hyphen separator and memo (example: "5812dcaa9a285aa6-memohere").
   */
  'v2.bankaccount.get': {
    parameters: {
      path: {
        bankAccountId: components['parameters']['pathBankAccountId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['BankAccount'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidBankAccountId'];
        };
      };
    };
  };
  /** Update bank account */
  'v2.bankaccount.update': {
    parameters: {
      path: {
        bankAccountId: components['parameters']['pathBankAccountId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateBankAccount'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['BankAccount'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidBankAccountId'];
        };
      };
    };
  };
  /**
   * Delete bank account
   * @description Removes a bank account if not already verified
   */
  'v2.bankaccount.delete': {
    parameters: {
      path: {
        bankAccountId: components['parameters']['pathBankAccountId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['BankAccount'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidBankAccountId'];
        };
      };
    };
  };
  /**
   * Ping BitGo Express
   * @description Ping bitgo express to ensure that it is still running. Unlike /ping, this does not try connecting to bitgo.com.
   */
  'express.ping': {
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ExpressPingResponse'];
        };
      };
    };
  };
  /**
   * Send transaction
   * @description This call allows you to create and send cryptocurrency to a destination address.
   */
  'express.wallet.sendcoins': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressSendCoinsRequest'];
      };
    };
    responses: {
      /** @description Transaction successfully sent */
      200: {
        content: {
          'application/json': components['schemas']['ExpressSendCoinsResponse'];
        };
      };
      /** @description A transaction has been created, but will require approval from admins on the wallet. */
      202: {
        content: {
          'application/json': components['schemas']['ExpressSendCoinsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Send to many
   * @description Send coins or tokens to one or more recipients. You can use this endpoint to schedule outgoing transactions in bulk, lowering your aggregate amount of blockchain fees.
   *
   * Currently available for UTXO and EVM coins, as well as SOL. Works with both multisignature and TSS wallets. Also supports external-signer mode for EdDSA-based coins in TSS wallets.
   */
  'express.wallet.sendmany': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressSendManyRequest'];
      };
    };
    responses: {
      /** @description Transaction successfully sent */
      200: {
        content: {
          'application/json': components['schemas']['ExpressSendCoinsResponse'];
        };
      };
      /** @description A transaction has been created, but will require approval from admins on the wallet. */
      202: {
        content: {
          'application/json': components['schemas']['ExpressSendCoinsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Encrypt messages
   * @description Symmetrically encrypt an arbitrary message with provided password
   */
  'express.encrypt': {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressEncryptRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ExpressEncryptResponse'];
        };
      };
    };
  };
  /**
   * Decrypt messages
   * @description Decrypt a ciphertext generated by encrypt route with provided password
   */
  'express.decrypt': {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressDecryptRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ExpressDecryptResponse'];
        };
      };
      /** @description If given decryption key does not decrypt the message */
      500: {
        content: never;
      };
    };
  };
  /**
   * Calculate mining fee
   * @deprecated
   * @description Calculate the fee and estimated size in bytes for a Bitcoin transaction
   */
  'express.calculateminerfeeinfo': {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressCalculateMinerFeeInfoRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ExpressCalculateMinerFeeInfoResponse'];
        };
      };
    };
  };
  /**
   * Create key
   * @description Local client-side function to create a new keychain.
   *
   * Creating your keychains is a critical step for safely securing your Bitcoin. When generating new keychains, this API uses a random number generator that adheres to industry standards. If you provide your own seed, you must take extreme caution when creating it.
   * Returns an object containing the xprv and xpub for the new chain. The created keychain is not known to the BitGo service. To use it with the BitGo service, use the ‘Store Keychain’ API call.
   *
   * For security reasons, it is highly recommended that you encrypt and destroy the original xprv immediately to prevent theft.
   */
  'express.keychain.local': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ExpressCreateKeychainResponse'];
        };
      };
    };
  };
  /**
   * Generate wallet
   * @description This API call creates a new wallet. Under the hood, the SDK (or BitGo Express) does the following:
   *
   * 1. Creates the user keychain locally on the machine, and encrypts it with the provided passphrase (skipped if userKey is provided).
   * 2. Creates the backup keychain locally on the machine.
   * 3. Uploads the encrypted user keychain and public backup keychain.
   * 4. Creates the BitGo key (and the backup key if backupXpubProvider is set) on the service.
   * 5. Creates the wallet on BitGo with the 3 public keys above.
   *
   * ⓘ Ethereum wallets can only be created under an enterprise. Pass in the id of the enterprise to associate the wallet with. Your enterprise id can be seen by clicking on the “Manage Organization” link on the enterprise dropdown. Each enterprise has a fee address which will be used to pay for transaction fees on all Ethereum wallets in that enterprise. The fee address is displayed in the dashboard of the website, please fund it before creating a wallet.
   *
   * ⓘ You cannot generate a wallet by passing in a subtoken as the coin. Subtokens share wallets with their parent coin and it is not possible to create a wallet specific to one token. Please see Coin-Specific Implementation for details.
   *
   * ⓘ This endpoint should be called through BitGo Express if used without the SDK, such as when using cURL.
   */
  'express.wallet.generate': {
    parameters: {
      query?: {
        includeKeychains?: boolean;
      };
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressGenerateWalletRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ExpressGenerateWalletResponse'];
        };
      };
    };
  };
  /**
   * Share wallet
   * @description Share wallet with an existing BitGo user
   */
  'express.wallet.share': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressShareWalletRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ShareWalletResponse'];
        };
      };
    };
  };
  /**
   * Accept wallet share
   * @description Accept a wallet share, adding the wallet to the user's list
   */
  'express.wallet.acceptshare': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressAcceptShareRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ExpressAcceptShareResponse'];
        };
      };
    };
  };
  /**
   * Sign transaction
   * @description This route is for users who would like to maintain their own keys, or otherwise would not like BitGo to decrypt their key, and instead provide it in the clear themselves
   */
  'express.signtx': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressSignTxRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ExpressSignTxResponse'];
        };
      };
    };
  };
  /**
   * Sign wallet transaction
   * @description Sign transactions for multisignature wallets using external-signing mode. You must maintain your keys, in the clear, on a separate Express server. BitGo doesn't decrypt your private keys.
   */
  'express.wallet.signtx': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressWalletSignTxRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ExpressSignTxResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Sign TSS transaction
   * @description Sign transactions for TSS wallets using external-signing mode. You must maintain your keys, in the clear, on a separate Express server. BitGo doesn't decrypt your private TSS key shares.
   */
  'express.wallet.signtxtss': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressSignTssTx'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['TransactionRequest'];
        };
      };
    };
  };
  /**
   * Recover ETH token
   * @description Recover an unsupported Ethereum token from a BitGo multisig wallet
   */
  'express.wallet.recovertoken': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressWalletRecoverTokenRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['ExpressWalletRecoverTokenResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Consolidate account (advanced)
   * @description This endpoint, builds a consolidation transaction. Once built, you must sign and send the transaction.
   * Consolidates the receive address balances to the root address of a wallet. Consolidation is limited to account-based assets.
   * The spendable balance of a wallet is the balance of the funds in the root address. Therefore, funds from wallets with multiple receive addresses must be consolidated before sending.
   */
  'v2.wallet.consolidateaccount.build': {
    parameters: {
      path: {
        coin: components['parameters']['pathAlgorand'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ConsolidateAccountBuildRequest'];
      };
    };
    responses: {
      /** @description Consolidation transaction build successfully sent */
      200: {
        content: {
          'application/json': components['schemas']['ConsolidateAccountBuildResponse'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['InvalidAddress']
            | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Consolidate unspents
   * @description Consolidate unspents on a wallet
   */
  'express.wallet.consolidateunspents': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressConsolidateUnspentsRequest'];
      };
    };
    responses: {
      /** @description Consolidation transaction successfully sent */
      200: {
        content: {
          'application/json': components['schemas']['ExpressSendCoinsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Fan out unspents
   * @description Fan out unspents on a wallet
   */
  'express.wallet.fanoutunspents': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressFanOutUnspentsRequest'];
      };
    };
    responses: {
      /** @description Fanout transaction successfully sent */
      200: {
        content: {
          'application/json': components['schemas']['ExpressSendCoinsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Sweep funds
   * @description The sweep call spends the full balance of the wallet to the provided address. On UTXO coins, the sweep call will
   * fail if the wallet has any unconfirmed funds, or if there are more unspents than can be sent with a
   * single transaction.
   */
  'express.wallet.sweep': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressSweepRequest'];
      };
    };
    responses: {
      /** @description Sweep transaction successfully sent */
      200: {
        content: {
          'application/json': components['schemas']['ExpressSendCoinsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Accelerate Transaction
   * @description Send a child-pays-for-parent (CPFP) transaction to accelerate the target unconfirmed transactions.
   *
   * **Background**:
   * In Bitcoin, a transaction can only be included in a block when all its inputs are confirmed.
   * This requirement can be used to increase the effective fee rate of a stuck low-fee transaction.
   * One of the stuck transaction's outputs is spent in a child transaction with a much higher fee.
   * Miners include the transactions with the highest fees first to maximize their revenue,
   * but the high-fee child transaction can only be included once the parent transaction is confirmed.
   * The miners are therefore incentivized to include both the parent and the child transaction together in a block.
   * A child-pays-for-parent transaction can be created by a recipient of the transaction or by the sender if the
   * target transaction has a change output.
   *
   * **Notes**:
   * 1. As other coins do not have a blockspace market, this route is only available for Bitcoin at this time.<br/>
   * 2. If a target transaction depends on other unconfirmed transactions, this route adds sufficient fees
   * to elevate the entire transaction ancestry's effective fee rate to the "cpfpFeeRate".
   */
  'express.wallet.acceleratetx': {
    parameters: {
      path: {
        coin: components['parameters']['pathBitcoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressAccelerateTxRequest'];
      };
    };
    responses: {
      /** @description CPFP transaction successfully sent */
      200: {
        content: {
          'application/json': components['schemas']['ExpressSendCoinsResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Update comment
   * @description Update the comment of a transfer
   * Requirements:
   *   - Transaction must be generated from a BitGo wallet
   */
  'v2.transfer.comment': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
        transferId: components['parameters']['pathTransferId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateCommentRequest'];
      };
    };
    responses: {
      /** @description Comment successfully changed */
      200: {
        content: {
          'application/json': components['schemas']['Transfer'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['InvalidWalletId']
            | components['schemas']['InvalidTransferId'];
        };
      };
      /** @description Token lacks required scope for wallet_edit */
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Change Fee
   * @description Change the fee rate of a transaction in an attempt to accelerate its confirmation.
   * Supported by: ETH, ERC20 tokens, CELO, RSK, ETC
   * Requirements:
   *   - Transaction gas price must increase by at least 10 Gwei or 20% higher than the original transaction fee
   *   - At least 15 minutes must have passed since original send
   */
  'v2.wallet.changefee': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ChangeFeeRequest'];
      };
    };
    responses: {
      /** @description Transaction fee successfully changed */
      200: {
        content: {
          'application/json': components['schemas']['ChangeFeeResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Canonicalize address
   * @description Canonicalize an LTC or BCH address.
   */
  'express.canonicaladdress': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressCanonicalAddressRequest'];
      };
    };
    responses: {
      /** @description Converted address */
      200: {
        content: {
          'application/json': components['schemas']['AddressString'];
        };
      };
    };
  };
  /**
   * Verify address
   * @description Verify address for a given coin
   */
  'express.verifycoinaddress': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressVerifyCoinAddressRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            isValid?: boolean;
          };
        };
      };
    };
  };
  /**
   * List counts of pending approvals
   * @description List counts of pending approvals by enterprises that the current user is a part of
   */
  'v2.pendingapprovals.count.list': {
    parameters: {
      query?: {
        actionable?: components['parameters']['actionable'];
      };
    };
    responses: {
      /** @description List counts of pending approvals by enterprises that the current user is a part of */
      200: {
        content: {
          'application/json': components['schemas']['PendingApprovalsCountByEnterprise'];
        };
      };
      /** @description No or invalid authentication provided */
      401: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Resolve pending approval
   * @description Accept or reject a pending approval
   */
  'express.pendingapprovals': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        approvalId: components['parameters']['pathApprovalId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressResolvePendingApprovalRequest'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['PendingApproval'];
        };
      };
    };
  };
  /** List audit logs */
  'v2.auditlog.list': {
    parameters: {
      query?: {
        /** @description Filter by coin(s). Must include coins to see activity on the wallets of those coins. */
        coin?: components['schemas']['Coin'][];
        enterpriseId?: components['parameters']['queryEnterpriseIdOrPersonal'];
        limit?: components['parameters']['limit'];
        prevId?: components['parameters']['prevId'];
        type?: components['parameters']['auditLogType'];
        walletId?: components['parameters']['walletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['AuditLogsResponse'];
        };
      };
    };
  };
  /**
   * Get staked balance data
   * @description Returns staking information about validator and staked amount for the current wallet. Currently only available for Casper and Stacks.
   */
  'v2.wallet.staked': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['BalanceStaked'];
        };
      };
      /** @description "CoinUnsupported" or "Invalid" */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Get total rewards data
   * @description Returns staking information receiving address and the total rewards received for the current wallet. Currently only available for Stacks.
   */
  'v2.wallet.totalrewards': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['BalanceTotalRewards'];
        };
      };
      /** @description "CoinUnsupported" or "Invalid" */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Withdraw from lightning balance
   * @description This API call is used to request a withdrawal of on-chain funds from the custodial lightning balance. Withdrawals are deducted from the wallet's lightning balance.
   */
  'v2.wallet.lightning.withdraw': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['LightningWithdrawRequest'];
      };
    };
    responses: {
      /** @description The lightning withdrawal has been successfully processed. */
      200: {
        content: {
          'application/json': components['schemas']['LightningWithdrawResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
      /** @description A withdrawal with the provided sequenceId already exists for this wallet */
      409: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Create address for lightning deposits
   * @description This API call is used to create a new address to deposit funds to the
   * wallet's custodial lightning balance. Funds sent to this address will
   * be credited to the wallet's lightning balance.
   */
  'v2.wallet.lightning.newAddress': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      /** @description An address for lightning deposits has been created */
      200: {
        content: {
          'application/json': components['schemas']['LightningAddressResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Fetch lightning invoices
   * @description This API call is used to fetch previously created lightning invoices
   * associated with a given walletId.
   */
  'v2.wallet.lightning.getInvoices': {
    parameters: {
      query?: {
        /** @description The status of lightning invoices to search for */
        status?: string;
        /** @description Limit the number of search results. Default 25 */
        limit?: number;
        /** @description The start date for range of lightning invoices to search for */
        startDate?: string;
        /** @description The end date for range of lightning invoices to search for */
        endDate?: string;
      };
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      /** @description Lightning invoices have been successfully fetched. */
      200: {
        content: {
          'application/json': components['schemas']['LightningGetInvoicesResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Create a lightning invoice
   * @description This API call is used to create a new lightning invoice which can be
   * used for requesting and receiving payments over the lightning network.
   */
  'v2.wallet.lightning.invoice': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateInvoiceRequest'];
      };
    };
    responses: {
      /** @description A lightning invoice has been successfully created. */
      200: {
        content: {
          'application/json': components['schemas']['LightningInvoice'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Get lightning balance
   * @description Get the custodial lightning balance for the wallet.
   */
  'v2.wallet.lightning.balance': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      /** @description The wallet lightning balance query was successful. */
      200: {
        content: {
          'application/json': components['schemas']['LightningBalanceResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Send a lightning payment
   * @description Send a lightning payment that pays a provided payment request using the
   * wallet's custodial lightning balance.
   */
  'v2.wallet.lightning.payment': {
    parameters: {
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json':
          | components['schemas']['LightningInvoicePaymentRequest']
          | components['schemas']['LightningLnurlPaymentRequest'];
      };
    };
    responses: {
      /** @description Payment successfully queued */
      200: {
        content: {
          'application/json': components['schemas']['LightningPaymentResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * List forwarder addresses and balances
   * @description Lists all forwarder addresses and their balances for a wallet. By default, returns low-balance forwarder addresses. A forwarder address has a low balance if the number of assets in it is less than the balance times by the current gas price times the transaction gas limit.
   */
  'v2.wallet.forwarders.balance': {
    parameters: {
      query?: {
        coin?: components['parameters']['coin'];
        /** @description Lower bound of balance range. */
        minimumBalance?: number;
        /** @description Upper bound of balance range. */
        maximumBalance?: number;
      };
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['GetForwardersBalanceResponse'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['InvalidWalletId']
            | components['schemas']['CoinOperationNotSupported'];
        };
      };
    };
  };
  /**
   * Get Bitgo TSS GPG public key
   * @description It is necessary to use correct TSS BitGo public GPG key when performing TSS operations. Different public keys might be necessary in different cases. This endpoint returns a valid GPG public key taking into account all factors, including: coin, user and enterprise feature flags. Using incorrect key may cause signing and wallet creation errors.
   */
  'v2.tsspubkey.getbycoin': {
    parameters: {
      query?: {
        /** @description Filter by enterprise. Allows to take enterprise settings into consideration. */
        enterpriseId?: components['schemas']['Id'];
      };
    };
    responses: {
      /** @description Public key returned successfully */
      200: {
        content: {
          'application/json': components['schemas']['GetTSSPubkeyByCoin'];
        };
      };
      /** @description Invalid parameters */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List last 10 contract sequenceIds of a wallet
   * @description Lists last 10 contract sequenceIds of the base address of a wallet alongwith their transaction ids.
   */
  'v2.wallet.getSequenceIds': {
    parameters: {
      query?: {
        coin?: components['parameters']['coin'];
      };
      path: {
        walletId: components['parameters']['pathWalletId'];
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['GetSequenceIdsResponse'];
        };
      };
      400: {
        content: {
          'application/json':
            | components['schemas']['PlatformError']
            | components['schemas']['InvalidWalletId']
            | components['schemas']['CoinOperationNotSupported'];
        };
      };
    };
  };
  /**
   * List ECDSA TSS configurations per enterprise
   * @description List all ECDSA TSS configurations from all enterprises for a user. Returns an empty array if the user's enterprise doesn't have any ECDSA TSS configurations.
   */
  'v2.tssconfigs.ecdsa.get': {
    parameters: {
      query?: {
        /** @description Filter by the user who created the config. Pass in "me" to filter by the current user's id. */
        createdBy?: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': components['schemas']['TssConfig'][];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description "NotFound" */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * Delete ECDSA TSS configurations
   * @description Deletes the ECDSA TSS configurations from all enterprises the user is an admin of.
   */
  'v2.tssconfigs.ecdsa.delete': {
    requestBody?: {
      content: {
        'application/json': {
          createdBy?: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            deletedCount?: number;
          };
        };
      };
    };
  };
  /**
   * Consolidate account (simple)
   * @description This Express endpoint, builds, signs, and sends the consolidation transaction all in 1 call.
   * Consolidates the receive address balances to the root address of a wallet. Consolidation is limited to account-based assets.
   * The spendable balance of a wallet is the balance of the funds in the root address. Therefore, funds from wallets with multiple receive addresses must be consolidated before sending.
   */
  'express.wallet.consolidateAccount': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin'];
        walletId: components['parameters']['pathWalletId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ExpressConsolidateAccountRequest'];
      };
    };
    responses: {
      /** @description Transaction successfully sent */
      200: {
        content: {
          'application/json': components['schemas']['ExpressSendConsolidationResponse'];
        };
      };
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'] | components['schemas']['InvalidWalletId'];
        };
      };
    };
  };
  /**
   * Create enterprise
   * @description Create an enterprise in the specified organization. Also create a user if it doesn't already exist.
   */
  'v2.organization.enterprise.create': {
    parameters: {
      path: {
        organizationId: components['parameters']['pathOrganizationId'];
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateOrganizationEnterpriseRequest'];
      };
    };
    responses: {
      /** @description The enterprise and user were created successfully */
      200: {
        content: {
          'application/json': components['schemas']['CreateOrganizationEnterpriseResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description The user does not have the correct permissions to create the enterprise */
      403: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description The organization could not be found */
      404: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
      /** @description Internal error while attempting to create enterprise */
      500: {
        content: {
          'application/json': components['schemas']['PlatformError'];
        };
      };
    };
  };
  /**
   * List Partner-Supported Currencies
   * @description List currencies which can be allocated/deallocated to/from a connection to a BitGo Network Partner.
   */
  v1EnterpriseSupportedCurrenciesRoute: {
    parameters: {
      query: {
        partnerIds: string[];
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1SupportedCurrencies */
            supportedCurrencies: {
              [key: string]: {
                ofcCurrency: string;
                backingCurrency: string;
                partnerNames: string[];
              }[];
            };
            /** NonEmptyString */
            domain: string;
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * List Client Settlement Transfers
   * @description Lists all settlement transfers for your BitGo Network client account.
   */
  v1ClientSettlementTransfersGetRoute: {
    parameters: {
      query?: {
        pageNumber?: string;
        pageSize?: string;
        currencies?: string[];
        partnerIds?: string[];
        initiatedBy?: string[];
        settlementIds?: string[];
        settlementStatuses?: ('failed' | 'completed' | 'pending')[];
        settlementUpdatedBefore?: string;
        settlementUpdatedOnOrAfter?: string;
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** MaskedV1SettlementTransfersOutput */
            settlementTransfers: {
              /** UUID */
              id: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** NonEmptyString */
              currency: string;
              /** UUID */
              settlementId: string;
              /** NonZeroBigIntFromString */
              quantity: string;
              txIds: string[];
              /**
               * SettlementStatuses
               * @enum {string}
               */
              settlementStatus: 'failed' | 'completed' | 'pending';
              /** NonEmptyString */
              sourceTradingAccountId?: string;
              /** NonEmptyString */
              sourceClientName?: string;
              /** NonEmptyString */
              destinationTradingAccountId?: string;
              /** NonEmptyString */
              destinationClientName?: string;
              /** UUID */
              sourceNetworkAccountId?: string;
              /** NonEmptyString */
              sourceConnectionName?: string;
              /** UUID */
              destinationNetworkAccountId?: string;
              /** NonEmptyString */
              destinationConnectionName?: string;
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Get Client Settlement
   * @description This API call allows clients to get a list of settlement transactions for any connected network account, for a specific settlement. The settlement and its metadata will be returned along with all related settlement transfers in and out of the clients’ network accounts.
   */
  v1ClientSettlementGetRoute: {
    parameters: {
      query?: {
        pageNumber?: string;
        pageSize?: string;
        currencies?: string[];
      };
      path: {
        enterpriseId: string;
        settlementId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1SettlementOutput */
            settlement: OneOf<
              [
                {
                  /** @enum {string} */
                  status: 'pending';
                  /** NonEmptyString */
                  notes?: string;
                  /** NonEmptyString */
                  reason?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                },
                {
                  /** @enum {string} */
                  status: 'failed';
                  /** NonEmptyString */
                  reason: string;
                  /** NonEmptyString */
                  notes?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                },
                {
                  /** @enum {string} */
                  status: 'completed';
                  /** NonEmptyString */
                  notes?: string;
                  /** NonEmptyString */
                  reason?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                }
              ]
            >;
            /** MaskedV1SettlementTransfersOutput */
            settlementTransfers: {
              /** UUID */
              id: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** NonEmptyString */
              currency: string;
              /** UUID */
              settlementId: string;
              /** NonZeroBigIntFromString */
              quantity: string;
              txIds: string[];
              /**
               * SettlementStatuses
               * @enum {string}
               */
              settlementStatus: 'failed' | 'completed' | 'pending';
              /** NonEmptyString */
              sourceTradingAccountId?: string;
              /** NonEmptyString */
              sourceClientName?: string;
              /** NonEmptyString */
              destinationTradingAccountId?: string;
              /** NonEmptyString */
              destinationClientName?: string;
              /** UUID */
              sourceNetworkAccountId?: string;
              /** NonEmptyString */
              sourceConnectionName?: string;
              /** UUID */
              destinationNetworkAccountId?: string;
              /** NonEmptyString */
              destinationConnectionName?: string;
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * List Client Settlements
   * @description This API call allows clients to get a list of settlements that involve their accounts and their metadata.
   */
  v1ClientSettlementsGetRoute: {
    parameters: {
      query?: {
        pageNumber?: string;
        pageSize?: string;
        partnerIds?: string[];
        partyConnectionIds?: string[];
        counterpartyConnectionIds?: string[];
        settlementIds?: string[];
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            settlements: OneOf<
              [
                {
                  /** @enum {string} */
                  status: 'pending';
                  /** NonEmptyString */
                  notes?: string;
                  /** NonEmptyString */
                  reason?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                },
                {
                  /** @enum {string} */
                  status: 'failed';
                  /** NonEmptyString */
                  reason: string;
                  /** NonEmptyString */
                  notes?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                },
                {
                  /** @enum {string} */
                  status: 'completed';
                  /** NonEmptyString */
                  notes?: string;
                  /** NonEmptyString */
                  reason?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                }
              ]
            >[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Get Partner Settlement
   * @description Returns a settlement for your BitGo Network partner account.
   */
  v1PartnerSettlementGetRoute: {
    parameters: {
      query?: {
        pageNumber?: string;
        pageSize?: string;
        currencies?: string[];
        sourceNetworkAccountIds?: string[];
        sourceTradingAccountIds?: string[];
        destinationNetworkAccountIds?: string[];
        destinationTradingAccountIds?: string[];
      };
      path: {
        enterpriseId: string;
        settlementId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1SettlementOutput */
            settlement: OneOf<
              [
                {
                  /** @enum {string} */
                  status: 'pending';
                  /** NonEmptyString */
                  notes?: string;
                  /** NonEmptyString */
                  reason?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                },
                {
                  /** @enum {string} */
                  status: 'failed';
                  /** NonEmptyString */
                  reason: string;
                  /** NonEmptyString */
                  notes?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                },
                {
                  /** @enum {string} */
                  status: 'completed';
                  /** NonEmptyString */
                  notes?: string;
                  /** NonEmptyString */
                  reason?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                }
              ]
            >;
            settlementTransfers: {
              /** NonEmptyString */
              sourceTradingAccountId: string;
              /** UUID */
              sourceNetworkAccountId?: string;
              /** NonEmptyString */
              destinationTradingAccountId: string;
              /** UUID */
              destinationNetworkAccountId: string;
              /** UUID */
              id: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** NonEmptyString */
              currency: string;
              /** UUID */
              settlementId: string;
              /** NonZeroBigIntFromString */
              quantity: string;
              txIds: {
                length: number;
                toString: Record<string, never>;
                toLocaleString: Record<string, never>;
                concat: Record<string, never>;
                join: Record<string, never>;
                slice: Record<string, never>;
                indexOf: Record<string, never>;
                lastIndexOf: Record<string, never>;
                every: Record<string, never>;
                some: Record<string, never>;
                forEach: Record<string, never>;
                map: Record<string, never>;
                filter: Record<string, never>;
                reduce: Record<string, never>;
                reduceRight: Record<string, never>;
                find: Record<string, never>;
                findIndex: Record<string, never>;
                entries: Record<string, never>;
                keys: Record<string, never>;
                values: Record<string, never>;
                includes: Record<string, never>;
                flatMap: Record<string, never>;
                flat: Record<string, never>;
                '__@iterator@82': Record<string, never>;
              };
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * List Partner Settlements
   * @description Lists all settlements for your BitGo Network partner account.
   */
  v1PartnerSettlementsGetRoute: {
    parameters: {
      query?: {
        pageNumber?: string;
        pageSize?: string;
        partyConnectionIds?: string[];
        counterpartyConnectionIds?: string[];
        settlementIds?: string[];
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            settlements: OneOf<
              [
                {
                  /** @enum {string} */
                  status: 'pending';
                  /** NonEmptyString */
                  notes?: string;
                  /** NonEmptyString */
                  reason?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                },
                {
                  /** @enum {string} */
                  status: 'failed';
                  /** NonEmptyString */
                  reason: string;
                  /** NonEmptyString */
                  notes?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                },
                {
                  /** @enum {string} */
                  status: 'completed';
                  /** NonEmptyString */
                  notes?: string;
                  /** NonEmptyString */
                  reason?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                  /** UUID */
                  id: string;
                  /** UUID */
                  partnerId: string;
                  /** NonEmptyString */
                  externalId: string;
                  reconciled: boolean;
                  /** NonEmptyString */
                  initiatedBy: string;
                }
              ]
            >[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Perform Partner Settlement
   * @description Partner route to perform a Settlement.
   */
  v1PartnerSettlementsPostRoute: {
    parameters: {
      path: {
        enterpriseId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** NonEmptyString */
          payload: string;
          /** NonEmptyString */
          signature: string;
          /** NonEmptyString */
          nonce: string;
          /** NonEmptyString */
          externalId: string;
          settlementAmounts: OneOf<
            [
              {
                [key: string]: {
                  [key: string]: string;
                };
              },
              {
                [key: string]: {
                  [key: string]: {
                    [key: string]: string;
                  };
                };
              }
            ]
          >;
          /** NonEmptyString */
          notes?: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1CompleteSettlementOutput */
            settlement: {
              /** @enum {string} */
              status: 'completed';
              /** NonEmptyString */
              notes?: string;
              /** NonEmptyString */
              reason?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** UUID */
              id: string;
              /** UUID */
              partnerId: string;
              /** NonEmptyString */
              externalId: string;
              reconciled: boolean;
              /** NonEmptyString */
              initiatedBy: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': OneOf<
            [
              {
                error: string;
              },
              {
                settlement: OneOf<
                  [
                    {
                      /** @enum {string} */
                      status: 'pending';
                      /** NonEmptyString */
                      notes?: string;
                      /** NonEmptyString */
                      reason?: string;
                      /** Format: date */
                      createdAt: string;
                      /** Format: date */
                      updatedAt: string;
                      /** UUID */
                      id: string;
                      /** UUID */
                      partnerId: string;
                      /** NonEmptyString */
                      externalId: string;
                      reconciled: boolean;
                      /** NonEmptyString */
                      initiatedBy: string;
                    },
                    {
                      /** @enum {string} */
                      status: 'failed';
                      /** NonEmptyString */
                      reason: string;
                      /** NonEmptyString */
                      notes?: string;
                      /** Format: date */
                      createdAt: string;
                      /** Format: date */
                      updatedAt: string;
                      /** UUID */
                      id: string;
                      /** UUID */
                      partnerId: string;
                      /** NonEmptyString */
                      externalId: string;
                      reconciled: boolean;
                      /** NonEmptyString */
                      initiatedBy: string;
                    }
                  ]
                >;
              }
            ]
          >;
        };
      };
      409: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': OneOf<
            [
              {
                error: string;
              },
              {
                settlement: OneOf<
                  [
                    {
                      /** @enum {string} */
                      status: 'pending';
                      /** NonEmptyString */
                      notes?: string;
                      /** NonEmptyString */
                      reason?: string;
                      /** Format: date */
                      createdAt: string;
                      /** Format: date */
                      updatedAt: string;
                      /** UUID */
                      id: string;
                      /** UUID */
                      partnerId: string;
                      /** NonEmptyString */
                      externalId: string;
                      reconciled: boolean;
                      /** NonEmptyString */
                      initiatedBy: string;
                    },
                    {
                      /** @enum {string} */
                      status: 'failed';
                      /** NonEmptyString */
                      reason: string;
                      /** NonEmptyString */
                      notes?: string;
                      /** Format: date */
                      createdAt: string;
                      /** Format: date */
                      updatedAt: string;
                      /** UUID */
                      id: string;
                      /** UUID */
                      partnerId: string;
                      /** NonEmptyString */
                      externalId: string;
                      reconciled: boolean;
                      /** NonEmptyString */
                      initiatedBy: string;
                    }
                  ]
                >;
              }
            ]
          >;
        };
      };
    };
  };
  /**
   * [DEPRECATED] Perform Partner Settlement
   * @description [DEPRECATED] Partner route to perform a Settlement. NOTE: this route is being deprecated in favor of the POST /api/network/v1/enterprises/{enterpriseId}/partners/settlements route.
   */
  v1PartnerSettlementsNonReconciledPostRoute: {
    parameters: {
      path: {
        enterpriseId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** NonEmptyString */
          payload: string;
          /** NonEmptyString */
          signature: string;
          /** NonEmptyString */
          nonce: string;
          /** NonEmptyString */
          externalId: string;
          settlementAmounts: OneOf<
            [
              {
                [key: string]: {
                  [key: string]: string;
                };
              },
              {
                [key: string]: {
                  [key: string]: {
                    [key: string]: string;
                  };
                };
              }
            ]
          >;
          /** NonEmptyString */
          notes?: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1CompleteSettlementOutput */
            settlement: {
              /** @enum {string} */
              status: 'completed';
              /** NonEmptyString */
              notes?: string;
              /** NonEmptyString */
              reason?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** UUID */
              id: string;
              /** UUID */
              partnerId: string;
              /** NonEmptyString */
              externalId: string;
              reconciled: boolean;
              /** NonEmptyString */
              initiatedBy: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': OneOf<
            [
              {
                error: string;
              },
              {
                settlement: OneOf<
                  [
                    {
                      /** @enum {string} */
                      status: 'pending';
                      /** NonEmptyString */
                      notes?: string;
                      /** NonEmptyString */
                      reason?: string;
                      /** Format: date */
                      createdAt: string;
                      /** Format: date */
                      updatedAt: string;
                      /** UUID */
                      id: string;
                      /** UUID */
                      partnerId: string;
                      /** NonEmptyString */
                      externalId: string;
                      reconciled: boolean;
                      /** NonEmptyString */
                      initiatedBy: string;
                    },
                    {
                      /** @enum {string} */
                      status: 'failed';
                      /** NonEmptyString */
                      reason: string;
                      /** NonEmptyString */
                      notes?: string;
                      /** Format: date */
                      createdAt: string;
                      /** Format: date */
                      updatedAt: string;
                      /** UUID */
                      id: string;
                      /** UUID */
                      partnerId: string;
                      /** NonEmptyString */
                      externalId: string;
                      reconciled: boolean;
                      /** NonEmptyString */
                      initiatedBy: string;
                    }
                  ]
                >;
              }
            ]
          >;
        };
      };
      409: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': OneOf<
            [
              {
                error: string;
              },
              {
                settlement: OneOf<
                  [
                    {
                      /** @enum {string} */
                      status: 'pending';
                      /** NonEmptyString */
                      notes?: string;
                      /** NonEmptyString */
                      reason?: string;
                      /** Format: date */
                      createdAt: string;
                      /** Format: date */
                      updatedAt: string;
                      /** UUID */
                      id: string;
                      /** UUID */
                      partnerId: string;
                      /** NonEmptyString */
                      externalId: string;
                      reconciled: boolean;
                      /** NonEmptyString */
                      initiatedBy: string;
                    },
                    {
                      /** @enum {string} */
                      status: 'failed';
                      /** NonEmptyString */
                      reason: string;
                      /** NonEmptyString */
                      notes?: string;
                      /** Format: date */
                      createdAt: string;
                      /** Format: date */
                      updatedAt: string;
                      /** UUID */
                      id: string;
                      /** UUID */
                      partnerId: string;
                      /** NonEmptyString */
                      externalId: string;
                      reconciled: boolean;
                      /** NonEmptyString */
                      initiatedBy: string;
                    }
                  ]
                >;
              }
            ]
          >;
        };
      };
    };
  };
  /**
   * List Partners
   * @description Lists all BitGo Network Partners.
   */
  v1PartnersGetRoute: {
    parameters: {
      query?: {
        pageNumber?: string;
        pageSize?: string;
        ids?: string[];
        names?: string[];
        institutionIds?: string[];
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            partners: {
              /** UUID */
              id: string;
              /** NonEmptyString */
              name: string;
              institutionId: null | string;
              /**
               * PartnerConnectionKeySchema
               * @enum {string}
               */
              connectionKeySchema: 'token' | 'tokenAndSignature';
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Create Partner
   * @description Create a new BitGo Network Partner.
   */
  v1PartnersPostRoute: {
    parameters: {
      path: {
        enterpriseId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** NonEmptyString */
          name: string;
          /**
           * PartnerConnectionKeySchema
           * @enum {string}
           */
          connectionKeySchema: 'token' | 'tokenAndSignature';
          broker: boolean;
          /** UUID */
          institutionId?: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1PartnersOutput */
            partner: {
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** UUID */
              id: string;
              /** NonEmptyString */
              enterpriseId: string;
              institutionId: null | string;
              /** NonEmptyString */
              name: string;
              /**
               * PartnerConnectionKeySchema
               * @enum {string}
               */
              connectionKeySchema: 'token' | 'tokenAndSignature';
              /** UUID */
              clientId: string;
              broker: boolean;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Deallocate Funds from Connection
   * @description This API call allows clients to deallocate funds from a connected partner. A successful deallocation will unlock funds and ensure that they are available for actions (withdrawal/rebalancing) at BitGo. Note: Deallocations will happen synchronously and deallocated amounts can be viewed in the BitGo Application or via a balance endpoint.
   */
  V1ClientDeallocationsPostRoute: {
    parameters: {
      path: {
        connectionId: string;
        enterpriseId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** PositiveBNCurrencyAmount */
          amount: {
            /** BNSupportedCurrency */
            currency: string;
            /** PositiveBigIntFromString */
            quantity: string;
          };
          /** NonEmptyString */
          clientExternalId: string;
          /** NonEmptyString */
          payload: string;
          /** NonEmptyString */
          signature: string;
          /** NonEmptyString */
          nonce: string;
          /** NonEmptyString */
          notes?: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1ClearedAllocation */
            deallocation: {
              /** @enum {string} */
              status: 'cleared';
              /** UUID */
              id: string;
              /** PositiveCurrencyAmount */
              amount: {
                /** NonEmptyString */
                currency: string;
                /** PositiveBigIntFromString */
                quantity: string;
              };
              /** UUID */
              connectionId: string;
              /** NonEmptyString */
              clientExternalId: string;
              /** NonEmptyString */
              partnerExternalId?: string;
              /** NonEmptyString */
              initiatedBy: string;
              /** NonEmptyString */
              notes?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      422: {
        content: {
          'application/json': {
            /** V1ReleasedAllocation */
            deallocation: {
              /** @enum {string} */
              status: 'released';
              /** NonEmptyString */
              reason: string;
              /** UUID */
              id: string;
              /** PositiveCurrencyAmount */
              amount: {
                /** NonEmptyString */
                currency: string;
                /** PositiveBigIntFromString */
                quantity: string;
              };
              /** UUID */
              connectionId: string;
              /** NonEmptyString */
              clientExternalId: string;
              /** NonEmptyString */
              partnerExternalId?: string;
              /** NonEmptyString */
              initiatedBy: string;
              /** NonEmptyString */
              notes?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
            };
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': OneOf<
            [
              {
                error: string;
              },
              {
                /** V1ReservedAllocationOutput */
                deallocation: {
                  /** NonEmptyString */
                  reason: string;
                  /** @enum {string} */
                  status: 'reserved';
                  /** UUID */
                  id: string;
                  /** PositiveCurrencyAmount */
                  amount: {
                    /** NonEmptyString */
                    currency: string;
                    /** PositiveBigIntFromString */
                    quantity: string;
                  };
                  /** UUID */
                  connectionId: string;
                  /** NonEmptyString */
                  clientExternalId: string;
                  /** NonEmptyString */
                  partnerExternalId?: string;
                  /** NonEmptyString */
                  initiatedBy: string;
                  /** NonEmptyString */
                  notes?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                };
              }
            ]
          >;
        };
      };
    };
  };
  /**
   * Get Client Connection
   * @description Returns a BitGo Network connection by its connection ID. For use only by BitGo Network clients.
   */
  v1ClientConnectionGetRoute: {
    parameters: {
      path: {
        connectionId: string;
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1ConnectionOutput */
            connection: {
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              partnersConnectionId: null | string;
              partnersClientId: null | string;
              initialized: boolean;
              /** UUID */
              id: string;
              /** NonEmptyString */
              name: string;
              /** UUID */
              clientId: string;
              /** UUID */
              partnerId: string;
              /** UUID */
              networkAccountId: string;
              active: boolean;
              /** NonEmptyString */
              proof: string;
              /** NonEmptyString */
              nonce: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Update Client Connection
   * @description Update a BitGo Network connection by its connection ID. For use only by BitGo Network clients.
   */
  v1ClientConnectionPutRoute: {
    parameters: {
      path: {
        connectionId: string;
        enterpriseId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** NonEmptyString */
          name?: string;
          active?: boolean;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1ConnectionOutput */
            connection: {
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              partnersConnectionId: null | string;
              partnersClientId: null | string;
              initialized: boolean;
              /** UUID */
              id: string;
              /** NonEmptyString */
              name: string;
              /** UUID */
              clientId: string;
              /** UUID */
              partnerId: string;
              /** UUID */
              networkAccountId: string;
              active: boolean;
              /** NonEmptyString */
              proof: string;
              /** NonEmptyString */
              nonce: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Get Partner Connection
   * @description Returns a BitGo Network connection by its connection ID. For use only by BitGo Network partners.
   */
  v1PartnerConnectionGetRoute: {
    parameters: {
      path: {
        connectionId: string;
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1ConnectionOutput */
            connection: {
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              partnersConnectionId: null | string;
              partnersClientId: null | string;
              initialized: boolean;
              /** UUID */
              id: string;
              /** NonEmptyString */
              name: string;
              /** UUID */
              clientId: string;
              /** UUID */
              partnerId: string;
              /** UUID */
              networkAccountId: string;
              active: boolean;
              /** NonEmptyString */
              proof: string;
              /** NonEmptyString */
              nonce: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * List Partner Connections
   * @description Returns all your BitGo Network connections. For use only by BitGo Network partners.
   */
  v1PartnerConnectionsGetRoute: {
    parameters: {
      query?: {
        pageNumber?: string;
        pageSize?: string;
        connectionIds?: string[];
        clientIds?: string[];
        partnersConnectionIds?: string[];
        active?: string;
        partnersClientIds?: string[];
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            connections: {
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              partnersConnectionId: null | string;
              partnersClientId: null | string;
              initialized: boolean;
              /** UUID */
              id: string;
              /** NonEmptyString */
              name: string;
              /** UUID */
              clientId: string;
              /** UUID */
              partnerId: string;
              /** UUID */
              networkAccountId: string;
              active: boolean;
              /** NonEmptyString */
              proof: string;
              /** NonEmptyString */
              nonce: string;
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * List Client Connections
   * @description Lists all your BitGo Network connections. For use only by BitGo Network clients.
   */
  v1ClientConnectionsGetRoute: {
    parameters: {
      query?: {
        pageNumber?: string;
        pageSize?: string;
        connectionIds?: string[];
        partnerIds?: string[];
        active?: string;
        names?: string[];
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            connections: {
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              partnersConnectionId: null | string;
              partnersClientId: null | string;
              initialized: boolean;
              /** UUID */
              id: string;
              /** NonEmptyString */
              name: string;
              /** UUID */
              clientId: string;
              /** UUID */
              partnerId: string;
              /** UUID */
              networkAccountId: string;
              active: boolean;
              /** NonEmptyString */
              proof: string;
              /** NonEmptyString */
              nonce: string;
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Connect to Partner
   * @description Connect your BitGo Network client account to a BitGo Network partner, enabling you to trade funds that you have custodied with BitGo. You must have an account on the partner's site. Clients can have multiple connections to the same partner.
   */
  v1ClientConnectionsPostRoute: {
    parameters: {
      path: {
        enterpriseId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** NonEmptyString */
          payload: string;
          /** NonEmptyString */
          signature: string;
          /** NonEmptyString */
          nonce: string;
          /** UUID */
          partnerId: string;
          /** NonEmptyString */
          name: string;
          /** ConnectionKey */
          connectionKey: OneOf<
            [
              {
                /** @enum {string} */
                schema: 'token';
                /** NonEmptyString */
                connectionToken: string;
              },
              {
                /** @enum {string} */
                schema: 'tokenAndSignature';
                /** NonEmptyString */
                connectionToken: string;
                /** NonEmptyString */
                signature: string;
              }
            ]
          >;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1ConnectionOutput */
            connection: {
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              partnersConnectionId: null | string;
              partnersClientId: null | string;
              initialized: boolean;
              /** UUID */
              id: string;
              /** NonEmptyString */
              name: string;
              /** UUID */
              clientId: string;
              /** UUID */
              partnerId: string;
              /** UUID */
              networkAccountId: string;
              active: boolean;
              /** NonEmptyString */
              proof: string;
              /** NonEmptyString */
              nonce: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Create Client
   * @description Create a new BitGo Network client.
   */
  v1ClientsPostRoute: {
    parameters: {
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1ClientsOutput */
            client: {
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** UUID */
              id: string;
              /** NonEmptyString */
              enterpriseId: string;
              /** NonEmptyString */
              walletId: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * List partner balances
   * @description Lists all your BitGo Network balances. For use only by BitGo Network partners.
   */
  v1PartnerBalancesGetRoute: {
    parameters: {
      query?: {
        pageNumber?: string;
        pageSize?: string;
        connectionIds?: string[];
        clientIds?: string[];
        partnersConnectionIds?: string[];
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** UUID */
            partnerId: string;
            /** AccountBalanceRecord */
            balances: {
              [key: string]: {
                /** NonNegativeBigIntFromString */
                available: string;
                /** NonNegativeBigIntFromString */
                held: string;
              };
            };
            /** NetworkAccountBalanceRecordForPartner */
            networkBalances: {
              [key: string]: {
                /** UUID */
                clientId: string;
                /** NonEmptyString */
                partnersConnectionId: string;
                /** AccountBalanceRecord */
                balances: {
                  [key: string]: {
                    /** NonNegativeBigIntFromString */
                    available: string;
                    /** NonNegativeBigIntFromString */
                    held: string;
                  };
                };
              };
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * List Client Balances
   * @description This API call allows clients to get trading and allocated balances at BitGo for any connected trading partner. The trading balances are live data. The data under networkBalances are not the live balances at the partner, the live balances should be viewed on the partner’s platform. networkBalances will only update as a result of allocations, deallocations, and settlement.
   */
  v1ClientBalancesGetRoute: {
    parameters: {
      query?: {
        pageNumber?: string;
        pageSize?: string;
        connectionIds?: string[];
        partnerIds?: string[];
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** UUID */
            clientId: string;
            /** AccountBalanceRecord */
            balances: {
              [key: string]: {
                /** NonNegativeBigIntFromString */
                available: string;
                /** NonNegativeBigIntFromString */
                held: string;
              };
            };
            /** NetworkAccountBalanceRecordForClient */
            networkBalances: {
              [key: string]: {
                /** UUID */
                partnerId: string;
                /** NonEmptyString */
                partnersConnectionId: string;
                /** NonEmptyString */
                name: string;
                /** AccountBalanceRecord */
                balances: {
                  [key: string]: {
                    /** NonNegativeBigIntFromString */
                    available: string;
                    /** NonNegativeBigIntFromString */
                    held: string;
                  };
                };
              };
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Get client Allocation or Deallocation
   * @description Returns an allocation or deallocation. For use only by BitGo Network clients.
   */
  v1ClientAllocationGetRoute: {
    parameters: {
      path: {
        enterpriseId: string;
        allocationId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1AllocationGetOutput */
            allocation: {
              reason: null | string;
              /**
               * AllocationStatus
               * @enum {string}
               */
              status: 'cleared' | 'released' | 'reserved';
              /**
               * AllocationType
               * @enum {string}
               */
              type: 'allocation' | 'deallocation';
              /** UUID */
              id: string;
              /** PositiveCurrencyAmount */
              amount: {
                /** NonEmptyString */
                currency: string;
                /** PositiveBigIntFromString */
                quantity: string;
              };
              /** UUID */
              connectionId: string;
              /** NonEmptyString */
              clientExternalId: string;
              /** NonEmptyString */
              partnerExternalId?: string;
              /** NonEmptyString */
              initiatedBy: string;
              /** NonEmptyString */
              notes?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Get Partner Allocation or Deallocation
   * @description Returns an allocation or deallocation. For use only by BitGo Network partners.
   */
  v1PartnerAllocationGetRoute: {
    parameters: {
      path: {
        enterpriseId: string;
        allocationId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1AllocationGetOutput */
            allocation: {
              reason: null | string;
              /**
               * AllocationStatus
               * @enum {string}
               */
              status: 'cleared' | 'released' | 'reserved';
              /**
               * AllocationType
               * @enum {string}
               */
              type: 'allocation' | 'deallocation';
              /** UUID */
              id: string;
              /** PositiveCurrencyAmount */
              amount: {
                /** NonEmptyString */
                currency: string;
                /** PositiveBigIntFromString */
                quantity: string;
              };
              /** UUID */
              connectionId: string;
              /** NonEmptyString */
              clientExternalId: string;
              /** NonEmptyString */
              partnerExternalId?: string;
              /** NonEmptyString */
              initiatedBy: string;
              /** NonEmptyString */
              notes?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * List Client Allocations and Deallocations
   * @description This API call allows clients to get a list of allocations & deallocations for any connected network account. Note that this endpoint requires a “types” query parameter set to “allocation” to view allocations or "deallocation" to view deallocations.
   */
  v1ClientAllocationsGetRoute: {
    parameters: {
      query?: {
        sortField?: 'id' | 'updatedAt' | 'quantity' | 'currency';
        sortDirection?: 'ASC' | 'DESC';
        pageNumber?: string;
        pageSize?: string;
        allocationIds?: string[];
        types?: ('allocation' | 'deallocation')[];
        statuses?: ('cleared' | 'released' | 'reserved')[];
        currencies?: string[];
        connectionIds?: string[];
        partnerIds?: string[];
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            allocations: {
              reason: null | string;
              /**
               * AllocationStatus
               * @enum {string}
               */
              status: 'cleared' | 'released' | 'reserved';
              /**
               * AllocationType
               * @enum {string}
               */
              type: 'allocation' | 'deallocation';
              /** UUID */
              id: string;
              /** PositiveCurrencyAmount */
              amount: {
                /** NonEmptyString */
                currency: string;
                /** PositiveBigIntFromString */
                quantity: string;
              };
              /** UUID */
              connectionId: string;
              /** NonEmptyString */
              clientExternalId: string;
              /** NonEmptyString */
              partnerExternalId?: string;
              /** NonEmptyString */
              initiatedBy: string;
              /** NonEmptyString */
              notes?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * List partner Allocations and Deallocations
   * @description Lists all allocations and deallocations. For use only by BitGo Network partners.
   */
  v1PartnerAllocationsGetRoute: {
    parameters: {
      query?: {
        sortField?: 'id' | 'updatedAt' | 'quantity';
        sortDirection?: 'ASC' | 'DESC';
        pageNumber?: string;
        pageSize?: string;
        allocationIds?: string[];
        types?: ('allocation' | 'deallocation')[];
        statuses?: ('cleared' | 'released' | 'reserved')[];
        currencies?: string[];
        connectionIds?: string[];
        clientIds?: string[];
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            allocations: {
              reason: null | string;
              /**
               * AllocationStatus
               * @enum {string}
               */
              status: 'cleared' | 'released' | 'reserved';
              /**
               * AllocationType
               * @enum {string}
               */
              type: 'allocation' | 'deallocation';
              /** UUID */
              id: string;
              /** PositiveCurrencyAmount */
              amount: {
                /** NonEmptyString */
                currency: string;
                /** PositiveBigIntFromString */
                quantity: string;
              };
              /** UUID */
              connectionId: string;
              /** NonEmptyString */
              clientExternalId: string;
              /** NonEmptyString */
              partnerExternalId?: string;
              /** NonEmptyString */
              initiatedBy: string;
              /** NonEmptyString */
              notes?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
    };
  };
  /**
   * Allocate funds to Partner Connection
   * @description This API call allows clients to allocate funds to a connected partner for trade. A successful allocation indicates that funds are locked at BitGo and available for spend on the connected partner. Note: Allocations will happen synchronously and allocated amounts can be viewed in the BitGo Application or via a balances endpoint.
   */
  V1ClientAllocationsPostRoute: {
    parameters: {
      path: {
        connectionId: string;
        enterpriseId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** PositiveBNCurrencyAmount */
          amount: {
            /** BNSupportedCurrency */
            currency: string;
            /** PositiveBigIntFromString */
            quantity: string;
          };
          /** NonEmptyString */
          clientExternalId: string;
          /** NonEmptyString */
          payload: string;
          /** NonEmptyString */
          signature: string;
          /** NonEmptyString */
          nonce: string;
          /** NonEmptyString */
          notes?: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** V1ClearedAllocation */
            allocation: {
              /** @enum {string} */
              status: 'cleared';
              /** UUID */
              id: string;
              /** PositiveCurrencyAmount */
              amount: {
                /** NonEmptyString */
                currency: string;
                /** PositiveBigIntFromString */
                quantity: string;
              };
              /** UUID */
              connectionId: string;
              /** NonEmptyString */
              clientExternalId: string;
              /** NonEmptyString */
              partnerExternalId?: string;
              /** NonEmptyString */
              initiatedBy: string;
              /** NonEmptyString */
              notes?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
            };
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
          };
        };
      };
      422: {
        content: {
          'application/json': {
            /** V1ReleasedAllocation */
            allocation: {
              /** @enum {string} */
              status: 'released';
              /** NonEmptyString */
              reason: string;
              /** UUID */
              id: string;
              /** PositiveCurrencyAmount */
              amount: {
                /** NonEmptyString */
                currency: string;
                /** PositiveBigIntFromString */
                quantity: string;
              };
              /** UUID */
              connectionId: string;
              /** NonEmptyString */
              clientExternalId: string;
              /** NonEmptyString */
              partnerExternalId?: string;
              /** NonEmptyString */
              initiatedBy: string;
              /** NonEmptyString */
              notes?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
            };
            error: string;
          };
        };
      };
      500: {
        content: {
          'application/json': OneOf<
            [
              {
                error: string;
              },
              {
                /** V1ReservedAllocationOutput */
                allocation: {
                  /** NonEmptyString */
                  reason: string;
                  /** @enum {string} */
                  status: 'reserved';
                  /** UUID */
                  id: string;
                  /** PositiveCurrencyAmount */
                  amount: {
                    /** NonEmptyString */
                    currency: string;
                    /** PositiveBigIntFromString */
                    quantity: string;
                  };
                  /** UUID */
                  connectionId: string;
                  /** NonEmptyString */
                  clientExternalId: string;
                  /** NonEmptyString */
                  partnerExternalId?: string;
                  /** NonEmptyString */
                  initiatedBy: string;
                  /** NonEmptyString */
                  notes?: string;
                  /** Format: date */
                  createdAt: string;
                  /** Format: date */
                  updatedAt: string;
                };
              }
            ]
          >;
        };
      };
    };
  };
  /**
   * List settlement trading partners
   * @description List trading partners (counterparties) for a trading account.
   */
  V1ListTradingPartnersByAccountRoute: {
    parameters: {
      query?: {
        status?: 'accepted' | 'rejected' | 'canceled' | 'pending';
      };
      path: {
        accountId: string;
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            tradingPartnerList: {
              id: string;
              primaryAccountId: string;
              primaryEnterpriseName: string;
              secondaryAccountId: string;
              secondaryEnterpriseName: string;
              /**
               * TradingPartnerStatuses
               * @enum {string}
               */
              status: 'accepted' | 'rejected' | 'canceled' | 'pending';
              /** Format: date */
              updatedAt: string;
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
    };
  };
  /**
   * List settlement trading partners
   * @description Creates a trading partner (counterparty) for a trading account.
   */
  V1TradingPartnerPostRoute: {
    parameters: {
      path: {
        accountId: string;
        enterpriseId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** NonEmptyString */
          referralCode: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            tradingPartnerList: {
              id: string;
              primaryAccountId: string;
              primaryEnterpriseName: string;
              secondaryAccountId: string;
              secondaryEnterpriseName: string;
              /**
               * TradingPartnerStatuses
               * @enum {string}
               */
              status: 'accepted' | 'rejected' | 'canceled' | 'pending';
              /** Format: date */
              updatedAt: string;
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
    };
  };
  /**
   * List settlements by account
   * @description List settlements by trading account.
   */
  V1ListSettlementsByAccountRoute: {
    parameters: {
      query: {
        limit: string;
        offset: string;
        status?: 'canceled' | 'rejected' | 'pending' | 'failed' | 'expired' | 'settled';
      };
      path: {
        accountId: string;
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            settlementList: {
              approvalRequests: {
                /** Format: date */
                approvedAt?: string;
                /** Format: date */
                createdAt: string;
                /** Format: date */
                updatedAt: string;
                /** NonEmptyString */
                id: string;
                /** NonEmptyString */
                accountId: string;
                /**
                 * ApprovalRequestStatus
                 * @enum {string}
                 */
                status:
                  | 'acknowledged'
                  | 'canceled'
                  | 'rejected'
                  | 'approved'
                  | 'pending'
                  | 'failed'
                  | 'overdue'
                  | 'expired';
                /** NonEmptyString */
                payload: string;
                /** NonEmptyString */
                signature?: string;
              }[];
              settlementTransfers: {
                /** Format: date */
                createdAt: string;
                /** Format: date */
                updatedAt: string;
                /** UUID */
                id: string;
                /** NonEmptyString */
                sourceTradingAccountId: string;
                /** NonEmptyString */
                destinationTradingAccountId: string;
                /** SupportedCurrency */
                currency: string;
                /** PositiveBigIntFromString */
                quantity: string;
                txIds?: string[];
              }[];
              /** NonEmptyString */
              requesterAccountName: string;
              /** Format: date */
              finalizedAt?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** NonEmptyString */
              id: string;
              /** NonEmptyString */
              externalId: string;
              notation?: string;
              /** NonEmptyString */
              requesterAccountId: string;
              /**
               * SettlementStatus
               * @enum {string}
               */
              status: 'canceled' | 'rejected' | 'pending' | 'failed' | 'expired' | 'settled';
              /** @enum {string} */
              type: 'direct';
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
    };
  };
  /**
   * List settlements by enterprise
   * @description List settlements by enterprise.
   */
  V1ListSettlementsByEnterpriseRoute: {
    parameters: {
      query: {
        limit: string;
        offset: string;
        status?: 'canceled' | 'rejected' | 'pending' | 'failed' | 'expired' | 'settled';
      };
      path: {
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            settlementList: {
              approvalRequests: {
                /** Format: date */
                approvedAt?: string;
                /** Format: date */
                createdAt: string;
                /** Format: date */
                updatedAt: string;
                /** NonEmptyString */
                id: string;
                /** NonEmptyString */
                accountId: string;
                /**
                 * ApprovalRequestStatus
                 * @enum {string}
                 */
                status:
                  | 'acknowledged'
                  | 'canceled'
                  | 'rejected'
                  | 'approved'
                  | 'pending'
                  | 'failed'
                  | 'overdue'
                  | 'expired';
                /** NonEmptyString */
                payload: string;
                /** NonEmptyString */
                signature?: string;
              }[];
              settlementTransfers: {
                /** Format: date */
                createdAt: string;
                /** Format: date */
                updatedAt: string;
                /** UUID */
                id: string;
                /** NonEmptyString */
                sourceTradingAccountId: string;
                /** NonEmptyString */
                destinationTradingAccountId: string;
                /** SupportedCurrency */
                currency: string;
                /** PositiveBigIntFromString */
                quantity: string;
                txIds?: string[];
              }[];
              /** NonEmptyString */
              requesterAccountName: string;
              /** Format: date */
              finalizedAt?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** NonEmptyString */
              id: string;
              /** NonEmptyString */
              externalId: string;
              notation?: string;
              /** NonEmptyString */
              requesterAccountId: string;
              /**
               * SettlementStatus
               * @enum {string}
               */
              status: 'canceled' | 'rejected' | 'pending' | 'failed' | 'expired' | 'settled';
              /** @enum {string} */
              type: 'direct';
            }[];
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      404: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
    };
  };
  /**
   * Get settlement by ID.
   * @description Get settlement by ID.
   */
  V1GetSettlementByIdRoute: {
    parameters: {
      path: {
        accountId: string;
        enterpriseId: string;
        settlementId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            approvalRequests: {
              /** Format: date */
              approvedAt?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** NonEmptyString */
              id: string;
              /** NonEmptyString */
              accountId: string;
              /**
               * ApprovalRequestStatus
               * @enum {string}
               */
              status:
                | 'acknowledged'
                | 'canceled'
                | 'rejected'
                | 'approved'
                | 'pending'
                | 'failed'
                | 'overdue'
                | 'expired';
              /** NonEmptyString */
              payload: string;
              /** NonEmptyString */
              signature?: string;
            }[];
            settlementTransfers: {
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** UUID */
              id: string;
              /** NonEmptyString */
              sourceTradingAccountId: string;
              /** NonEmptyString */
              destinationTradingAccountId: string;
              /** SupportedCurrency */
              currency: string;
              /** PositiveBigIntFromString */
              quantity: string;
              txIds?: string[];
            }[];
            /** NonEmptyString */
            requesterAccountName: string;
            /** Format: date */
            finalizedAt?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** NonEmptyString */
            id: string;
            /** NonEmptyString */
            externalId: string;
            notation?: string;
            /** NonEmptyString */
            requesterAccountId: string;
            /**
             * SettlementStatus
             * @enum {string}
             */
            status: 'canceled' | 'rejected' | 'pending' | 'failed' | 'expired' | 'settled';
            /** @enum {string} */
            type: 'direct';
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
    };
  };
  /**
   * Create settlement
   * @description Creates a settlement.
   */
  V1EnterpriseAccountSettlementPostRoute: {
    parameters: {
      path: {
        accountId: string;
        enterpriseId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** NonEmptyString */
          externalId: string;
          /** NonEmptyString */
          counterpartyAccountId: string;
          /** NonEmptyArray */
          assetTransfers: {
            /** SupportedCurrency */
            currency: string;
            /** BigIntFromString */
            quantity: string;
          }[];
          notation?: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            approvalRequests: {
              /** Format: date */
              approvedAt?: string;
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** NonEmptyString */
              id: string;
              /** NonEmptyString */
              accountId: string;
              /**
               * ApprovalRequestStatus
               * @enum {string}
               */
              status:
                | 'acknowledged'
                | 'canceled'
                | 'rejected'
                | 'approved'
                | 'pending'
                | 'failed'
                | 'overdue'
                | 'expired';
              /** NonEmptyString */
              payload: string;
              /** NonEmptyString */
              signature?: string;
            }[];
            settlementTransfers: {
              /** Format: date */
              createdAt: string;
              /** Format: date */
              updatedAt: string;
              /** UUID */
              id: string;
              /** NonEmptyString */
              sourceTradingAccountId: string;
              /** NonEmptyString */
              destinationTradingAccountId: string;
              /** SupportedCurrency */
              currency: string;
              /** PositiveBigIntFromString */
              quantity: string;
              txIds?: string[];
            }[];
            /** NonEmptyString */
            requesterAccountName: string;
            /** Format: date */
            finalizedAt?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** NonEmptyString */
            id: string;
            /** NonEmptyString */
            externalId: string;
            notation?: string;
            /** NonEmptyString */
            requesterAccountId: string;
            /**
             * SettlementStatus
             * @enum {string}
             */
            status: 'canceled' | 'rejected' | 'pending' | 'failed' | 'expired' | 'settled';
            /** @enum {string} */
            type: 'direct';
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      409: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
    };
  };
  /**
   * Get settlement signing
   * @description Get settlement signing.
   */
  V1GetSettlementSigningRoute: {
    parameters: {
      path: {
        accountId: string;
        enterpriseId: string;
        settlementId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            payload: string;
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
    };
  };
  /**
   * Sign settlement
   * @description Signs a Settlement.
   */
  V1PostSettlementSigningRoute: {
    parameters: {
      path: {
        accountId: string;
        enterpriseId: string;
        settlementId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** NonEmptyString */
          payload: string;
          /** NonEmptyString */
          signature: string;
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** NonEmptyString */
            settlementId: string;
            /** Format: date */
            approvedAt?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** NonEmptyString */
            id: string;
            /** NonEmptyString */
            accountId: string;
            /**
             * ApprovalRequestStatus
             * @enum {string}
             */
            status:
              | 'acknowledged'
              | 'canceled'
              | 'rejected'
              | 'approved'
              | 'pending'
              | 'failed'
              | 'overdue'
              | 'expired';
            /** NonEmptyString */
            payload: string;
            /** NonEmptyString */
            signature?: string;
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
    };
  };
  /**
   * Update settlement approval request
   * @description Update an approval request for a settlement.
   */
  V1ApprovalRequestPutRoute: {
    parameters: {
      path: {
        accountId: string;
        enterpriseId: string;
        approvalRequestId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * ApprovalRequestUpdateStatus
           * @enum {string}
           */
          status: 'acknowledged' | 'canceled' | 'rejected';
        };
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            /** NonEmptyString */
            settlementId: string;
            /** Format: date */
            approvedAt?: string;
            /** Format: date */
            createdAt: string;
            /** Format: date */
            updatedAt: string;
            /** NonEmptyString */
            id: string;
            /** NonEmptyString */
            accountId: string;
            /**
             * ApprovalRequestStatus
             * @enum {string}
             */
            status:
              | 'acknowledged'
              | 'canceled'
              | 'rejected'
              | 'approved'
              | 'pending'
              | 'failed'
              | 'overdue'
              | 'expired';
            /** NonEmptyString */
            payload: string;
            /** NonEmptyString */
            signature?: string;
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
    };
  };
  /**
   * Get settlement trading account settings
   * @description Get settlement settings for a trading account.
   */
  V1AccountSettingsGetRoute: {
    parameters: {
      path: {
        accountId: string;
        enterpriseId: string;
      };
    };
    responses: {
      200: {
        content: {
          'application/json': {
            accountId: string;
            affirmationExpirationTime: number;
            /** FeeRate */
            feeRates?: {
              /** PositiveIntConfig */
              settlement: string | number;
            };
            referralCode: string;
          };
        };
      };
      400: {
        content: {
          'application/json': Record<string, never>;
        };
      };
      401: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
      500: {
        content: {
          'application/json': {
            error: string;
            errorName: string;
          };
        };
      };
    };
  };
  /**
   * Get historical prices
   * @description Get a list of historical prices in a specified time range. Using this endpoint requires an access token with the appropriate enterprise ID.
   */
  'marketdata.cryptocompare.historical.prices.get': {
    parameters: {
      query: {
        base: components['parameters']['Base'];
        quote: components['parameters']['Quote'];
        interval: components['parameters']['Interval'];
        start?: components['parameters']['Start'];
        end?: components['parameters']['End'];
      };
    };
    responses: {
      /** @description Returns historical-price data points. Also returns a page cursor if there are more than 1,000 results. */
      200: {
        content: {
          'application/json': components['schemas']['HistoricalPriceResult'];
        };
      };
      /** @description Bad request. */
      400: {
        content: {
          'application/json': components['schemas']['MarketDataError'];
        };
      };
    };
  };
  /**
   * Get spot prices
   * @description Get historical spot prices from a specific time. Using this endpoint requires an access token with the appropriate enterprise ID.
   */
  'marketdata.cryptocompare.spot.prices.get': {
    parameters: {
      query: {
        base: components['parameters']['Base'];
        quote: components['parameters']['Quote'];
        interval: components['parameters']['Interval'];
        timestamp?: string;
      };
    };
    responses: {
      /** @description Returns a historical-price data point. */
      200: {
        content: {
          'application/json': components['schemas']['HistoricalPrice'];
        };
      };
      /** @description Bad request. */
      400: {
        content: {
          'application/json': components['schemas']['MarketDataError'];
        };
      };
    };
  };
  /**
   * Get spot prices
   * @description Get historical spot prices from a specific time.
   */
  'internal.marketdata.spot.prices.get': {
    parameters: {
      query: {
        base: components['parameters']['Base'];
        quote: components['parameters']['Quote'];
        interval: components['parameters']['Interval'];
        timestamp?: components['schemas']['DateFromISOString'];
      };
    };
    responses: {
      /** @description Returns a historical-price data point. */
      200: {
        content: {
          'application/json': components['schemas']['HistoricalPrice'];
        };
      };
      /** @description Bad request. */
      400: {
        content: {
          'application/json': components['schemas']['MarketDataError'];
        };
      };
    };
  };
  /**
   * Get Current User
   * @description Get the current user’s public information
   */
  'portfolio.user.current': {
    responses: {
      /** @description A user */
      200: {
        content: {
          'application/json': components['schemas']['PortfolioUser'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Portfolios
   * @description Get a list of the portfolios to which the user with the access token belongs
   */
  'portfolio.portfolios': {
    responses: {
      /** @description An array of portfolios */
      200: {
        content: {
          'application/json': components['schemas']['Portfolios'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Historical Prices
   * @description Get a list of daily historical prices in the portfolio's functional currency - defaults to prior month
   */
  'portfolio.prices': {
    parameters: {
      query: {
        /** @description Symbol of instrument to be queried */
        instrument: string;
        /** @description Must be provided if endDate is provided. Otherwise, will default to one month ago */
        startDate?: string;
        /** @description Must have corresponding startDate if provided */
        endDate?: string;
      };
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
      };
    };
    responses: {
      /** @description An array of instrument prices */
      200: {
        content: {
          'application/json': components['schemas']['InstrumentPrices'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Connections
   * @description Get a list of the connections for a given portfolio to which the user with the access token belongs
   */
  'portfolio.connections': {
    parameters: {
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
      };
    };
    responses: {
      /** @description An array of connections */
      200: {
        content: {
          'application/json': components['schemas']['Connections'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Get Connection
   * @description Get information for a single connection within a given portfolio to which the user with the access token belongs
   */
  'portfolio.connection': {
    parameters: {
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
        /** @description The id of the connection to retrieve */
        connectionId: string;
      };
    };
    responses: {
      /** @description A Connection object */
      200: {
        content: {
          'application/json': components['schemas']['Connection'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Accounts
   * @description Get a list of the accounts for a given portfolio to which the user with the access token belongs
   */
  'portfolio.accounts': {
    parameters: {
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
      };
    };
    responses: {
      /** @description An array of accounts */
      200: {
        content: {
          'application/json': components['schemas']['PortfolioAccounts'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Get Account
   * @description Get information for a single account within a given portfolio to which the user with the access token belongs
   */
  'portfolio.account': {
    parameters: {
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
        /** @description The id of the account to retrieve */
        accountId: string;
      };
    };
    responses: {
      /** @description A PortfolioAccount object */
      200: {
        content: {
          'application/json': components['schemas']['PortfolioAccount'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Balances
   * @description Get balance information (grouped by instrument) for a single portfolio to which the user with the access token belongs
   */
  'portfolio.balances': {
    parameters: {
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
      };
    };
    responses: {
      /** @description An array of instrument balances */
      200: {
        content: {
          'application/json': components['schemas']['InstrumentBalances'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Connection Balances
   * @description Get balance information (grouped by instrument) for a single connection within a given portfolio to which the user with the access token belongs
   */
  'portfolio.connection.balances': {
    parameters: {
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
        /** @description The id of the connection to retrieve */
        connectionId: string;
      };
    };
    responses: {
      /** @description An array of instrument balances */
      200: {
        content: {
          'application/json': components['schemas']['InstrumentBalances'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Account Balances
   * @description Get balance information (grouped by instrument) for a single account within a given portfolio to which the user with the access token belongs
   */
  'portfolio.account.balances': {
    parameters: {
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
        /** @description The id of the account to retrieve */
        accountId: string;
      };
    };
    responses: {
      /** @description An array of instrument balances */
      200: {
        content: {
          'application/json': components['schemas']['InstrumentBalances'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Transactions
   * @description List all transactions for a given portfolio to which the user with the access token belongs
   */
  'portfolio.transactions': {
    parameters: {
      query?: {
        offset?: number;
        limit?: number;
      };
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
      };
    };
    responses: {
      /** @description An array of transactions */
      200: {
        content: {
          'application/json': components['schemas']['Transactions'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Get Transaction
   * @description Get details for a single transaction by Transaction ID within a given portfolio to which the user with the access token belongs
   */
  'portfolio.transaction': {
    parameters: {
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
        /** @description The id of the transaction to retrieve */
        transactionId: string;
      };
    };
    responses: {
      /** @description A single transaction object */
      200: {
        content: {
          'application/json': components['schemas']['PortfolioTransaction'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Line Items
   * @description List all accounting line items within a given portfolio to which the user with the access token belongs
   */
  'portfolio.line_items': {
    parameters: {
      query?: {
        offset?: number;
        limit?: number;
      };
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
      };
    };
    responses: {
      /** @description An array of line items */
      200: {
        content: {
          'application/json': components['schemas']['LineItems'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Get Line Item
   * @description Get details for a single accounting line item by Line Item ID within a given portfolio to which the user with the access token belongs
   */
  'portfolio.line_item': {
    parameters: {
      path: {
        /** @description The id of the portfolio to retrieve */
        portfolioId: string;
        /** @description The id of the accounting line item to retrieve */
        itemId: string;
      };
    };
    responses: {
      /** @description A single accounting line item object */
      200: {
        content: {
          'application/json': components['schemas']['LineItem'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Get Current User
   * @description Get the current user’s public information.
   */
  'trade.user.current': {
    responses: {
      /** @description A user */
      200: {
        content: {
          'application/json': components['schemas']['TradeUser'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Accounts
   * @description Get the list of trading accounts that the current user belongs to.
   */
  'trade.accounts': {
    responses: {
      /** @description An array of accounts */
      200: {
        content: {
          'application/json': {
            data: components['schemas']['Accounts'];
          };
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Get Account Balance
   * @description Get balance information about a single trading account.
   */
  'trade.accounts.balances': {
    parameters: {
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
      };
    };
    responses: {
      /** @description An array of account balances */
      200: {
        content: {
          'application/json': {
            data: components['schemas']['AccountBalances'];
          };
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Orders
   * @description Lists all orders from the given trading account.
   */
  'trade.orders.detail': {
    parameters: {
      query?: {
        offset?: number;
        limit?: number;
        /** @description The clientOrderId of the order to retrieve */
        clientOrderId?: string;
        /** @description Return client orders with a "creationDate" that is greater than or equal to the given timestamp */
        dateGte?: string;
        /** @description Return client orders with a "creationDate" that is less than the given timestamp */
        dateLt?: string;
        /** @description Return client orders with an order "status" that is equal to the given string */
        status?: components['schemas']['OrderStatus'];
      };
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
      };
    };
    responses: {
      /** @description An array of orders */
      200: {
        content: {
          'application/json': {
            data: components['schemas']['Orders'];
          };
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Place Order
   * @description Places a new order. There are several types of orders available - Market, Limit, and TWAP (with or without a limit). Orders can only be placed if your account has a sufficient balance. When an order is placed, funds will be reserved for the amount of the order.
   */
  'trade.orders.add': {
    parameters: {
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['NewOrderRequest'];
      };
    };
    responses: {
      /** @description An order */
      200: {
        content: {
          'application/json': components['schemas']['Order'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Get Order
   * @description Get a single order by order id.
   */
  'trade.orders.order': {
    parameters: {
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
        /** @description The id of the order to retrieve */
        orderId: string;
      };
    };
    responses: {
      /** @description An order */
      200: {
        content: {
          'application/json': components['schemas']['Order'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Cancel Order
   * @description Attempt to cancel an order that was previously placed. The response will return successful if the cancel request is submitted. Use Get Order endpoint or subscribe to the orders websocket to get the order details.
   */
  'trade.orders.order.cancel': {
    parameters: {
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
        /** @description The id of the order to retrieve */
        orderId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Trades
   * @description Lists trades from the trading account. This will include trades that have not yet settled.
   */
  'trade.trades': {
    parameters: {
      query?: {
        offset?: number;
        limit?: number;
        /** @description The orderId of the trades to retrieve */
        orderId?: string;
        /** @description Return exchange trades with a trade date that is greater than or equal to the given timestamp */
        dateGte?: string;
        /** @description Return exchange trades with a trade date that is less than the given timestamp */
        dateLt?: string;
      };
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
      };
    };
    responses: {
      /** @description An array of trades */
      200: {
        content: {
          'application/json': {
            data: components['schemas']['Trades'];
          };
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Get Trade
   * @description Get the details of a single trade by trade id.
   */
  'trade.trades.trade': {
    parameters: {
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
        /** @description The id of the trade to retrieve */
        tradeId: string;
      };
    };
    responses: {
      /** @description A trade */
      200: {
        content: {
          'application/json': components['schemas']['PrimeTrade'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Currencies
   * @description Gets a list of all available currencies.
   */
  'trade.currencies': {
    parameters: {
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
      };
    };
    responses: {
      /** @description An array of currencies */
      200: {
        content: {
          'application/json': {
            data: components['schemas']['Currencies'];
          };
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * List Products
   * @description Gets a list of all available products.
   */
  'trade.products': {
    parameters: {
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
      };
    };
    responses: {
      /** @description An array of products */
      200: {
        content: {
          'application/json': {
            data: components['schemas']['Products'];
          };
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Get Level1 Order Book
   * @description Gets a snapshot of the level1 order book for product
   */
  'trade.products.product.level1': {
    parameters: {
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
        /** @description The name of the product */
        product: string;
      };
    };
    responses: {
      /** @description A Level1OrderBookSnapshot */
      200: {
        content: {
          'application/json': components['schemas']['Level1OrderBookSnapshot'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Get Level2 Order Book
   * @description Gets a snapshot of the order book for product
   */
  'products.product.level2': {
    parameters: {
      path: {
        /** @description The id of the trading account to retrieve */
        accountId: string;
        /** @description The name of the product */
        product: string;
      };
    };
    responses: {
      /** @description A Level2OrderBookSnapshot */
      200: {
        content: {
          'application/json': components['schemas']['Level2OrderBookSnapshot'];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
    };
  };
  /**
   * Retrieve Staking Requests for a User's Wallet
   * @description Retrieve Staking Requests for a User's Wallet.
   */
  'Retrieve Staking Requests for a Users Wallet': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin1'];
        walletId: components['parameters']['pathWalletId1'];
      };
    };
    responses: {
      /** @description Successful Retrieving Staking Requests */
      200: {
        content: {
          'application/json': components['schemas']['StakingRequestsListResponse'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Staking Request Creation
   * @description Create a Staking Request of type STAKE or UNSTAKE.
   */
  'Create staking request': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin1'];
        walletId: components['parameters']['pathWalletId1'];
      };
    };
    requestBody?: {
      content: {
        'application/json':
          | components['schemas']['AvaxPStakingRequestPOSTBody']
          | components['schemas']['EthStakingRequestPOSTBody']
          | components['schemas']['MaticStakingRequestPOSTBody']
          | components['schemas']['MaticUnStakingRequestPOSTBody']
          | components['schemas']['NearStakingRequestPOSTBody']
          | components['schemas']['NearUnStakingRequestPOSTBody']
          | components['schemas']['SolStakingRequestPOSTBody']
          | components['schemas']['SolUnStakingRequestPOSTBody']
          | components['schemas']['DotStakingRequestPOSTBody']
          | components['schemas']['CosmosLikeStakingRequestPOSTBody']
          | components['schemas']['AtomStakingRequestPOSTBody']
          | components['schemas']['DotUnStakingRequestPOSTBody']
          | components['schemas']['CosmosLikeUnStakingRequestPOSTBody']
          | components['schemas']['AtomUnStakingRequestPOSTBody'];
      };
    };
    responses: {
      /** @description Successful Staking Request Accepted and needs Approval */
      202: {
        content: {
          'application/json':
            | components['schemas']['AvaxPStakingRequest']
            | components['schemas']['DotStakingRequest']
            | components['schemas']['EthStakingRequest']
            | components['schemas']['MaticStakingRequest']
            | components['schemas']['NearStakingRequest']
            | components['schemas']['CosmosLikeStakingRequest']
            | components['schemas']['AtomStakingRequest']
            | components['schemas']['SolStakingRequest'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * List Staking Requests for a Wallet
   * @description List Staking Requests for a Wallet.
   */
  'List Filtered Staking Requests for a Wallet': {
    parameters: {
      query?: {
        /** @description The staking asset. */
        coin?: string[];
        /** @description Filter by Staking Request Type */
        requestType?: components['schemas']['StakingRequestType'][];
        /** @description Filter by Staking Request status */
        requestStatus?: components['schemas']['StakingRequestStatus'][];
        /** @description Filter by created date greater than or equal to */
        createdDateGte?: string;
        /** @description Filter by created date less than */
        createdDateLt?: string;
        /** @description Filter by staking request id */
        id?: string[];
        page?: components['parameters']['queryPage'];
        pageSize?: components['parameters']['queryPageSize'];
        sortBy?: components['parameters']['querySortByCreatedDate'];
      };
      path: {
        walletId: components['parameters']['pathWalletId1'];
      };
    };
    responses: {
      /** @description Successful Listing Staking Requests for Wallet */
      200: {
        content: {
          'application/json': components['schemas']['StakingRequestsResponse'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Retrieve Staking Request for a staking request id
   * @description Retrieve A Specific Staking Request.
   */
  'Retrieve A Specific Staking Request': {
    parameters: {
      path: {
        /** @description The id for the staking request */
        stakingRequestId: string;
      };
    };
    responses: {
      /** @description Successful Retrieving a Staking Request */
      200: {
        content: {
          'application/json':
            | components['schemas']['AvaxPStakingRequest']
            | components['schemas']['DotStakingRequest']
            | components['schemas']['EthStakingRequest']
            | components['schemas']['MaticStakingRequest']
            | components['schemas']['NearStakingRequest']
            | components['schemas']['CosmosLikeStakingRequest']
            | components['schemas']['AtomStakingRequest']
            | components['schemas']['SolStakingRequest'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Retrieve staking requests and staking transactions for a given enterprise and query params
   * @description Retrieve staking requests and staking transactions for a given enterprise and query params.
   */
  'Retrieve staking requests for a given enterprise': {
    parameters: {
      query?: {
        /** @description Filter by Wallet Type (e.g. custodial, hot) */
        walletType?: string;
        /** @description Wallet Ids */
        walletIds?: string[];
        /** @description Filter by Staking Request Type */
        requestType?: components['schemas']['StakingRequestType'];
        /** @description Filter by Staking Request status */
        requestStatus?: components['schemas']['StakingRequestStatus'];
        /** @description True, if to include staking build params */
        expandBuildParams?: boolean;
        page?: components['parameters']['queryPage'];
        pageSize?: components['parameters']['queryPageSize'];
        sortBy?: components['parameters']['querySortByCreatedDate'];
      };
      path: {
        /** @description The enterprise id */
        enterpriseId: string;
        coin: components['parameters']['pathCoin1'];
      };
    };
    responses: {
      /** @description Successful Retrieving Staking Requests with Transactions */
      200: {
        content: {
          'application/json': components['schemas']['StakingRequestsResponse'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Act On A Transaction like sending a transaction
   * @description Use to act on a transaction like sending a transaction
   */
  'Act On A Transaction': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin1'];
        walletId: components['parameters']['pathWalletId1'];
        /** @description The id for the staking request */
        stakingRequestId: string;
        /** @description The id for the staking request transaction */
        stakingTransactionId: string;
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['EthStakingTransactionSendRequest'];
      };
    };
    responses: {
      /** @description Successful Acting on a Transaction */
      200: {
        content: {
          'application/json': components['schemas']['EthStakingTransaction'][];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Get Staking Wallet Details
   * @description Get staking wallet information including staking delegated balance, rewards accrued, and rewards accrual annual percentage rate.
   */
  'v1.stakingWallet.get': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin1'];
        walletId: components['parameters']['pathWalletId1'];
      };
    };
    responses: {
      /** @description Successful Get a Staking Wallet */
      200: {
        content: {
          'application/json': components['schemas']['StakingWallet'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Retrieve Staking Wallet Delegations
   * @description Retrieve staking wallet delegation information.
   */
  'Retrieve Staking Wallet Delegations': {
    parameters: {
      query?: {
        /** @description Delegation ids */
        delegationIds?: string;
        /** @description Delegation status */
        delegationStatus?: string;
        /** @description Unsupported for staking */
        unstakeable?: boolean;
        /** @description The delegation Address */
        delegationAddress?: string;
        /** @description Validator provider used for staking */
        provider?: string;
        page?: components['parameters']['queryPage'];
        pageSize?: components['parameters']['queryPageSize'];
        sortBy?: components['parameters']['querySortByCreatedDate'];
      };
      path: {
        coin: components['parameters']['pathCoin1'];
        walletId: components['parameters']['pathWalletId1'];
      };
    };
    responses: {
      /** @description Successful Retrieving a Staking Wallet Delegations */
      200: {
        content: {
          'application/json': components['schemas']['DelegationResults'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Retrieve Staking Enterprise Information
   * @description Retrieve staking staking information like staking delegated balance, rewards accrued, and rewards accrual annual percentage rate.
   */
  'Retrieve Staking Enterprise Information': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin1'];
        /** @description The enterprise id representing the enterprise a user staked from */
        enterpriseId: string;
      };
    };
    responses: {
      /** @description Successful Retrieving Staking Information For An Enterprise */
      200: {
        content: {
          'application/json': components['schemas']['StakingEnterprise'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Retrieve Staking Reward History
   * @description Retrieve staking staking reward history.
   */
  'Retrieve Staking Reward History': {
    parameters: {
      query?: {
        /** @description The enterprise id representing the enterprise a user staked from */
        enterpriseId?: string;
        /** @description The wallet id representing the wallet a user staked from. Either the enterpriseId or walletId need to be passed in. */
        walletId?: components['schemas']['WalletId'];
        /** @description The time range for the data either hourly or daily */
        range?: string;
        /** @description The start date to search from */
        startDate?: string;
        /** @description The end date to search from */
        endDate?: string;
        page?: components['parameters']['queryPage'];
        pageSize?: components['parameters']['queryPageSize'];
        sortBy?: components['parameters']['querySortByDate'];
      };
      path: {
        coin: components['parameters']['pathCoin1'];
      };
    };
    responses: {
      /** @description Successful Retrieving Staking History */
      200: {
        content: {
          'application/json': components['schemas']['StakingRewards'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Retrieve Staking Delegation Accrual History
   * @description Retrieve staking delegation accrual history.
   */
  'Retrieve Staking Delegation Accrual History': {
    parameters: {
      query?: {
        /** @description Delegation ids */
        delegationIds?: string;
        /** @description The time range for the data either hourly or daily */
        range?: string;
        /** @description The start date to search from */
        startDate?: string;
        /** @description The end date to search from */
        endDate?: string;
        page?: components['parameters']['queryPage'];
        pageSize?: components['parameters']['queryPageSize'];
        sortBy?: components['parameters']['querySortByCreatedDate'];
      };
      path: {
        coin: components['parameters']['pathCoin1'];
        /** @description The wallet id representing the wallet a user staked from. Either the enterpriseId or walletId need to be passed in. */
        walletId: components['schemas']['WalletId'];
      };
    };
    responses: {
      /** @description Successful Retrieving Delegation Accrual History */
      200: {
        content: {
          'application/json': components['schemas']['DelegationAccruals'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Retrieve Staking Wallet State Attribute Information
   * @description Retrieve Staking Wallet State Attribute Information.
   */
  'Retrieve Staking Wallet State Attribute Information': {
    parameters: {
      path: {
        coin: components['parameters']['pathCoin1'];
        walletId: components['parameters']['pathWalletId1'];
      };
    };
    responses: {
      /** @description Successful Retrieving a Staking Wallet State Attribute Information */
      200: {
        content: {
          'application/json':
            | components['schemas']['AvaxpWalletStakingStateAttributes']
            | components['schemas']['DotWalletStakingStateAttributes']
            | components['schemas']['WalletStakingStateAttributes'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Retrieve coins available for staking and some basic information
   * @description Retrieve coins available for staking and some basic information
   */
  'Retrieve coins available for staking and some basic information': {
    parameters: {
      query?: {
        page?: components['parameters']['queryPage'];
        pageSize?: components['parameters']['queryPageSize'];
      };
    };
    responses: {
      /** @description Successful Retrieving a List of Stake-able Coins */
      200: {
        content: {
          'application/json': components['schemas']['StakeableCoinsResult'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['CoinsUnauthorizedError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * List staking validators for a wallet
   * @description Returns a list of staking validators for a wallet, and includes the total delegated amount and the amount of accrued rewards.
   */
  'v1.validators.list': {
    parameters: {
      query?: {
        page?: components['parameters']['queryPage'];
        pageSize?: components['parameters']['queryPageSize'];
      };
      path: {
        coin: components['parameters']['pathCoin1'];
        walletId: components['parameters']['pathWalletId1'];
      };
    };
    responses: {
      /** @description Successful Retrieving Staking Validators For A Wallet */
      200: {
        content: {
          'application/json': components['schemas']['StakingValidatorsResponse'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * List staking partnered validators
   * @description Returns a list of staking partnered validators.
   */
  'v1.partneredValidators.list': {
    parameters: {
      query?: {
        /** @description The staking asset. */
        coin?: string;
        /** @description The enterprise id */
        enterpriseId?: string;
        /** @description The wallet id */
        walletId?: string;
        /** @description The delegation status */
        delegationStatus?: string;
        /** @description True if only validators with active delegations are requested */
        onlyActive?: boolean;
        page?: components['parameters']['queryPage'];
        pageSize?: components['parameters']['queryPageSize'];
      };
    };
    responses: {
      /** @description Successful Retrieving Staking Partnered Validators */
      200: {
        content: {
          'application/json': components['schemas']['StakingPartneredValidatorsResponse'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Get staking license
   * @description Returns a staking license for the given enterprise.
   */
  'v1.license': {
    parameters: {
      path: {
        /** @description The enterprise id */
        enterpriseId: string;
      };
    };
    responses: {
      /** @description Successful Retrieving Staking License For An Enterprise */
      200: {
        content: {
          'application/json': components['schemas']['StakingLicenseResponse'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['StakingError'] | components['schemas']['ValidationError1'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * List Enterprise Staking Wallets Rewards
   * @description Returns total rewards per staking wallet for an enterprise.
   */
  'v1.enterprise.stakingWallets.list': {
    parameters: {
      query?: {
        coin?: components['parameters']['queryCoin'];
        label?: components['parameters']['queryLabel'];
        page?: components['parameters']['queryPage'];
        pageSize?: components['parameters']['queryPageSize'];
      };
      path: {
        /** @description The enterprise id */
        enterpriseId: string;
      };
    };
    responses: {
      /** @description Successful List Enterprise Staking Wallets Rewards */
      200: {
        content: {
          'application/json': components['schemas']['StakingWalletsResponse'];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description The specified resource was not found */
      404: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
      /** @description Server Error - Transient error please try again */
      500: {
        content: {
          'application/json': components['schemas']['StakingError'];
        };
      };
    };
  };
  /**
   * Get Trading Account Settings
   * @description The Get Trading Account Settings API displays the current settings on your trading account.
   */
  'v1.trade.getAccountSettings': {
    parameters: {
      path: {
        /** @description Enterprise ID */
        enterpriseId: string;
        /** @description Trading Account ID */
        accountId: string;
      };
    };
    responses: {
      /** @description Current settings for the specified trading account */
      200: {
        content: {
          'application/json': components['schemas']['AccountSettings'];
        };
      };
      /** @description Bad request - invalid parameters. */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /**
   * Update Trading Account Settings
   * @description The Update Trading Account Settings API allows you to modify the settings on your trading account.
   */
  'v1.trade.updateAccountSettings': {
    parameters: {
      path: {
        /** @description Enterprise ID */
        enterpriseId: string;
        /** @description Trading Account ID */
        accountId: string;
      };
    };
    /** @description Account settings to update and their new values */
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description Expiration time for new settlements and affirmations, in milliseconds. If this amount of time passes before a settlement is affirmed, rejected, or canceled, the settlement will be marked as failed.
           * @example 86400000
           */
          affirmationExpirationTime?: number;
        };
      };
    };
    responses: {
      /** @description Updated settings for the specified trading account */
      200: {
        content: {
          'application/json': components['schemas']['AccountSettings'];
        };
      };
      /** @description Bad request - invalid parameters. */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /**
   * List Trading Partners
   * @description The List Trading Partners API gets the trading partners for the given trading account.
   */
  'v1.tradingPartner.listTradingPartners': {
    parameters: {
      query?: {
        /** @description Status of trading partner relationship */
        status?: components['schemas']['TradingPartnerStatus'];
      };
      path: {
        /** @description Enterprise ID */
        enterpriseId: string;
        /** @description Trading Account ID */
        accountId: string;
      };
    };
    responses: {
      /** @description A list of trading partners. */
      200: {
        content: {
          'application/json': {
            tradingPartners?: components['schemas']['TradingPartner'][];
          };
        };
      };
      /** @description Bad request - invalid parameters. */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /**
   * Add Trading Partner
   * @description The Add Trading Partners API lets you add a trading partner given your trading partner's referral code
   */
  'v1.tradingPartner.add': {
    parameters: {
      path: {
        /** @description Enterprise ID */
        enterpriseId: string;
        /** @description Trading Account ID */
        accountId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description Trading partner's referral code
           * @example FC8G
           */
          referralCode: string;
          type: components['schemas']['TradingPartnerType'];
          requesterSide: components['schemas']['TradingReferralRequesterSide'];
        };
      };
    };
    responses: {
      /** @description Request has been sent to trading partner for approval. */
      200: {
        content: {
          'application/json': components['schemas']['TradingPartner'];
        };
      };
      /** @description Bad request - invalid parameters. */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /**
   * List Trading Partners By Enterprise
   * @description The List Trading Partners By Enterprise API gets the trading partners for the given enterprise.
   */
  'v1.tradingPartner.listTradingPartnersByEnterprise': {
    parameters: {
      query?: {
        /** @description Status of trading partner relationship */
        status?: components['schemas']['TradingPartnerStatus'];
      };
      path: {
        /** @description Enterprise ID */
        enterpriseId: string;
      };
    };
    responses: {
      /** @description A list of trading partners. */
      200: {
        content: {
          'application/json': {
            tradingPartners?: components['schemas']['TradingPartner'][];
          };
        };
      };
      /** @description Bad request - invalid parameters. */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /**
   * Update Trading Partner Request
   * @description The Update Trading Partner Request API allows you to accept, reject, or cancel a pending trading partner request
   */
  'v1.tradingPartner.update': {
    parameters: {
      path: {
        /** @description Enterprise ID */
        enterpriseId: string;
        /** @description Your trading account ID */
        accountId: string;
        /** @description unique ID of the trading partnership that is to be updated */
        partnershipId: string;
      };
    };
    /** @description Trading partner status update */
    requestBody: {
      content: {
        'application/json': {
          status: components['schemas']['TradingPartnerStatus'];
        };
      };
    };
    responses: {
      /** @description Trading partner status updated */
      200: {
        content: {
          'application/json': components['schemas']['TradingPartner'];
        };
      };
      /** @description Bad request - invalid parameters. */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /**
   * Account Balance Check
   * @description The Account Balance Check API verifies whether an account has enough funds to support a settlement of some amount.
   */
  'v1.tradingPartner.accountBalanceCheck': {
    parameters: {
      query: {
        /** @description Amount of offchain currency to balance check. Integer as a string */
        amount: string;
        /** @description Offchain currency to balance check */
        currency: string;
      };
      path: {
        /** @description Enterprise ID */
        enterpriseId: string;
        /** @description Your trading account ID */
        accountId: string;
        /** @description Trading partner's trading account ID to balance check */
        partnerAccountId: string;
      };
    };
    responses: {
      /** @description True or false if account has sufficient balance. */
      200: {
        content: {
          'application/json': {
            check?: boolean;
          };
        };
      };
      /** @description Bad request - invalid parameters. */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
}
