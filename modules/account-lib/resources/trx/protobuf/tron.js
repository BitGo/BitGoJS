/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.protocol = (function() {

    /**
     * Namespace protocol.
     * @exports protocol
     * @namespace
     */
    var protocol = {};

    protocol.Endpoint = (function() {

        /**
         * Properties of an Endpoint.
         * @memberof protocol
         * @interface IEndpoint
         * @property {Uint8Array|null} [address] Endpoint address
         * @property {number|null} [port] Endpoint port
         * @property {Uint8Array|null} [nodeId] Endpoint nodeId
         */

        /**
         * Constructs a new Endpoint.
         * @memberof protocol
         * @classdesc Represents an Endpoint.
         * @implements IEndpoint
         * @constructor
         * @param {protocol.IEndpoint=} [properties] Properties to set
         */
        function Endpoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Endpoint address.
         * @member {Uint8Array} address
         * @memberof protocol.Endpoint
         * @instance
         */
        Endpoint.prototype.address = $util.newBuffer([]);

        /**
         * Endpoint port.
         * @member {number} port
         * @memberof protocol.Endpoint
         * @instance
         */
        Endpoint.prototype.port = 0;

        /**
         * Endpoint nodeId.
         * @member {Uint8Array} nodeId
         * @memberof protocol.Endpoint
         * @instance
         */
        Endpoint.prototype.nodeId = $util.newBuffer([]);

        /**
         * Creates a new Endpoint instance using the specified properties.
         * @function create
         * @memberof protocol.Endpoint
         * @static
         * @param {protocol.IEndpoint=} [properties] Properties to set
         * @returns {protocol.Endpoint} Endpoint instance
         */
        Endpoint.create = function create(properties) {
            return new Endpoint(properties);
        };

        /**
         * Encodes the specified Endpoint message. Does not implicitly {@link protocol.Endpoint.verify|verify} messages.
         * @function encode
         * @memberof protocol.Endpoint
         * @static
         * @param {protocol.IEndpoint} message Endpoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Endpoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
            if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nodeId);
            return writer;
        };

        /**
         * Encodes the specified Endpoint message, length delimited. Does not implicitly {@link protocol.Endpoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Endpoint
         * @static
         * @param {protocol.IEndpoint} message Endpoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Endpoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Endpoint message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Endpoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Endpoint} Endpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Endpoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Endpoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.port = reader.int32();
                    break;
                case 3:
                    message.nodeId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Endpoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Endpoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Endpoint} Endpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Endpoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Endpoint message.
         * @function verify
         * @memberof protocol.Endpoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Endpoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!(message.nodeId && typeof message.nodeId.length === "number" || $util.isString(message.nodeId)))
                    return "nodeId: buffer expected";
            return null;
        };

        /**
         * Creates an Endpoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Endpoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Endpoint} Endpoint
         */
        Endpoint.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Endpoint)
                return object;
            var message = new $root.protocol.Endpoint();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.port != null)
                message.port = object.port | 0;
            if (object.nodeId != null)
                if (typeof object.nodeId === "string")
                    $util.base64.decode(object.nodeId, message.nodeId = $util.newBuffer($util.base64.length(object.nodeId)), 0);
                else if (object.nodeId.length)
                    message.nodeId = object.nodeId;
            return message;
        };

        /**
         * Creates a plain object from an Endpoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Endpoint
         * @static
         * @param {protocol.Endpoint} message Endpoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Endpoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.port = 0;
                if (options.bytes === String)
                    object.nodeId = "";
                else {
                    object.nodeId = [];
                    if (options.bytes !== Array)
                        object.nodeId = $util.newBuffer(object.nodeId);
                }
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                object.nodeId = options.bytes === String ? $util.base64.encode(message.nodeId, 0, message.nodeId.length) : options.bytes === Array ? Array.prototype.slice.call(message.nodeId) : message.nodeId;
            return object;
        };

        /**
         * Converts this Endpoint to JSON.
         * @function toJSON
         * @memberof protocol.Endpoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Endpoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Endpoint;
    })();

    protocol.PingMessage = (function() {

        /**
         * Properties of a PingMessage.
         * @memberof protocol
         * @interface IPingMessage
         * @property {protocol.IEndpoint|null} [from] PingMessage from
         * @property {protocol.IEndpoint|null} [to] PingMessage to
         * @property {number|null} [version] PingMessage version
         * @property {number|Long|null} [timestamp] PingMessage timestamp
         */

        /**
         * Constructs a new PingMessage.
         * @memberof protocol
         * @classdesc Represents a PingMessage.
         * @implements IPingMessage
         * @constructor
         * @param {protocol.IPingMessage=} [properties] Properties to set
         */
        function PingMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PingMessage from.
         * @member {protocol.IEndpoint|null|undefined} from
         * @memberof protocol.PingMessage
         * @instance
         */
        PingMessage.prototype.from = null;

        /**
         * PingMessage to.
         * @member {protocol.IEndpoint|null|undefined} to
         * @memberof protocol.PingMessage
         * @instance
         */
        PingMessage.prototype.to = null;

        /**
         * PingMessage version.
         * @member {number} version
         * @memberof protocol.PingMessage
         * @instance
         */
        PingMessage.prototype.version = 0;

        /**
         * PingMessage timestamp.
         * @member {number|Long} timestamp
         * @memberof protocol.PingMessage
         * @instance
         */
        PingMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PingMessage instance using the specified properties.
         * @function create
         * @memberof protocol.PingMessage
         * @static
         * @param {protocol.IPingMessage=} [properties] Properties to set
         * @returns {protocol.PingMessage} PingMessage instance
         */
        PingMessage.create = function create(properties) {
            return new PingMessage(properties);
        };

        /**
         * Encodes the specified PingMessage message. Does not implicitly {@link protocol.PingMessage.verify|verify} messages.
         * @function encode
         * @memberof protocol.PingMessage
         * @static
         * @param {protocol.IPingMessage} message PingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                $root.protocol.Endpoint.encode(message.to, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.version);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified PingMessage message, length delimited. Does not implicitly {@link protocol.PingMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.PingMessage
         * @static
         * @param {protocol.IPingMessage} message PingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.PingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.PingMessage} PingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.PingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.to = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.version = reader.int32();
                    break;
                case 4:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.PingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.PingMessage} PingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingMessage message.
         * @function verify
         * @memberof protocol.PingMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.to != null && message.hasOwnProperty("to")) {
                var error = $root.protocol.Endpoint.verify(message.to);
                if (error)
                    return "to." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a PingMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.PingMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.PingMessage} PingMessage
         */
        PingMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.PingMessage)
                return object;
            var message = new $root.protocol.PingMessage();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.PingMessage.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.to != null) {
                if (typeof object.to !== "object")
                    throw TypeError(".protocol.PingMessage.to: object expected");
                message.to = $root.protocol.Endpoint.fromObject(object.to);
            }
            if (object.version != null)
                message.version = object.version | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PingMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.PingMessage
         * @static
         * @param {protocol.PingMessage} message PingMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                object.to = null;
                object.version = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.to != null && message.hasOwnProperty("to"))
                object.to = $root.protocol.Endpoint.toObject(message.to, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this PingMessage to JSON.
         * @function toJSON
         * @memberof protocol.PingMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PingMessage;
    })();

    protocol.PongMessage = (function() {

        /**
         * Properties of a PongMessage.
         * @memberof protocol
         * @interface IPongMessage
         * @property {protocol.IEndpoint|null} [from] PongMessage from
         * @property {number|null} [echo] PongMessage echo
         * @property {number|Long|null} [timestamp] PongMessage timestamp
         */

        /**
         * Constructs a new PongMessage.
         * @memberof protocol
         * @classdesc Represents a PongMessage.
         * @implements IPongMessage
         * @constructor
         * @param {protocol.IPongMessage=} [properties] Properties to set
         */
        function PongMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PongMessage from.
         * @member {protocol.IEndpoint|null|undefined} from
         * @memberof protocol.PongMessage
         * @instance
         */
        PongMessage.prototype.from = null;

        /**
         * PongMessage echo.
         * @member {number} echo
         * @memberof protocol.PongMessage
         * @instance
         */
        PongMessage.prototype.echo = 0;

        /**
         * PongMessage timestamp.
         * @member {number|Long} timestamp
         * @memberof protocol.PongMessage
         * @instance
         */
        PongMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PongMessage instance using the specified properties.
         * @function create
         * @memberof protocol.PongMessage
         * @static
         * @param {protocol.IPongMessage=} [properties] Properties to set
         * @returns {protocol.PongMessage} PongMessage instance
         */
        PongMessage.create = function create(properties) {
            return new PongMessage(properties);
        };

        /**
         * Encodes the specified PongMessage message. Does not implicitly {@link protocol.PongMessage.verify|verify} messages.
         * @function encode
         * @memberof protocol.PongMessage
         * @static
         * @param {protocol.IPongMessage} message PongMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PongMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.echo != null && Object.hasOwnProperty.call(message, "echo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.echo);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified PongMessage message, length delimited. Does not implicitly {@link protocol.PongMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.PongMessage
         * @static
         * @param {protocol.IPongMessage} message PongMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PongMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PongMessage message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.PongMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.PongMessage} PongMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PongMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.PongMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.echo = reader.int32();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PongMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.PongMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.PongMessage} PongMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PongMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PongMessage message.
         * @function verify
         * @memberof protocol.PongMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PongMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.echo != null && message.hasOwnProperty("echo"))
                if (!$util.isInteger(message.echo))
                    return "echo: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a PongMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.PongMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.PongMessage} PongMessage
         */
        PongMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.PongMessage)
                return object;
            var message = new $root.protocol.PongMessage();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.PongMessage.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.echo != null)
                message.echo = object.echo | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PongMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.PongMessage
         * @static
         * @param {protocol.PongMessage} message PongMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PongMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                object.echo = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.echo != null && message.hasOwnProperty("echo"))
                object.echo = message.echo;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this PongMessage to JSON.
         * @function toJSON
         * @memberof protocol.PongMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PongMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PongMessage;
    })();

    protocol.FindNeighbours = (function() {

        /**
         * Properties of a FindNeighbours.
         * @memberof protocol
         * @interface IFindNeighbours
         * @property {protocol.IEndpoint|null} [from] FindNeighbours from
         * @property {Uint8Array|null} [targetId] FindNeighbours targetId
         * @property {number|Long|null} [timestamp] FindNeighbours timestamp
         */

        /**
         * Constructs a new FindNeighbours.
         * @memberof protocol
         * @classdesc Represents a FindNeighbours.
         * @implements IFindNeighbours
         * @constructor
         * @param {protocol.IFindNeighbours=} [properties] Properties to set
         */
        function FindNeighbours(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FindNeighbours from.
         * @member {protocol.IEndpoint|null|undefined} from
         * @memberof protocol.FindNeighbours
         * @instance
         */
        FindNeighbours.prototype.from = null;

        /**
         * FindNeighbours targetId.
         * @member {Uint8Array} targetId
         * @memberof protocol.FindNeighbours
         * @instance
         */
        FindNeighbours.prototype.targetId = $util.newBuffer([]);

        /**
         * FindNeighbours timestamp.
         * @member {number|Long} timestamp
         * @memberof protocol.FindNeighbours
         * @instance
         */
        FindNeighbours.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FindNeighbours instance using the specified properties.
         * @function create
         * @memberof protocol.FindNeighbours
         * @static
         * @param {protocol.IFindNeighbours=} [properties] Properties to set
         * @returns {protocol.FindNeighbours} FindNeighbours instance
         */
        FindNeighbours.create = function create(properties) {
            return new FindNeighbours(properties);
        };

        /**
         * Encodes the specified FindNeighbours message. Does not implicitly {@link protocol.FindNeighbours.verify|verify} messages.
         * @function encode
         * @memberof protocol.FindNeighbours
         * @static
         * @param {protocol.IFindNeighbours} message FindNeighbours message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindNeighbours.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.targetId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified FindNeighbours message, length delimited. Does not implicitly {@link protocol.FindNeighbours.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.FindNeighbours
         * @static
         * @param {protocol.IFindNeighbours} message FindNeighbours message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindNeighbours.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FindNeighbours message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.FindNeighbours
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.FindNeighbours} FindNeighbours
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindNeighbours.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.FindNeighbours();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.targetId = reader.bytes();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FindNeighbours message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.FindNeighbours
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.FindNeighbours} FindNeighbours
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindNeighbours.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FindNeighbours message.
         * @function verify
         * @memberof protocol.FindNeighbours
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FindNeighbours.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!(message.targetId && typeof message.targetId.length === "number" || $util.isString(message.targetId)))
                    return "targetId: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a FindNeighbours message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.FindNeighbours
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.FindNeighbours} FindNeighbours
         */
        FindNeighbours.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.FindNeighbours)
                return object;
            var message = new $root.protocol.FindNeighbours();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.FindNeighbours.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.targetId != null)
                if (typeof object.targetId === "string")
                    $util.base64.decode(object.targetId, message.targetId = $util.newBuffer($util.base64.length(object.targetId)), 0);
                else if (object.targetId.length)
                    message.targetId = object.targetId;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FindNeighbours message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.FindNeighbours
         * @static
         * @param {protocol.FindNeighbours} message FindNeighbours
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FindNeighbours.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                if (options.bytes === String)
                    object.targetId = "";
                else {
                    object.targetId = [];
                    if (options.bytes !== Array)
                        object.targetId = $util.newBuffer(object.targetId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = options.bytes === String ? $util.base64.encode(message.targetId, 0, message.targetId.length) : options.bytes === Array ? Array.prototype.slice.call(message.targetId) : message.targetId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this FindNeighbours to JSON.
         * @function toJSON
         * @memberof protocol.FindNeighbours
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FindNeighbours.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FindNeighbours;
    })();

    protocol.Neighbours = (function() {

        /**
         * Properties of a Neighbours.
         * @memberof protocol
         * @interface INeighbours
         * @property {protocol.IEndpoint|null} [from] Neighbours from
         * @property {Array.<protocol.IEndpoint>|null} [neighbours] Neighbours neighbours
         * @property {number|Long|null} [timestamp] Neighbours timestamp
         */

        /**
         * Constructs a new Neighbours.
         * @memberof protocol
         * @classdesc Represents a Neighbours.
         * @implements INeighbours
         * @constructor
         * @param {protocol.INeighbours=} [properties] Properties to set
         */
        function Neighbours(properties) {
            this.neighbours = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Neighbours from.
         * @member {protocol.IEndpoint|null|undefined} from
         * @memberof protocol.Neighbours
         * @instance
         */
        Neighbours.prototype.from = null;

        /**
         * Neighbours neighbours.
         * @member {Array.<protocol.IEndpoint>} neighbours
         * @memberof protocol.Neighbours
         * @instance
         */
        Neighbours.prototype.neighbours = $util.emptyArray;

        /**
         * Neighbours timestamp.
         * @member {number|Long} timestamp
         * @memberof protocol.Neighbours
         * @instance
         */
        Neighbours.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Neighbours instance using the specified properties.
         * @function create
         * @memberof protocol.Neighbours
         * @static
         * @param {protocol.INeighbours=} [properties] Properties to set
         * @returns {protocol.Neighbours} Neighbours instance
         */
        Neighbours.create = function create(properties) {
            return new Neighbours(properties);
        };

        /**
         * Encodes the specified Neighbours message. Does not implicitly {@link protocol.Neighbours.verify|verify} messages.
         * @function encode
         * @memberof protocol.Neighbours
         * @static
         * @param {protocol.INeighbours} message Neighbours message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Neighbours.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.neighbours != null && message.neighbours.length)
                for (var i = 0; i < message.neighbours.length; ++i)
                    $root.protocol.Endpoint.encode(message.neighbours[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Neighbours message, length delimited. Does not implicitly {@link protocol.Neighbours.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Neighbours
         * @static
         * @param {protocol.INeighbours} message Neighbours message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Neighbours.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Neighbours message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Neighbours
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Neighbours} Neighbours
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Neighbours.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Neighbours();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.neighbours && message.neighbours.length))
                        message.neighbours = [];
                    message.neighbours.push($root.protocol.Endpoint.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Neighbours message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Neighbours
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Neighbours} Neighbours
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Neighbours.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Neighbours message.
         * @function verify
         * @memberof protocol.Neighbours
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Neighbours.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.neighbours != null && message.hasOwnProperty("neighbours")) {
                if (!Array.isArray(message.neighbours))
                    return "neighbours: array expected";
                for (var i = 0; i < message.neighbours.length; ++i) {
                    var error = $root.protocol.Endpoint.verify(message.neighbours[i]);
                    if (error)
                        return "neighbours." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a Neighbours message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Neighbours
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Neighbours} Neighbours
         */
        Neighbours.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Neighbours)
                return object;
            var message = new $root.protocol.Neighbours();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.Neighbours.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.neighbours) {
                if (!Array.isArray(object.neighbours))
                    throw TypeError(".protocol.Neighbours.neighbours: array expected");
                message.neighbours = [];
                for (var i = 0; i < object.neighbours.length; ++i) {
                    if (typeof object.neighbours[i] !== "object")
                        throw TypeError(".protocol.Neighbours.neighbours: object expected");
                    message.neighbours[i] = $root.protocol.Endpoint.fromObject(object.neighbours[i]);
                }
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Neighbours message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Neighbours
         * @static
         * @param {protocol.Neighbours} message Neighbours
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Neighbours.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.neighbours = [];
            if (options.defaults) {
                object.from = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.neighbours && message.neighbours.length) {
                object.neighbours = [];
                for (var j = 0; j < message.neighbours.length; ++j)
                    object.neighbours[j] = $root.protocol.Endpoint.toObject(message.neighbours[j], options);
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this Neighbours to JSON.
         * @function toJSON
         * @memberof protocol.Neighbours
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Neighbours.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Neighbours;
    })();

    protocol.BackupMessage = (function() {

        /**
         * Properties of a BackupMessage.
         * @memberof protocol
         * @interface IBackupMessage
         * @property {boolean|null} [flag] BackupMessage flag
         * @property {number|null} [priority] BackupMessage priority
         */

        /**
         * Constructs a new BackupMessage.
         * @memberof protocol
         * @classdesc Represents a BackupMessage.
         * @implements IBackupMessage
         * @constructor
         * @param {protocol.IBackupMessage=} [properties] Properties to set
         */
        function BackupMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BackupMessage flag.
         * @member {boolean} flag
         * @memberof protocol.BackupMessage
         * @instance
         */
        BackupMessage.prototype.flag = false;

        /**
         * BackupMessage priority.
         * @member {number} priority
         * @memberof protocol.BackupMessage
         * @instance
         */
        BackupMessage.prototype.priority = 0;

        /**
         * Creates a new BackupMessage instance using the specified properties.
         * @function create
         * @memberof protocol.BackupMessage
         * @static
         * @param {protocol.IBackupMessage=} [properties] Properties to set
         * @returns {protocol.BackupMessage} BackupMessage instance
         */
        BackupMessage.create = function create(properties) {
            return new BackupMessage(properties);
        };

        /**
         * Encodes the specified BackupMessage message. Does not implicitly {@link protocol.BackupMessage.verify|verify} messages.
         * @function encode
         * @memberof protocol.BackupMessage
         * @static
         * @param {protocol.IBackupMessage} message BackupMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BackupMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.flag);
            if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.priority);
            return writer;
        };

        /**
         * Encodes the specified BackupMessage message, length delimited. Does not implicitly {@link protocol.BackupMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.BackupMessage
         * @static
         * @param {protocol.IBackupMessage} message BackupMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BackupMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BackupMessage message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.BackupMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.BackupMessage} BackupMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BackupMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BackupMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.flag = reader.bool();
                    break;
                case 2:
                    message.priority = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BackupMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.BackupMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.BackupMessage} BackupMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BackupMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BackupMessage message.
         * @function verify
         * @memberof protocol.BackupMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BackupMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (typeof message.flag !== "boolean")
                    return "flag: boolean expected";
            if (message.priority != null && message.hasOwnProperty("priority"))
                if (!$util.isInteger(message.priority))
                    return "priority: integer expected";
            return null;
        };

        /**
         * Creates a BackupMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.BackupMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.BackupMessage} BackupMessage
         */
        BackupMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BackupMessage)
                return object;
            var message = new $root.protocol.BackupMessage();
            if (object.flag != null)
                message.flag = Boolean(object.flag);
            if (object.priority != null)
                message.priority = object.priority | 0;
            return message;
        };

        /**
         * Creates a plain object from a BackupMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.BackupMessage
         * @static
         * @param {protocol.BackupMessage} message BackupMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BackupMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.flag = false;
                object.priority = 0;
            }
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.priority != null && message.hasOwnProperty("priority"))
                object.priority = message.priority;
            return object;
        };

        /**
         * Converts this BackupMessage to JSON.
         * @function toJSON
         * @memberof protocol.BackupMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BackupMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BackupMessage;
    })();

    protocol.AccountCreateContract = (function() {

        /**
         * Properties of an AccountCreateContract.
         * @memberof protocol
         * @interface IAccountCreateContract
         * @property {Uint8Array|null} [ownerAddress] AccountCreateContract ownerAddress
         * @property {Uint8Array|null} [accountAddress] AccountCreateContract accountAddress
         * @property {protocol.AccountType|null} [type] AccountCreateContract type
         */

        /**
         * Constructs a new AccountCreateContract.
         * @memberof protocol
         * @classdesc Represents an AccountCreateContract.
         * @implements IAccountCreateContract
         * @constructor
         * @param {protocol.IAccountCreateContract=} [properties] Properties to set
         */
        function AccountCreateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountCreateContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.AccountCreateContract
         * @instance
         */
        AccountCreateContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * AccountCreateContract accountAddress.
         * @member {Uint8Array} accountAddress
         * @memberof protocol.AccountCreateContract
         * @instance
         */
        AccountCreateContract.prototype.accountAddress = $util.newBuffer([]);

        /**
         * AccountCreateContract type.
         * @member {protocol.AccountType} type
         * @memberof protocol.AccountCreateContract
         * @instance
         */
        AccountCreateContract.prototype.type = 0;

        /**
         * Creates a new AccountCreateContract instance using the specified properties.
         * @function create
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {protocol.IAccountCreateContract=} [properties] Properties to set
         * @returns {protocol.AccountCreateContract} AccountCreateContract instance
         */
        AccountCreateContract.create = function create(properties) {
            return new AccountCreateContract(properties);
        };

        /**
         * Encodes the specified AccountCreateContract message. Does not implicitly {@link protocol.AccountCreateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {protocol.IAccountCreateContract} message AccountCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.accountAddress != null && Object.hasOwnProperty.call(message, "accountAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accountAddress);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified AccountCreateContract message, length delimited. Does not implicitly {@link protocol.AccountCreateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {protocol.IAccountCreateContract} message AccountCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountCreateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.AccountCreateContract} AccountCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountCreateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.accountAddress = reader.bytes();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountCreateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.AccountCreateContract} AccountCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountCreateContract message.
         * @function verify
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.accountAddress != null && message.hasOwnProperty("accountAddress"))
                if (!(message.accountAddress && typeof message.accountAddress.length === "number" || $util.isString(message.accountAddress)))
                    return "accountAddress: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an AccountCreateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.AccountCreateContract} AccountCreateContract
         */
        AccountCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountCreateContract)
                return object;
            var message = new $root.protocol.AccountCreateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.accountAddress != null)
                if (typeof object.accountAddress === "string")
                    $util.base64.decode(object.accountAddress, message.accountAddress = $util.newBuffer($util.base64.length(object.accountAddress)), 0);
                else if (object.accountAddress.length)
                    message.accountAddress = object.accountAddress;
            switch (object.type) {
            case "Normal":
            case 0:
                message.type = 0;
                break;
            case "AssetIssue":
            case 1:
                message.type = 1;
                break;
            case "Contract":
            case 2:
                message.type = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountCreateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {protocol.AccountCreateContract} message AccountCreateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.accountAddress = "";
                else {
                    object.accountAddress = [];
                    if (options.bytes !== Array)
                        object.accountAddress = $util.newBuffer(object.accountAddress);
                }
                object.type = options.enums === String ? "Normal" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.accountAddress != null && message.hasOwnProperty("accountAddress"))
                object.accountAddress = options.bytes === String ? $util.base64.encode(message.accountAddress, 0, message.accountAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountAddress) : message.accountAddress;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.AccountType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this AccountCreateContract to JSON.
         * @function toJSON
         * @memberof protocol.AccountCreateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountCreateContract;
    })();

    protocol.AccountUpdateContract = (function() {

        /**
         * Properties of an AccountUpdateContract.
         * @memberof protocol
         * @interface IAccountUpdateContract
         * @property {Uint8Array|null} [accountName] AccountUpdateContract accountName
         * @property {Uint8Array|null} [ownerAddress] AccountUpdateContract ownerAddress
         */

        /**
         * Constructs a new AccountUpdateContract.
         * @memberof protocol
         * @classdesc Represents an AccountUpdateContract.
         * @implements IAccountUpdateContract
         * @constructor
         * @param {protocol.IAccountUpdateContract=} [properties] Properties to set
         */
        function AccountUpdateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountUpdateContract accountName.
         * @member {Uint8Array} accountName
         * @memberof protocol.AccountUpdateContract
         * @instance
         */
        AccountUpdateContract.prototype.accountName = $util.newBuffer([]);

        /**
         * AccountUpdateContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.AccountUpdateContract
         * @instance
         */
        AccountUpdateContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * Creates a new AccountUpdateContract instance using the specified properties.
         * @function create
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {protocol.IAccountUpdateContract=} [properties] Properties to set
         * @returns {protocol.AccountUpdateContract} AccountUpdateContract instance
         */
        AccountUpdateContract.create = function create(properties) {
            return new AccountUpdateContract(properties);
        };

        /**
         * Encodes the specified AccountUpdateContract message. Does not implicitly {@link protocol.AccountUpdateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {protocol.IAccountUpdateContract} message AccountUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUpdateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountName != null && Object.hasOwnProperty.call(message, "accountName"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountName);
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ownerAddress);
            return writer;
        };

        /**
         * Encodes the specified AccountUpdateContract message, length delimited. Does not implicitly {@link protocol.AccountUpdateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {protocol.IAccountUpdateContract} message AccountUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUpdateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountUpdateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.AccountUpdateContract} AccountUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUpdateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountUpdateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accountName = reader.bytes();
                    break;
                case 2:
                    message.ownerAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountUpdateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.AccountUpdateContract} AccountUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUpdateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountUpdateContract message.
         * @function verify
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountUpdateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountName != null && message.hasOwnProperty("accountName"))
                if (!(message.accountName && typeof message.accountName.length === "number" || $util.isString(message.accountName)))
                    return "accountName: buffer expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            return null;
        };

        /**
         * Creates an AccountUpdateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.AccountUpdateContract} AccountUpdateContract
         */
        AccountUpdateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountUpdateContract)
                return object;
            var message = new $root.protocol.AccountUpdateContract();
            if (object.accountName != null)
                if (typeof object.accountName === "string")
                    $util.base64.decode(object.accountName, message.accountName = $util.newBuffer($util.base64.length(object.accountName)), 0);
                else if (object.accountName.length)
                    message.accountName = object.accountName;
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            return message;
        };

        /**
         * Creates a plain object from an AccountUpdateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {protocol.AccountUpdateContract} message AccountUpdateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUpdateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.accountName = "";
                else {
                    object.accountName = [];
                    if (options.bytes !== Array)
                        object.accountName = $util.newBuffer(object.accountName);
                }
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
            }
            if (message.accountName != null && message.hasOwnProperty("accountName"))
                object.accountName = options.bytes === String ? $util.base64.encode(message.accountName, 0, message.accountName.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountName) : message.accountName;
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            return object;
        };

        /**
         * Converts this AccountUpdateContract to JSON.
         * @function toJSON
         * @memberof protocol.AccountUpdateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUpdateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountUpdateContract;
    })();

    protocol.SetAccountIdContract = (function() {

        /**
         * Properties of a SetAccountIdContract.
         * @memberof protocol
         * @interface ISetAccountIdContract
         * @property {Uint8Array|null} [accountId] SetAccountIdContract accountId
         * @property {Uint8Array|null} [ownerAddress] SetAccountIdContract ownerAddress
         */

        /**
         * Constructs a new SetAccountIdContract.
         * @memberof protocol
         * @classdesc Represents a SetAccountIdContract.
         * @implements ISetAccountIdContract
         * @constructor
         * @param {protocol.ISetAccountIdContract=} [properties] Properties to set
         */
        function SetAccountIdContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetAccountIdContract accountId.
         * @member {Uint8Array} accountId
         * @memberof protocol.SetAccountIdContract
         * @instance
         */
        SetAccountIdContract.prototype.accountId = $util.newBuffer([]);

        /**
         * SetAccountIdContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.SetAccountIdContract
         * @instance
         */
        SetAccountIdContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * Creates a new SetAccountIdContract instance using the specified properties.
         * @function create
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {protocol.ISetAccountIdContract=} [properties] Properties to set
         * @returns {protocol.SetAccountIdContract} SetAccountIdContract instance
         */
        SetAccountIdContract.create = function create(properties) {
            return new SetAccountIdContract(properties);
        };

        /**
         * Encodes the specified SetAccountIdContract message. Does not implicitly {@link protocol.SetAccountIdContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {protocol.ISetAccountIdContract} message SetAccountIdContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetAccountIdContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountId);
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ownerAddress);
            return writer;
        };

        /**
         * Encodes the specified SetAccountIdContract message, length delimited. Does not implicitly {@link protocol.SetAccountIdContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {protocol.ISetAccountIdContract} message SetAccountIdContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetAccountIdContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetAccountIdContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.SetAccountIdContract} SetAccountIdContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetAccountIdContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SetAccountIdContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.bytes();
                    break;
                case 2:
                    message.ownerAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetAccountIdContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.SetAccountIdContract} SetAccountIdContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetAccountIdContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetAccountIdContract message.
         * @function verify
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetAccountIdContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                    return "accountId: buffer expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            return null;
        };

        /**
         * Creates a SetAccountIdContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.SetAccountIdContract} SetAccountIdContract
         */
        SetAccountIdContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.SetAccountIdContract)
                return object;
            var message = new $root.protocol.SetAccountIdContract();
            if (object.accountId != null)
                if (typeof object.accountId === "string")
                    $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                else if (object.accountId.length)
                    message.accountId = object.accountId;
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            return message;
        };

        /**
         * Creates a plain object from a SetAccountIdContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {protocol.SetAccountIdContract} message SetAccountIdContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetAccountIdContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.accountId = "";
                else {
                    object.accountId = [];
                    if (options.bytes !== Array)
                        object.accountId = $util.newBuffer(object.accountId);
                }
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
            }
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            return object;
        };

        /**
         * Converts this SetAccountIdContract to JSON.
         * @function toJSON
         * @memberof protocol.SetAccountIdContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetAccountIdContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetAccountIdContract;
    })();

    protocol.TransferContract = (function() {

        /**
         * Properties of a TransferContract.
         * @memberof protocol
         * @interface ITransferContract
         * @property {Uint8Array|null} [ownerAddress] TransferContract ownerAddress
         * @property {Uint8Array|null} [toAddress] TransferContract toAddress
         * @property {number|Long|null} [amount] TransferContract amount
         */

        /**
         * Constructs a new TransferContract.
         * @memberof protocol
         * @classdesc Represents a TransferContract.
         * @implements ITransferContract
         * @constructor
         * @param {protocol.ITransferContract=} [properties] Properties to set
         */
        function TransferContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransferContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.TransferContract
         * @instance
         */
        TransferContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * TransferContract toAddress.
         * @member {Uint8Array} toAddress
         * @memberof protocol.TransferContract
         * @instance
         */
        TransferContract.prototype.toAddress = $util.newBuffer([]);

        /**
         * TransferContract amount.
         * @member {number|Long} amount
         * @memberof protocol.TransferContract
         * @instance
         */
        TransferContract.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TransferContract instance using the specified properties.
         * @function create
         * @memberof protocol.TransferContract
         * @static
         * @param {protocol.ITransferContract=} [properties] Properties to set
         * @returns {protocol.TransferContract} TransferContract instance
         */
        TransferContract.create = function create(properties) {
            return new TransferContract(properties);
        };

        /**
         * Encodes the specified TransferContract message. Does not implicitly {@link protocol.TransferContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.TransferContract
         * @static
         * @param {protocol.ITransferContract} message TransferContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.toAddress);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified TransferContract message, length delimited. Does not implicitly {@link protocol.TransferContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TransferContract
         * @static
         * @param {protocol.ITransferContract} message TransferContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransferContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TransferContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TransferContract} TransferContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransferContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.toAddress = reader.bytes();
                    break;
                case 3:
                    message.amount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransferContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TransferContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TransferContract} TransferContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransferContract message.
         * @function verify
         * @memberof protocol.TransferContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                if (!(message.toAddress && typeof message.toAddress.length === "number" || $util.isString(message.toAddress)))
                    return "toAddress: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates a TransferContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TransferContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TransferContract} TransferContract
         */
        TransferContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransferContract)
                return object;
            var message = new $root.protocol.TransferContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.toAddress != null)
                if (typeof object.toAddress === "string")
                    $util.base64.decode(object.toAddress, message.toAddress = $util.newBuffer($util.base64.length(object.toAddress)), 0);
                else if (object.toAddress.length)
                    message.toAddress = object.toAddress;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TransferContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TransferContract
         * @static
         * @param {protocol.TransferContract} message TransferContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.toAddress = "";
                else {
                    object.toAddress = [];
                    if (options.bytes !== Array)
                        object.toAddress = $util.newBuffer(object.toAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                object.toAddress = options.bytes === String ? $util.base64.encode(message.toAddress, 0, message.toAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.toAddress) : message.toAddress;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };

        /**
         * Converts this TransferContract to JSON.
         * @function toJSON
         * @memberof protocol.TransferContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransferContract;
    })();

    protocol.TransferAssetContract = (function() {

        /**
         * Properties of a TransferAssetContract.
         * @memberof protocol
         * @interface ITransferAssetContract
         * @property {Uint8Array|null} [assetName] TransferAssetContract assetName
         * @property {Uint8Array|null} [ownerAddress] TransferAssetContract ownerAddress
         * @property {Uint8Array|null} [toAddress] TransferAssetContract toAddress
         * @property {number|Long|null} [amount] TransferAssetContract amount
         */

        /**
         * Constructs a new TransferAssetContract.
         * @memberof protocol
         * @classdesc Represents a TransferAssetContract.
         * @implements ITransferAssetContract
         * @constructor
         * @param {protocol.ITransferAssetContract=} [properties] Properties to set
         */
        function TransferAssetContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransferAssetContract assetName.
         * @member {Uint8Array} assetName
         * @memberof protocol.TransferAssetContract
         * @instance
         */
        TransferAssetContract.prototype.assetName = $util.newBuffer([]);

        /**
         * TransferAssetContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.TransferAssetContract
         * @instance
         */
        TransferAssetContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * TransferAssetContract toAddress.
         * @member {Uint8Array} toAddress
         * @memberof protocol.TransferAssetContract
         * @instance
         */
        TransferAssetContract.prototype.toAddress = $util.newBuffer([]);

        /**
         * TransferAssetContract amount.
         * @member {number|Long} amount
         * @memberof protocol.TransferAssetContract
         * @instance
         */
        TransferAssetContract.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TransferAssetContract instance using the specified properties.
         * @function create
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {protocol.ITransferAssetContract=} [properties] Properties to set
         * @returns {protocol.TransferAssetContract} TransferAssetContract instance
         */
        TransferAssetContract.create = function create(properties) {
            return new TransferAssetContract(properties);
        };

        /**
         * Encodes the specified TransferAssetContract message. Does not implicitly {@link protocol.TransferAssetContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {protocol.ITransferAssetContract} message TransferAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.assetName != null && Object.hasOwnProperty.call(message, "assetName"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.assetName);
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ownerAddress);
            if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.toAddress);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified TransferAssetContract message, length delimited. Does not implicitly {@link protocol.TransferAssetContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {protocol.ITransferAssetContract} message TransferAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransferAssetContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TransferAssetContract} TransferAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransferAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.assetName = reader.bytes();
                    break;
                case 2:
                    message.ownerAddress = reader.bytes();
                    break;
                case 3:
                    message.toAddress = reader.bytes();
                    break;
                case 4:
                    message.amount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransferAssetContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TransferAssetContract} TransferAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransferAssetContract message.
         * @function verify
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.assetName != null && message.hasOwnProperty("assetName"))
                if (!(message.assetName && typeof message.assetName.length === "number" || $util.isString(message.assetName)))
                    return "assetName: buffer expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                if (!(message.toAddress && typeof message.toAddress.length === "number" || $util.isString(message.toAddress)))
                    return "toAddress: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates a TransferAssetContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TransferAssetContract} TransferAssetContract
         */
        TransferAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransferAssetContract)
                return object;
            var message = new $root.protocol.TransferAssetContract();
            if (object.assetName != null)
                if (typeof object.assetName === "string")
                    $util.base64.decode(object.assetName, message.assetName = $util.newBuffer($util.base64.length(object.assetName)), 0);
                else if (object.assetName.length)
                    message.assetName = object.assetName;
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.toAddress != null)
                if (typeof object.toAddress === "string")
                    $util.base64.decode(object.toAddress, message.toAddress = $util.newBuffer($util.base64.length(object.toAddress)), 0);
                else if (object.toAddress.length)
                    message.toAddress = object.toAddress;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TransferAssetContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {protocol.TransferAssetContract} message TransferAssetContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.assetName = "";
                else {
                    object.assetName = [];
                    if (options.bytes !== Array)
                        object.assetName = $util.newBuffer(object.assetName);
                }
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.toAddress = "";
                else {
                    object.toAddress = [];
                    if (options.bytes !== Array)
                        object.toAddress = $util.newBuffer(object.toAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.assetName != null && message.hasOwnProperty("assetName"))
                object.assetName = options.bytes === String ? $util.base64.encode(message.assetName, 0, message.assetName.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetName) : message.assetName;
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                object.toAddress = options.bytes === String ? $util.base64.encode(message.toAddress, 0, message.toAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.toAddress) : message.toAddress;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };

        /**
         * Converts this TransferAssetContract to JSON.
         * @function toJSON
         * @memberof protocol.TransferAssetContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransferAssetContract;
    })();

    protocol.VoteAssetContract = (function() {

        /**
         * Properties of a VoteAssetContract.
         * @memberof protocol
         * @interface IVoteAssetContract
         * @property {Uint8Array|null} [ownerAddress] VoteAssetContract ownerAddress
         * @property {Array.<Uint8Array>|null} [voteAddress] VoteAssetContract voteAddress
         * @property {boolean|null} [support] VoteAssetContract support
         * @property {number|null} [count] VoteAssetContract count
         */

        /**
         * Constructs a new VoteAssetContract.
         * @memberof protocol
         * @classdesc Represents a VoteAssetContract.
         * @implements IVoteAssetContract
         * @constructor
         * @param {protocol.IVoteAssetContract=} [properties] Properties to set
         */
        function VoteAssetContract(properties) {
            this.voteAddress = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VoteAssetContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.VoteAssetContract
         * @instance
         */
        VoteAssetContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * VoteAssetContract voteAddress.
         * @member {Array.<Uint8Array>} voteAddress
         * @memberof protocol.VoteAssetContract
         * @instance
         */
        VoteAssetContract.prototype.voteAddress = $util.emptyArray;

        /**
         * VoteAssetContract support.
         * @member {boolean} support
         * @memberof protocol.VoteAssetContract
         * @instance
         */
        VoteAssetContract.prototype.support = false;

        /**
         * VoteAssetContract count.
         * @member {number} count
         * @memberof protocol.VoteAssetContract
         * @instance
         */
        VoteAssetContract.prototype.count = 0;

        /**
         * Creates a new VoteAssetContract instance using the specified properties.
         * @function create
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {protocol.IVoteAssetContract=} [properties] Properties to set
         * @returns {protocol.VoteAssetContract} VoteAssetContract instance
         */
        VoteAssetContract.create = function create(properties) {
            return new VoteAssetContract(properties);
        };

        /**
         * Encodes the specified VoteAssetContract message. Does not implicitly {@link protocol.VoteAssetContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {protocol.IVoteAssetContract} message VoteAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.voteAddress != null && message.voteAddress.length)
                for (var i = 0; i < message.voteAddress.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.voteAddress[i]);
            if (message.support != null && Object.hasOwnProperty.call(message, "support"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.support);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified VoteAssetContract message, length delimited. Does not implicitly {@link protocol.VoteAssetContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {protocol.IVoteAssetContract} message VoteAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VoteAssetContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.VoteAssetContract} VoteAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.VoteAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    if (!(message.voteAddress && message.voteAddress.length))
                        message.voteAddress = [];
                    message.voteAddress.push(reader.bytes());
                    break;
                case 3:
                    message.support = reader.bool();
                    break;
                case 5:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VoteAssetContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.VoteAssetContract} VoteAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VoteAssetContract message.
         * @function verify
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VoteAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.voteAddress != null && message.hasOwnProperty("voteAddress")) {
                if (!Array.isArray(message.voteAddress))
                    return "voteAddress: array expected";
                for (var i = 0; i < message.voteAddress.length; ++i)
                    if (!(message.voteAddress[i] && typeof message.voteAddress[i].length === "number" || $util.isString(message.voteAddress[i])))
                        return "voteAddress: buffer[] expected";
            }
            if (message.support != null && message.hasOwnProperty("support"))
                if (typeof message.support !== "boolean")
                    return "support: boolean expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a VoteAssetContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.VoteAssetContract} VoteAssetContract
         */
        VoteAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.VoteAssetContract)
                return object;
            var message = new $root.protocol.VoteAssetContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.voteAddress) {
                if (!Array.isArray(object.voteAddress))
                    throw TypeError(".protocol.VoteAssetContract.voteAddress: array expected");
                message.voteAddress = [];
                for (var i = 0; i < object.voteAddress.length; ++i)
                    if (typeof object.voteAddress[i] === "string")
                        $util.base64.decode(object.voteAddress[i], message.voteAddress[i] = $util.newBuffer($util.base64.length(object.voteAddress[i])), 0);
                    else if (object.voteAddress[i].length)
                        message.voteAddress[i] = object.voteAddress[i];
            }
            if (object.support != null)
                message.support = Boolean(object.support);
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a VoteAssetContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {protocol.VoteAssetContract} message VoteAssetContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VoteAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.voteAddress = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                object.support = false;
                object.count = 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.voteAddress && message.voteAddress.length) {
                object.voteAddress = [];
                for (var j = 0; j < message.voteAddress.length; ++j)
                    object.voteAddress[j] = options.bytes === String ? $util.base64.encode(message.voteAddress[j], 0, message.voteAddress[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.voteAddress[j]) : message.voteAddress[j];
            }
            if (message.support != null && message.hasOwnProperty("support"))
                object.support = message.support;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this VoteAssetContract to JSON.
         * @function toJSON
         * @memberof protocol.VoteAssetContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VoteAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VoteAssetContract;
    })();

    protocol.VoteWitnessContract = (function() {

        /**
         * Properties of a VoteWitnessContract.
         * @memberof protocol
         * @interface IVoteWitnessContract
         * @property {Uint8Array|null} [ownerAddress] VoteWitnessContract ownerAddress
         * @property {Array.<protocol.VoteWitnessContract.IVote>|null} [votes] VoteWitnessContract votes
         * @property {boolean|null} [support] VoteWitnessContract support
         */

        /**
         * Constructs a new VoteWitnessContract.
         * @memberof protocol
         * @classdesc Represents a VoteWitnessContract.
         * @implements IVoteWitnessContract
         * @constructor
         * @param {protocol.IVoteWitnessContract=} [properties] Properties to set
         */
        function VoteWitnessContract(properties) {
            this.votes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VoteWitnessContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.VoteWitnessContract
         * @instance
         */
        VoteWitnessContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * VoteWitnessContract votes.
         * @member {Array.<protocol.VoteWitnessContract.IVote>} votes
         * @memberof protocol.VoteWitnessContract
         * @instance
         */
        VoteWitnessContract.prototype.votes = $util.emptyArray;

        /**
         * VoteWitnessContract support.
         * @member {boolean} support
         * @memberof protocol.VoteWitnessContract
         * @instance
         */
        VoteWitnessContract.prototype.support = false;

        /**
         * Creates a new VoteWitnessContract instance using the specified properties.
         * @function create
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {protocol.IVoteWitnessContract=} [properties] Properties to set
         * @returns {protocol.VoteWitnessContract} VoteWitnessContract instance
         */
        VoteWitnessContract.create = function create(properties) {
            return new VoteWitnessContract(properties);
        };

        /**
         * Encodes the specified VoteWitnessContract message. Does not implicitly {@link protocol.VoteWitnessContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {protocol.IVoteWitnessContract} message VoteWitnessContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteWitnessContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.votes != null && message.votes.length)
                for (var i = 0; i < message.votes.length; ++i)
                    $root.protocol.VoteWitnessContract.Vote.encode(message.votes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.support != null && Object.hasOwnProperty.call(message, "support"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.support);
            return writer;
        };

        /**
         * Encodes the specified VoteWitnessContract message, length delimited. Does not implicitly {@link protocol.VoteWitnessContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {protocol.IVoteWitnessContract} message VoteWitnessContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteWitnessContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VoteWitnessContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.VoteWitnessContract} VoteWitnessContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteWitnessContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.VoteWitnessContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    if (!(message.votes && message.votes.length))
                        message.votes = [];
                    message.votes.push($root.protocol.VoteWitnessContract.Vote.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.support = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VoteWitnessContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.VoteWitnessContract} VoteWitnessContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteWitnessContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VoteWitnessContract message.
         * @function verify
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VoteWitnessContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.votes != null && message.hasOwnProperty("votes")) {
                if (!Array.isArray(message.votes))
                    return "votes: array expected";
                for (var i = 0; i < message.votes.length; ++i) {
                    var error = $root.protocol.VoteWitnessContract.Vote.verify(message.votes[i]);
                    if (error)
                        return "votes." + error;
                }
            }
            if (message.support != null && message.hasOwnProperty("support"))
                if (typeof message.support !== "boolean")
                    return "support: boolean expected";
            return null;
        };

        /**
         * Creates a VoteWitnessContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.VoteWitnessContract} VoteWitnessContract
         */
        VoteWitnessContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.VoteWitnessContract)
                return object;
            var message = new $root.protocol.VoteWitnessContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.votes) {
                if (!Array.isArray(object.votes))
                    throw TypeError(".protocol.VoteWitnessContract.votes: array expected");
                message.votes = [];
                for (var i = 0; i < object.votes.length; ++i) {
                    if (typeof object.votes[i] !== "object")
                        throw TypeError(".protocol.VoteWitnessContract.votes: object expected");
                    message.votes[i] = $root.protocol.VoteWitnessContract.Vote.fromObject(object.votes[i]);
                }
            }
            if (object.support != null)
                message.support = Boolean(object.support);
            return message;
        };

        /**
         * Creates a plain object from a VoteWitnessContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {protocol.VoteWitnessContract} message VoteWitnessContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VoteWitnessContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.votes = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                object.support = false;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.votes && message.votes.length) {
                object.votes = [];
                for (var j = 0; j < message.votes.length; ++j)
                    object.votes[j] = $root.protocol.VoteWitnessContract.Vote.toObject(message.votes[j], options);
            }
            if (message.support != null && message.hasOwnProperty("support"))
                object.support = message.support;
            return object;
        };

        /**
         * Converts this VoteWitnessContract to JSON.
         * @function toJSON
         * @memberof protocol.VoteWitnessContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VoteWitnessContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        VoteWitnessContract.Vote = (function() {

            /**
             * Properties of a Vote.
             * @memberof protocol.VoteWitnessContract
             * @interface IVote
             * @property {Uint8Array|null} [voteAddress] Vote voteAddress
             * @property {number|Long|null} [voteCount] Vote voteCount
             */

            /**
             * Constructs a new Vote.
             * @memberof protocol.VoteWitnessContract
             * @classdesc Represents a Vote.
             * @implements IVote
             * @constructor
             * @param {protocol.VoteWitnessContract.IVote=} [properties] Properties to set
             */
            function Vote(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Vote voteAddress.
             * @member {Uint8Array} voteAddress
             * @memberof protocol.VoteWitnessContract.Vote
             * @instance
             */
            Vote.prototype.voteAddress = $util.newBuffer([]);

            /**
             * Vote voteCount.
             * @member {number|Long} voteCount
             * @memberof protocol.VoteWitnessContract.Vote
             * @instance
             */
            Vote.prototype.voteCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Vote instance using the specified properties.
             * @function create
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {protocol.VoteWitnessContract.IVote=} [properties] Properties to set
             * @returns {protocol.VoteWitnessContract.Vote} Vote instance
             */
            Vote.create = function create(properties) {
                return new Vote(properties);
            };

            /**
             * Encodes the specified Vote message. Does not implicitly {@link protocol.VoteWitnessContract.Vote.verify|verify} messages.
             * @function encode
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {protocol.VoteWitnessContract.IVote} message Vote message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Vote.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.voteAddress != null && Object.hasOwnProperty.call(message, "voteAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.voteAddress);
                if (message.voteCount != null && Object.hasOwnProperty.call(message, "voteCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.voteCount);
                return writer;
            };

            /**
             * Encodes the specified Vote message, length delimited. Does not implicitly {@link protocol.VoteWitnessContract.Vote.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {protocol.VoteWitnessContract.IVote} message Vote message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Vote.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Vote message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.VoteWitnessContract.Vote} Vote
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Vote.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.VoteWitnessContract.Vote();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.voteAddress = reader.bytes();
                        break;
                    case 2:
                        message.voteCount = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Vote message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.VoteWitnessContract.Vote} Vote
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Vote.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Vote message.
             * @function verify
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Vote.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.voteAddress != null && message.hasOwnProperty("voteAddress"))
                    if (!(message.voteAddress && typeof message.voteAddress.length === "number" || $util.isString(message.voteAddress)))
                        return "voteAddress: buffer expected";
                if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                    if (!$util.isInteger(message.voteCount) && !(message.voteCount && $util.isInteger(message.voteCount.low) && $util.isInteger(message.voteCount.high)))
                        return "voteCount: integer|Long expected";
                return null;
            };

            /**
             * Creates a Vote message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.VoteWitnessContract.Vote} Vote
             */
            Vote.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.VoteWitnessContract.Vote)
                    return object;
                var message = new $root.protocol.VoteWitnessContract.Vote();
                if (object.voteAddress != null)
                    if (typeof object.voteAddress === "string")
                        $util.base64.decode(object.voteAddress, message.voteAddress = $util.newBuffer($util.base64.length(object.voteAddress)), 0);
                    else if (object.voteAddress.length)
                        message.voteAddress = object.voteAddress;
                if (object.voteCount != null)
                    if ($util.Long)
                        (message.voteCount = $util.Long.fromValue(object.voteCount)).unsigned = false;
                    else if (typeof object.voteCount === "string")
                        message.voteCount = parseInt(object.voteCount, 10);
                    else if (typeof object.voteCount === "number")
                        message.voteCount = object.voteCount;
                    else if (typeof object.voteCount === "object")
                        message.voteCount = new $util.LongBits(object.voteCount.low >>> 0, object.voteCount.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Vote message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {protocol.VoteWitnessContract.Vote} message Vote
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Vote.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.voteAddress = "";
                    else {
                        object.voteAddress = [];
                        if (options.bytes !== Array)
                            object.voteAddress = $util.newBuffer(object.voteAddress);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.voteCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.voteCount = options.longs === String ? "0" : 0;
                }
                if (message.voteAddress != null && message.hasOwnProperty("voteAddress"))
                    object.voteAddress = options.bytes === String ? $util.base64.encode(message.voteAddress, 0, message.voteAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.voteAddress) : message.voteAddress;
                if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                    if (typeof message.voteCount === "number")
                        object.voteCount = options.longs === String ? String(message.voteCount) : message.voteCount;
                    else
                        object.voteCount = options.longs === String ? $util.Long.prototype.toString.call(message.voteCount) : options.longs === Number ? new $util.LongBits(message.voteCount.low >>> 0, message.voteCount.high >>> 0).toNumber() : message.voteCount;
                return object;
            };

            /**
             * Converts this Vote to JSON.
             * @function toJSON
             * @memberof protocol.VoteWitnessContract.Vote
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Vote.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Vote;
        })();

        return VoteWitnessContract;
    })();

    protocol.UpdateSettingContract = (function() {

        /**
         * Properties of an UpdateSettingContract.
         * @memberof protocol
         * @interface IUpdateSettingContract
         * @property {Uint8Array|null} [ownerAddress] UpdateSettingContract ownerAddress
         * @property {Uint8Array|null} [contractAddress] UpdateSettingContract contractAddress
         * @property {number|Long|null} [consumeUserResourcePercent] UpdateSettingContract consumeUserResourcePercent
         */

        /**
         * Constructs a new UpdateSettingContract.
         * @memberof protocol
         * @classdesc Represents an UpdateSettingContract.
         * @implements IUpdateSettingContract
         * @constructor
         * @param {protocol.IUpdateSettingContract=} [properties] Properties to set
         */
        function UpdateSettingContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateSettingContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.UpdateSettingContract
         * @instance
         */
        UpdateSettingContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * UpdateSettingContract contractAddress.
         * @member {Uint8Array} contractAddress
         * @memberof protocol.UpdateSettingContract
         * @instance
         */
        UpdateSettingContract.prototype.contractAddress = $util.newBuffer([]);

        /**
         * UpdateSettingContract consumeUserResourcePercent.
         * @member {number|Long} consumeUserResourcePercent
         * @memberof protocol.UpdateSettingContract
         * @instance
         */
        UpdateSettingContract.prototype.consumeUserResourcePercent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpdateSettingContract instance using the specified properties.
         * @function create
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {protocol.IUpdateSettingContract=} [properties] Properties to set
         * @returns {protocol.UpdateSettingContract} UpdateSettingContract instance
         */
        UpdateSettingContract.create = function create(properties) {
            return new UpdateSettingContract(properties);
        };

        /**
         * Encodes the specified UpdateSettingContract message. Does not implicitly {@link protocol.UpdateSettingContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {protocol.IUpdateSettingContract} message UpdateSettingContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateSettingContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contractAddress);
            if (message.consumeUserResourcePercent != null && Object.hasOwnProperty.call(message, "consumeUserResourcePercent"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.consumeUserResourcePercent);
            return writer;
        };

        /**
         * Encodes the specified UpdateSettingContract message, length delimited. Does not implicitly {@link protocol.UpdateSettingContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {protocol.IUpdateSettingContract} message UpdateSettingContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateSettingContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateSettingContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.UpdateSettingContract} UpdateSettingContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateSettingContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UpdateSettingContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.contractAddress = reader.bytes();
                    break;
                case 3:
                    message.consumeUserResourcePercent = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateSettingContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.UpdateSettingContract} UpdateSettingContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateSettingContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateSettingContract message.
         * @function verify
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateSettingContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            if (message.consumeUserResourcePercent != null && message.hasOwnProperty("consumeUserResourcePercent"))
                if (!$util.isInteger(message.consumeUserResourcePercent) && !(message.consumeUserResourcePercent && $util.isInteger(message.consumeUserResourcePercent.low) && $util.isInteger(message.consumeUserResourcePercent.high)))
                    return "consumeUserResourcePercent: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdateSettingContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.UpdateSettingContract} UpdateSettingContract
         */
        UpdateSettingContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UpdateSettingContract)
                return object;
            var message = new $root.protocol.UpdateSettingContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            if (object.consumeUserResourcePercent != null)
                if ($util.Long)
                    (message.consumeUserResourcePercent = $util.Long.fromValue(object.consumeUserResourcePercent)).unsigned = false;
                else if (typeof object.consumeUserResourcePercent === "string")
                    message.consumeUserResourcePercent = parseInt(object.consumeUserResourcePercent, 10);
                else if (typeof object.consumeUserResourcePercent === "number")
                    message.consumeUserResourcePercent = object.consumeUserResourcePercent;
                else if (typeof object.consumeUserResourcePercent === "object")
                    message.consumeUserResourcePercent = new $util.LongBits(object.consumeUserResourcePercent.low >>> 0, object.consumeUserResourcePercent.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpdateSettingContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {protocol.UpdateSettingContract} message UpdateSettingContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateSettingContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.consumeUserResourcePercent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.consumeUserResourcePercent = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            if (message.consumeUserResourcePercent != null && message.hasOwnProperty("consumeUserResourcePercent"))
                if (typeof message.consumeUserResourcePercent === "number")
                    object.consumeUserResourcePercent = options.longs === String ? String(message.consumeUserResourcePercent) : message.consumeUserResourcePercent;
                else
                    object.consumeUserResourcePercent = options.longs === String ? $util.Long.prototype.toString.call(message.consumeUserResourcePercent) : options.longs === Number ? new $util.LongBits(message.consumeUserResourcePercent.low >>> 0, message.consumeUserResourcePercent.high >>> 0).toNumber() : message.consumeUserResourcePercent;
            return object;
        };

        /**
         * Converts this UpdateSettingContract to JSON.
         * @function toJSON
         * @memberof protocol.UpdateSettingContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateSettingContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateSettingContract;
    })();

    protocol.UpdateEnergyLimitContract = (function() {

        /**
         * Properties of an UpdateEnergyLimitContract.
         * @memberof protocol
         * @interface IUpdateEnergyLimitContract
         * @property {Uint8Array|null} [ownerAddress] UpdateEnergyLimitContract ownerAddress
         * @property {Uint8Array|null} [contractAddress] UpdateEnergyLimitContract contractAddress
         * @property {number|Long|null} [originEnergyLimit] UpdateEnergyLimitContract originEnergyLimit
         */

        /**
         * Constructs a new UpdateEnergyLimitContract.
         * @memberof protocol
         * @classdesc Represents an UpdateEnergyLimitContract.
         * @implements IUpdateEnergyLimitContract
         * @constructor
         * @param {protocol.IUpdateEnergyLimitContract=} [properties] Properties to set
         */
        function UpdateEnergyLimitContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateEnergyLimitContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.UpdateEnergyLimitContract
         * @instance
         */
        UpdateEnergyLimitContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * UpdateEnergyLimitContract contractAddress.
         * @member {Uint8Array} contractAddress
         * @memberof protocol.UpdateEnergyLimitContract
         * @instance
         */
        UpdateEnergyLimitContract.prototype.contractAddress = $util.newBuffer([]);

        /**
         * UpdateEnergyLimitContract originEnergyLimit.
         * @member {number|Long} originEnergyLimit
         * @memberof protocol.UpdateEnergyLimitContract
         * @instance
         */
        UpdateEnergyLimitContract.prototype.originEnergyLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpdateEnergyLimitContract instance using the specified properties.
         * @function create
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {protocol.IUpdateEnergyLimitContract=} [properties] Properties to set
         * @returns {protocol.UpdateEnergyLimitContract} UpdateEnergyLimitContract instance
         */
        UpdateEnergyLimitContract.create = function create(properties) {
            return new UpdateEnergyLimitContract(properties);
        };

        /**
         * Encodes the specified UpdateEnergyLimitContract message. Does not implicitly {@link protocol.UpdateEnergyLimitContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {protocol.IUpdateEnergyLimitContract} message UpdateEnergyLimitContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateEnergyLimitContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contractAddress);
            if (message.originEnergyLimit != null && Object.hasOwnProperty.call(message, "originEnergyLimit"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.originEnergyLimit);
            return writer;
        };

        /**
         * Encodes the specified UpdateEnergyLimitContract message, length delimited. Does not implicitly {@link protocol.UpdateEnergyLimitContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {protocol.IUpdateEnergyLimitContract} message UpdateEnergyLimitContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateEnergyLimitContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateEnergyLimitContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.UpdateEnergyLimitContract} UpdateEnergyLimitContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateEnergyLimitContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UpdateEnergyLimitContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.contractAddress = reader.bytes();
                    break;
                case 3:
                    message.originEnergyLimit = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateEnergyLimitContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.UpdateEnergyLimitContract} UpdateEnergyLimitContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateEnergyLimitContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateEnergyLimitContract message.
         * @function verify
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateEnergyLimitContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            if (message.originEnergyLimit != null && message.hasOwnProperty("originEnergyLimit"))
                if (!$util.isInteger(message.originEnergyLimit) && !(message.originEnergyLimit && $util.isInteger(message.originEnergyLimit.low) && $util.isInteger(message.originEnergyLimit.high)))
                    return "originEnergyLimit: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdateEnergyLimitContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.UpdateEnergyLimitContract} UpdateEnergyLimitContract
         */
        UpdateEnergyLimitContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UpdateEnergyLimitContract)
                return object;
            var message = new $root.protocol.UpdateEnergyLimitContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            if (object.originEnergyLimit != null)
                if ($util.Long)
                    (message.originEnergyLimit = $util.Long.fromValue(object.originEnergyLimit)).unsigned = false;
                else if (typeof object.originEnergyLimit === "string")
                    message.originEnergyLimit = parseInt(object.originEnergyLimit, 10);
                else if (typeof object.originEnergyLimit === "number")
                    message.originEnergyLimit = object.originEnergyLimit;
                else if (typeof object.originEnergyLimit === "object")
                    message.originEnergyLimit = new $util.LongBits(object.originEnergyLimit.low >>> 0, object.originEnergyLimit.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpdateEnergyLimitContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {protocol.UpdateEnergyLimitContract} message UpdateEnergyLimitContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateEnergyLimitContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.originEnergyLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.originEnergyLimit = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            if (message.originEnergyLimit != null && message.hasOwnProperty("originEnergyLimit"))
                if (typeof message.originEnergyLimit === "number")
                    object.originEnergyLimit = options.longs === String ? String(message.originEnergyLimit) : message.originEnergyLimit;
                else
                    object.originEnergyLimit = options.longs === String ? $util.Long.prototype.toString.call(message.originEnergyLimit) : options.longs === Number ? new $util.LongBits(message.originEnergyLimit.low >>> 0, message.originEnergyLimit.high >>> 0).toNumber() : message.originEnergyLimit;
            return object;
        };

        /**
         * Converts this UpdateEnergyLimitContract to JSON.
         * @function toJSON
         * @memberof protocol.UpdateEnergyLimitContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateEnergyLimitContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateEnergyLimitContract;
    })();

    protocol.ClearABIContract = (function() {

        /**
         * Properties of a ClearABIContract.
         * @memberof protocol
         * @interface IClearABIContract
         * @property {Uint8Array|null} [ownerAddress] ClearABIContract ownerAddress
         * @property {Uint8Array|null} [contractAddress] ClearABIContract contractAddress
         */

        /**
         * Constructs a new ClearABIContract.
         * @memberof protocol
         * @classdesc Represents a ClearABIContract.
         * @implements IClearABIContract
         * @constructor
         * @param {protocol.IClearABIContract=} [properties] Properties to set
         */
        function ClearABIContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClearABIContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.ClearABIContract
         * @instance
         */
        ClearABIContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * ClearABIContract contractAddress.
         * @member {Uint8Array} contractAddress
         * @memberof protocol.ClearABIContract
         * @instance
         */
        ClearABIContract.prototype.contractAddress = $util.newBuffer([]);

        /**
         * Creates a new ClearABIContract instance using the specified properties.
         * @function create
         * @memberof protocol.ClearABIContract
         * @static
         * @param {protocol.IClearABIContract=} [properties] Properties to set
         * @returns {protocol.ClearABIContract} ClearABIContract instance
         */
        ClearABIContract.create = function create(properties) {
            return new ClearABIContract(properties);
        };

        /**
         * Encodes the specified ClearABIContract message. Does not implicitly {@link protocol.ClearABIContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ClearABIContract
         * @static
         * @param {protocol.IClearABIContract} message ClearABIContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearABIContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contractAddress);
            return writer;
        };

        /**
         * Encodes the specified ClearABIContract message, length delimited. Does not implicitly {@link protocol.ClearABIContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ClearABIContract
         * @static
         * @param {protocol.IClearABIContract} message ClearABIContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearABIContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClearABIContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ClearABIContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ClearABIContract} ClearABIContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearABIContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ClearABIContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.contractAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClearABIContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ClearABIContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ClearABIContract} ClearABIContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearABIContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClearABIContract message.
         * @function verify
         * @memberof protocol.ClearABIContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClearABIContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            return null;
        };

        /**
         * Creates a ClearABIContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ClearABIContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ClearABIContract} ClearABIContract
         */
        ClearABIContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ClearABIContract)
                return object;
            var message = new $root.protocol.ClearABIContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            return message;
        };

        /**
         * Creates a plain object from a ClearABIContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ClearABIContract
         * @static
         * @param {protocol.ClearABIContract} message ClearABIContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClearABIContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            return object;
        };

        /**
         * Converts this ClearABIContract to JSON.
         * @function toJSON
         * @memberof protocol.ClearABIContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClearABIContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClearABIContract;
    })();

    protocol.WitnessCreateContract = (function() {

        /**
         * Properties of a WitnessCreateContract.
         * @memberof protocol
         * @interface IWitnessCreateContract
         * @property {Uint8Array|null} [ownerAddress] WitnessCreateContract ownerAddress
         * @property {Uint8Array|null} [url] WitnessCreateContract url
         */

        /**
         * Constructs a new WitnessCreateContract.
         * @memberof protocol
         * @classdesc Represents a WitnessCreateContract.
         * @implements IWitnessCreateContract
         * @constructor
         * @param {protocol.IWitnessCreateContract=} [properties] Properties to set
         */
        function WitnessCreateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WitnessCreateContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.WitnessCreateContract
         * @instance
         */
        WitnessCreateContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * WitnessCreateContract url.
         * @member {Uint8Array} url
         * @memberof protocol.WitnessCreateContract
         * @instance
         */
        WitnessCreateContract.prototype.url = $util.newBuffer([]);

        /**
         * Creates a new WitnessCreateContract instance using the specified properties.
         * @function create
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {protocol.IWitnessCreateContract=} [properties] Properties to set
         * @returns {protocol.WitnessCreateContract} WitnessCreateContract instance
         */
        WitnessCreateContract.create = function create(properties) {
            return new WitnessCreateContract(properties);
        };

        /**
         * Encodes the specified WitnessCreateContract message. Does not implicitly {@link protocol.WitnessCreateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {protocol.IWitnessCreateContract} message WitnessCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WitnessCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.url);
            return writer;
        };

        /**
         * Encodes the specified WitnessCreateContract message, length delimited. Does not implicitly {@link protocol.WitnessCreateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {protocol.IWitnessCreateContract} message WitnessCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WitnessCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WitnessCreateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.WitnessCreateContract} WitnessCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WitnessCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.WitnessCreateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.url = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WitnessCreateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.WitnessCreateContract} WitnessCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WitnessCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WitnessCreateContract message.
         * @function verify
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WitnessCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!(message.url && typeof message.url.length === "number" || $util.isString(message.url)))
                    return "url: buffer expected";
            return null;
        };

        /**
         * Creates a WitnessCreateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.WitnessCreateContract} WitnessCreateContract
         */
        WitnessCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.WitnessCreateContract)
                return object;
            var message = new $root.protocol.WitnessCreateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.url != null)
                if (typeof object.url === "string")
                    $util.base64.decode(object.url, message.url = $util.newBuffer($util.base64.length(object.url)), 0);
                else if (object.url.length)
                    message.url = object.url;
            return message;
        };

        /**
         * Creates a plain object from a WitnessCreateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {protocol.WitnessCreateContract} message WitnessCreateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WitnessCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.url = "";
                else {
                    object.url = [];
                    if (options.bytes !== Array)
                        object.url = $util.newBuffer(object.url);
                }
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = options.bytes === String ? $util.base64.encode(message.url, 0, message.url.length) : options.bytes === Array ? Array.prototype.slice.call(message.url) : message.url;
            return object;
        };

        /**
         * Converts this WitnessCreateContract to JSON.
         * @function toJSON
         * @memberof protocol.WitnessCreateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WitnessCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WitnessCreateContract;
    })();

    protocol.WitnessUpdateContract = (function() {

        /**
         * Properties of a WitnessUpdateContract.
         * @memberof protocol
         * @interface IWitnessUpdateContract
         * @property {Uint8Array|null} [ownerAddress] WitnessUpdateContract ownerAddress
         * @property {Uint8Array|null} [updateUrl] WitnessUpdateContract updateUrl
         */

        /**
         * Constructs a new WitnessUpdateContract.
         * @memberof protocol
         * @classdesc Represents a WitnessUpdateContract.
         * @implements IWitnessUpdateContract
         * @constructor
         * @param {protocol.IWitnessUpdateContract=} [properties] Properties to set
         */
        function WitnessUpdateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WitnessUpdateContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.WitnessUpdateContract
         * @instance
         */
        WitnessUpdateContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * WitnessUpdateContract updateUrl.
         * @member {Uint8Array} updateUrl
         * @memberof protocol.WitnessUpdateContract
         * @instance
         */
        WitnessUpdateContract.prototype.updateUrl = $util.newBuffer([]);

        /**
         * Creates a new WitnessUpdateContract instance using the specified properties.
         * @function create
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {protocol.IWitnessUpdateContract=} [properties] Properties to set
         * @returns {protocol.WitnessUpdateContract} WitnessUpdateContract instance
         */
        WitnessUpdateContract.create = function create(properties) {
            return new WitnessUpdateContract(properties);
        };

        /**
         * Encodes the specified WitnessUpdateContract message. Does not implicitly {@link protocol.WitnessUpdateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {protocol.IWitnessUpdateContract} message WitnessUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WitnessUpdateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.updateUrl != null && Object.hasOwnProperty.call(message, "updateUrl"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.updateUrl);
            return writer;
        };

        /**
         * Encodes the specified WitnessUpdateContract message, length delimited. Does not implicitly {@link protocol.WitnessUpdateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {protocol.IWitnessUpdateContract} message WitnessUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WitnessUpdateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WitnessUpdateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.WitnessUpdateContract} WitnessUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WitnessUpdateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.WitnessUpdateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 12:
                    message.updateUrl = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WitnessUpdateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.WitnessUpdateContract} WitnessUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WitnessUpdateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WitnessUpdateContract message.
         * @function verify
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WitnessUpdateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.updateUrl != null && message.hasOwnProperty("updateUrl"))
                if (!(message.updateUrl && typeof message.updateUrl.length === "number" || $util.isString(message.updateUrl)))
                    return "updateUrl: buffer expected";
            return null;
        };

        /**
         * Creates a WitnessUpdateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.WitnessUpdateContract} WitnessUpdateContract
         */
        WitnessUpdateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.WitnessUpdateContract)
                return object;
            var message = new $root.protocol.WitnessUpdateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.updateUrl != null)
                if (typeof object.updateUrl === "string")
                    $util.base64.decode(object.updateUrl, message.updateUrl = $util.newBuffer($util.base64.length(object.updateUrl)), 0);
                else if (object.updateUrl.length)
                    message.updateUrl = object.updateUrl;
            return message;
        };

        /**
         * Creates a plain object from a WitnessUpdateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {protocol.WitnessUpdateContract} message WitnessUpdateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WitnessUpdateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.updateUrl = "";
                else {
                    object.updateUrl = [];
                    if (options.bytes !== Array)
                        object.updateUrl = $util.newBuffer(object.updateUrl);
                }
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.updateUrl != null && message.hasOwnProperty("updateUrl"))
                object.updateUrl = options.bytes === String ? $util.base64.encode(message.updateUrl, 0, message.updateUrl.length) : options.bytes === Array ? Array.prototype.slice.call(message.updateUrl) : message.updateUrl;
            return object;
        };

        /**
         * Converts this WitnessUpdateContract to JSON.
         * @function toJSON
         * @memberof protocol.WitnessUpdateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WitnessUpdateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WitnessUpdateContract;
    })();

    protocol.AssetIssueContract = (function() {

        /**
         * Properties of an AssetIssueContract.
         * @memberof protocol
         * @interface IAssetIssueContract
         * @property {string|null} [id] AssetIssueContract id
         * @property {Uint8Array|null} [ownerAddress] AssetIssueContract ownerAddress
         * @property {Uint8Array|null} [name] AssetIssueContract name
         * @property {Uint8Array|null} [abbr] AssetIssueContract abbr
         * @property {number|Long|null} [totalSupply] AssetIssueContract totalSupply
         * @property {Array.<protocol.AssetIssueContract.IFrozenSupply>|null} [frozenSupply] AssetIssueContract frozenSupply
         * @property {number|null} [trxNum] AssetIssueContract trxNum
         * @property {number|null} [precision] AssetIssueContract precision
         * @property {number|null} [num] AssetIssueContract num
         * @property {number|Long|null} [startTime] AssetIssueContract startTime
         * @property {number|Long|null} [endTime] AssetIssueContract endTime
         * @property {number|Long|null} [order] AssetIssueContract order
         * @property {number|null} [voteScore] AssetIssueContract voteScore
         * @property {Uint8Array|null} [description] AssetIssueContract description
         * @property {Uint8Array|null} [url] AssetIssueContract url
         * @property {number|Long|null} [freeAssetNetLimit] AssetIssueContract freeAssetNetLimit
         * @property {number|Long|null} [publicFreeAssetNetLimit] AssetIssueContract publicFreeAssetNetLimit
         * @property {number|Long|null} [publicFreeAssetNetUsage] AssetIssueContract publicFreeAssetNetUsage
         * @property {number|Long|null} [publicLatestFreeNetTime] AssetIssueContract publicLatestFreeNetTime
         */

        /**
         * Constructs a new AssetIssueContract.
         * @memberof protocol
         * @classdesc Represents an AssetIssueContract.
         * @implements IAssetIssueContract
         * @constructor
         * @param {protocol.IAssetIssueContract=} [properties] Properties to set
         */
        function AssetIssueContract(properties) {
            this.frozenSupply = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AssetIssueContract id.
         * @member {string} id
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.id = "";

        /**
         * AssetIssueContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * AssetIssueContract name.
         * @member {Uint8Array} name
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.name = $util.newBuffer([]);

        /**
         * AssetIssueContract abbr.
         * @member {Uint8Array} abbr
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.abbr = $util.newBuffer([]);

        /**
         * AssetIssueContract totalSupply.
         * @member {number|Long} totalSupply
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.totalSupply = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract frozenSupply.
         * @member {Array.<protocol.AssetIssueContract.IFrozenSupply>} frozenSupply
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.frozenSupply = $util.emptyArray;

        /**
         * AssetIssueContract trxNum.
         * @member {number} trxNum
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.trxNum = 0;

        /**
         * AssetIssueContract precision.
         * @member {number} precision
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.precision = 0;

        /**
         * AssetIssueContract num.
         * @member {number} num
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.num = 0;

        /**
         * AssetIssueContract startTime.
         * @member {number|Long} startTime
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract endTime.
         * @member {number|Long} endTime
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract order.
         * @member {number|Long} order
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.order = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract voteScore.
         * @member {number} voteScore
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.voteScore = 0;

        /**
         * AssetIssueContract description.
         * @member {Uint8Array} description
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.description = $util.newBuffer([]);

        /**
         * AssetIssueContract url.
         * @member {Uint8Array} url
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.url = $util.newBuffer([]);

        /**
         * AssetIssueContract freeAssetNetLimit.
         * @member {number|Long} freeAssetNetLimit
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.freeAssetNetLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract publicFreeAssetNetLimit.
         * @member {number|Long} publicFreeAssetNetLimit
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.publicFreeAssetNetLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract publicFreeAssetNetUsage.
         * @member {number|Long} publicFreeAssetNetUsage
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.publicFreeAssetNetUsage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract publicLatestFreeNetTime.
         * @member {number|Long} publicLatestFreeNetTime
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.publicLatestFreeNetTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AssetIssueContract instance using the specified properties.
         * @function create
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {protocol.IAssetIssueContract=} [properties] Properties to set
         * @returns {protocol.AssetIssueContract} AssetIssueContract instance
         */
        AssetIssueContract.create = function create(properties) {
            return new AssetIssueContract(properties);
        };

        /**
         * Encodes the specified AssetIssueContract message. Does not implicitly {@link protocol.AssetIssueContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {protocol.IAssetIssueContract} message AssetIssueContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetIssueContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.name);
            if (message.abbr != null && Object.hasOwnProperty.call(message, "abbr"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.abbr);
            if (message.totalSupply != null && Object.hasOwnProperty.call(message, "totalSupply"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.totalSupply);
            if (message.frozenSupply != null && message.frozenSupply.length)
                for (var i = 0; i < message.frozenSupply.length; ++i)
                    $root.protocol.AssetIssueContract.FrozenSupply.encode(message.frozenSupply[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.trxNum != null && Object.hasOwnProperty.call(message, "trxNum"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.trxNum);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.precision);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.num);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.startTime);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.endTime);
            if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.order);
            if (message.voteScore != null && Object.hasOwnProperty.call(message, "voteScore"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.voteScore);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.description);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.url);
            if (message.freeAssetNetLimit != null && Object.hasOwnProperty.call(message, "freeAssetNetLimit"))
                writer.uint32(/* id 22, wireType 0 =*/176).int64(message.freeAssetNetLimit);
            if (message.publicFreeAssetNetLimit != null && Object.hasOwnProperty.call(message, "publicFreeAssetNetLimit"))
                writer.uint32(/* id 23, wireType 0 =*/184).int64(message.publicFreeAssetNetLimit);
            if (message.publicFreeAssetNetUsage != null && Object.hasOwnProperty.call(message, "publicFreeAssetNetUsage"))
                writer.uint32(/* id 24, wireType 0 =*/192).int64(message.publicFreeAssetNetUsage);
            if (message.publicLatestFreeNetTime != null && Object.hasOwnProperty.call(message, "publicLatestFreeNetTime"))
                writer.uint32(/* id 25, wireType 0 =*/200).int64(message.publicLatestFreeNetTime);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 41, wireType 2 =*/330).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified AssetIssueContract message, length delimited. Does not implicitly {@link protocol.AssetIssueContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {protocol.IAssetIssueContract} message AssetIssueContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetIssueContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AssetIssueContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.AssetIssueContract} AssetIssueContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetIssueContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AssetIssueContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 41:
                    message.id = reader.string();
                    break;
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.name = reader.bytes();
                    break;
                case 3:
                    message.abbr = reader.bytes();
                    break;
                case 4:
                    message.totalSupply = reader.int64();
                    break;
                case 5:
                    if (!(message.frozenSupply && message.frozenSupply.length))
                        message.frozenSupply = [];
                    message.frozenSupply.push($root.protocol.AssetIssueContract.FrozenSupply.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.trxNum = reader.int32();
                    break;
                case 7:
                    message.precision = reader.int32();
                    break;
                case 8:
                    message.num = reader.int32();
                    break;
                case 9:
                    message.startTime = reader.int64();
                    break;
                case 10:
                    message.endTime = reader.int64();
                    break;
                case 11:
                    message.order = reader.int64();
                    break;
                case 16:
                    message.voteScore = reader.int32();
                    break;
                case 20:
                    message.description = reader.bytes();
                    break;
                case 21:
                    message.url = reader.bytes();
                    break;
                case 22:
                    message.freeAssetNetLimit = reader.int64();
                    break;
                case 23:
                    message.publicFreeAssetNetLimit = reader.int64();
                    break;
                case 24:
                    message.publicFreeAssetNetUsage = reader.int64();
                    break;
                case 25:
                    message.publicLatestFreeNetTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AssetIssueContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.AssetIssueContract} AssetIssueContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetIssueContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AssetIssueContract message.
         * @function verify
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AssetIssueContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                    return "name: buffer expected";
            if (message.abbr != null && message.hasOwnProperty("abbr"))
                if (!(message.abbr && typeof message.abbr.length === "number" || $util.isString(message.abbr)))
                    return "abbr: buffer expected";
            if (message.totalSupply != null && message.hasOwnProperty("totalSupply"))
                if (!$util.isInteger(message.totalSupply) && !(message.totalSupply && $util.isInteger(message.totalSupply.low) && $util.isInteger(message.totalSupply.high)))
                    return "totalSupply: integer|Long expected";
            if (message.frozenSupply != null && message.hasOwnProperty("frozenSupply")) {
                if (!Array.isArray(message.frozenSupply))
                    return "frozenSupply: array expected";
                for (var i = 0; i < message.frozenSupply.length; ++i) {
                    var error = $root.protocol.AssetIssueContract.FrozenSupply.verify(message.frozenSupply[i]);
                    if (error)
                        return "frozenSupply." + error;
                }
            }
            if (message.trxNum != null && message.hasOwnProperty("trxNum"))
                if (!$util.isInteger(message.trxNum))
                    return "trxNum: integer expected";
            if (message.precision != null && message.hasOwnProperty("precision"))
                if (!$util.isInteger(message.precision))
                    return "precision: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
            if (message.order != null && message.hasOwnProperty("order"))
                if (!$util.isInteger(message.order) && !(message.order && $util.isInteger(message.order.low) && $util.isInteger(message.order.high)))
                    return "order: integer|Long expected";
            if (message.voteScore != null && message.hasOwnProperty("voteScore"))
                if (!$util.isInteger(message.voteScore))
                    return "voteScore: integer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!(message.description && typeof message.description.length === "number" || $util.isString(message.description)))
                    return "description: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!(message.url && typeof message.url.length === "number" || $util.isString(message.url)))
                    return "url: buffer expected";
            if (message.freeAssetNetLimit != null && message.hasOwnProperty("freeAssetNetLimit"))
                if (!$util.isInteger(message.freeAssetNetLimit) && !(message.freeAssetNetLimit && $util.isInteger(message.freeAssetNetLimit.low) && $util.isInteger(message.freeAssetNetLimit.high)))
                    return "freeAssetNetLimit: integer|Long expected";
            if (message.publicFreeAssetNetLimit != null && message.hasOwnProperty("publicFreeAssetNetLimit"))
                if (!$util.isInteger(message.publicFreeAssetNetLimit) && !(message.publicFreeAssetNetLimit && $util.isInteger(message.publicFreeAssetNetLimit.low) && $util.isInteger(message.publicFreeAssetNetLimit.high)))
                    return "publicFreeAssetNetLimit: integer|Long expected";
            if (message.publicFreeAssetNetUsage != null && message.hasOwnProperty("publicFreeAssetNetUsage"))
                if (!$util.isInteger(message.publicFreeAssetNetUsage) && !(message.publicFreeAssetNetUsage && $util.isInteger(message.publicFreeAssetNetUsage.low) && $util.isInteger(message.publicFreeAssetNetUsage.high)))
                    return "publicFreeAssetNetUsage: integer|Long expected";
            if (message.publicLatestFreeNetTime != null && message.hasOwnProperty("publicLatestFreeNetTime"))
                if (!$util.isInteger(message.publicLatestFreeNetTime) && !(message.publicLatestFreeNetTime && $util.isInteger(message.publicLatestFreeNetTime.low) && $util.isInteger(message.publicLatestFreeNetTime.high)))
                    return "publicLatestFreeNetTime: integer|Long expected";
            return null;
        };

        /**
         * Creates an AssetIssueContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.AssetIssueContract} AssetIssueContract
         */
        AssetIssueContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AssetIssueContract)
                return object;
            var message = new $root.protocol.AssetIssueContract();
            if (object.id != null)
                message.id = String(object.id);
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.name != null)
                if (typeof object.name === "string")
                    $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
                else if (object.name.length)
                    message.name = object.name;
            if (object.abbr != null)
                if (typeof object.abbr === "string")
                    $util.base64.decode(object.abbr, message.abbr = $util.newBuffer($util.base64.length(object.abbr)), 0);
                else if (object.abbr.length)
                    message.abbr = object.abbr;
            if (object.totalSupply != null)
                if ($util.Long)
                    (message.totalSupply = $util.Long.fromValue(object.totalSupply)).unsigned = false;
                else if (typeof object.totalSupply === "string")
                    message.totalSupply = parseInt(object.totalSupply, 10);
                else if (typeof object.totalSupply === "number")
                    message.totalSupply = object.totalSupply;
                else if (typeof object.totalSupply === "object")
                    message.totalSupply = new $util.LongBits(object.totalSupply.low >>> 0, object.totalSupply.high >>> 0).toNumber();
            if (object.frozenSupply) {
                if (!Array.isArray(object.frozenSupply))
                    throw TypeError(".protocol.AssetIssueContract.frozenSupply: array expected");
                message.frozenSupply = [];
                for (var i = 0; i < object.frozenSupply.length; ++i) {
                    if (typeof object.frozenSupply[i] !== "object")
                        throw TypeError(".protocol.AssetIssueContract.frozenSupply: object expected");
                    message.frozenSupply[i] = $root.protocol.AssetIssueContract.FrozenSupply.fromObject(object.frozenSupply[i]);
                }
            }
            if (object.trxNum != null)
                message.trxNum = object.trxNum | 0;
            if (object.precision != null)
                message.precision = object.precision | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.endTime != null)
                if ($util.Long)
                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
                else if (typeof object.endTime === "string")
                    message.endTime = parseInt(object.endTime, 10);
                else if (typeof object.endTime === "number")
                    message.endTime = object.endTime;
                else if (typeof object.endTime === "object")
                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
            if (object.order != null)
                if ($util.Long)
                    (message.order = $util.Long.fromValue(object.order)).unsigned = false;
                else if (typeof object.order === "string")
                    message.order = parseInt(object.order, 10);
                else if (typeof object.order === "number")
                    message.order = object.order;
                else if (typeof object.order === "object")
                    message.order = new $util.LongBits(object.order.low >>> 0, object.order.high >>> 0).toNumber();
            if (object.voteScore != null)
                message.voteScore = object.voteScore | 0;
            if (object.description != null)
                if (typeof object.description === "string")
                    $util.base64.decode(object.description, message.description = $util.newBuffer($util.base64.length(object.description)), 0);
                else if (object.description.length)
                    message.description = object.description;
            if (object.url != null)
                if (typeof object.url === "string")
                    $util.base64.decode(object.url, message.url = $util.newBuffer($util.base64.length(object.url)), 0);
                else if (object.url.length)
                    message.url = object.url;
            if (object.freeAssetNetLimit != null)
                if ($util.Long)
                    (message.freeAssetNetLimit = $util.Long.fromValue(object.freeAssetNetLimit)).unsigned = false;
                else if (typeof object.freeAssetNetLimit === "string")
                    message.freeAssetNetLimit = parseInt(object.freeAssetNetLimit, 10);
                else if (typeof object.freeAssetNetLimit === "number")
                    message.freeAssetNetLimit = object.freeAssetNetLimit;
                else if (typeof object.freeAssetNetLimit === "object")
                    message.freeAssetNetLimit = new $util.LongBits(object.freeAssetNetLimit.low >>> 0, object.freeAssetNetLimit.high >>> 0).toNumber();
            if (object.publicFreeAssetNetLimit != null)
                if ($util.Long)
                    (message.publicFreeAssetNetLimit = $util.Long.fromValue(object.publicFreeAssetNetLimit)).unsigned = false;
                else if (typeof object.publicFreeAssetNetLimit === "string")
                    message.publicFreeAssetNetLimit = parseInt(object.publicFreeAssetNetLimit, 10);
                else if (typeof object.publicFreeAssetNetLimit === "number")
                    message.publicFreeAssetNetLimit = object.publicFreeAssetNetLimit;
                else if (typeof object.publicFreeAssetNetLimit === "object")
                    message.publicFreeAssetNetLimit = new $util.LongBits(object.publicFreeAssetNetLimit.low >>> 0, object.publicFreeAssetNetLimit.high >>> 0).toNumber();
            if (object.publicFreeAssetNetUsage != null)
                if ($util.Long)
                    (message.publicFreeAssetNetUsage = $util.Long.fromValue(object.publicFreeAssetNetUsage)).unsigned = false;
                else if (typeof object.publicFreeAssetNetUsage === "string")
                    message.publicFreeAssetNetUsage = parseInt(object.publicFreeAssetNetUsage, 10);
                else if (typeof object.publicFreeAssetNetUsage === "number")
                    message.publicFreeAssetNetUsage = object.publicFreeAssetNetUsage;
                else if (typeof object.publicFreeAssetNetUsage === "object")
                    message.publicFreeAssetNetUsage = new $util.LongBits(object.publicFreeAssetNetUsage.low >>> 0, object.publicFreeAssetNetUsage.high >>> 0).toNumber();
            if (object.publicLatestFreeNetTime != null)
                if ($util.Long)
                    (message.publicLatestFreeNetTime = $util.Long.fromValue(object.publicLatestFreeNetTime)).unsigned = false;
                else if (typeof object.publicLatestFreeNetTime === "string")
                    message.publicLatestFreeNetTime = parseInt(object.publicLatestFreeNetTime, 10);
                else if (typeof object.publicLatestFreeNetTime === "number")
                    message.publicLatestFreeNetTime = object.publicLatestFreeNetTime;
                else if (typeof object.publicLatestFreeNetTime === "object")
                    message.publicLatestFreeNetTime = new $util.LongBits(object.publicLatestFreeNetTime.low >>> 0, object.publicLatestFreeNetTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AssetIssueContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {protocol.AssetIssueContract} message AssetIssueContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AssetIssueContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.frozenSupply = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.name = "";
                else {
                    object.name = [];
                    if (options.bytes !== Array)
                        object.name = $util.newBuffer(object.name);
                }
                if (options.bytes === String)
                    object.abbr = "";
                else {
                    object.abbr = [];
                    if (options.bytes !== Array)
                        object.abbr = $util.newBuffer(object.abbr);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalSupply = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalSupply = options.longs === String ? "0" : 0;
                object.trxNum = 0;
                object.precision = 0;
                object.num = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.order = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.order = options.longs === String ? "0" : 0;
                object.voteScore = 0;
                if (options.bytes === String)
                    object.description = "";
                else {
                    object.description = [];
                    if (options.bytes !== Array)
                        object.description = $util.newBuffer(object.description);
                }
                if (options.bytes === String)
                    object.url = "";
                else {
                    object.url = [];
                    if (options.bytes !== Array)
                        object.url = $util.newBuffer(object.url);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.freeAssetNetLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.freeAssetNetLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.publicFreeAssetNetLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.publicFreeAssetNetLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.publicFreeAssetNetUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.publicFreeAssetNetUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.publicLatestFreeNetTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.publicLatestFreeNetTime = options.longs === String ? "0" : 0;
                object.id = "";
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
            if (message.abbr != null && message.hasOwnProperty("abbr"))
                object.abbr = options.bytes === String ? $util.base64.encode(message.abbr, 0, message.abbr.length) : options.bytes === Array ? Array.prototype.slice.call(message.abbr) : message.abbr;
            if (message.totalSupply != null && message.hasOwnProperty("totalSupply"))
                if (typeof message.totalSupply === "number")
                    object.totalSupply = options.longs === String ? String(message.totalSupply) : message.totalSupply;
                else
                    object.totalSupply = options.longs === String ? $util.Long.prototype.toString.call(message.totalSupply) : options.longs === Number ? new $util.LongBits(message.totalSupply.low >>> 0, message.totalSupply.high >>> 0).toNumber() : message.totalSupply;
            if (message.frozenSupply && message.frozenSupply.length) {
                object.frozenSupply = [];
                for (var j = 0; j < message.frozenSupply.length; ++j)
                    object.frozenSupply[j] = $root.protocol.AssetIssueContract.FrozenSupply.toObject(message.frozenSupply[j], options);
            }
            if (message.trxNum != null && message.hasOwnProperty("trxNum"))
                object.trxNum = message.trxNum;
            if (message.precision != null && message.hasOwnProperty("precision"))
                object.precision = message.precision;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (typeof message.endTime === "number")
                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
                else
                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
            if (message.order != null && message.hasOwnProperty("order"))
                if (typeof message.order === "number")
                    object.order = options.longs === String ? String(message.order) : message.order;
                else
                    object.order = options.longs === String ? $util.Long.prototype.toString.call(message.order) : options.longs === Number ? new $util.LongBits(message.order.low >>> 0, message.order.high >>> 0).toNumber() : message.order;
            if (message.voteScore != null && message.hasOwnProperty("voteScore"))
                object.voteScore = message.voteScore;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = options.bytes === String ? $util.base64.encode(message.description, 0, message.description.length) : options.bytes === Array ? Array.prototype.slice.call(message.description) : message.description;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = options.bytes === String ? $util.base64.encode(message.url, 0, message.url.length) : options.bytes === Array ? Array.prototype.slice.call(message.url) : message.url;
            if (message.freeAssetNetLimit != null && message.hasOwnProperty("freeAssetNetLimit"))
                if (typeof message.freeAssetNetLimit === "number")
                    object.freeAssetNetLimit = options.longs === String ? String(message.freeAssetNetLimit) : message.freeAssetNetLimit;
                else
                    object.freeAssetNetLimit = options.longs === String ? $util.Long.prototype.toString.call(message.freeAssetNetLimit) : options.longs === Number ? new $util.LongBits(message.freeAssetNetLimit.low >>> 0, message.freeAssetNetLimit.high >>> 0).toNumber() : message.freeAssetNetLimit;
            if (message.publicFreeAssetNetLimit != null && message.hasOwnProperty("publicFreeAssetNetLimit"))
                if (typeof message.publicFreeAssetNetLimit === "number")
                    object.publicFreeAssetNetLimit = options.longs === String ? String(message.publicFreeAssetNetLimit) : message.publicFreeAssetNetLimit;
                else
                    object.publicFreeAssetNetLimit = options.longs === String ? $util.Long.prototype.toString.call(message.publicFreeAssetNetLimit) : options.longs === Number ? new $util.LongBits(message.publicFreeAssetNetLimit.low >>> 0, message.publicFreeAssetNetLimit.high >>> 0).toNumber() : message.publicFreeAssetNetLimit;
            if (message.publicFreeAssetNetUsage != null && message.hasOwnProperty("publicFreeAssetNetUsage"))
                if (typeof message.publicFreeAssetNetUsage === "number")
                    object.publicFreeAssetNetUsage = options.longs === String ? String(message.publicFreeAssetNetUsage) : message.publicFreeAssetNetUsage;
                else
                    object.publicFreeAssetNetUsage = options.longs === String ? $util.Long.prototype.toString.call(message.publicFreeAssetNetUsage) : options.longs === Number ? new $util.LongBits(message.publicFreeAssetNetUsage.low >>> 0, message.publicFreeAssetNetUsage.high >>> 0).toNumber() : message.publicFreeAssetNetUsage;
            if (message.publicLatestFreeNetTime != null && message.hasOwnProperty("publicLatestFreeNetTime"))
                if (typeof message.publicLatestFreeNetTime === "number")
                    object.publicLatestFreeNetTime = options.longs === String ? String(message.publicLatestFreeNetTime) : message.publicLatestFreeNetTime;
                else
                    object.publicLatestFreeNetTime = options.longs === String ? $util.Long.prototype.toString.call(message.publicLatestFreeNetTime) : options.longs === Number ? new $util.LongBits(message.publicLatestFreeNetTime.low >>> 0, message.publicLatestFreeNetTime.high >>> 0).toNumber() : message.publicLatestFreeNetTime;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this AssetIssueContract to JSON.
         * @function toJSON
         * @memberof protocol.AssetIssueContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AssetIssueContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        AssetIssueContract.FrozenSupply = (function() {

            /**
             * Properties of a FrozenSupply.
             * @memberof protocol.AssetIssueContract
             * @interface IFrozenSupply
             * @property {number|Long|null} [frozenAmount] FrozenSupply frozenAmount
             * @property {number|Long|null} [frozenDays] FrozenSupply frozenDays
             */

            /**
             * Constructs a new FrozenSupply.
             * @memberof protocol.AssetIssueContract
             * @classdesc Represents a FrozenSupply.
             * @implements IFrozenSupply
             * @constructor
             * @param {protocol.AssetIssueContract.IFrozenSupply=} [properties] Properties to set
             */
            function FrozenSupply(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FrozenSupply frozenAmount.
             * @member {number|Long} frozenAmount
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @instance
             */
            FrozenSupply.prototype.frozenAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * FrozenSupply frozenDays.
             * @member {number|Long} frozenDays
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @instance
             */
            FrozenSupply.prototype.frozenDays = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new FrozenSupply instance using the specified properties.
             * @function create
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {protocol.AssetIssueContract.IFrozenSupply=} [properties] Properties to set
             * @returns {protocol.AssetIssueContract.FrozenSupply} FrozenSupply instance
             */
            FrozenSupply.create = function create(properties) {
                return new FrozenSupply(properties);
            };

            /**
             * Encodes the specified FrozenSupply message. Does not implicitly {@link protocol.AssetIssueContract.FrozenSupply.verify|verify} messages.
             * @function encode
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {protocol.AssetIssueContract.IFrozenSupply} message FrozenSupply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FrozenSupply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frozenAmount != null && Object.hasOwnProperty.call(message, "frozenAmount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.frozenAmount);
                if (message.frozenDays != null && Object.hasOwnProperty.call(message, "frozenDays"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.frozenDays);
                return writer;
            };

            /**
             * Encodes the specified FrozenSupply message, length delimited. Does not implicitly {@link protocol.AssetIssueContract.FrozenSupply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {protocol.AssetIssueContract.IFrozenSupply} message FrozenSupply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FrozenSupply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FrozenSupply message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.AssetIssueContract.FrozenSupply} FrozenSupply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FrozenSupply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AssetIssueContract.FrozenSupply();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.frozenAmount = reader.int64();
                        break;
                    case 2:
                        message.frozenDays = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FrozenSupply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.AssetIssueContract.FrozenSupply} FrozenSupply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FrozenSupply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FrozenSupply message.
             * @function verify
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FrozenSupply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.frozenAmount != null && message.hasOwnProperty("frozenAmount"))
                    if (!$util.isInteger(message.frozenAmount) && !(message.frozenAmount && $util.isInteger(message.frozenAmount.low) && $util.isInteger(message.frozenAmount.high)))
                        return "frozenAmount: integer|Long expected";
                if (message.frozenDays != null && message.hasOwnProperty("frozenDays"))
                    if (!$util.isInteger(message.frozenDays) && !(message.frozenDays && $util.isInteger(message.frozenDays.low) && $util.isInteger(message.frozenDays.high)))
                        return "frozenDays: integer|Long expected";
                return null;
            };

            /**
             * Creates a FrozenSupply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.AssetIssueContract.FrozenSupply} FrozenSupply
             */
            FrozenSupply.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.AssetIssueContract.FrozenSupply)
                    return object;
                var message = new $root.protocol.AssetIssueContract.FrozenSupply();
                if (object.frozenAmount != null)
                    if ($util.Long)
                        (message.frozenAmount = $util.Long.fromValue(object.frozenAmount)).unsigned = false;
                    else if (typeof object.frozenAmount === "string")
                        message.frozenAmount = parseInt(object.frozenAmount, 10);
                    else if (typeof object.frozenAmount === "number")
                        message.frozenAmount = object.frozenAmount;
                    else if (typeof object.frozenAmount === "object")
                        message.frozenAmount = new $util.LongBits(object.frozenAmount.low >>> 0, object.frozenAmount.high >>> 0).toNumber();
                if (object.frozenDays != null)
                    if ($util.Long)
                        (message.frozenDays = $util.Long.fromValue(object.frozenDays)).unsigned = false;
                    else if (typeof object.frozenDays === "string")
                        message.frozenDays = parseInt(object.frozenDays, 10);
                    else if (typeof object.frozenDays === "number")
                        message.frozenDays = object.frozenDays;
                    else if (typeof object.frozenDays === "object")
                        message.frozenDays = new $util.LongBits(object.frozenDays.low >>> 0, object.frozenDays.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a FrozenSupply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {protocol.AssetIssueContract.FrozenSupply} message FrozenSupply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FrozenSupply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.frozenAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.frozenAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.frozenDays = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.frozenDays = options.longs === String ? "0" : 0;
                }
                if (message.frozenAmount != null && message.hasOwnProperty("frozenAmount"))
                    if (typeof message.frozenAmount === "number")
                        object.frozenAmount = options.longs === String ? String(message.frozenAmount) : message.frozenAmount;
                    else
                        object.frozenAmount = options.longs === String ? $util.Long.prototype.toString.call(message.frozenAmount) : options.longs === Number ? new $util.LongBits(message.frozenAmount.low >>> 0, message.frozenAmount.high >>> 0).toNumber() : message.frozenAmount;
                if (message.frozenDays != null && message.hasOwnProperty("frozenDays"))
                    if (typeof message.frozenDays === "number")
                        object.frozenDays = options.longs === String ? String(message.frozenDays) : message.frozenDays;
                    else
                        object.frozenDays = options.longs === String ? $util.Long.prototype.toString.call(message.frozenDays) : options.longs === Number ? new $util.LongBits(message.frozenDays.low >>> 0, message.frozenDays.high >>> 0).toNumber() : message.frozenDays;
                return object;
            };

            /**
             * Converts this FrozenSupply to JSON.
             * @function toJSON
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FrozenSupply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FrozenSupply;
        })();

        return AssetIssueContract;
    })();

    protocol.ParticipateAssetIssueContract = (function() {

        /**
         * Properties of a ParticipateAssetIssueContract.
         * @memberof protocol
         * @interface IParticipateAssetIssueContract
         * @property {Uint8Array|null} [ownerAddress] ParticipateAssetIssueContract ownerAddress
         * @property {Uint8Array|null} [toAddress] ParticipateAssetIssueContract toAddress
         * @property {Uint8Array|null} [assetName] ParticipateAssetIssueContract assetName
         * @property {number|Long|null} [amount] ParticipateAssetIssueContract amount
         */

        /**
         * Constructs a new ParticipateAssetIssueContract.
         * @memberof protocol
         * @classdesc Represents a ParticipateAssetIssueContract.
         * @implements IParticipateAssetIssueContract
         * @constructor
         * @param {protocol.IParticipateAssetIssueContract=} [properties] Properties to set
         */
        function ParticipateAssetIssueContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ParticipateAssetIssueContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.ParticipateAssetIssueContract
         * @instance
         */
        ParticipateAssetIssueContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * ParticipateAssetIssueContract toAddress.
         * @member {Uint8Array} toAddress
         * @memberof protocol.ParticipateAssetIssueContract
         * @instance
         */
        ParticipateAssetIssueContract.prototype.toAddress = $util.newBuffer([]);

        /**
         * ParticipateAssetIssueContract assetName.
         * @member {Uint8Array} assetName
         * @memberof protocol.ParticipateAssetIssueContract
         * @instance
         */
        ParticipateAssetIssueContract.prototype.assetName = $util.newBuffer([]);

        /**
         * ParticipateAssetIssueContract amount.
         * @member {number|Long} amount
         * @memberof protocol.ParticipateAssetIssueContract
         * @instance
         */
        ParticipateAssetIssueContract.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ParticipateAssetIssueContract instance using the specified properties.
         * @function create
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {protocol.IParticipateAssetIssueContract=} [properties] Properties to set
         * @returns {protocol.ParticipateAssetIssueContract} ParticipateAssetIssueContract instance
         */
        ParticipateAssetIssueContract.create = function create(properties) {
            return new ParticipateAssetIssueContract(properties);
        };

        /**
         * Encodes the specified ParticipateAssetIssueContract message. Does not implicitly {@link protocol.ParticipateAssetIssueContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {protocol.IParticipateAssetIssueContract} message ParticipateAssetIssueContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ParticipateAssetIssueContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.toAddress);
            if (message.assetName != null && Object.hasOwnProperty.call(message, "assetName"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.assetName);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified ParticipateAssetIssueContract message, length delimited. Does not implicitly {@link protocol.ParticipateAssetIssueContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {protocol.IParticipateAssetIssueContract} message ParticipateAssetIssueContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ParticipateAssetIssueContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ParticipateAssetIssueContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ParticipateAssetIssueContract} ParticipateAssetIssueContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ParticipateAssetIssueContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ParticipateAssetIssueContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.toAddress = reader.bytes();
                    break;
                case 3:
                    message.assetName = reader.bytes();
                    break;
                case 4:
                    message.amount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ParticipateAssetIssueContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ParticipateAssetIssueContract} ParticipateAssetIssueContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ParticipateAssetIssueContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ParticipateAssetIssueContract message.
         * @function verify
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ParticipateAssetIssueContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                if (!(message.toAddress && typeof message.toAddress.length === "number" || $util.isString(message.toAddress)))
                    return "toAddress: buffer expected";
            if (message.assetName != null && message.hasOwnProperty("assetName"))
                if (!(message.assetName && typeof message.assetName.length === "number" || $util.isString(message.assetName)))
                    return "assetName: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates a ParticipateAssetIssueContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ParticipateAssetIssueContract} ParticipateAssetIssueContract
         */
        ParticipateAssetIssueContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ParticipateAssetIssueContract)
                return object;
            var message = new $root.protocol.ParticipateAssetIssueContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.toAddress != null)
                if (typeof object.toAddress === "string")
                    $util.base64.decode(object.toAddress, message.toAddress = $util.newBuffer($util.base64.length(object.toAddress)), 0);
                else if (object.toAddress.length)
                    message.toAddress = object.toAddress;
            if (object.assetName != null)
                if (typeof object.assetName === "string")
                    $util.base64.decode(object.assetName, message.assetName = $util.newBuffer($util.base64.length(object.assetName)), 0);
                else if (object.assetName.length)
                    message.assetName = object.assetName;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ParticipateAssetIssueContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {protocol.ParticipateAssetIssueContract} message ParticipateAssetIssueContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ParticipateAssetIssueContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.toAddress = "";
                else {
                    object.toAddress = [];
                    if (options.bytes !== Array)
                        object.toAddress = $util.newBuffer(object.toAddress);
                }
                if (options.bytes === String)
                    object.assetName = "";
                else {
                    object.assetName = [];
                    if (options.bytes !== Array)
                        object.assetName = $util.newBuffer(object.assetName);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                object.toAddress = options.bytes === String ? $util.base64.encode(message.toAddress, 0, message.toAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.toAddress) : message.toAddress;
            if (message.assetName != null && message.hasOwnProperty("assetName"))
                object.assetName = options.bytes === String ? $util.base64.encode(message.assetName, 0, message.assetName.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetName) : message.assetName;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };

        /**
         * Converts this ParticipateAssetIssueContract to JSON.
         * @function toJSON
         * @memberof protocol.ParticipateAssetIssueContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ParticipateAssetIssueContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ParticipateAssetIssueContract;
    })();

    /**
     * ResourceCode enum.
     * @name protocol.ResourceCode
     * @enum {number}
     * @property {number} BANDWIDTH=0 BANDWIDTH value
     * @property {number} ENERGY=1 ENERGY value
     */
    protocol.ResourceCode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BANDWIDTH"] = 0;
        values[valuesById[1] = "ENERGY"] = 1;
        return values;
    })();

    protocol.FreezeBalanceContract = (function() {

        /**
         * Properties of a FreezeBalanceContract.
         * @memberof protocol
         * @interface IFreezeBalanceContract
         * @property {Uint8Array|null} [ownerAddress] FreezeBalanceContract ownerAddress
         * @property {number|Long|null} [frozenBalance] FreezeBalanceContract frozenBalance
         * @property {number|Long|null} [frozenDuration] FreezeBalanceContract frozenDuration
         * @property {protocol.ResourceCode|null} [resource] FreezeBalanceContract resource
         * @property {Uint8Array|null} [receiverAddress] FreezeBalanceContract receiverAddress
         */

        /**
         * Constructs a new FreezeBalanceContract.
         * @memberof protocol
         * @classdesc Represents a FreezeBalanceContract.
         * @implements IFreezeBalanceContract
         * @constructor
         * @param {protocol.IFreezeBalanceContract=} [properties] Properties to set
         */
        function FreezeBalanceContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreezeBalanceContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.FreezeBalanceContract
         * @instance
         */
        FreezeBalanceContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * FreezeBalanceContract frozenBalance.
         * @member {number|Long} frozenBalance
         * @memberof protocol.FreezeBalanceContract
         * @instance
         */
        FreezeBalanceContract.prototype.frozenBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FreezeBalanceContract frozenDuration.
         * @member {number|Long} frozenDuration
         * @memberof protocol.FreezeBalanceContract
         * @instance
         */
        FreezeBalanceContract.prototype.frozenDuration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FreezeBalanceContract resource.
         * @member {protocol.ResourceCode} resource
         * @memberof protocol.FreezeBalanceContract
         * @instance
         */
        FreezeBalanceContract.prototype.resource = 0;

        /**
         * FreezeBalanceContract receiverAddress.
         * @member {Uint8Array} receiverAddress
         * @memberof protocol.FreezeBalanceContract
         * @instance
         */
        FreezeBalanceContract.prototype.receiverAddress = $util.newBuffer([]);

        /**
         * Creates a new FreezeBalanceContract instance using the specified properties.
         * @function create
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {protocol.IFreezeBalanceContract=} [properties] Properties to set
         * @returns {protocol.FreezeBalanceContract} FreezeBalanceContract instance
         */
        FreezeBalanceContract.create = function create(properties) {
            return new FreezeBalanceContract(properties);
        };

        /**
         * Encodes the specified FreezeBalanceContract message. Does not implicitly {@link protocol.FreezeBalanceContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {protocol.IFreezeBalanceContract} message FreezeBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreezeBalanceContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.frozenBalance != null && Object.hasOwnProperty.call(message, "frozenBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.frozenBalance);
            if (message.frozenDuration != null && Object.hasOwnProperty.call(message, "frozenDuration"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.frozenDuration);
            if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.resource);
            if (message.receiverAddress != null && Object.hasOwnProperty.call(message, "receiverAddress"))
                writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.receiverAddress);
            return writer;
        };

        /**
         * Encodes the specified FreezeBalanceContract message, length delimited. Does not implicitly {@link protocol.FreezeBalanceContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {protocol.IFreezeBalanceContract} message FreezeBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreezeBalanceContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreezeBalanceContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.FreezeBalanceContract} FreezeBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreezeBalanceContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.FreezeBalanceContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.frozenBalance = reader.int64();
                    break;
                case 3:
                    message.frozenDuration = reader.int64();
                    break;
                case 10:
                    message.resource = reader.int32();
                    break;
                case 15:
                    message.receiverAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreezeBalanceContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.FreezeBalanceContract} FreezeBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreezeBalanceContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreezeBalanceContract message.
         * @function verify
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreezeBalanceContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.frozenBalance != null && message.hasOwnProperty("frozenBalance"))
                if (!$util.isInteger(message.frozenBalance) && !(message.frozenBalance && $util.isInteger(message.frozenBalance.low) && $util.isInteger(message.frozenBalance.high)))
                    return "frozenBalance: integer|Long expected";
            if (message.frozenDuration != null && message.hasOwnProperty("frozenDuration"))
                if (!$util.isInteger(message.frozenDuration) && !(message.frozenDuration && $util.isInteger(message.frozenDuration.low) && $util.isInteger(message.frozenDuration.high)))
                    return "frozenDuration: integer|Long expected";
            if (message.resource != null && message.hasOwnProperty("resource"))
                switch (message.resource) {
                default:
                    return "resource: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                if (!(message.receiverAddress && typeof message.receiverAddress.length === "number" || $util.isString(message.receiverAddress)))
                    return "receiverAddress: buffer expected";
            return null;
        };

        /**
         * Creates a FreezeBalanceContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.FreezeBalanceContract} FreezeBalanceContract
         */
        FreezeBalanceContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.FreezeBalanceContract)
                return object;
            var message = new $root.protocol.FreezeBalanceContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.frozenBalance != null)
                if ($util.Long)
                    (message.frozenBalance = $util.Long.fromValue(object.frozenBalance)).unsigned = false;
                else if (typeof object.frozenBalance === "string")
                    message.frozenBalance = parseInt(object.frozenBalance, 10);
                else if (typeof object.frozenBalance === "number")
                    message.frozenBalance = object.frozenBalance;
                else if (typeof object.frozenBalance === "object")
                    message.frozenBalance = new $util.LongBits(object.frozenBalance.low >>> 0, object.frozenBalance.high >>> 0).toNumber();
            if (object.frozenDuration != null)
                if ($util.Long)
                    (message.frozenDuration = $util.Long.fromValue(object.frozenDuration)).unsigned = false;
                else if (typeof object.frozenDuration === "string")
                    message.frozenDuration = parseInt(object.frozenDuration, 10);
                else if (typeof object.frozenDuration === "number")
                    message.frozenDuration = object.frozenDuration;
                else if (typeof object.frozenDuration === "object")
                    message.frozenDuration = new $util.LongBits(object.frozenDuration.low >>> 0, object.frozenDuration.high >>> 0).toNumber();
            switch (object.resource) {
            case "BANDWIDTH":
            case 0:
                message.resource = 0;
                break;
            case "ENERGY":
            case 1:
                message.resource = 1;
                break;
            }
            if (object.receiverAddress != null)
                if (typeof object.receiverAddress === "string")
                    $util.base64.decode(object.receiverAddress, message.receiverAddress = $util.newBuffer($util.base64.length(object.receiverAddress)), 0);
                else if (object.receiverAddress.length)
                    message.receiverAddress = object.receiverAddress;
            return message;
        };

        /**
         * Creates a plain object from a FreezeBalanceContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {protocol.FreezeBalanceContract} message FreezeBalanceContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreezeBalanceContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.frozenBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozenDuration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.frozenDuration = options.longs === String ? "0" : 0;
                object.resource = options.enums === String ? "BANDWIDTH" : 0;
                if (options.bytes === String)
                    object.receiverAddress = "";
                else {
                    object.receiverAddress = [];
                    if (options.bytes !== Array)
                        object.receiverAddress = $util.newBuffer(object.receiverAddress);
                }
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.frozenBalance != null && message.hasOwnProperty("frozenBalance"))
                if (typeof message.frozenBalance === "number")
                    object.frozenBalance = options.longs === String ? String(message.frozenBalance) : message.frozenBalance;
                else
                    object.frozenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.frozenBalance) : options.longs === Number ? new $util.LongBits(message.frozenBalance.low >>> 0, message.frozenBalance.high >>> 0).toNumber() : message.frozenBalance;
            if (message.frozenDuration != null && message.hasOwnProperty("frozenDuration"))
                if (typeof message.frozenDuration === "number")
                    object.frozenDuration = options.longs === String ? String(message.frozenDuration) : message.frozenDuration;
                else
                    object.frozenDuration = options.longs === String ? $util.Long.prototype.toString.call(message.frozenDuration) : options.longs === Number ? new $util.LongBits(message.frozenDuration.low >>> 0, message.frozenDuration.high >>> 0).toNumber() : message.frozenDuration;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = options.enums === String ? $root.protocol.ResourceCode[message.resource] : message.resource;
            if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                object.receiverAddress = options.bytes === String ? $util.base64.encode(message.receiverAddress, 0, message.receiverAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.receiverAddress) : message.receiverAddress;
            return object;
        };

        /**
         * Converts this FreezeBalanceContract to JSON.
         * @function toJSON
         * @memberof protocol.FreezeBalanceContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreezeBalanceContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreezeBalanceContract;
    })();

    protocol.UnfreezeBalanceContract = (function() {

        /**
         * Properties of an UnfreezeBalanceContract.
         * @memberof protocol
         * @interface IUnfreezeBalanceContract
         * @property {Uint8Array|null} [ownerAddress] UnfreezeBalanceContract ownerAddress
         * @property {protocol.ResourceCode|null} [resource] UnfreezeBalanceContract resource
         * @property {Uint8Array|null} [receiverAddress] UnfreezeBalanceContract receiverAddress
         */

        /**
         * Constructs a new UnfreezeBalanceContract.
         * @memberof protocol
         * @classdesc Represents an UnfreezeBalanceContract.
         * @implements IUnfreezeBalanceContract
         * @constructor
         * @param {protocol.IUnfreezeBalanceContract=} [properties] Properties to set
         */
        function UnfreezeBalanceContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnfreezeBalanceContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.UnfreezeBalanceContract
         * @instance
         */
        UnfreezeBalanceContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * UnfreezeBalanceContract resource.
         * @member {protocol.ResourceCode} resource
         * @memberof protocol.UnfreezeBalanceContract
         * @instance
         */
        UnfreezeBalanceContract.prototype.resource = 0;

        /**
         * UnfreezeBalanceContract receiverAddress.
         * @member {Uint8Array} receiverAddress
         * @memberof protocol.UnfreezeBalanceContract
         * @instance
         */
        UnfreezeBalanceContract.prototype.receiverAddress = $util.newBuffer([]);

        /**
         * Creates a new UnfreezeBalanceContract instance using the specified properties.
         * @function create
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {protocol.IUnfreezeBalanceContract=} [properties] Properties to set
         * @returns {protocol.UnfreezeBalanceContract} UnfreezeBalanceContract instance
         */
        UnfreezeBalanceContract.create = function create(properties) {
            return new UnfreezeBalanceContract(properties);
        };

        /**
         * Encodes the specified UnfreezeBalanceContract message. Does not implicitly {@link protocol.UnfreezeBalanceContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {protocol.IUnfreezeBalanceContract} message UnfreezeBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnfreezeBalanceContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.resource);
            if (message.receiverAddress != null && Object.hasOwnProperty.call(message, "receiverAddress"))
                writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.receiverAddress);
            return writer;
        };

        /**
         * Encodes the specified UnfreezeBalanceContract message, length delimited. Does not implicitly {@link protocol.UnfreezeBalanceContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {protocol.IUnfreezeBalanceContract} message UnfreezeBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnfreezeBalanceContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnfreezeBalanceContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.UnfreezeBalanceContract} UnfreezeBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnfreezeBalanceContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UnfreezeBalanceContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 10:
                    message.resource = reader.int32();
                    break;
                case 15:
                    message.receiverAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnfreezeBalanceContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.UnfreezeBalanceContract} UnfreezeBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnfreezeBalanceContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnfreezeBalanceContract message.
         * @function verify
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnfreezeBalanceContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.resource != null && message.hasOwnProperty("resource"))
                switch (message.resource) {
                default:
                    return "resource: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                if (!(message.receiverAddress && typeof message.receiverAddress.length === "number" || $util.isString(message.receiverAddress)))
                    return "receiverAddress: buffer expected";
            return null;
        };

        /**
         * Creates an UnfreezeBalanceContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.UnfreezeBalanceContract} UnfreezeBalanceContract
         */
        UnfreezeBalanceContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UnfreezeBalanceContract)
                return object;
            var message = new $root.protocol.UnfreezeBalanceContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            switch (object.resource) {
            case "BANDWIDTH":
            case 0:
                message.resource = 0;
                break;
            case "ENERGY":
            case 1:
                message.resource = 1;
                break;
            }
            if (object.receiverAddress != null)
                if (typeof object.receiverAddress === "string")
                    $util.base64.decode(object.receiverAddress, message.receiverAddress = $util.newBuffer($util.base64.length(object.receiverAddress)), 0);
                else if (object.receiverAddress.length)
                    message.receiverAddress = object.receiverAddress;
            return message;
        };

        /**
         * Creates a plain object from an UnfreezeBalanceContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {protocol.UnfreezeBalanceContract} message UnfreezeBalanceContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnfreezeBalanceContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                object.resource = options.enums === String ? "BANDWIDTH" : 0;
                if (options.bytes === String)
                    object.receiverAddress = "";
                else {
                    object.receiverAddress = [];
                    if (options.bytes !== Array)
                        object.receiverAddress = $util.newBuffer(object.receiverAddress);
                }
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = options.enums === String ? $root.protocol.ResourceCode[message.resource] : message.resource;
            if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                object.receiverAddress = options.bytes === String ? $util.base64.encode(message.receiverAddress, 0, message.receiverAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.receiverAddress) : message.receiverAddress;
            return object;
        };

        /**
         * Converts this UnfreezeBalanceContract to JSON.
         * @function toJSON
         * @memberof protocol.UnfreezeBalanceContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnfreezeBalanceContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnfreezeBalanceContract;
    })();

    protocol.UnfreezeAssetContract = (function() {

        /**
         * Properties of an UnfreezeAssetContract.
         * @memberof protocol
         * @interface IUnfreezeAssetContract
         * @property {Uint8Array|null} [ownerAddress] UnfreezeAssetContract ownerAddress
         */

        /**
         * Constructs a new UnfreezeAssetContract.
         * @memberof protocol
         * @classdesc Represents an UnfreezeAssetContract.
         * @implements IUnfreezeAssetContract
         * @constructor
         * @param {protocol.IUnfreezeAssetContract=} [properties] Properties to set
         */
        function UnfreezeAssetContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnfreezeAssetContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.UnfreezeAssetContract
         * @instance
         */
        UnfreezeAssetContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * Creates a new UnfreezeAssetContract instance using the specified properties.
         * @function create
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {protocol.IUnfreezeAssetContract=} [properties] Properties to set
         * @returns {protocol.UnfreezeAssetContract} UnfreezeAssetContract instance
         */
        UnfreezeAssetContract.create = function create(properties) {
            return new UnfreezeAssetContract(properties);
        };

        /**
         * Encodes the specified UnfreezeAssetContract message. Does not implicitly {@link protocol.UnfreezeAssetContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {protocol.IUnfreezeAssetContract} message UnfreezeAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnfreezeAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            return writer;
        };

        /**
         * Encodes the specified UnfreezeAssetContract message, length delimited. Does not implicitly {@link protocol.UnfreezeAssetContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {protocol.IUnfreezeAssetContract} message UnfreezeAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnfreezeAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnfreezeAssetContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.UnfreezeAssetContract} UnfreezeAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnfreezeAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UnfreezeAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnfreezeAssetContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.UnfreezeAssetContract} UnfreezeAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnfreezeAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnfreezeAssetContract message.
         * @function verify
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnfreezeAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            return null;
        };

        /**
         * Creates an UnfreezeAssetContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.UnfreezeAssetContract} UnfreezeAssetContract
         */
        UnfreezeAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UnfreezeAssetContract)
                return object;
            var message = new $root.protocol.UnfreezeAssetContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            return message;
        };

        /**
         * Creates a plain object from an UnfreezeAssetContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {protocol.UnfreezeAssetContract} message UnfreezeAssetContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnfreezeAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            return object;
        };

        /**
         * Converts this UnfreezeAssetContract to JSON.
         * @function toJSON
         * @memberof protocol.UnfreezeAssetContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnfreezeAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnfreezeAssetContract;
    })();

    protocol.WithdrawBalanceContract = (function() {

        /**
         * Properties of a WithdrawBalanceContract.
         * @memberof protocol
         * @interface IWithdrawBalanceContract
         * @property {Uint8Array|null} [ownerAddress] WithdrawBalanceContract ownerAddress
         */

        /**
         * Constructs a new WithdrawBalanceContract.
         * @memberof protocol
         * @classdesc Represents a WithdrawBalanceContract.
         * @implements IWithdrawBalanceContract
         * @constructor
         * @param {protocol.IWithdrawBalanceContract=} [properties] Properties to set
         */
        function WithdrawBalanceContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WithdrawBalanceContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.WithdrawBalanceContract
         * @instance
         */
        WithdrawBalanceContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * Creates a new WithdrawBalanceContract instance using the specified properties.
         * @function create
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {protocol.IWithdrawBalanceContract=} [properties] Properties to set
         * @returns {protocol.WithdrawBalanceContract} WithdrawBalanceContract instance
         */
        WithdrawBalanceContract.create = function create(properties) {
            return new WithdrawBalanceContract(properties);
        };

        /**
         * Encodes the specified WithdrawBalanceContract message. Does not implicitly {@link protocol.WithdrawBalanceContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {protocol.IWithdrawBalanceContract} message WithdrawBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WithdrawBalanceContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            return writer;
        };

        /**
         * Encodes the specified WithdrawBalanceContract message, length delimited. Does not implicitly {@link protocol.WithdrawBalanceContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {protocol.IWithdrawBalanceContract} message WithdrawBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WithdrawBalanceContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WithdrawBalanceContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.WithdrawBalanceContract} WithdrawBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WithdrawBalanceContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.WithdrawBalanceContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WithdrawBalanceContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.WithdrawBalanceContract} WithdrawBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WithdrawBalanceContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WithdrawBalanceContract message.
         * @function verify
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WithdrawBalanceContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            return null;
        };

        /**
         * Creates a WithdrawBalanceContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.WithdrawBalanceContract} WithdrawBalanceContract
         */
        WithdrawBalanceContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.WithdrawBalanceContract)
                return object;
            var message = new $root.protocol.WithdrawBalanceContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            return message;
        };

        /**
         * Creates a plain object from a WithdrawBalanceContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {protocol.WithdrawBalanceContract} message WithdrawBalanceContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WithdrawBalanceContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            return object;
        };

        /**
         * Converts this WithdrawBalanceContract to JSON.
         * @function toJSON
         * @memberof protocol.WithdrawBalanceContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WithdrawBalanceContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WithdrawBalanceContract;
    })();

    protocol.UpdateAssetContract = (function() {

        /**
         * Properties of an UpdateAssetContract.
         * @memberof protocol
         * @interface IUpdateAssetContract
         * @property {Uint8Array|null} [ownerAddress] UpdateAssetContract ownerAddress
         * @property {Uint8Array|null} [description] UpdateAssetContract description
         * @property {Uint8Array|null} [url] UpdateAssetContract url
         * @property {number|Long|null} [newLimit] UpdateAssetContract newLimit
         * @property {number|Long|null} [newPublicLimit] UpdateAssetContract newPublicLimit
         */

        /**
         * Constructs a new UpdateAssetContract.
         * @memberof protocol
         * @classdesc Represents an UpdateAssetContract.
         * @implements IUpdateAssetContract
         * @constructor
         * @param {protocol.IUpdateAssetContract=} [properties] Properties to set
         */
        function UpdateAssetContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateAssetContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.UpdateAssetContract
         * @instance
         */
        UpdateAssetContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * UpdateAssetContract description.
         * @member {Uint8Array} description
         * @memberof protocol.UpdateAssetContract
         * @instance
         */
        UpdateAssetContract.prototype.description = $util.newBuffer([]);

        /**
         * UpdateAssetContract url.
         * @member {Uint8Array} url
         * @memberof protocol.UpdateAssetContract
         * @instance
         */
        UpdateAssetContract.prototype.url = $util.newBuffer([]);

        /**
         * UpdateAssetContract newLimit.
         * @member {number|Long} newLimit
         * @memberof protocol.UpdateAssetContract
         * @instance
         */
        UpdateAssetContract.prototype.newLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UpdateAssetContract newPublicLimit.
         * @member {number|Long} newPublicLimit
         * @memberof protocol.UpdateAssetContract
         * @instance
         */
        UpdateAssetContract.prototype.newPublicLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpdateAssetContract instance using the specified properties.
         * @function create
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {protocol.IUpdateAssetContract=} [properties] Properties to set
         * @returns {protocol.UpdateAssetContract} UpdateAssetContract instance
         */
        UpdateAssetContract.create = function create(properties) {
            return new UpdateAssetContract(properties);
        };

        /**
         * Encodes the specified UpdateAssetContract message. Does not implicitly {@link protocol.UpdateAssetContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {protocol.IUpdateAssetContract} message UpdateAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.description);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.url);
            if (message.newLimit != null && Object.hasOwnProperty.call(message, "newLimit"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.newLimit);
            if (message.newPublicLimit != null && Object.hasOwnProperty.call(message, "newPublicLimit"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.newPublicLimit);
            return writer;
        };

        /**
         * Encodes the specified UpdateAssetContract message, length delimited. Does not implicitly {@link protocol.UpdateAssetContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {protocol.IUpdateAssetContract} message UpdateAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateAssetContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.UpdateAssetContract} UpdateAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UpdateAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.description = reader.bytes();
                    break;
                case 3:
                    message.url = reader.bytes();
                    break;
                case 4:
                    message.newLimit = reader.int64();
                    break;
                case 5:
                    message.newPublicLimit = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateAssetContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.UpdateAssetContract} UpdateAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateAssetContract message.
         * @function verify
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!(message.description && typeof message.description.length === "number" || $util.isString(message.description)))
                    return "description: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!(message.url && typeof message.url.length === "number" || $util.isString(message.url)))
                    return "url: buffer expected";
            if (message.newLimit != null && message.hasOwnProperty("newLimit"))
                if (!$util.isInteger(message.newLimit) && !(message.newLimit && $util.isInteger(message.newLimit.low) && $util.isInteger(message.newLimit.high)))
                    return "newLimit: integer|Long expected";
            if (message.newPublicLimit != null && message.hasOwnProperty("newPublicLimit"))
                if (!$util.isInteger(message.newPublicLimit) && !(message.newPublicLimit && $util.isInteger(message.newPublicLimit.low) && $util.isInteger(message.newPublicLimit.high)))
                    return "newPublicLimit: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdateAssetContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.UpdateAssetContract} UpdateAssetContract
         */
        UpdateAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UpdateAssetContract)
                return object;
            var message = new $root.protocol.UpdateAssetContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.description != null)
                if (typeof object.description === "string")
                    $util.base64.decode(object.description, message.description = $util.newBuffer($util.base64.length(object.description)), 0);
                else if (object.description.length)
                    message.description = object.description;
            if (object.url != null)
                if (typeof object.url === "string")
                    $util.base64.decode(object.url, message.url = $util.newBuffer($util.base64.length(object.url)), 0);
                else if (object.url.length)
                    message.url = object.url;
            if (object.newLimit != null)
                if ($util.Long)
                    (message.newLimit = $util.Long.fromValue(object.newLimit)).unsigned = false;
                else if (typeof object.newLimit === "string")
                    message.newLimit = parseInt(object.newLimit, 10);
                else if (typeof object.newLimit === "number")
                    message.newLimit = object.newLimit;
                else if (typeof object.newLimit === "object")
                    message.newLimit = new $util.LongBits(object.newLimit.low >>> 0, object.newLimit.high >>> 0).toNumber();
            if (object.newPublicLimit != null)
                if ($util.Long)
                    (message.newPublicLimit = $util.Long.fromValue(object.newPublicLimit)).unsigned = false;
                else if (typeof object.newPublicLimit === "string")
                    message.newPublicLimit = parseInt(object.newPublicLimit, 10);
                else if (typeof object.newPublicLimit === "number")
                    message.newPublicLimit = object.newPublicLimit;
                else if (typeof object.newPublicLimit === "object")
                    message.newPublicLimit = new $util.LongBits(object.newPublicLimit.low >>> 0, object.newPublicLimit.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpdateAssetContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {protocol.UpdateAssetContract} message UpdateAssetContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.description = "";
                else {
                    object.description = [];
                    if (options.bytes !== Array)
                        object.description = $util.newBuffer(object.description);
                }
                if (options.bytes === String)
                    object.url = "";
                else {
                    object.url = [];
                    if (options.bytes !== Array)
                        object.url = $util.newBuffer(object.url);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.newLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.newLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.newPublicLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.newPublicLimit = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = options.bytes === String ? $util.base64.encode(message.description, 0, message.description.length) : options.bytes === Array ? Array.prototype.slice.call(message.description) : message.description;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = options.bytes === String ? $util.base64.encode(message.url, 0, message.url.length) : options.bytes === Array ? Array.prototype.slice.call(message.url) : message.url;
            if (message.newLimit != null && message.hasOwnProperty("newLimit"))
                if (typeof message.newLimit === "number")
                    object.newLimit = options.longs === String ? String(message.newLimit) : message.newLimit;
                else
                    object.newLimit = options.longs === String ? $util.Long.prototype.toString.call(message.newLimit) : options.longs === Number ? new $util.LongBits(message.newLimit.low >>> 0, message.newLimit.high >>> 0).toNumber() : message.newLimit;
            if (message.newPublicLimit != null && message.hasOwnProperty("newPublicLimit"))
                if (typeof message.newPublicLimit === "number")
                    object.newPublicLimit = options.longs === String ? String(message.newPublicLimit) : message.newPublicLimit;
                else
                    object.newPublicLimit = options.longs === String ? $util.Long.prototype.toString.call(message.newPublicLimit) : options.longs === Number ? new $util.LongBits(message.newPublicLimit.low >>> 0, message.newPublicLimit.high >>> 0).toNumber() : message.newPublicLimit;
            return object;
        };

        /**
         * Converts this UpdateAssetContract to JSON.
         * @function toJSON
         * @memberof protocol.UpdateAssetContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateAssetContract;
    })();

    protocol.ProposalCreateContract = (function() {

        /**
         * Properties of a ProposalCreateContract.
         * @memberof protocol
         * @interface IProposalCreateContract
         * @property {Uint8Array|null} [ownerAddress] ProposalCreateContract ownerAddress
         * @property {Object.<string,number|Long>|null} [parameters] ProposalCreateContract parameters
         */

        /**
         * Constructs a new ProposalCreateContract.
         * @memberof protocol
         * @classdesc Represents a ProposalCreateContract.
         * @implements IProposalCreateContract
         * @constructor
         * @param {protocol.IProposalCreateContract=} [properties] Properties to set
         */
        function ProposalCreateContract(properties) {
            this.parameters = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProposalCreateContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.ProposalCreateContract
         * @instance
         */
        ProposalCreateContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * ProposalCreateContract parameters.
         * @member {Object.<string,number|Long>} parameters
         * @memberof protocol.ProposalCreateContract
         * @instance
         */
        ProposalCreateContract.prototype.parameters = $util.emptyObject;

        /**
         * Creates a new ProposalCreateContract instance using the specified properties.
         * @function create
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {protocol.IProposalCreateContract=} [properties] Properties to set
         * @returns {protocol.ProposalCreateContract} ProposalCreateContract instance
         */
        ProposalCreateContract.create = function create(properties) {
            return new ProposalCreateContract(properties);
        };

        /**
         * Encodes the specified ProposalCreateContract message. Does not implicitly {@link protocol.ProposalCreateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {protocol.IProposalCreateContract} message ProposalCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.parameters != null && Object.hasOwnProperty.call(message, "parameters"))
                for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 0 =*/8).int64(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.parameters[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProposalCreateContract message, length delimited. Does not implicitly {@link protocol.ProposalCreateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {protocol.IProposalCreateContract} message ProposalCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProposalCreateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ProposalCreateContract} ProposalCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ProposalCreateContract(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    reader.skip().pos++;
                    if (message.parameters === $util.emptyObject)
                        message.parameters = {};
                    key = reader.int64();
                    reader.pos++;
                    message.parameters[typeof key === "object" ? $util.longToHash(key) : key] = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProposalCreateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ProposalCreateContract} ProposalCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProposalCreateContract message.
         * @function verify
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProposalCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.parameters != null && message.hasOwnProperty("parameters")) {
                if (!$util.isObject(message.parameters))
                    return "parameters: object expected";
                var key = Object.keys(message.parameters);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "parameters: integer|Long key{k:int64} expected";
                    if (!$util.isInteger(message.parameters[key[i]]) && !(message.parameters[key[i]] && $util.isInteger(message.parameters[key[i]].low) && $util.isInteger(message.parameters[key[i]].high)))
                        return "parameters: integer|Long{k:int64} expected";
                }
            }
            return null;
        };

        /**
         * Creates a ProposalCreateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ProposalCreateContract} ProposalCreateContract
         */
        ProposalCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ProposalCreateContract)
                return object;
            var message = new $root.protocol.ProposalCreateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.parameters) {
                if (typeof object.parameters !== "object")
                    throw TypeError(".protocol.ProposalCreateContract.parameters: object expected");
                message.parameters = {};
                for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.parameters[keys[i]] = $util.Long.fromValue(object.parameters[keys[i]])).unsigned = false;
                    else if (typeof object.parameters[keys[i]] === "string")
                        message.parameters[keys[i]] = parseInt(object.parameters[keys[i]], 10);
                    else if (typeof object.parameters[keys[i]] === "number")
                        message.parameters[keys[i]] = object.parameters[keys[i]];
                    else if (typeof object.parameters[keys[i]] === "object")
                        message.parameters[keys[i]] = new $util.LongBits(object.parameters[keys[i]].low >>> 0, object.parameters[keys[i]].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a ProposalCreateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {protocol.ProposalCreateContract} message ProposalCreateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProposalCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.parameters = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            var keys2;
            if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                object.parameters = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.parameters[keys2[j]] === "number")
                        object.parameters[keys2[j]] = options.longs === String ? String(message.parameters[keys2[j]]) : message.parameters[keys2[j]];
                    else
                        object.parameters[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.parameters[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.parameters[keys2[j]].low >>> 0, message.parameters[keys2[j]].high >>> 0).toNumber() : message.parameters[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this ProposalCreateContract to JSON.
         * @function toJSON
         * @memberof protocol.ProposalCreateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProposalCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProposalCreateContract;
    })();

    protocol.ProposalApproveContract = (function() {

        /**
         * Properties of a ProposalApproveContract.
         * @memberof protocol
         * @interface IProposalApproveContract
         * @property {Uint8Array|null} [ownerAddress] ProposalApproveContract ownerAddress
         * @property {number|Long|null} [proposalId] ProposalApproveContract proposalId
         * @property {boolean|null} [isAddApproval] ProposalApproveContract isAddApproval
         */

        /**
         * Constructs a new ProposalApproveContract.
         * @memberof protocol
         * @classdesc Represents a ProposalApproveContract.
         * @implements IProposalApproveContract
         * @constructor
         * @param {protocol.IProposalApproveContract=} [properties] Properties to set
         */
        function ProposalApproveContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProposalApproveContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.ProposalApproveContract
         * @instance
         */
        ProposalApproveContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * ProposalApproveContract proposalId.
         * @member {number|Long} proposalId
         * @memberof protocol.ProposalApproveContract
         * @instance
         */
        ProposalApproveContract.prototype.proposalId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ProposalApproveContract isAddApproval.
         * @member {boolean} isAddApproval
         * @memberof protocol.ProposalApproveContract
         * @instance
         */
        ProposalApproveContract.prototype.isAddApproval = false;

        /**
         * Creates a new ProposalApproveContract instance using the specified properties.
         * @function create
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {protocol.IProposalApproveContract=} [properties] Properties to set
         * @returns {protocol.ProposalApproveContract} ProposalApproveContract instance
         */
        ProposalApproveContract.create = function create(properties) {
            return new ProposalApproveContract(properties);
        };

        /**
         * Encodes the specified ProposalApproveContract message. Does not implicitly {@link protocol.ProposalApproveContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {protocol.IProposalApproveContract} message ProposalApproveContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalApproveContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.proposalId != null && Object.hasOwnProperty.call(message, "proposalId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.proposalId);
            if (message.isAddApproval != null && Object.hasOwnProperty.call(message, "isAddApproval"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isAddApproval);
            return writer;
        };

        /**
         * Encodes the specified ProposalApproveContract message, length delimited. Does not implicitly {@link protocol.ProposalApproveContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {protocol.IProposalApproveContract} message ProposalApproveContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalApproveContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProposalApproveContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ProposalApproveContract} ProposalApproveContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalApproveContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ProposalApproveContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.proposalId = reader.int64();
                    break;
                case 3:
                    message.isAddApproval = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProposalApproveContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ProposalApproveContract} ProposalApproveContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalApproveContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProposalApproveContract message.
         * @function verify
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProposalApproveContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!$util.isInteger(message.proposalId) && !(message.proposalId && $util.isInteger(message.proposalId.low) && $util.isInteger(message.proposalId.high)))
                    return "proposalId: integer|Long expected";
            if (message.isAddApproval != null && message.hasOwnProperty("isAddApproval"))
                if (typeof message.isAddApproval !== "boolean")
                    return "isAddApproval: boolean expected";
            return null;
        };

        /**
         * Creates a ProposalApproveContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ProposalApproveContract} ProposalApproveContract
         */
        ProposalApproveContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ProposalApproveContract)
                return object;
            var message = new $root.protocol.ProposalApproveContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.proposalId != null)
                if ($util.Long)
                    (message.proposalId = $util.Long.fromValue(object.proposalId)).unsigned = false;
                else if (typeof object.proposalId === "string")
                    message.proposalId = parseInt(object.proposalId, 10);
                else if (typeof object.proposalId === "number")
                    message.proposalId = object.proposalId;
                else if (typeof object.proposalId === "object")
                    message.proposalId = new $util.LongBits(object.proposalId.low >>> 0, object.proposalId.high >>> 0).toNumber();
            if (object.isAddApproval != null)
                message.isAddApproval = Boolean(object.isAddApproval);
            return message;
        };

        /**
         * Creates a plain object from a ProposalApproveContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {protocol.ProposalApproveContract} message ProposalApproveContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProposalApproveContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.proposalId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.proposalId = options.longs === String ? "0" : 0;
                object.isAddApproval = false;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (typeof message.proposalId === "number")
                    object.proposalId = options.longs === String ? String(message.proposalId) : message.proposalId;
                else
                    object.proposalId = options.longs === String ? $util.Long.prototype.toString.call(message.proposalId) : options.longs === Number ? new $util.LongBits(message.proposalId.low >>> 0, message.proposalId.high >>> 0).toNumber() : message.proposalId;
            if (message.isAddApproval != null && message.hasOwnProperty("isAddApproval"))
                object.isAddApproval = message.isAddApproval;
            return object;
        };

        /**
         * Converts this ProposalApproveContract to JSON.
         * @function toJSON
         * @memberof protocol.ProposalApproveContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProposalApproveContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProposalApproveContract;
    })();

    protocol.ProposalDeleteContract = (function() {

        /**
         * Properties of a ProposalDeleteContract.
         * @memberof protocol
         * @interface IProposalDeleteContract
         * @property {Uint8Array|null} [ownerAddress] ProposalDeleteContract ownerAddress
         * @property {number|Long|null} [proposalId] ProposalDeleteContract proposalId
         */

        /**
         * Constructs a new ProposalDeleteContract.
         * @memberof protocol
         * @classdesc Represents a ProposalDeleteContract.
         * @implements IProposalDeleteContract
         * @constructor
         * @param {protocol.IProposalDeleteContract=} [properties] Properties to set
         */
        function ProposalDeleteContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProposalDeleteContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.ProposalDeleteContract
         * @instance
         */
        ProposalDeleteContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * ProposalDeleteContract proposalId.
         * @member {number|Long} proposalId
         * @memberof protocol.ProposalDeleteContract
         * @instance
         */
        ProposalDeleteContract.prototype.proposalId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ProposalDeleteContract instance using the specified properties.
         * @function create
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {protocol.IProposalDeleteContract=} [properties] Properties to set
         * @returns {protocol.ProposalDeleteContract} ProposalDeleteContract instance
         */
        ProposalDeleteContract.create = function create(properties) {
            return new ProposalDeleteContract(properties);
        };

        /**
         * Encodes the specified ProposalDeleteContract message. Does not implicitly {@link protocol.ProposalDeleteContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {protocol.IProposalDeleteContract} message ProposalDeleteContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalDeleteContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.proposalId != null && Object.hasOwnProperty.call(message, "proposalId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.proposalId);
            return writer;
        };

        /**
         * Encodes the specified ProposalDeleteContract message, length delimited. Does not implicitly {@link protocol.ProposalDeleteContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {protocol.IProposalDeleteContract} message ProposalDeleteContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalDeleteContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProposalDeleteContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ProposalDeleteContract} ProposalDeleteContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalDeleteContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ProposalDeleteContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.proposalId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProposalDeleteContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ProposalDeleteContract} ProposalDeleteContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalDeleteContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProposalDeleteContract message.
         * @function verify
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProposalDeleteContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!$util.isInteger(message.proposalId) && !(message.proposalId && $util.isInteger(message.proposalId.low) && $util.isInteger(message.proposalId.high)))
                    return "proposalId: integer|Long expected";
            return null;
        };

        /**
         * Creates a ProposalDeleteContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ProposalDeleteContract} ProposalDeleteContract
         */
        ProposalDeleteContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ProposalDeleteContract)
                return object;
            var message = new $root.protocol.ProposalDeleteContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.proposalId != null)
                if ($util.Long)
                    (message.proposalId = $util.Long.fromValue(object.proposalId)).unsigned = false;
                else if (typeof object.proposalId === "string")
                    message.proposalId = parseInt(object.proposalId, 10);
                else if (typeof object.proposalId === "number")
                    message.proposalId = object.proposalId;
                else if (typeof object.proposalId === "object")
                    message.proposalId = new $util.LongBits(object.proposalId.low >>> 0, object.proposalId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ProposalDeleteContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {protocol.ProposalDeleteContract} message ProposalDeleteContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProposalDeleteContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.proposalId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.proposalId = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (typeof message.proposalId === "number")
                    object.proposalId = options.longs === String ? String(message.proposalId) : message.proposalId;
                else
                    object.proposalId = options.longs === String ? $util.Long.prototype.toString.call(message.proposalId) : options.longs === Number ? new $util.LongBits(message.proposalId.low >>> 0, message.proposalId.high >>> 0).toNumber() : message.proposalId;
            return object;
        };

        /**
         * Converts this ProposalDeleteContract to JSON.
         * @function toJSON
         * @memberof protocol.ProposalDeleteContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProposalDeleteContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProposalDeleteContract;
    })();

    protocol.CreateSmartContract = (function() {

        /**
         * Properties of a CreateSmartContract.
         * @memberof protocol
         * @interface ICreateSmartContract
         * @property {Uint8Array|null} [ownerAddress] CreateSmartContract ownerAddress
         * @property {protocol.ISmartContract|null} [newContract] CreateSmartContract newContract
         * @property {number|Long|null} [callTokenValue] CreateSmartContract callTokenValue
         * @property {number|Long|null} [tokenId] CreateSmartContract tokenId
         */

        /**
         * Constructs a new CreateSmartContract.
         * @memberof protocol
         * @classdesc Represents a CreateSmartContract.
         * @implements ICreateSmartContract
         * @constructor
         * @param {protocol.ICreateSmartContract=} [properties] Properties to set
         */
        function CreateSmartContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateSmartContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.CreateSmartContract
         * @instance
         */
        CreateSmartContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * CreateSmartContract newContract.
         * @member {protocol.ISmartContract|null|undefined} newContract
         * @memberof protocol.CreateSmartContract
         * @instance
         */
        CreateSmartContract.prototype.newContract = null;

        /**
         * CreateSmartContract callTokenValue.
         * @member {number|Long} callTokenValue
         * @memberof protocol.CreateSmartContract
         * @instance
         */
        CreateSmartContract.prototype.callTokenValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreateSmartContract tokenId.
         * @member {number|Long} tokenId
         * @memberof protocol.CreateSmartContract
         * @instance
         */
        CreateSmartContract.prototype.tokenId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CreateSmartContract instance using the specified properties.
         * @function create
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {protocol.ICreateSmartContract=} [properties] Properties to set
         * @returns {protocol.CreateSmartContract} CreateSmartContract instance
         */
        CreateSmartContract.create = function create(properties) {
            return new CreateSmartContract(properties);
        };

        /**
         * Encodes the specified CreateSmartContract message. Does not implicitly {@link protocol.CreateSmartContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {protocol.ICreateSmartContract} message CreateSmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateSmartContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.newContract != null && Object.hasOwnProperty.call(message, "newContract"))
                $root.protocol.SmartContract.encode(message.newContract, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.callTokenValue != null && Object.hasOwnProperty.call(message, "callTokenValue"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.callTokenValue);
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.tokenId);
            return writer;
        };

        /**
         * Encodes the specified CreateSmartContract message, length delimited. Does not implicitly {@link protocol.CreateSmartContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {protocol.ICreateSmartContract} message CreateSmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateSmartContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateSmartContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.CreateSmartContract} CreateSmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateSmartContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.CreateSmartContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.newContract = $root.protocol.SmartContract.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.callTokenValue = reader.int64();
                    break;
                case 4:
                    message.tokenId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateSmartContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.CreateSmartContract} CreateSmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateSmartContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateSmartContract message.
         * @function verify
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateSmartContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.newContract != null && message.hasOwnProperty("newContract")) {
                var error = $root.protocol.SmartContract.verify(message.newContract);
                if (error)
                    return "newContract." + error;
            }
            if (message.callTokenValue != null && message.hasOwnProperty("callTokenValue"))
                if (!$util.isInteger(message.callTokenValue) && !(message.callTokenValue && $util.isInteger(message.callTokenValue.low) && $util.isInteger(message.callTokenValue.high)))
                    return "callTokenValue: integer|Long expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (!$util.isInteger(message.tokenId) && !(message.tokenId && $util.isInteger(message.tokenId.low) && $util.isInteger(message.tokenId.high)))
                    return "tokenId: integer|Long expected";
            return null;
        };

        /**
         * Creates a CreateSmartContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.CreateSmartContract} CreateSmartContract
         */
        CreateSmartContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.CreateSmartContract)
                return object;
            var message = new $root.protocol.CreateSmartContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.newContract != null) {
                if (typeof object.newContract !== "object")
                    throw TypeError(".protocol.CreateSmartContract.newContract: object expected");
                message.newContract = $root.protocol.SmartContract.fromObject(object.newContract);
            }
            if (object.callTokenValue != null)
                if ($util.Long)
                    (message.callTokenValue = $util.Long.fromValue(object.callTokenValue)).unsigned = false;
                else if (typeof object.callTokenValue === "string")
                    message.callTokenValue = parseInt(object.callTokenValue, 10);
                else if (typeof object.callTokenValue === "number")
                    message.callTokenValue = object.callTokenValue;
                else if (typeof object.callTokenValue === "object")
                    message.callTokenValue = new $util.LongBits(object.callTokenValue.low >>> 0, object.callTokenValue.high >>> 0).toNumber();
            if (object.tokenId != null)
                if ($util.Long)
                    (message.tokenId = $util.Long.fromValue(object.tokenId)).unsigned = false;
                else if (typeof object.tokenId === "string")
                    message.tokenId = parseInt(object.tokenId, 10);
                else if (typeof object.tokenId === "number")
                    message.tokenId = object.tokenId;
                else if (typeof object.tokenId === "object")
                    message.tokenId = new $util.LongBits(object.tokenId.low >>> 0, object.tokenId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CreateSmartContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {protocol.CreateSmartContract} message CreateSmartContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateSmartContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                object.newContract = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.callTokenValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.callTokenValue = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.tokenId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tokenId = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.newContract != null && message.hasOwnProperty("newContract"))
                object.newContract = $root.protocol.SmartContract.toObject(message.newContract, options);
            if (message.callTokenValue != null && message.hasOwnProperty("callTokenValue"))
                if (typeof message.callTokenValue === "number")
                    object.callTokenValue = options.longs === String ? String(message.callTokenValue) : message.callTokenValue;
                else
                    object.callTokenValue = options.longs === String ? $util.Long.prototype.toString.call(message.callTokenValue) : options.longs === Number ? new $util.LongBits(message.callTokenValue.low >>> 0, message.callTokenValue.high >>> 0).toNumber() : message.callTokenValue;
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (typeof message.tokenId === "number")
                    object.tokenId = options.longs === String ? String(message.tokenId) : message.tokenId;
                else
                    object.tokenId = options.longs === String ? $util.Long.prototype.toString.call(message.tokenId) : options.longs === Number ? new $util.LongBits(message.tokenId.low >>> 0, message.tokenId.high >>> 0).toNumber() : message.tokenId;
            return object;
        };

        /**
         * Converts this CreateSmartContract to JSON.
         * @function toJSON
         * @memberof protocol.CreateSmartContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateSmartContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateSmartContract;
    })();

    protocol.TriggerSmartContract = (function() {

        /**
         * Properties of a TriggerSmartContract.
         * @memberof protocol
         * @interface ITriggerSmartContract
         * @property {Uint8Array|null} [ownerAddress] TriggerSmartContract ownerAddress
         * @property {Uint8Array|null} [contractAddress] TriggerSmartContract contractAddress
         * @property {number|Long|null} [callValue] TriggerSmartContract callValue
         * @property {Uint8Array|null} [data] TriggerSmartContract data
         * @property {number|Long|null} [callTokenValue] TriggerSmartContract callTokenValue
         * @property {number|Long|null} [tokenId] TriggerSmartContract tokenId
         */

        /**
         * Constructs a new TriggerSmartContract.
         * @memberof protocol
         * @classdesc Represents a TriggerSmartContract.
         * @implements ITriggerSmartContract
         * @constructor
         * @param {protocol.ITriggerSmartContract=} [properties] Properties to set
         */
        function TriggerSmartContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TriggerSmartContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * TriggerSmartContract contractAddress.
         * @member {Uint8Array} contractAddress
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.contractAddress = $util.newBuffer([]);

        /**
         * TriggerSmartContract callValue.
         * @member {number|Long} callValue
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.callValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TriggerSmartContract data.
         * @member {Uint8Array} data
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.data = $util.newBuffer([]);

        /**
         * TriggerSmartContract callTokenValue.
         * @member {number|Long} callTokenValue
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.callTokenValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TriggerSmartContract tokenId.
         * @member {number|Long} tokenId
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.tokenId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TriggerSmartContract instance using the specified properties.
         * @function create
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {protocol.ITriggerSmartContract=} [properties] Properties to set
         * @returns {protocol.TriggerSmartContract} TriggerSmartContract instance
         */
        TriggerSmartContract.create = function create(properties) {
            return new TriggerSmartContract(properties);
        };

        /**
         * Encodes the specified TriggerSmartContract message. Does not implicitly {@link protocol.TriggerSmartContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {protocol.ITriggerSmartContract} message TriggerSmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TriggerSmartContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contractAddress);
            if (message.callValue != null && Object.hasOwnProperty.call(message, "callValue"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.callValue);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
            if (message.callTokenValue != null && Object.hasOwnProperty.call(message, "callTokenValue"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.callTokenValue);
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.tokenId);
            return writer;
        };

        /**
         * Encodes the specified TriggerSmartContract message, length delimited. Does not implicitly {@link protocol.TriggerSmartContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {protocol.ITriggerSmartContract} message TriggerSmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TriggerSmartContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TriggerSmartContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TriggerSmartContract} TriggerSmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TriggerSmartContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TriggerSmartContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.contractAddress = reader.bytes();
                    break;
                case 3:
                    message.callValue = reader.int64();
                    break;
                case 4:
                    message.data = reader.bytes();
                    break;
                case 5:
                    message.callTokenValue = reader.int64();
                    break;
                case 6:
                    message.tokenId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TriggerSmartContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TriggerSmartContract} TriggerSmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TriggerSmartContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TriggerSmartContract message.
         * @function verify
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TriggerSmartContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            if (message.callValue != null && message.hasOwnProperty("callValue"))
                if (!$util.isInteger(message.callValue) && !(message.callValue && $util.isInteger(message.callValue.low) && $util.isInteger(message.callValue.high)))
                    return "callValue: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.callTokenValue != null && message.hasOwnProperty("callTokenValue"))
                if (!$util.isInteger(message.callTokenValue) && !(message.callTokenValue && $util.isInteger(message.callTokenValue.low) && $util.isInteger(message.callTokenValue.high)))
                    return "callTokenValue: integer|Long expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (!$util.isInteger(message.tokenId) && !(message.tokenId && $util.isInteger(message.tokenId.low) && $util.isInteger(message.tokenId.high)))
                    return "tokenId: integer|Long expected";
            return null;
        };

        /**
         * Creates a TriggerSmartContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TriggerSmartContract} TriggerSmartContract
         */
        TriggerSmartContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TriggerSmartContract)
                return object;
            var message = new $root.protocol.TriggerSmartContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            if (object.callValue != null)
                if ($util.Long)
                    (message.callValue = $util.Long.fromValue(object.callValue)).unsigned = false;
                else if (typeof object.callValue === "string")
                    message.callValue = parseInt(object.callValue, 10);
                else if (typeof object.callValue === "number")
                    message.callValue = object.callValue;
                else if (typeof object.callValue === "object")
                    message.callValue = new $util.LongBits(object.callValue.low >>> 0, object.callValue.high >>> 0).toNumber();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.callTokenValue != null)
                if ($util.Long)
                    (message.callTokenValue = $util.Long.fromValue(object.callTokenValue)).unsigned = false;
                else if (typeof object.callTokenValue === "string")
                    message.callTokenValue = parseInt(object.callTokenValue, 10);
                else if (typeof object.callTokenValue === "number")
                    message.callTokenValue = object.callTokenValue;
                else if (typeof object.callTokenValue === "object")
                    message.callTokenValue = new $util.LongBits(object.callTokenValue.low >>> 0, object.callTokenValue.high >>> 0).toNumber();
            if (object.tokenId != null)
                if ($util.Long)
                    (message.tokenId = $util.Long.fromValue(object.tokenId)).unsigned = false;
                else if (typeof object.tokenId === "string")
                    message.tokenId = parseInt(object.tokenId, 10);
                else if (typeof object.tokenId === "number")
                    message.tokenId = object.tokenId;
                else if (typeof object.tokenId === "object")
                    message.tokenId = new $util.LongBits(object.tokenId.low >>> 0, object.tokenId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TriggerSmartContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {protocol.TriggerSmartContract} message TriggerSmartContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TriggerSmartContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.callValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.callValue = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.callTokenValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.callTokenValue = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.tokenId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tokenId = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            if (message.callValue != null && message.hasOwnProperty("callValue"))
                if (typeof message.callValue === "number")
                    object.callValue = options.longs === String ? String(message.callValue) : message.callValue;
                else
                    object.callValue = options.longs === String ? $util.Long.prototype.toString.call(message.callValue) : options.longs === Number ? new $util.LongBits(message.callValue.low >>> 0, message.callValue.high >>> 0).toNumber() : message.callValue;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.callTokenValue != null && message.hasOwnProperty("callTokenValue"))
                if (typeof message.callTokenValue === "number")
                    object.callTokenValue = options.longs === String ? String(message.callTokenValue) : message.callTokenValue;
                else
                    object.callTokenValue = options.longs === String ? $util.Long.prototype.toString.call(message.callTokenValue) : options.longs === Number ? new $util.LongBits(message.callTokenValue.low >>> 0, message.callTokenValue.high >>> 0).toNumber() : message.callTokenValue;
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (typeof message.tokenId === "number")
                    object.tokenId = options.longs === String ? String(message.tokenId) : message.tokenId;
                else
                    object.tokenId = options.longs === String ? $util.Long.prototype.toString.call(message.tokenId) : options.longs === Number ? new $util.LongBits(message.tokenId.low >>> 0, message.tokenId.high >>> 0).toNumber() : message.tokenId;
            return object;
        };

        /**
         * Converts this TriggerSmartContract to JSON.
         * @function toJSON
         * @memberof protocol.TriggerSmartContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TriggerSmartContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TriggerSmartContract;
    })();

    protocol.BuyStorageContract = (function() {

        /**
         * Properties of a BuyStorageContract.
         * @memberof protocol
         * @interface IBuyStorageContract
         * @property {Uint8Array|null} [ownerAddress] BuyStorageContract ownerAddress
         * @property {number|Long|null} [quant] BuyStorageContract quant
         */

        /**
         * Constructs a new BuyStorageContract.
         * @memberof protocol
         * @classdesc Represents a BuyStorageContract.
         * @implements IBuyStorageContract
         * @constructor
         * @param {protocol.IBuyStorageContract=} [properties] Properties to set
         */
        function BuyStorageContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyStorageContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.BuyStorageContract
         * @instance
         */
        BuyStorageContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * BuyStorageContract quant.
         * @member {number|Long} quant
         * @memberof protocol.BuyStorageContract
         * @instance
         */
        BuyStorageContract.prototype.quant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BuyStorageContract instance using the specified properties.
         * @function create
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {protocol.IBuyStorageContract=} [properties] Properties to set
         * @returns {protocol.BuyStorageContract} BuyStorageContract instance
         */
        BuyStorageContract.create = function create(properties) {
            return new BuyStorageContract(properties);
        };

        /**
         * Encodes the specified BuyStorageContract message. Does not implicitly {@link protocol.BuyStorageContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {protocol.IBuyStorageContract} message BuyStorageContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyStorageContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.quant != null && Object.hasOwnProperty.call(message, "quant"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.quant);
            return writer;
        };

        /**
         * Encodes the specified BuyStorageContract message, length delimited. Does not implicitly {@link protocol.BuyStorageContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {protocol.IBuyStorageContract} message BuyStorageContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyStorageContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyStorageContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.BuyStorageContract} BuyStorageContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyStorageContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BuyStorageContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.quant = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyStorageContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.BuyStorageContract} BuyStorageContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyStorageContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyStorageContract message.
         * @function verify
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyStorageContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            return null;
        };

        /**
         * Creates a BuyStorageContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.BuyStorageContract} BuyStorageContract
         */
        BuyStorageContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BuyStorageContract)
                return object;
            var message = new $root.protocol.BuyStorageContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BuyStorageContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {protocol.BuyStorageContract} message BuyStorageContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuyStorageContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quant = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            return object;
        };

        /**
         * Converts this BuyStorageContract to JSON.
         * @function toJSON
         * @memberof protocol.BuyStorageContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuyStorageContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuyStorageContract;
    })();

    protocol.BuyStorageBytesContract = (function() {

        /**
         * Properties of a BuyStorageBytesContract.
         * @memberof protocol
         * @interface IBuyStorageBytesContract
         * @property {Uint8Array|null} [ownerAddress] BuyStorageBytesContract ownerAddress
         * @property {number|Long|null} [bytes] BuyStorageBytesContract bytes
         */

        /**
         * Constructs a new BuyStorageBytesContract.
         * @memberof protocol
         * @classdesc Represents a BuyStorageBytesContract.
         * @implements IBuyStorageBytesContract
         * @constructor
         * @param {protocol.IBuyStorageBytesContract=} [properties] Properties to set
         */
        function BuyStorageBytesContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyStorageBytesContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.BuyStorageBytesContract
         * @instance
         */
        BuyStorageBytesContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * BuyStorageBytesContract bytes.
         * @member {number|Long} bytes
         * @memberof protocol.BuyStorageBytesContract
         * @instance
         */
        BuyStorageBytesContract.prototype.bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BuyStorageBytesContract instance using the specified properties.
         * @function create
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {protocol.IBuyStorageBytesContract=} [properties] Properties to set
         * @returns {protocol.BuyStorageBytesContract} BuyStorageBytesContract instance
         */
        BuyStorageBytesContract.create = function create(properties) {
            return new BuyStorageBytesContract(properties);
        };

        /**
         * Encodes the specified BuyStorageBytesContract message. Does not implicitly {@link protocol.BuyStorageBytesContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {protocol.IBuyStorageBytesContract} message BuyStorageBytesContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyStorageBytesContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.bytes != null && Object.hasOwnProperty.call(message, "bytes"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.bytes);
            return writer;
        };

        /**
         * Encodes the specified BuyStorageBytesContract message, length delimited. Does not implicitly {@link protocol.BuyStorageBytesContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {protocol.IBuyStorageBytesContract} message BuyStorageBytesContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyStorageBytesContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyStorageBytesContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.BuyStorageBytesContract} BuyStorageBytesContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyStorageBytesContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BuyStorageBytesContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.bytes = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyStorageBytesContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.BuyStorageBytesContract} BuyStorageBytesContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyStorageBytesContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyStorageBytesContract message.
         * @function verify
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyStorageBytesContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.bytes != null && message.hasOwnProperty("bytes"))
                if (!$util.isInteger(message.bytes) && !(message.bytes && $util.isInteger(message.bytes.low) && $util.isInteger(message.bytes.high)))
                    return "bytes: integer|Long expected";
            return null;
        };

        /**
         * Creates a BuyStorageBytesContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.BuyStorageBytesContract} BuyStorageBytesContract
         */
        BuyStorageBytesContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BuyStorageBytesContract)
                return object;
            var message = new $root.protocol.BuyStorageBytesContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.bytes != null)
                if ($util.Long)
                    (message.bytes = $util.Long.fromValue(object.bytes)).unsigned = false;
                else if (typeof object.bytes === "string")
                    message.bytes = parseInt(object.bytes, 10);
                else if (typeof object.bytes === "number")
                    message.bytes = object.bytes;
                else if (typeof object.bytes === "object")
                    message.bytes = new $util.LongBits(object.bytes.low >>> 0, object.bytes.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BuyStorageBytesContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {protocol.BuyStorageBytesContract} message BuyStorageBytesContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuyStorageBytesContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytes = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.bytes != null && message.hasOwnProperty("bytes"))
                if (typeof message.bytes === "number")
                    object.bytes = options.longs === String ? String(message.bytes) : message.bytes;
                else
                    object.bytes = options.longs === String ? $util.Long.prototype.toString.call(message.bytes) : options.longs === Number ? new $util.LongBits(message.bytes.low >>> 0, message.bytes.high >>> 0).toNumber() : message.bytes;
            return object;
        };

        /**
         * Converts this BuyStorageBytesContract to JSON.
         * @function toJSON
         * @memberof protocol.BuyStorageBytesContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuyStorageBytesContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuyStorageBytesContract;
    })();

    protocol.SellStorageContract = (function() {

        /**
         * Properties of a SellStorageContract.
         * @memberof protocol
         * @interface ISellStorageContract
         * @property {Uint8Array|null} [ownerAddress] SellStorageContract ownerAddress
         * @property {number|Long|null} [storageBytes] SellStorageContract storageBytes
         */

        /**
         * Constructs a new SellStorageContract.
         * @memberof protocol
         * @classdesc Represents a SellStorageContract.
         * @implements ISellStorageContract
         * @constructor
         * @param {protocol.ISellStorageContract=} [properties] Properties to set
         */
        function SellStorageContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SellStorageContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.SellStorageContract
         * @instance
         */
        SellStorageContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * SellStorageContract storageBytes.
         * @member {number|Long} storageBytes
         * @memberof protocol.SellStorageContract
         * @instance
         */
        SellStorageContract.prototype.storageBytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SellStorageContract instance using the specified properties.
         * @function create
         * @memberof protocol.SellStorageContract
         * @static
         * @param {protocol.ISellStorageContract=} [properties] Properties to set
         * @returns {protocol.SellStorageContract} SellStorageContract instance
         */
        SellStorageContract.create = function create(properties) {
            return new SellStorageContract(properties);
        };

        /**
         * Encodes the specified SellStorageContract message. Does not implicitly {@link protocol.SellStorageContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.SellStorageContract
         * @static
         * @param {protocol.ISellStorageContract} message SellStorageContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SellStorageContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.storageBytes != null && Object.hasOwnProperty.call(message, "storageBytes"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.storageBytes);
            return writer;
        };

        /**
         * Encodes the specified SellStorageContract message, length delimited. Does not implicitly {@link protocol.SellStorageContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.SellStorageContract
         * @static
         * @param {protocol.ISellStorageContract} message SellStorageContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SellStorageContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SellStorageContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.SellStorageContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.SellStorageContract} SellStorageContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SellStorageContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SellStorageContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.storageBytes = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SellStorageContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.SellStorageContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.SellStorageContract} SellStorageContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SellStorageContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SellStorageContract message.
         * @function verify
         * @memberof protocol.SellStorageContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SellStorageContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.storageBytes != null && message.hasOwnProperty("storageBytes"))
                if (!$util.isInteger(message.storageBytes) && !(message.storageBytes && $util.isInteger(message.storageBytes.low) && $util.isInteger(message.storageBytes.high)))
                    return "storageBytes: integer|Long expected";
            return null;
        };

        /**
         * Creates a SellStorageContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.SellStorageContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.SellStorageContract} SellStorageContract
         */
        SellStorageContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.SellStorageContract)
                return object;
            var message = new $root.protocol.SellStorageContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.storageBytes != null)
                if ($util.Long)
                    (message.storageBytes = $util.Long.fromValue(object.storageBytes)).unsigned = false;
                else if (typeof object.storageBytes === "string")
                    message.storageBytes = parseInt(object.storageBytes, 10);
                else if (typeof object.storageBytes === "number")
                    message.storageBytes = object.storageBytes;
                else if (typeof object.storageBytes === "object")
                    message.storageBytes = new $util.LongBits(object.storageBytes.low >>> 0, object.storageBytes.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SellStorageContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.SellStorageContract
         * @static
         * @param {protocol.SellStorageContract} message SellStorageContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SellStorageContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.storageBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.storageBytes = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.storageBytes != null && message.hasOwnProperty("storageBytes"))
                if (typeof message.storageBytes === "number")
                    object.storageBytes = options.longs === String ? String(message.storageBytes) : message.storageBytes;
                else
                    object.storageBytes = options.longs === String ? $util.Long.prototype.toString.call(message.storageBytes) : options.longs === Number ? new $util.LongBits(message.storageBytes.low >>> 0, message.storageBytes.high >>> 0).toNumber() : message.storageBytes;
            return object;
        };

        /**
         * Converts this SellStorageContract to JSON.
         * @function toJSON
         * @memberof protocol.SellStorageContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SellStorageContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SellStorageContract;
    })();

    protocol.ExchangeCreateContract = (function() {

        /**
         * Properties of an ExchangeCreateContract.
         * @memberof protocol
         * @interface IExchangeCreateContract
         * @property {Uint8Array|null} [ownerAddress] ExchangeCreateContract ownerAddress
         * @property {Uint8Array|null} [firstTokenId] ExchangeCreateContract firstTokenId
         * @property {number|Long|null} [firstTokenBalance] ExchangeCreateContract firstTokenBalance
         * @property {Uint8Array|null} [secondTokenId] ExchangeCreateContract secondTokenId
         * @property {number|Long|null} [secondTokenBalance] ExchangeCreateContract secondTokenBalance
         */

        /**
         * Constructs a new ExchangeCreateContract.
         * @memberof protocol
         * @classdesc Represents an ExchangeCreateContract.
         * @implements IExchangeCreateContract
         * @constructor
         * @param {protocol.IExchangeCreateContract=} [properties] Properties to set
         */
        function ExchangeCreateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeCreateContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.ExchangeCreateContract
         * @instance
         */
        ExchangeCreateContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * ExchangeCreateContract firstTokenId.
         * @member {Uint8Array} firstTokenId
         * @memberof protocol.ExchangeCreateContract
         * @instance
         */
        ExchangeCreateContract.prototype.firstTokenId = $util.newBuffer([]);

        /**
         * ExchangeCreateContract firstTokenBalance.
         * @member {number|Long} firstTokenBalance
         * @memberof protocol.ExchangeCreateContract
         * @instance
         */
        ExchangeCreateContract.prototype.firstTokenBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeCreateContract secondTokenId.
         * @member {Uint8Array} secondTokenId
         * @memberof protocol.ExchangeCreateContract
         * @instance
         */
        ExchangeCreateContract.prototype.secondTokenId = $util.newBuffer([]);

        /**
         * ExchangeCreateContract secondTokenBalance.
         * @member {number|Long} secondTokenBalance
         * @memberof protocol.ExchangeCreateContract
         * @instance
         */
        ExchangeCreateContract.prototype.secondTokenBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExchangeCreateContract instance using the specified properties.
         * @function create
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {protocol.IExchangeCreateContract=} [properties] Properties to set
         * @returns {protocol.ExchangeCreateContract} ExchangeCreateContract instance
         */
        ExchangeCreateContract.create = function create(properties) {
            return new ExchangeCreateContract(properties);
        };

        /**
         * Encodes the specified ExchangeCreateContract message. Does not implicitly {@link protocol.ExchangeCreateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {protocol.IExchangeCreateContract} message ExchangeCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.firstTokenId != null && Object.hasOwnProperty.call(message, "firstTokenId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.firstTokenId);
            if (message.firstTokenBalance != null && Object.hasOwnProperty.call(message, "firstTokenBalance"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.firstTokenBalance);
            if (message.secondTokenId != null && Object.hasOwnProperty.call(message, "secondTokenId"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.secondTokenId);
            if (message.secondTokenBalance != null && Object.hasOwnProperty.call(message, "secondTokenBalance"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.secondTokenBalance);
            return writer;
        };

        /**
         * Encodes the specified ExchangeCreateContract message, length delimited. Does not implicitly {@link protocol.ExchangeCreateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {protocol.IExchangeCreateContract} message ExchangeCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeCreateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ExchangeCreateContract} ExchangeCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeCreateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.firstTokenId = reader.bytes();
                    break;
                case 3:
                    message.firstTokenBalance = reader.int64();
                    break;
                case 4:
                    message.secondTokenId = reader.bytes();
                    break;
                case 5:
                    message.secondTokenBalance = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeCreateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ExchangeCreateContract} ExchangeCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeCreateContract message.
         * @function verify
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.firstTokenId != null && message.hasOwnProperty("firstTokenId"))
                if (!(message.firstTokenId && typeof message.firstTokenId.length === "number" || $util.isString(message.firstTokenId)))
                    return "firstTokenId: buffer expected";
            if (message.firstTokenBalance != null && message.hasOwnProperty("firstTokenBalance"))
                if (!$util.isInteger(message.firstTokenBalance) && !(message.firstTokenBalance && $util.isInteger(message.firstTokenBalance.low) && $util.isInteger(message.firstTokenBalance.high)))
                    return "firstTokenBalance: integer|Long expected";
            if (message.secondTokenId != null && message.hasOwnProperty("secondTokenId"))
                if (!(message.secondTokenId && typeof message.secondTokenId.length === "number" || $util.isString(message.secondTokenId)))
                    return "secondTokenId: buffer expected";
            if (message.secondTokenBalance != null && message.hasOwnProperty("secondTokenBalance"))
                if (!$util.isInteger(message.secondTokenBalance) && !(message.secondTokenBalance && $util.isInteger(message.secondTokenBalance.low) && $util.isInteger(message.secondTokenBalance.high)))
                    return "secondTokenBalance: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExchangeCreateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ExchangeCreateContract} ExchangeCreateContract
         */
        ExchangeCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeCreateContract)
                return object;
            var message = new $root.protocol.ExchangeCreateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.firstTokenId != null)
                if (typeof object.firstTokenId === "string")
                    $util.base64.decode(object.firstTokenId, message.firstTokenId = $util.newBuffer($util.base64.length(object.firstTokenId)), 0);
                else if (object.firstTokenId.length)
                    message.firstTokenId = object.firstTokenId;
            if (object.firstTokenBalance != null)
                if ($util.Long)
                    (message.firstTokenBalance = $util.Long.fromValue(object.firstTokenBalance)).unsigned = false;
                else if (typeof object.firstTokenBalance === "string")
                    message.firstTokenBalance = parseInt(object.firstTokenBalance, 10);
                else if (typeof object.firstTokenBalance === "number")
                    message.firstTokenBalance = object.firstTokenBalance;
                else if (typeof object.firstTokenBalance === "object")
                    message.firstTokenBalance = new $util.LongBits(object.firstTokenBalance.low >>> 0, object.firstTokenBalance.high >>> 0).toNumber();
            if (object.secondTokenId != null)
                if (typeof object.secondTokenId === "string")
                    $util.base64.decode(object.secondTokenId, message.secondTokenId = $util.newBuffer($util.base64.length(object.secondTokenId)), 0);
                else if (object.secondTokenId.length)
                    message.secondTokenId = object.secondTokenId;
            if (object.secondTokenBalance != null)
                if ($util.Long)
                    (message.secondTokenBalance = $util.Long.fromValue(object.secondTokenBalance)).unsigned = false;
                else if (typeof object.secondTokenBalance === "string")
                    message.secondTokenBalance = parseInt(object.secondTokenBalance, 10);
                else if (typeof object.secondTokenBalance === "number")
                    message.secondTokenBalance = object.secondTokenBalance;
                else if (typeof object.secondTokenBalance === "object")
                    message.secondTokenBalance = new $util.LongBits(object.secondTokenBalance.low >>> 0, object.secondTokenBalance.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExchangeCreateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {protocol.ExchangeCreateContract} message ExchangeCreateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangeCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.firstTokenId = "";
                else {
                    object.firstTokenId = [];
                    if (options.bytes !== Array)
                        object.firstTokenId = $util.newBuffer(object.firstTokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.firstTokenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.firstTokenBalance = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.secondTokenId = "";
                else {
                    object.secondTokenId = [];
                    if (options.bytes !== Array)
                        object.secondTokenId = $util.newBuffer(object.secondTokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.secondTokenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.secondTokenBalance = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.firstTokenId != null && message.hasOwnProperty("firstTokenId"))
                object.firstTokenId = options.bytes === String ? $util.base64.encode(message.firstTokenId, 0, message.firstTokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.firstTokenId) : message.firstTokenId;
            if (message.firstTokenBalance != null && message.hasOwnProperty("firstTokenBalance"))
                if (typeof message.firstTokenBalance === "number")
                    object.firstTokenBalance = options.longs === String ? String(message.firstTokenBalance) : message.firstTokenBalance;
                else
                    object.firstTokenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.firstTokenBalance) : options.longs === Number ? new $util.LongBits(message.firstTokenBalance.low >>> 0, message.firstTokenBalance.high >>> 0).toNumber() : message.firstTokenBalance;
            if (message.secondTokenId != null && message.hasOwnProperty("secondTokenId"))
                object.secondTokenId = options.bytes === String ? $util.base64.encode(message.secondTokenId, 0, message.secondTokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.secondTokenId) : message.secondTokenId;
            if (message.secondTokenBalance != null && message.hasOwnProperty("secondTokenBalance"))
                if (typeof message.secondTokenBalance === "number")
                    object.secondTokenBalance = options.longs === String ? String(message.secondTokenBalance) : message.secondTokenBalance;
                else
                    object.secondTokenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.secondTokenBalance) : options.longs === Number ? new $util.LongBits(message.secondTokenBalance.low >>> 0, message.secondTokenBalance.high >>> 0).toNumber() : message.secondTokenBalance;
            return object;
        };

        /**
         * Converts this ExchangeCreateContract to JSON.
         * @function toJSON
         * @memberof protocol.ExchangeCreateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangeCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExchangeCreateContract;
    })();

    protocol.ExchangeInjectContract = (function() {

        /**
         * Properties of an ExchangeInjectContract.
         * @memberof protocol
         * @interface IExchangeInjectContract
         * @property {Uint8Array|null} [ownerAddress] ExchangeInjectContract ownerAddress
         * @property {number|Long|null} [exchangeId] ExchangeInjectContract exchangeId
         * @property {Uint8Array|null} [tokenId] ExchangeInjectContract tokenId
         * @property {number|Long|null} [quant] ExchangeInjectContract quant
         */

        /**
         * Constructs a new ExchangeInjectContract.
         * @memberof protocol
         * @classdesc Represents an ExchangeInjectContract.
         * @implements IExchangeInjectContract
         * @constructor
         * @param {protocol.IExchangeInjectContract=} [properties] Properties to set
         */
        function ExchangeInjectContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeInjectContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.ExchangeInjectContract
         * @instance
         */
        ExchangeInjectContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * ExchangeInjectContract exchangeId.
         * @member {number|Long} exchangeId
         * @memberof protocol.ExchangeInjectContract
         * @instance
         */
        ExchangeInjectContract.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeInjectContract tokenId.
         * @member {Uint8Array} tokenId
         * @memberof protocol.ExchangeInjectContract
         * @instance
         */
        ExchangeInjectContract.prototype.tokenId = $util.newBuffer([]);

        /**
         * ExchangeInjectContract quant.
         * @member {number|Long} quant
         * @memberof protocol.ExchangeInjectContract
         * @instance
         */
        ExchangeInjectContract.prototype.quant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExchangeInjectContract instance using the specified properties.
         * @function create
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {protocol.IExchangeInjectContract=} [properties] Properties to set
         * @returns {protocol.ExchangeInjectContract} ExchangeInjectContract instance
         */
        ExchangeInjectContract.create = function create(properties) {
            return new ExchangeInjectContract(properties);
        };

        /**
         * Encodes the specified ExchangeInjectContract message. Does not implicitly {@link protocol.ExchangeInjectContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {protocol.IExchangeInjectContract} message ExchangeInjectContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeInjectContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.exchangeId);
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tokenId);
            if (message.quant != null && Object.hasOwnProperty.call(message, "quant"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.quant);
            return writer;
        };

        /**
         * Encodes the specified ExchangeInjectContract message, length delimited. Does not implicitly {@link protocol.ExchangeInjectContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {protocol.IExchangeInjectContract} message ExchangeInjectContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeInjectContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeInjectContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ExchangeInjectContract} ExchangeInjectContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeInjectContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeInjectContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.exchangeId = reader.int64();
                    break;
                case 3:
                    message.tokenId = reader.bytes();
                    break;
                case 4:
                    message.quant = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeInjectContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ExchangeInjectContract} ExchangeInjectContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeInjectContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeInjectContract message.
         * @function verify
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeInjectContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (!(message.tokenId && typeof message.tokenId.length === "number" || $util.isString(message.tokenId)))
                    return "tokenId: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExchangeInjectContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ExchangeInjectContract} ExchangeInjectContract
         */
        ExchangeInjectContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeInjectContract)
                return object;
            var message = new $root.protocol.ExchangeInjectContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
            if (object.tokenId != null)
                if (typeof object.tokenId === "string")
                    $util.base64.decode(object.tokenId, message.tokenId = $util.newBuffer($util.base64.length(object.tokenId)), 0);
                else if (object.tokenId.length)
                    message.tokenId = object.tokenId;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExchangeInjectContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {protocol.ExchangeInjectContract} message ExchangeInjectContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangeInjectContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchangeId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.tokenId = "";
                else {
                    object.tokenId = [];
                    if (options.bytes !== Array)
                        object.tokenId = $util.newBuffer(object.tokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quant = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                object.tokenId = options.bytes === String ? $util.base64.encode(message.tokenId, 0, message.tokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.tokenId) : message.tokenId;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            return object;
        };

        /**
         * Converts this ExchangeInjectContract to JSON.
         * @function toJSON
         * @memberof protocol.ExchangeInjectContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangeInjectContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExchangeInjectContract;
    })();

    protocol.ExchangeWithdrawContract = (function() {

        /**
         * Properties of an ExchangeWithdrawContract.
         * @memberof protocol
         * @interface IExchangeWithdrawContract
         * @property {Uint8Array|null} [ownerAddress] ExchangeWithdrawContract ownerAddress
         * @property {number|Long|null} [exchangeId] ExchangeWithdrawContract exchangeId
         * @property {Uint8Array|null} [tokenId] ExchangeWithdrawContract tokenId
         * @property {number|Long|null} [quant] ExchangeWithdrawContract quant
         */

        /**
         * Constructs a new ExchangeWithdrawContract.
         * @memberof protocol
         * @classdesc Represents an ExchangeWithdrawContract.
         * @implements IExchangeWithdrawContract
         * @constructor
         * @param {protocol.IExchangeWithdrawContract=} [properties] Properties to set
         */
        function ExchangeWithdrawContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeWithdrawContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.ExchangeWithdrawContract
         * @instance
         */
        ExchangeWithdrawContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * ExchangeWithdrawContract exchangeId.
         * @member {number|Long} exchangeId
         * @memberof protocol.ExchangeWithdrawContract
         * @instance
         */
        ExchangeWithdrawContract.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeWithdrawContract tokenId.
         * @member {Uint8Array} tokenId
         * @memberof protocol.ExchangeWithdrawContract
         * @instance
         */
        ExchangeWithdrawContract.prototype.tokenId = $util.newBuffer([]);

        /**
         * ExchangeWithdrawContract quant.
         * @member {number|Long} quant
         * @memberof protocol.ExchangeWithdrawContract
         * @instance
         */
        ExchangeWithdrawContract.prototype.quant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExchangeWithdrawContract instance using the specified properties.
         * @function create
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {protocol.IExchangeWithdrawContract=} [properties] Properties to set
         * @returns {protocol.ExchangeWithdrawContract} ExchangeWithdrawContract instance
         */
        ExchangeWithdrawContract.create = function create(properties) {
            return new ExchangeWithdrawContract(properties);
        };

        /**
         * Encodes the specified ExchangeWithdrawContract message. Does not implicitly {@link protocol.ExchangeWithdrawContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {protocol.IExchangeWithdrawContract} message ExchangeWithdrawContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeWithdrawContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.exchangeId);
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tokenId);
            if (message.quant != null && Object.hasOwnProperty.call(message, "quant"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.quant);
            return writer;
        };

        /**
         * Encodes the specified ExchangeWithdrawContract message, length delimited. Does not implicitly {@link protocol.ExchangeWithdrawContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {protocol.IExchangeWithdrawContract} message ExchangeWithdrawContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeWithdrawContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeWithdrawContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ExchangeWithdrawContract} ExchangeWithdrawContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeWithdrawContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeWithdrawContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.exchangeId = reader.int64();
                    break;
                case 3:
                    message.tokenId = reader.bytes();
                    break;
                case 4:
                    message.quant = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeWithdrawContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ExchangeWithdrawContract} ExchangeWithdrawContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeWithdrawContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeWithdrawContract message.
         * @function verify
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeWithdrawContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (!(message.tokenId && typeof message.tokenId.length === "number" || $util.isString(message.tokenId)))
                    return "tokenId: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExchangeWithdrawContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ExchangeWithdrawContract} ExchangeWithdrawContract
         */
        ExchangeWithdrawContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeWithdrawContract)
                return object;
            var message = new $root.protocol.ExchangeWithdrawContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
            if (object.tokenId != null)
                if (typeof object.tokenId === "string")
                    $util.base64.decode(object.tokenId, message.tokenId = $util.newBuffer($util.base64.length(object.tokenId)), 0);
                else if (object.tokenId.length)
                    message.tokenId = object.tokenId;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExchangeWithdrawContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {protocol.ExchangeWithdrawContract} message ExchangeWithdrawContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangeWithdrawContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchangeId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.tokenId = "";
                else {
                    object.tokenId = [];
                    if (options.bytes !== Array)
                        object.tokenId = $util.newBuffer(object.tokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quant = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                object.tokenId = options.bytes === String ? $util.base64.encode(message.tokenId, 0, message.tokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.tokenId) : message.tokenId;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            return object;
        };

        /**
         * Converts this ExchangeWithdrawContract to JSON.
         * @function toJSON
         * @memberof protocol.ExchangeWithdrawContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangeWithdrawContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExchangeWithdrawContract;
    })();

    protocol.ExchangeTransactionContract = (function() {

        /**
         * Properties of an ExchangeTransactionContract.
         * @memberof protocol
         * @interface IExchangeTransactionContract
         * @property {Uint8Array|null} [ownerAddress] ExchangeTransactionContract ownerAddress
         * @property {number|Long|null} [exchangeId] ExchangeTransactionContract exchangeId
         * @property {Uint8Array|null} [tokenId] ExchangeTransactionContract tokenId
         * @property {number|Long|null} [quant] ExchangeTransactionContract quant
         * @property {number|Long|null} [expected] ExchangeTransactionContract expected
         */

        /**
         * Constructs a new ExchangeTransactionContract.
         * @memberof protocol
         * @classdesc Represents an ExchangeTransactionContract.
         * @implements IExchangeTransactionContract
         * @constructor
         * @param {protocol.IExchangeTransactionContract=} [properties] Properties to set
         */
        function ExchangeTransactionContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeTransactionContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         */
        ExchangeTransactionContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * ExchangeTransactionContract exchangeId.
         * @member {number|Long} exchangeId
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         */
        ExchangeTransactionContract.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeTransactionContract tokenId.
         * @member {Uint8Array} tokenId
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         */
        ExchangeTransactionContract.prototype.tokenId = $util.newBuffer([]);

        /**
         * ExchangeTransactionContract quant.
         * @member {number|Long} quant
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         */
        ExchangeTransactionContract.prototype.quant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeTransactionContract expected.
         * @member {number|Long} expected
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         */
        ExchangeTransactionContract.prototype.expected = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExchangeTransactionContract instance using the specified properties.
         * @function create
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {protocol.IExchangeTransactionContract=} [properties] Properties to set
         * @returns {protocol.ExchangeTransactionContract} ExchangeTransactionContract instance
         */
        ExchangeTransactionContract.create = function create(properties) {
            return new ExchangeTransactionContract(properties);
        };

        /**
         * Encodes the specified ExchangeTransactionContract message. Does not implicitly {@link protocol.ExchangeTransactionContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {protocol.IExchangeTransactionContract} message ExchangeTransactionContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeTransactionContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.exchangeId);
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tokenId);
            if (message.quant != null && Object.hasOwnProperty.call(message, "quant"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.quant);
            if (message.expected != null && Object.hasOwnProperty.call(message, "expected"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expected);
            return writer;
        };

        /**
         * Encodes the specified ExchangeTransactionContract message, length delimited. Does not implicitly {@link protocol.ExchangeTransactionContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {protocol.IExchangeTransactionContract} message ExchangeTransactionContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeTransactionContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeTransactionContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ExchangeTransactionContract} ExchangeTransactionContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeTransactionContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeTransactionContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.exchangeId = reader.int64();
                    break;
                case 3:
                    message.tokenId = reader.bytes();
                    break;
                case 4:
                    message.quant = reader.int64();
                    break;
                case 5:
                    message.expected = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeTransactionContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ExchangeTransactionContract} ExchangeTransactionContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeTransactionContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeTransactionContract message.
         * @function verify
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeTransactionContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (!(message.tokenId && typeof message.tokenId.length === "number" || $util.isString(message.tokenId)))
                    return "tokenId: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (!$util.isInteger(message.expected) && !(message.expected && $util.isInteger(message.expected.low) && $util.isInteger(message.expected.high)))
                    return "expected: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExchangeTransactionContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ExchangeTransactionContract} ExchangeTransactionContract
         */
        ExchangeTransactionContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeTransactionContract)
                return object;
            var message = new $root.protocol.ExchangeTransactionContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
            if (object.tokenId != null)
                if (typeof object.tokenId === "string")
                    $util.base64.decode(object.tokenId, message.tokenId = $util.newBuffer($util.base64.length(object.tokenId)), 0);
                else if (object.tokenId.length)
                    message.tokenId = object.tokenId;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            if (object.expected != null)
                if ($util.Long)
                    (message.expected = $util.Long.fromValue(object.expected)).unsigned = false;
                else if (typeof object.expected === "string")
                    message.expected = parseInt(object.expected, 10);
                else if (typeof object.expected === "number")
                    message.expected = object.expected;
                else if (typeof object.expected === "object")
                    message.expected = new $util.LongBits(object.expected.low >>> 0, object.expected.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExchangeTransactionContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {protocol.ExchangeTransactionContract} message ExchangeTransactionContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangeTransactionContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchangeId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.tokenId = "";
                else {
                    object.tokenId = [];
                    if (options.bytes !== Array)
                        object.tokenId = $util.newBuffer(object.tokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quant = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expected = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expected = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                object.tokenId = options.bytes === String ? $util.base64.encode(message.tokenId, 0, message.tokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.tokenId) : message.tokenId;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (typeof message.expected === "number")
                    object.expected = options.longs === String ? String(message.expected) : message.expected;
                else
                    object.expected = options.longs === String ? $util.Long.prototype.toString.call(message.expected) : options.longs === Number ? new $util.LongBits(message.expected.low >>> 0, message.expected.high >>> 0).toNumber() : message.expected;
            return object;
        };

        /**
         * Converts this ExchangeTransactionContract to JSON.
         * @function toJSON
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangeTransactionContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExchangeTransactionContract;
    })();

    protocol.AccountPermissionUpdateContract = (function() {

        /**
         * Properties of an AccountPermissionUpdateContract.
         * @memberof protocol
         * @interface IAccountPermissionUpdateContract
         * @property {Uint8Array|null} [ownerAddress] AccountPermissionUpdateContract ownerAddress
         * @property {protocol.IPermission|null} [owner] AccountPermissionUpdateContract owner
         * @property {protocol.IPermission|null} [witness] AccountPermissionUpdateContract witness
         * @property {Array.<protocol.IPermission>|null} [actives] AccountPermissionUpdateContract actives
         */

        /**
         * Constructs a new AccountPermissionUpdateContract.
         * @memberof protocol
         * @classdesc Represents an AccountPermissionUpdateContract.
         * @implements IAccountPermissionUpdateContract
         * @constructor
         * @param {protocol.IAccountPermissionUpdateContract=} [properties] Properties to set
         */
        function AccountPermissionUpdateContract(properties) {
            this.actives = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountPermissionUpdateContract ownerAddress.
         * @member {Uint8Array} ownerAddress
         * @memberof protocol.AccountPermissionUpdateContract
         * @instance
         */
        AccountPermissionUpdateContract.prototype.ownerAddress = $util.newBuffer([]);

        /**
         * AccountPermissionUpdateContract owner.
         * @member {protocol.IPermission|null|undefined} owner
         * @memberof protocol.AccountPermissionUpdateContract
         * @instance
         */
        AccountPermissionUpdateContract.prototype.owner = null;

        /**
         * AccountPermissionUpdateContract witness.
         * @member {protocol.IPermission|null|undefined} witness
         * @memberof protocol.AccountPermissionUpdateContract
         * @instance
         */
        AccountPermissionUpdateContract.prototype.witness = null;

        /**
         * AccountPermissionUpdateContract actives.
         * @member {Array.<protocol.IPermission>} actives
         * @memberof protocol.AccountPermissionUpdateContract
         * @instance
         */
        AccountPermissionUpdateContract.prototype.actives = $util.emptyArray;

        /**
         * Creates a new AccountPermissionUpdateContract instance using the specified properties.
         * @function create
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {protocol.IAccountPermissionUpdateContract=} [properties] Properties to set
         * @returns {protocol.AccountPermissionUpdateContract} AccountPermissionUpdateContract instance
         */
        AccountPermissionUpdateContract.create = function create(properties) {
            return new AccountPermissionUpdateContract(properties);
        };

        /**
         * Encodes the specified AccountPermissionUpdateContract message. Does not implicitly {@link protocol.AccountPermissionUpdateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {protocol.IAccountPermissionUpdateContract} message AccountPermissionUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountPermissionUpdateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ownerAddress);
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                $root.protocol.Permission.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.witness != null && Object.hasOwnProperty.call(message, "witness"))
                $root.protocol.Permission.encode(message.witness, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.actives != null && message.actives.length)
                for (var i = 0; i < message.actives.length; ++i)
                    $root.protocol.Permission.encode(message.actives[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountPermissionUpdateContract message, length delimited. Does not implicitly {@link protocol.AccountPermissionUpdateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {protocol.IAccountPermissionUpdateContract} message AccountPermissionUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountPermissionUpdateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountPermissionUpdateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.AccountPermissionUpdateContract} AccountPermissionUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountPermissionUpdateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountPermissionUpdateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ownerAddress = reader.bytes();
                    break;
                case 2:
                    message.owner = $root.protocol.Permission.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.witness = $root.protocol.Permission.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.actives && message.actives.length))
                        message.actives = [];
                    message.actives.push($root.protocol.Permission.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountPermissionUpdateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.AccountPermissionUpdateContract} AccountPermissionUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountPermissionUpdateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountPermissionUpdateContract message.
         * @function verify
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountPermissionUpdateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.protocol.Permission.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.witness != null && message.hasOwnProperty("witness")) {
                var error = $root.protocol.Permission.verify(message.witness);
                if (error)
                    return "witness." + error;
            }
            if (message.actives != null && message.hasOwnProperty("actives")) {
                if (!Array.isArray(message.actives))
                    return "actives: array expected";
                for (var i = 0; i < message.actives.length; ++i) {
                    var error = $root.protocol.Permission.verify(message.actives[i]);
                    if (error)
                        return "actives." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AccountPermissionUpdateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.AccountPermissionUpdateContract} AccountPermissionUpdateContract
         */
        AccountPermissionUpdateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountPermissionUpdateContract)
                return object;
            var message = new $root.protocol.AccountPermissionUpdateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".protocol.AccountPermissionUpdateContract.owner: object expected");
                message.owner = $root.protocol.Permission.fromObject(object.owner);
            }
            if (object.witness != null) {
                if (typeof object.witness !== "object")
                    throw TypeError(".protocol.AccountPermissionUpdateContract.witness: object expected");
                message.witness = $root.protocol.Permission.fromObject(object.witness);
            }
            if (object.actives) {
                if (!Array.isArray(object.actives))
                    throw TypeError(".protocol.AccountPermissionUpdateContract.actives: array expected");
                message.actives = [];
                for (var i = 0; i < object.actives.length; ++i) {
                    if (typeof object.actives[i] !== "object")
                        throw TypeError(".protocol.AccountPermissionUpdateContract.actives: object expected");
                    message.actives[i] = $root.protocol.Permission.fromObject(object.actives[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountPermissionUpdateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {protocol.AccountPermissionUpdateContract} message AccountPermissionUpdateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountPermissionUpdateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.actives = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                object.owner = null;
                object.witness = null;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.protocol.Permission.toObject(message.owner, options);
            if (message.witness != null && message.hasOwnProperty("witness"))
                object.witness = $root.protocol.Permission.toObject(message.witness, options);
            if (message.actives && message.actives.length) {
                object.actives = [];
                for (var j = 0; j < message.actives.length; ++j)
                    object.actives[j] = $root.protocol.Permission.toObject(message.actives[j], options);
            }
            return object;
        };

        /**
         * Converts this AccountPermissionUpdateContract to JSON.
         * @function toJSON
         * @memberof protocol.AccountPermissionUpdateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountPermissionUpdateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountPermissionUpdateContract;
    })();

    /**
     * AccountType enum.
     * @name protocol.AccountType
     * @enum {number}
     * @property {number} Normal=0 Normal value
     * @property {number} AssetIssue=1 AssetIssue value
     * @property {number} Contract=2 Contract value
     */
    protocol.AccountType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Normal"] = 0;
        values[valuesById[1] = "AssetIssue"] = 1;
        values[valuesById[2] = "Contract"] = 2;
        return values;
    })();

    protocol.AccountId = (function() {

        /**
         * Properties of an AccountId.
         * @memberof protocol
         * @interface IAccountId
         * @property {Uint8Array|null} [name] AccountId name
         * @property {Uint8Array|null} [address] AccountId address
         */

        /**
         * Constructs a new AccountId.
         * @memberof protocol
         * @classdesc Represents an AccountId.
         * @implements IAccountId
         * @constructor
         * @param {protocol.IAccountId=} [properties] Properties to set
         */
        function AccountId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountId name.
         * @member {Uint8Array} name
         * @memberof protocol.AccountId
         * @instance
         */
        AccountId.prototype.name = $util.newBuffer([]);

        /**
         * AccountId address.
         * @member {Uint8Array} address
         * @memberof protocol.AccountId
         * @instance
         */
        AccountId.prototype.address = $util.newBuffer([]);

        /**
         * Creates a new AccountId instance using the specified properties.
         * @function create
         * @memberof protocol.AccountId
         * @static
         * @param {protocol.IAccountId=} [properties] Properties to set
         * @returns {protocol.AccountId} AccountId instance
         */
        AccountId.create = function create(properties) {
            return new AccountId(properties);
        };

        /**
         * Encodes the specified AccountId message. Does not implicitly {@link protocol.AccountId.verify|verify} messages.
         * @function encode
         * @memberof protocol.AccountId
         * @static
         * @param {protocol.IAccountId} message AccountId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.name);
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.address);
            return writer;
        };

        /**
         * Encodes the specified AccountId message, length delimited. Does not implicitly {@link protocol.AccountId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.AccountId
         * @static
         * @param {protocol.IAccountId} message AccountId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountId message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.AccountId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.AccountId} AccountId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.bytes();
                    break;
                case 2:
                    message.address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.AccountId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.AccountId} AccountId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountId message.
         * @function verify
         * @memberof protocol.AccountId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                    return "name: buffer expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            return null;
        };

        /**
         * Creates an AccountId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.AccountId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.AccountId} AccountId
         */
        AccountId.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountId)
                return object;
            var message = new $root.protocol.AccountId();
            if (object.name != null)
                if (typeof object.name === "string")
                    $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
                else if (object.name.length)
                    message.name = object.name;
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            return message;
        };

        /**
         * Creates a plain object from an AccountId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.AccountId
         * @static
         * @param {protocol.AccountId} message AccountId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.name = "";
                else {
                    object.name = [];
                    if (options.bytes !== Array)
                        object.name = $util.newBuffer(object.name);
                }
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            return object;
        };

        /**
         * Converts this AccountId to JSON.
         * @function toJSON
         * @memberof protocol.AccountId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountId;
    })();

    protocol.Vote = (function() {

        /**
         * Properties of a Vote.
         * @memberof protocol
         * @interface IVote
         * @property {Uint8Array|null} [voteAddress] Vote voteAddress
         * @property {number|Long|null} [voteCount] Vote voteCount
         */

        /**
         * Constructs a new Vote.
         * @memberof protocol
         * @classdesc Represents a Vote.
         * @implements IVote
         * @constructor
         * @param {protocol.IVote=} [properties] Properties to set
         */
        function Vote(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vote voteAddress.
         * @member {Uint8Array} voteAddress
         * @memberof protocol.Vote
         * @instance
         */
        Vote.prototype.voteAddress = $util.newBuffer([]);

        /**
         * Vote voteCount.
         * @member {number|Long} voteCount
         * @memberof protocol.Vote
         * @instance
         */
        Vote.prototype.voteCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Vote instance using the specified properties.
         * @function create
         * @memberof protocol.Vote
         * @static
         * @param {protocol.IVote=} [properties] Properties to set
         * @returns {protocol.Vote} Vote instance
         */
        Vote.create = function create(properties) {
            return new Vote(properties);
        };

        /**
         * Encodes the specified Vote message. Does not implicitly {@link protocol.Vote.verify|verify} messages.
         * @function encode
         * @memberof protocol.Vote
         * @static
         * @param {protocol.IVote} message Vote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vote.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.voteAddress != null && Object.hasOwnProperty.call(message, "voteAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.voteAddress);
            if (message.voteCount != null && Object.hasOwnProperty.call(message, "voteCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.voteCount);
            return writer;
        };

        /**
         * Encodes the specified Vote message, length delimited. Does not implicitly {@link protocol.Vote.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Vote
         * @static
         * @param {protocol.IVote} message Vote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vote.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vote message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Vote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Vote} Vote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vote.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Vote();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.voteAddress = reader.bytes();
                    break;
                case 2:
                    message.voteCount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vote message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Vote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Vote} Vote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vote.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vote message.
         * @function verify
         * @memberof protocol.Vote
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vote.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.voteAddress != null && message.hasOwnProperty("voteAddress"))
                if (!(message.voteAddress && typeof message.voteAddress.length === "number" || $util.isString(message.voteAddress)))
                    return "voteAddress: buffer expected";
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                if (!$util.isInteger(message.voteCount) && !(message.voteCount && $util.isInteger(message.voteCount.low) && $util.isInteger(message.voteCount.high)))
                    return "voteCount: integer|Long expected";
            return null;
        };

        /**
         * Creates a Vote message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Vote
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Vote} Vote
         */
        Vote.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Vote)
                return object;
            var message = new $root.protocol.Vote();
            if (object.voteAddress != null)
                if (typeof object.voteAddress === "string")
                    $util.base64.decode(object.voteAddress, message.voteAddress = $util.newBuffer($util.base64.length(object.voteAddress)), 0);
                else if (object.voteAddress.length)
                    message.voteAddress = object.voteAddress;
            if (object.voteCount != null)
                if ($util.Long)
                    (message.voteCount = $util.Long.fromValue(object.voteCount)).unsigned = false;
                else if (typeof object.voteCount === "string")
                    message.voteCount = parseInt(object.voteCount, 10);
                else if (typeof object.voteCount === "number")
                    message.voteCount = object.voteCount;
                else if (typeof object.voteCount === "object")
                    message.voteCount = new $util.LongBits(object.voteCount.low >>> 0, object.voteCount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Vote message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Vote
         * @static
         * @param {protocol.Vote} message Vote
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vote.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.voteAddress = "";
                else {
                    object.voteAddress = [];
                    if (options.bytes !== Array)
                        object.voteAddress = $util.newBuffer(object.voteAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.voteCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.voteCount = options.longs === String ? "0" : 0;
            }
            if (message.voteAddress != null && message.hasOwnProperty("voteAddress"))
                object.voteAddress = options.bytes === String ? $util.base64.encode(message.voteAddress, 0, message.voteAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.voteAddress) : message.voteAddress;
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                if (typeof message.voteCount === "number")
                    object.voteCount = options.longs === String ? String(message.voteCount) : message.voteCount;
                else
                    object.voteCount = options.longs === String ? $util.Long.prototype.toString.call(message.voteCount) : options.longs === Number ? new $util.LongBits(message.voteCount.low >>> 0, message.voteCount.high >>> 0).toNumber() : message.voteCount;
            return object;
        };

        /**
         * Converts this Vote to JSON.
         * @function toJSON
         * @memberof protocol.Vote
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vote.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Vote;
    })();

    protocol.Proposal = (function() {

        /**
         * Properties of a Proposal.
         * @memberof protocol
         * @interface IProposal
         * @property {number|Long|null} [proposalId] Proposal proposalId
         * @property {Uint8Array|null} [proposerAddress] Proposal proposerAddress
         * @property {Object.<string,number|Long>|null} [parameters] Proposal parameters
         * @property {number|Long|null} [expirationTime] Proposal expirationTime
         * @property {number|Long|null} [createTime] Proposal createTime
         * @property {Array.<Uint8Array>|null} [approvals] Proposal approvals
         * @property {protocol.Proposal.State|null} [state] Proposal state
         */

        /**
         * Constructs a new Proposal.
         * @memberof protocol
         * @classdesc Represents a Proposal.
         * @implements IProposal
         * @constructor
         * @param {protocol.IProposal=} [properties] Properties to set
         */
        function Proposal(properties) {
            this.parameters = {};
            this.approvals = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Proposal proposalId.
         * @member {number|Long} proposalId
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.proposalId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Proposal proposerAddress.
         * @member {Uint8Array} proposerAddress
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.proposerAddress = $util.newBuffer([]);

        /**
         * Proposal parameters.
         * @member {Object.<string,number|Long>} parameters
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.parameters = $util.emptyObject;

        /**
         * Proposal expirationTime.
         * @member {number|Long} expirationTime
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.expirationTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Proposal createTime.
         * @member {number|Long} createTime
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Proposal approvals.
         * @member {Array.<Uint8Array>} approvals
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.approvals = $util.emptyArray;

        /**
         * Proposal state.
         * @member {protocol.Proposal.State} state
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.state = 0;

        /**
         * Creates a new Proposal instance using the specified properties.
         * @function create
         * @memberof protocol.Proposal
         * @static
         * @param {protocol.IProposal=} [properties] Properties to set
         * @returns {protocol.Proposal} Proposal instance
         */
        Proposal.create = function create(properties) {
            return new Proposal(properties);
        };

        /**
         * Encodes the specified Proposal message. Does not implicitly {@link protocol.Proposal.verify|verify} messages.
         * @function encode
         * @memberof protocol.Proposal
         * @static
         * @param {protocol.IProposal} message Proposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proposal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.proposalId != null && Object.hasOwnProperty.call(message, "proposalId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.proposalId);
            if (message.proposerAddress != null && Object.hasOwnProperty.call(message, "proposerAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.proposerAddress);
            if (message.parameters != null && Object.hasOwnProperty.call(message, "parameters"))
                for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 0 =*/8).int64(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.parameters[keys[i]]).ldelim();
            if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.expirationTime);
            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.createTime);
            if (message.approvals != null && message.approvals.length)
                for (var i = 0; i < message.approvals.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.approvals[i]);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.state);
            return writer;
        };

        /**
         * Encodes the specified Proposal message, length delimited. Does not implicitly {@link protocol.Proposal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Proposal
         * @static
         * @param {protocol.IProposal} message Proposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proposal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Proposal message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Proposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Proposal} Proposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proposal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Proposal(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.proposalId = reader.int64();
                    break;
                case 2:
                    message.proposerAddress = reader.bytes();
                    break;
                case 3:
                    reader.skip().pos++;
                    if (message.parameters === $util.emptyObject)
                        message.parameters = {};
                    key = reader.int64();
                    reader.pos++;
                    message.parameters[typeof key === "object" ? $util.longToHash(key) : key] = reader.int64();
                    break;
                case 4:
                    message.expirationTime = reader.int64();
                    break;
                case 5:
                    message.createTime = reader.int64();
                    break;
                case 6:
                    if (!(message.approvals && message.approvals.length))
                        message.approvals = [];
                    message.approvals.push(reader.bytes());
                    break;
                case 7:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Proposal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Proposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Proposal} Proposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proposal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Proposal message.
         * @function verify
         * @memberof protocol.Proposal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Proposal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!$util.isInteger(message.proposalId) && !(message.proposalId && $util.isInteger(message.proposalId.low) && $util.isInteger(message.proposalId.high)))
                    return "proposalId: integer|Long expected";
            if (message.proposerAddress != null && message.hasOwnProperty("proposerAddress"))
                if (!(message.proposerAddress && typeof message.proposerAddress.length === "number" || $util.isString(message.proposerAddress)))
                    return "proposerAddress: buffer expected";
            if (message.parameters != null && message.hasOwnProperty("parameters")) {
                if (!$util.isObject(message.parameters))
                    return "parameters: object expected";
                var key = Object.keys(message.parameters);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "parameters: integer|Long key{k:int64} expected";
                    if (!$util.isInteger(message.parameters[key[i]]) && !(message.parameters[key[i]] && $util.isInteger(message.parameters[key[i]].low) && $util.isInteger(message.parameters[key[i]].high)))
                        return "parameters: integer|Long{k:int64} expected";
                }
            }
            if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                if (!$util.isInteger(message.expirationTime) && !(message.expirationTime && $util.isInteger(message.expirationTime.low) && $util.isInteger(message.expirationTime.high)))
                    return "expirationTime: integer|Long expected";
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                    return "createTime: integer|Long expected";
            if (message.approvals != null && message.hasOwnProperty("approvals")) {
                if (!Array.isArray(message.approvals))
                    return "approvals: array expected";
                for (var i = 0; i < message.approvals.length; ++i)
                    if (!(message.approvals[i] && typeof message.approvals[i].length === "number" || $util.isString(message.approvals[i])))
                        return "approvals: buffer[] expected";
            }
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a Proposal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Proposal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Proposal} Proposal
         */
        Proposal.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Proposal)
                return object;
            var message = new $root.protocol.Proposal();
            if (object.proposalId != null)
                if ($util.Long)
                    (message.proposalId = $util.Long.fromValue(object.proposalId)).unsigned = false;
                else if (typeof object.proposalId === "string")
                    message.proposalId = parseInt(object.proposalId, 10);
                else if (typeof object.proposalId === "number")
                    message.proposalId = object.proposalId;
                else if (typeof object.proposalId === "object")
                    message.proposalId = new $util.LongBits(object.proposalId.low >>> 0, object.proposalId.high >>> 0).toNumber();
            if (object.proposerAddress != null)
                if (typeof object.proposerAddress === "string")
                    $util.base64.decode(object.proposerAddress, message.proposerAddress = $util.newBuffer($util.base64.length(object.proposerAddress)), 0);
                else if (object.proposerAddress.length)
                    message.proposerAddress = object.proposerAddress;
            if (object.parameters) {
                if (typeof object.parameters !== "object")
                    throw TypeError(".protocol.Proposal.parameters: object expected");
                message.parameters = {};
                for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.parameters[keys[i]] = $util.Long.fromValue(object.parameters[keys[i]])).unsigned = false;
                    else if (typeof object.parameters[keys[i]] === "string")
                        message.parameters[keys[i]] = parseInt(object.parameters[keys[i]], 10);
                    else if (typeof object.parameters[keys[i]] === "number")
                        message.parameters[keys[i]] = object.parameters[keys[i]];
                    else if (typeof object.parameters[keys[i]] === "object")
                        message.parameters[keys[i]] = new $util.LongBits(object.parameters[keys[i]].low >>> 0, object.parameters[keys[i]].high >>> 0).toNumber();
            }
            if (object.expirationTime != null)
                if ($util.Long)
                    (message.expirationTime = $util.Long.fromValue(object.expirationTime)).unsigned = false;
                else if (typeof object.expirationTime === "string")
                    message.expirationTime = parseInt(object.expirationTime, 10);
                else if (typeof object.expirationTime === "number")
                    message.expirationTime = object.expirationTime;
                else if (typeof object.expirationTime === "object")
                    message.expirationTime = new $util.LongBits(object.expirationTime.low >>> 0, object.expirationTime.high >>> 0).toNumber();
            if (object.createTime != null)
                if ($util.Long)
                    (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = false;
                else if (typeof object.createTime === "string")
                    message.createTime = parseInt(object.createTime, 10);
                else if (typeof object.createTime === "number")
                    message.createTime = object.createTime;
                else if (typeof object.createTime === "object")
                    message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber();
            if (object.approvals) {
                if (!Array.isArray(object.approvals))
                    throw TypeError(".protocol.Proposal.approvals: array expected");
                message.approvals = [];
                for (var i = 0; i < object.approvals.length; ++i)
                    if (typeof object.approvals[i] === "string")
                        $util.base64.decode(object.approvals[i], message.approvals[i] = $util.newBuffer($util.base64.length(object.approvals[i])), 0);
                    else if (object.approvals[i].length)
                        message.approvals[i] = object.approvals[i];
            }
            switch (object.state) {
            case "PENDING":
            case 0:
                message.state = 0;
                break;
            case "DISAPPROVED":
            case 1:
                message.state = 1;
                break;
            case "APPROVED":
            case 2:
                message.state = 2;
                break;
            case "CANCELED":
            case 3:
                message.state = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Proposal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Proposal
         * @static
         * @param {protocol.Proposal} message Proposal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Proposal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.approvals = [];
            if (options.objects || options.defaults)
                object.parameters = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.proposalId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.proposalId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.proposerAddress = "";
                else {
                    object.proposerAddress = [];
                    if (options.bytes !== Array)
                        object.proposerAddress = $util.newBuffer(object.proposerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expirationTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expirationTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createTime = options.longs === String ? "0" : 0;
                object.state = options.enums === String ? "PENDING" : 0;
            }
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (typeof message.proposalId === "number")
                    object.proposalId = options.longs === String ? String(message.proposalId) : message.proposalId;
                else
                    object.proposalId = options.longs === String ? $util.Long.prototype.toString.call(message.proposalId) : options.longs === Number ? new $util.LongBits(message.proposalId.low >>> 0, message.proposalId.high >>> 0).toNumber() : message.proposalId;
            if (message.proposerAddress != null && message.hasOwnProperty("proposerAddress"))
                object.proposerAddress = options.bytes === String ? $util.base64.encode(message.proposerAddress, 0, message.proposerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposerAddress) : message.proposerAddress;
            var keys2;
            if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                object.parameters = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.parameters[keys2[j]] === "number")
                        object.parameters[keys2[j]] = options.longs === String ? String(message.parameters[keys2[j]]) : message.parameters[keys2[j]];
                    else
                        object.parameters[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.parameters[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.parameters[keys2[j]].low >>> 0, message.parameters[keys2[j]].high >>> 0).toNumber() : message.parameters[keys2[j]];
            }
            if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                if (typeof message.expirationTime === "number")
                    object.expirationTime = options.longs === String ? String(message.expirationTime) : message.expirationTime;
                else
                    object.expirationTime = options.longs === String ? $util.Long.prototype.toString.call(message.expirationTime) : options.longs === Number ? new $util.LongBits(message.expirationTime.low >>> 0, message.expirationTime.high >>> 0).toNumber() : message.expirationTime;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (typeof message.createTime === "number")
                    object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                else
                    object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber() : message.createTime;
            if (message.approvals && message.approvals.length) {
                object.approvals = [];
                for (var j = 0; j < message.approvals.length; ++j)
                    object.approvals[j] = options.bytes === String ? $util.base64.encode(message.approvals[j], 0, message.approvals[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.approvals[j]) : message.approvals[j];
            }
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.protocol.Proposal.State[message.state] : message.state;
            return object;
        };

        /**
         * Converts this Proposal to JSON.
         * @function toJSON
         * @memberof protocol.Proposal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Proposal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * State enum.
         * @name protocol.Proposal.State
         * @enum {number}
         * @property {number} PENDING=0 PENDING value
         * @property {number} DISAPPROVED=1 DISAPPROVED value
         * @property {number} APPROVED=2 APPROVED value
         * @property {number} CANCELED=3 CANCELED value
         */
        Proposal.State = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PENDING"] = 0;
            values[valuesById[1] = "DISAPPROVED"] = 1;
            values[valuesById[2] = "APPROVED"] = 2;
            values[valuesById[3] = "CANCELED"] = 3;
            return values;
        })();

        return Proposal;
    })();

    protocol.Exchange = (function() {

        /**
         * Properties of an Exchange.
         * @memberof protocol
         * @interface IExchange
         * @property {number|Long|null} [exchangeId] Exchange exchangeId
         * @property {Uint8Array|null} [creatorAddress] Exchange creatorAddress
         * @property {number|Long|null} [createTime] Exchange createTime
         * @property {Uint8Array|null} [firstTokenId] Exchange firstTokenId
         * @property {number|Long|null} [firstTokenBalance] Exchange firstTokenBalance
         * @property {Uint8Array|null} [secondTokenId] Exchange secondTokenId
         * @property {number|Long|null} [secondTokenBalance] Exchange secondTokenBalance
         */

        /**
         * Constructs a new Exchange.
         * @memberof protocol
         * @classdesc Represents an Exchange.
         * @implements IExchange
         * @constructor
         * @param {protocol.IExchange=} [properties] Properties to set
         */
        function Exchange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Exchange exchangeId.
         * @member {number|Long} exchangeId
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Exchange creatorAddress.
         * @member {Uint8Array} creatorAddress
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.creatorAddress = $util.newBuffer([]);

        /**
         * Exchange createTime.
         * @member {number|Long} createTime
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Exchange firstTokenId.
         * @member {Uint8Array} firstTokenId
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.firstTokenId = $util.newBuffer([]);

        /**
         * Exchange firstTokenBalance.
         * @member {number|Long} firstTokenBalance
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.firstTokenBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Exchange secondTokenId.
         * @member {Uint8Array} secondTokenId
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.secondTokenId = $util.newBuffer([]);

        /**
         * Exchange secondTokenBalance.
         * @member {number|Long} secondTokenBalance
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.secondTokenBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Exchange instance using the specified properties.
         * @function create
         * @memberof protocol.Exchange
         * @static
         * @param {protocol.IExchange=} [properties] Properties to set
         * @returns {protocol.Exchange} Exchange instance
         */
        Exchange.create = function create(properties) {
            return new Exchange(properties);
        };

        /**
         * Encodes the specified Exchange message. Does not implicitly {@link protocol.Exchange.verify|verify} messages.
         * @function encode
         * @memberof protocol.Exchange
         * @static
         * @param {protocol.IExchange} message Exchange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Exchange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.exchangeId);
            if (message.creatorAddress != null && Object.hasOwnProperty.call(message, "creatorAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.creatorAddress);
            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.createTime);
            if (message.firstTokenId != null && Object.hasOwnProperty.call(message, "firstTokenId"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.firstTokenId);
            if (message.firstTokenBalance != null && Object.hasOwnProperty.call(message, "firstTokenBalance"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.firstTokenBalance);
            if (message.secondTokenId != null && Object.hasOwnProperty.call(message, "secondTokenId"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.secondTokenId);
            if (message.secondTokenBalance != null && Object.hasOwnProperty.call(message, "secondTokenBalance"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.secondTokenBalance);
            return writer;
        };

        /**
         * Encodes the specified Exchange message, length delimited. Does not implicitly {@link protocol.Exchange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Exchange
         * @static
         * @param {protocol.IExchange} message Exchange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Exchange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Exchange message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Exchange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Exchange} Exchange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Exchange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Exchange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.exchangeId = reader.int64();
                    break;
                case 2:
                    message.creatorAddress = reader.bytes();
                    break;
                case 3:
                    message.createTime = reader.int64();
                    break;
                case 6:
                    message.firstTokenId = reader.bytes();
                    break;
                case 7:
                    message.firstTokenBalance = reader.int64();
                    break;
                case 8:
                    message.secondTokenId = reader.bytes();
                    break;
                case 9:
                    message.secondTokenBalance = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Exchange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Exchange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Exchange} Exchange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Exchange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Exchange message.
         * @function verify
         * @memberof protocol.Exchange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Exchange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            if (message.creatorAddress != null && message.hasOwnProperty("creatorAddress"))
                if (!(message.creatorAddress && typeof message.creatorAddress.length === "number" || $util.isString(message.creatorAddress)))
                    return "creatorAddress: buffer expected";
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                    return "createTime: integer|Long expected";
            if (message.firstTokenId != null && message.hasOwnProperty("firstTokenId"))
                if (!(message.firstTokenId && typeof message.firstTokenId.length === "number" || $util.isString(message.firstTokenId)))
                    return "firstTokenId: buffer expected";
            if (message.firstTokenBalance != null && message.hasOwnProperty("firstTokenBalance"))
                if (!$util.isInteger(message.firstTokenBalance) && !(message.firstTokenBalance && $util.isInteger(message.firstTokenBalance.low) && $util.isInteger(message.firstTokenBalance.high)))
                    return "firstTokenBalance: integer|Long expected";
            if (message.secondTokenId != null && message.hasOwnProperty("secondTokenId"))
                if (!(message.secondTokenId && typeof message.secondTokenId.length === "number" || $util.isString(message.secondTokenId)))
                    return "secondTokenId: buffer expected";
            if (message.secondTokenBalance != null && message.hasOwnProperty("secondTokenBalance"))
                if (!$util.isInteger(message.secondTokenBalance) && !(message.secondTokenBalance && $util.isInteger(message.secondTokenBalance.low) && $util.isInteger(message.secondTokenBalance.high)))
                    return "secondTokenBalance: integer|Long expected";
            return null;
        };

        /**
         * Creates an Exchange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Exchange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Exchange} Exchange
         */
        Exchange.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Exchange)
                return object;
            var message = new $root.protocol.Exchange();
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
            if (object.creatorAddress != null)
                if (typeof object.creatorAddress === "string")
                    $util.base64.decode(object.creatorAddress, message.creatorAddress = $util.newBuffer($util.base64.length(object.creatorAddress)), 0);
                else if (object.creatorAddress.length)
                    message.creatorAddress = object.creatorAddress;
            if (object.createTime != null)
                if ($util.Long)
                    (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = false;
                else if (typeof object.createTime === "string")
                    message.createTime = parseInt(object.createTime, 10);
                else if (typeof object.createTime === "number")
                    message.createTime = object.createTime;
                else if (typeof object.createTime === "object")
                    message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber();
            if (object.firstTokenId != null)
                if (typeof object.firstTokenId === "string")
                    $util.base64.decode(object.firstTokenId, message.firstTokenId = $util.newBuffer($util.base64.length(object.firstTokenId)), 0);
                else if (object.firstTokenId.length)
                    message.firstTokenId = object.firstTokenId;
            if (object.firstTokenBalance != null)
                if ($util.Long)
                    (message.firstTokenBalance = $util.Long.fromValue(object.firstTokenBalance)).unsigned = false;
                else if (typeof object.firstTokenBalance === "string")
                    message.firstTokenBalance = parseInt(object.firstTokenBalance, 10);
                else if (typeof object.firstTokenBalance === "number")
                    message.firstTokenBalance = object.firstTokenBalance;
                else if (typeof object.firstTokenBalance === "object")
                    message.firstTokenBalance = new $util.LongBits(object.firstTokenBalance.low >>> 0, object.firstTokenBalance.high >>> 0).toNumber();
            if (object.secondTokenId != null)
                if (typeof object.secondTokenId === "string")
                    $util.base64.decode(object.secondTokenId, message.secondTokenId = $util.newBuffer($util.base64.length(object.secondTokenId)), 0);
                else if (object.secondTokenId.length)
                    message.secondTokenId = object.secondTokenId;
            if (object.secondTokenBalance != null)
                if ($util.Long)
                    (message.secondTokenBalance = $util.Long.fromValue(object.secondTokenBalance)).unsigned = false;
                else if (typeof object.secondTokenBalance === "string")
                    message.secondTokenBalance = parseInt(object.secondTokenBalance, 10);
                else if (typeof object.secondTokenBalance === "number")
                    message.secondTokenBalance = object.secondTokenBalance;
                else if (typeof object.secondTokenBalance === "object")
                    message.secondTokenBalance = new $util.LongBits(object.secondTokenBalance.low >>> 0, object.secondTokenBalance.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Exchange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Exchange
         * @static
         * @param {protocol.Exchange} message Exchange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Exchange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchangeId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.creatorAddress = "";
                else {
                    object.creatorAddress = [];
                    if (options.bytes !== Array)
                        object.creatorAddress = $util.newBuffer(object.creatorAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.firstTokenId = "";
                else {
                    object.firstTokenId = [];
                    if (options.bytes !== Array)
                        object.firstTokenId = $util.newBuffer(object.firstTokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.firstTokenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.firstTokenBalance = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.secondTokenId = "";
                else {
                    object.secondTokenId = [];
                    if (options.bytes !== Array)
                        object.secondTokenId = $util.newBuffer(object.secondTokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.secondTokenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.secondTokenBalance = options.longs === String ? "0" : 0;
            }
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
            if (message.creatorAddress != null && message.hasOwnProperty("creatorAddress"))
                object.creatorAddress = options.bytes === String ? $util.base64.encode(message.creatorAddress, 0, message.creatorAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.creatorAddress) : message.creatorAddress;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (typeof message.createTime === "number")
                    object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                else
                    object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber() : message.createTime;
            if (message.firstTokenId != null && message.hasOwnProperty("firstTokenId"))
                object.firstTokenId = options.bytes === String ? $util.base64.encode(message.firstTokenId, 0, message.firstTokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.firstTokenId) : message.firstTokenId;
            if (message.firstTokenBalance != null && message.hasOwnProperty("firstTokenBalance"))
                if (typeof message.firstTokenBalance === "number")
                    object.firstTokenBalance = options.longs === String ? String(message.firstTokenBalance) : message.firstTokenBalance;
                else
                    object.firstTokenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.firstTokenBalance) : options.longs === Number ? new $util.LongBits(message.firstTokenBalance.low >>> 0, message.firstTokenBalance.high >>> 0).toNumber() : message.firstTokenBalance;
            if (message.secondTokenId != null && message.hasOwnProperty("secondTokenId"))
                object.secondTokenId = options.bytes === String ? $util.base64.encode(message.secondTokenId, 0, message.secondTokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.secondTokenId) : message.secondTokenId;
            if (message.secondTokenBalance != null && message.hasOwnProperty("secondTokenBalance"))
                if (typeof message.secondTokenBalance === "number")
                    object.secondTokenBalance = options.longs === String ? String(message.secondTokenBalance) : message.secondTokenBalance;
                else
                    object.secondTokenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.secondTokenBalance) : options.longs === Number ? new $util.LongBits(message.secondTokenBalance.low >>> 0, message.secondTokenBalance.high >>> 0).toNumber() : message.secondTokenBalance;
            return object;
        };

        /**
         * Converts this Exchange to JSON.
         * @function toJSON
         * @memberof protocol.Exchange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Exchange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Exchange;
    })();

    protocol.ChainParameters = (function() {

        /**
         * Properties of a ChainParameters.
         * @memberof protocol
         * @interface IChainParameters
         * @property {Array.<protocol.ChainParameters.IChainParameter>|null} [chainParameter] ChainParameters chainParameter
         */

        /**
         * Constructs a new ChainParameters.
         * @memberof protocol
         * @classdesc Represents a ChainParameters.
         * @implements IChainParameters
         * @constructor
         * @param {protocol.IChainParameters=} [properties] Properties to set
         */
        function ChainParameters(properties) {
            this.chainParameter = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChainParameters chainParameter.
         * @member {Array.<protocol.ChainParameters.IChainParameter>} chainParameter
         * @memberof protocol.ChainParameters
         * @instance
         */
        ChainParameters.prototype.chainParameter = $util.emptyArray;

        /**
         * Creates a new ChainParameters instance using the specified properties.
         * @function create
         * @memberof protocol.ChainParameters
         * @static
         * @param {protocol.IChainParameters=} [properties] Properties to set
         * @returns {protocol.ChainParameters} ChainParameters instance
         */
        ChainParameters.create = function create(properties) {
            return new ChainParameters(properties);
        };

        /**
         * Encodes the specified ChainParameters message. Does not implicitly {@link protocol.ChainParameters.verify|verify} messages.
         * @function encode
         * @memberof protocol.ChainParameters
         * @static
         * @param {protocol.IChainParameters} message ChainParameters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainParameters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chainParameter != null && message.chainParameter.length)
                for (var i = 0; i < message.chainParameter.length; ++i)
                    $root.protocol.ChainParameters.ChainParameter.encode(message.chainParameter[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChainParameters message, length delimited. Does not implicitly {@link protocol.ChainParameters.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ChainParameters
         * @static
         * @param {protocol.IChainParameters} message ChainParameters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainParameters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChainParameters message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ChainParameters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ChainParameters} ChainParameters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainParameters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainParameters();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chainParameter && message.chainParameter.length))
                        message.chainParameter = [];
                    message.chainParameter.push($root.protocol.ChainParameters.ChainParameter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChainParameters message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ChainParameters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ChainParameters} ChainParameters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainParameters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChainParameters message.
         * @function verify
         * @memberof protocol.ChainParameters
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChainParameters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chainParameter != null && message.hasOwnProperty("chainParameter")) {
                if (!Array.isArray(message.chainParameter))
                    return "chainParameter: array expected";
                for (var i = 0; i < message.chainParameter.length; ++i) {
                    var error = $root.protocol.ChainParameters.ChainParameter.verify(message.chainParameter[i]);
                    if (error)
                        return "chainParameter." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChainParameters message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ChainParameters
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ChainParameters} ChainParameters
         */
        ChainParameters.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ChainParameters)
                return object;
            var message = new $root.protocol.ChainParameters();
            if (object.chainParameter) {
                if (!Array.isArray(object.chainParameter))
                    throw TypeError(".protocol.ChainParameters.chainParameter: array expected");
                message.chainParameter = [];
                for (var i = 0; i < object.chainParameter.length; ++i) {
                    if (typeof object.chainParameter[i] !== "object")
                        throw TypeError(".protocol.ChainParameters.chainParameter: object expected");
                    message.chainParameter[i] = $root.protocol.ChainParameters.ChainParameter.fromObject(object.chainParameter[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChainParameters message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ChainParameters
         * @static
         * @param {protocol.ChainParameters} message ChainParameters
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChainParameters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chainParameter = [];
            if (message.chainParameter && message.chainParameter.length) {
                object.chainParameter = [];
                for (var j = 0; j < message.chainParameter.length; ++j)
                    object.chainParameter[j] = $root.protocol.ChainParameters.ChainParameter.toObject(message.chainParameter[j], options);
            }
            return object;
        };

        /**
         * Converts this ChainParameters to JSON.
         * @function toJSON
         * @memberof protocol.ChainParameters
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChainParameters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ChainParameters.ChainParameter = (function() {

            /**
             * Properties of a ChainParameter.
             * @memberof protocol.ChainParameters
             * @interface IChainParameter
             * @property {string|null} [key] ChainParameter key
             * @property {number|Long|null} [value] ChainParameter value
             */

            /**
             * Constructs a new ChainParameter.
             * @memberof protocol.ChainParameters
             * @classdesc Represents a ChainParameter.
             * @implements IChainParameter
             * @constructor
             * @param {protocol.ChainParameters.IChainParameter=} [properties] Properties to set
             */
            function ChainParameter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChainParameter key.
             * @member {string} key
             * @memberof protocol.ChainParameters.ChainParameter
             * @instance
             */
            ChainParameter.prototype.key = "";

            /**
             * ChainParameter value.
             * @member {number|Long} value
             * @memberof protocol.ChainParameters.ChainParameter
             * @instance
             */
            ChainParameter.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ChainParameter instance using the specified properties.
             * @function create
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {protocol.ChainParameters.IChainParameter=} [properties] Properties to set
             * @returns {protocol.ChainParameters.ChainParameter} ChainParameter instance
             */
            ChainParameter.create = function create(properties) {
                return new ChainParameter(properties);
            };

            /**
             * Encodes the specified ChainParameter message. Does not implicitly {@link protocol.ChainParameters.ChainParameter.verify|verify} messages.
             * @function encode
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {protocol.ChainParameters.IChainParameter} message ChainParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChainParameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value);
                return writer;
            };

            /**
             * Encodes the specified ChainParameter message, length delimited. Does not implicitly {@link protocol.ChainParameters.ChainParameter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {protocol.ChainParameters.IChainParameter} message ChainParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChainParameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChainParameter message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.ChainParameters.ChainParameter} ChainParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChainParameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainParameters.ChainParameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChainParameter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.ChainParameters.ChainParameter} ChainParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChainParameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChainParameter message.
             * @function verify
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChainParameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates a ChainParameter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.ChainParameters.ChainParameter} ChainParameter
             */
            ChainParameter.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.ChainParameters.ChainParameter)
                    return object;
                var message = new $root.protocol.ChainParameters.ChainParameter();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a ChainParameter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {protocol.ChainParameters.ChainParameter} message ChainParameter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChainParameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                return object;
            };

            /**
             * Converts this ChainParameter to JSON.
             * @function toJSON
             * @memberof protocol.ChainParameters.ChainParameter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChainParameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ChainParameter;
        })();

        return ChainParameters;
    })();

    protocol.Account = (function() {

        /**
         * Properties of an Account.
         * @memberof protocol
         * @interface IAccount
         * @property {Uint8Array|null} [accountName] Account accountName
         * @property {protocol.AccountType|null} [type] Account type
         * @property {Uint8Array|null} [address] Account address
         * @property {number|Long|null} [balance] Account balance
         * @property {Array.<protocol.IVote>|null} [votes] Account votes
         * @property {Object.<string,number|Long>|null} [asset] Account asset
         * @property {Object.<string,number|Long>|null} [assetV2] Account assetV2
         * @property {Array.<protocol.Account.IFrozen>|null} [frozen] Account frozen
         * @property {number|Long|null} [netUsage] Account netUsage
         * @property {number|Long|null} [acquiredDelegatedFrozenBalanceForBandwidth] Account acquiredDelegatedFrozenBalanceForBandwidth
         * @property {number|Long|null} [delegatedFrozenBalanceForBandwidth] Account delegatedFrozenBalanceForBandwidth
         * @property {number|Long|null} [createTime] Account createTime
         * @property {number|Long|null} [latestOprationTime] Account latestOprationTime
         * @property {number|Long|null} [allowance] Account allowance
         * @property {number|Long|null} [latestWithdrawTime] Account latestWithdrawTime
         * @property {Uint8Array|null} [code] Account code
         * @property {boolean|null} [isWitness] Account isWitness
         * @property {boolean|null} [isCommittee] Account isCommittee
         * @property {Array.<protocol.Account.IFrozen>|null} [frozenSupply] Account frozenSupply
         * @property {Uint8Array|null} [assetIssuedName] Account assetIssuedName
         * @property {Uint8Array|null} [assetIssued_ID] Account assetIssued_ID
         * @property {Object.<string,number|Long>|null} [latestAssetOperationTime] Account latestAssetOperationTime
         * @property {Object.<string,number|Long>|null} [latestAssetOperationTimeV2] Account latestAssetOperationTimeV2
         * @property {number|Long|null} [freeNetUsage] Account freeNetUsage
         * @property {Object.<string,number|Long>|null} [freeAssetNetUsage] Account freeAssetNetUsage
         * @property {Object.<string,number|Long>|null} [freeAssetNetUsageV2] Account freeAssetNetUsageV2
         * @property {number|Long|null} [latestConsumeTime] Account latestConsumeTime
         * @property {number|Long|null} [latestConsumeFreeTime] Account latestConsumeFreeTime
         * @property {Uint8Array|null} [accountId] Account accountId
         * @property {protocol.Account.IAccountResource|null} [accountResource] Account accountResource
         * @property {Uint8Array|null} [codeHash] Account codeHash
         * @property {protocol.IPermission|null} [ownerPermission] Account ownerPermission
         * @property {protocol.IPermission|null} [witnessPermission] Account witnessPermission
         * @property {Array.<protocol.IPermission>|null} [activePermission] Account activePermission
         */

        /**
         * Constructs a new Account.
         * @memberof protocol
         * @classdesc Represents an Account.
         * @implements IAccount
         * @constructor
         * @param {protocol.IAccount=} [properties] Properties to set
         */
        function Account(properties) {
            this.votes = [];
            this.asset = {};
            this.assetV2 = {};
            this.frozen = [];
            this.frozenSupply = [];
            this.latestAssetOperationTime = {};
            this.latestAssetOperationTimeV2 = {};
            this.freeAssetNetUsage = {};
            this.freeAssetNetUsageV2 = {};
            this.activePermission = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Account accountName.
         * @member {Uint8Array} accountName
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.accountName = $util.newBuffer([]);

        /**
         * Account type.
         * @member {protocol.AccountType} type
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.type = 0;

        /**
         * Account address.
         * @member {Uint8Array} address
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.address = $util.newBuffer([]);

        /**
         * Account balance.
         * @member {number|Long} balance
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account votes.
         * @member {Array.<protocol.IVote>} votes
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.votes = $util.emptyArray;

        /**
         * Account asset.
         * @member {Object.<string,number|Long>} asset
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.asset = $util.emptyObject;

        /**
         * Account assetV2.
         * @member {Object.<string,number|Long>} assetV2
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.assetV2 = $util.emptyObject;

        /**
         * Account frozen.
         * @member {Array.<protocol.Account.IFrozen>} frozen
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.frozen = $util.emptyArray;

        /**
         * Account netUsage.
         * @member {number|Long} netUsage
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.netUsage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account acquiredDelegatedFrozenBalanceForBandwidth.
         * @member {number|Long} acquiredDelegatedFrozenBalanceForBandwidth
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.acquiredDelegatedFrozenBalanceForBandwidth = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account delegatedFrozenBalanceForBandwidth.
         * @member {number|Long} delegatedFrozenBalanceForBandwidth
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.delegatedFrozenBalanceForBandwidth = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account createTime.
         * @member {number|Long} createTime
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account latestOprationTime.
         * @member {number|Long} latestOprationTime
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latestOprationTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account allowance.
         * @member {number|Long} allowance
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.allowance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account latestWithdrawTime.
         * @member {number|Long} latestWithdrawTime
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latestWithdrawTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account code.
         * @member {Uint8Array} code
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.code = $util.newBuffer([]);

        /**
         * Account isWitness.
         * @member {boolean} isWitness
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.isWitness = false;

        /**
         * Account isCommittee.
         * @member {boolean} isCommittee
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.isCommittee = false;

        /**
         * Account frozenSupply.
         * @member {Array.<protocol.Account.IFrozen>} frozenSupply
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.frozenSupply = $util.emptyArray;

        /**
         * Account assetIssuedName.
         * @member {Uint8Array} assetIssuedName
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.assetIssuedName = $util.newBuffer([]);

        /**
         * Account assetIssued_ID.
         * @member {Uint8Array} assetIssued_ID
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.assetIssued_ID = $util.newBuffer([]);

        /**
         * Account latestAssetOperationTime.
         * @member {Object.<string,number|Long>} latestAssetOperationTime
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latestAssetOperationTime = $util.emptyObject;

        /**
         * Account latestAssetOperationTimeV2.
         * @member {Object.<string,number|Long>} latestAssetOperationTimeV2
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latestAssetOperationTimeV2 = $util.emptyObject;

        /**
         * Account freeNetUsage.
         * @member {number|Long} freeNetUsage
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.freeNetUsage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account freeAssetNetUsage.
         * @member {Object.<string,number|Long>} freeAssetNetUsage
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.freeAssetNetUsage = $util.emptyObject;

        /**
         * Account freeAssetNetUsageV2.
         * @member {Object.<string,number|Long>} freeAssetNetUsageV2
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.freeAssetNetUsageV2 = $util.emptyObject;

        /**
         * Account latestConsumeTime.
         * @member {number|Long} latestConsumeTime
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latestConsumeTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account latestConsumeFreeTime.
         * @member {number|Long} latestConsumeFreeTime
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latestConsumeFreeTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account accountId.
         * @member {Uint8Array} accountId
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.accountId = $util.newBuffer([]);

        /**
         * Account accountResource.
         * @member {protocol.Account.IAccountResource|null|undefined} accountResource
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.accountResource = null;

        /**
         * Account codeHash.
         * @member {Uint8Array} codeHash
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.codeHash = $util.newBuffer([]);

        /**
         * Account ownerPermission.
         * @member {protocol.IPermission|null|undefined} ownerPermission
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.ownerPermission = null;

        /**
         * Account witnessPermission.
         * @member {protocol.IPermission|null|undefined} witnessPermission
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.witnessPermission = null;

        /**
         * Account activePermission.
         * @member {Array.<protocol.IPermission>} activePermission
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.activePermission = $util.emptyArray;

        /**
         * Creates a new Account instance using the specified properties.
         * @function create
         * @memberof protocol.Account
         * @static
         * @param {protocol.IAccount=} [properties] Properties to set
         * @returns {protocol.Account} Account instance
         */
        Account.create = function create(properties) {
            return new Account(properties);
        };

        /**
         * Encodes the specified Account message. Does not implicitly {@link protocol.Account.verify|verify} messages.
         * @function encode
         * @memberof protocol.Account
         * @static
         * @param {protocol.IAccount} message Account message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Account.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountName != null && Object.hasOwnProperty.call(message, "accountName"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountName);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.address);
            if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.balance);
            if (message.votes != null && message.votes.length)
                for (var i = 0; i < message.votes.length; ++i)
                    $root.protocol.Vote.encode(message.votes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.asset != null && Object.hasOwnProperty.call(message, "asset"))
                for (var keys = Object.keys(message.asset), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.asset[keys[i]]).ldelim();
            if (message.frozen != null && message.frozen.length)
                for (var i = 0; i < message.frozen.length; ++i)
                    $root.protocol.Account.Frozen.encode(message.frozen[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.netUsage != null && Object.hasOwnProperty.call(message, "netUsage"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.netUsage);
            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.createTime);
            if (message.latestOprationTime != null && Object.hasOwnProperty.call(message, "latestOprationTime"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.latestOprationTime);
            if (message.allowance != null && Object.hasOwnProperty.call(message, "allowance"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.allowance);
            if (message.latestWithdrawTime != null && Object.hasOwnProperty.call(message, "latestWithdrawTime"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.latestWithdrawTime);
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.code);
            if (message.isWitness != null && Object.hasOwnProperty.call(message, "isWitness"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.isWitness);
            if (message.isCommittee != null && Object.hasOwnProperty.call(message, "isCommittee"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.isCommittee);
            if (message.frozenSupply != null && message.frozenSupply.length)
                for (var i = 0; i < message.frozenSupply.length; ++i)
                    $root.protocol.Account.Frozen.encode(message.frozenSupply[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.assetIssuedName != null && Object.hasOwnProperty.call(message, "assetIssuedName"))
                writer.uint32(/* id 17, wireType 2 =*/138).bytes(message.assetIssuedName);
            if (message.latestAssetOperationTime != null && Object.hasOwnProperty.call(message, "latestAssetOperationTime"))
                for (var keys = Object.keys(message.latestAssetOperationTime), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 18, wireType 2 =*/146).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.latestAssetOperationTime[keys[i]]).ldelim();
            if (message.freeNetUsage != null && Object.hasOwnProperty.call(message, "freeNetUsage"))
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.freeNetUsage);
            if (message.freeAssetNetUsage != null && Object.hasOwnProperty.call(message, "freeAssetNetUsage"))
                for (var keys = Object.keys(message.freeAssetNetUsage), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 20, wireType 2 =*/162).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.freeAssetNetUsage[keys[i]]).ldelim();
            if (message.latestConsumeTime != null && Object.hasOwnProperty.call(message, "latestConsumeTime"))
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.latestConsumeTime);
            if (message.latestConsumeFreeTime != null && Object.hasOwnProperty.call(message, "latestConsumeFreeTime"))
                writer.uint32(/* id 22, wireType 0 =*/176).int64(message.latestConsumeFreeTime);
            if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                writer.uint32(/* id 23, wireType 2 =*/186).bytes(message.accountId);
            if (message.accountResource != null && Object.hasOwnProperty.call(message, "accountResource"))
                $root.protocol.Account.AccountResource.encode(message.accountResource, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.codeHash != null && Object.hasOwnProperty.call(message, "codeHash"))
                writer.uint32(/* id 30, wireType 2 =*/242).bytes(message.codeHash);
            if (message.ownerPermission != null && Object.hasOwnProperty.call(message, "ownerPermission"))
                $root.protocol.Permission.encode(message.ownerPermission, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.witnessPermission != null && Object.hasOwnProperty.call(message, "witnessPermission"))
                $root.protocol.Permission.encode(message.witnessPermission, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.activePermission != null && message.activePermission.length)
                for (var i = 0; i < message.activePermission.length; ++i)
                    $root.protocol.Permission.encode(message.activePermission[i], writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.acquiredDelegatedFrozenBalanceForBandwidth != null && Object.hasOwnProperty.call(message, "acquiredDelegatedFrozenBalanceForBandwidth"))
                writer.uint32(/* id 41, wireType 0 =*/328).int64(message.acquiredDelegatedFrozenBalanceForBandwidth);
            if (message.delegatedFrozenBalanceForBandwidth != null && Object.hasOwnProperty.call(message, "delegatedFrozenBalanceForBandwidth"))
                writer.uint32(/* id 42, wireType 0 =*/336).int64(message.delegatedFrozenBalanceForBandwidth);
            if (message.assetV2 != null && Object.hasOwnProperty.call(message, "assetV2"))
                for (var keys = Object.keys(message.assetV2), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 56, wireType 2 =*/450).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.assetV2[keys[i]]).ldelim();
            if (message.assetIssued_ID != null && Object.hasOwnProperty.call(message, "assetIssued_ID"))
                writer.uint32(/* id 57, wireType 2 =*/458).bytes(message.assetIssued_ID);
            if (message.latestAssetOperationTimeV2 != null && Object.hasOwnProperty.call(message, "latestAssetOperationTimeV2"))
                for (var keys = Object.keys(message.latestAssetOperationTimeV2), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 58, wireType 2 =*/466).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.latestAssetOperationTimeV2[keys[i]]).ldelim();
            if (message.freeAssetNetUsageV2 != null && Object.hasOwnProperty.call(message, "freeAssetNetUsageV2"))
                for (var keys = Object.keys(message.freeAssetNetUsageV2), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 59, wireType 2 =*/474).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.freeAssetNetUsageV2[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Account message, length delimited. Does not implicitly {@link protocol.Account.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Account
         * @static
         * @param {protocol.IAccount} message Account message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Account.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Account message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Account
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Account} Account
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Account.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Account(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accountName = reader.bytes();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.address = reader.bytes();
                    break;
                case 4:
                    message.balance = reader.int64();
                    break;
                case 5:
                    if (!(message.votes && message.votes.length))
                        message.votes = [];
                    message.votes.push($root.protocol.Vote.decode(reader, reader.uint32()));
                    break;
                case 6:
                    reader.skip().pos++;
                    if (message.asset === $util.emptyObject)
                        message.asset = {};
                    key = reader.string();
                    reader.pos++;
                    message.asset[key] = reader.int64();
                    break;
                case 56:
                    reader.skip().pos++;
                    if (message.assetV2 === $util.emptyObject)
                        message.assetV2 = {};
                    key = reader.string();
                    reader.pos++;
                    message.assetV2[key] = reader.int64();
                    break;
                case 7:
                    if (!(message.frozen && message.frozen.length))
                        message.frozen = [];
                    message.frozen.push($root.protocol.Account.Frozen.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.netUsage = reader.int64();
                    break;
                case 41:
                    message.acquiredDelegatedFrozenBalanceForBandwidth = reader.int64();
                    break;
                case 42:
                    message.delegatedFrozenBalanceForBandwidth = reader.int64();
                    break;
                case 9:
                    message.createTime = reader.int64();
                    break;
                case 10:
                    message.latestOprationTime = reader.int64();
                    break;
                case 11:
                    message.allowance = reader.int64();
                    break;
                case 12:
                    message.latestWithdrawTime = reader.int64();
                    break;
                case 13:
                    message.code = reader.bytes();
                    break;
                case 14:
                    message.isWitness = reader.bool();
                    break;
                case 15:
                    message.isCommittee = reader.bool();
                    break;
                case 16:
                    if (!(message.frozenSupply && message.frozenSupply.length))
                        message.frozenSupply = [];
                    message.frozenSupply.push($root.protocol.Account.Frozen.decode(reader, reader.uint32()));
                    break;
                case 17:
                    message.assetIssuedName = reader.bytes();
                    break;
                case 57:
                    message.assetIssued_ID = reader.bytes();
                    break;
                case 18:
                    reader.skip().pos++;
                    if (message.latestAssetOperationTime === $util.emptyObject)
                        message.latestAssetOperationTime = {};
                    key = reader.string();
                    reader.pos++;
                    message.latestAssetOperationTime[key] = reader.int64();
                    break;
                case 58:
                    reader.skip().pos++;
                    if (message.latestAssetOperationTimeV2 === $util.emptyObject)
                        message.latestAssetOperationTimeV2 = {};
                    key = reader.string();
                    reader.pos++;
                    message.latestAssetOperationTimeV2[key] = reader.int64();
                    break;
                case 19:
                    message.freeNetUsage = reader.int64();
                    break;
                case 20:
                    reader.skip().pos++;
                    if (message.freeAssetNetUsage === $util.emptyObject)
                        message.freeAssetNetUsage = {};
                    key = reader.string();
                    reader.pos++;
                    message.freeAssetNetUsage[key] = reader.int64();
                    break;
                case 59:
                    reader.skip().pos++;
                    if (message.freeAssetNetUsageV2 === $util.emptyObject)
                        message.freeAssetNetUsageV2 = {};
                    key = reader.string();
                    reader.pos++;
                    message.freeAssetNetUsageV2[key] = reader.int64();
                    break;
                case 21:
                    message.latestConsumeTime = reader.int64();
                    break;
                case 22:
                    message.latestConsumeFreeTime = reader.int64();
                    break;
                case 23:
                    message.accountId = reader.bytes();
                    break;
                case 26:
                    message.accountResource = $root.protocol.Account.AccountResource.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.codeHash = reader.bytes();
                    break;
                case 31:
                    message.ownerPermission = $root.protocol.Permission.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.witnessPermission = $root.protocol.Permission.decode(reader, reader.uint32());
                    break;
                case 33:
                    if (!(message.activePermission && message.activePermission.length))
                        message.activePermission = [];
                    message.activePermission.push($root.protocol.Permission.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Account message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Account
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Account} Account
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Account.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Account message.
         * @function verify
         * @memberof protocol.Account
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Account.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountName != null && message.hasOwnProperty("accountName"))
                if (!(message.accountName && typeof message.accountName.length === "number" || $util.isString(message.accountName)))
                    return "accountName: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                    return "balance: integer|Long expected";
            if (message.votes != null && message.hasOwnProperty("votes")) {
                if (!Array.isArray(message.votes))
                    return "votes: array expected";
                for (var i = 0; i < message.votes.length; ++i) {
                    var error = $root.protocol.Vote.verify(message.votes[i]);
                    if (error)
                        return "votes." + error;
                }
            }
            if (message.asset != null && message.hasOwnProperty("asset")) {
                if (!$util.isObject(message.asset))
                    return "asset: object expected";
                var key = Object.keys(message.asset);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.asset[key[i]]) && !(message.asset[key[i]] && $util.isInteger(message.asset[key[i]].low) && $util.isInteger(message.asset[key[i]].high)))
                        return "asset: integer|Long{k:string} expected";
            }
            if (message.assetV2 != null && message.hasOwnProperty("assetV2")) {
                if (!$util.isObject(message.assetV2))
                    return "assetV2: object expected";
                var key = Object.keys(message.assetV2);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.assetV2[key[i]]) && !(message.assetV2[key[i]] && $util.isInteger(message.assetV2[key[i]].low) && $util.isInteger(message.assetV2[key[i]].high)))
                        return "assetV2: integer|Long{k:string} expected";
            }
            if (message.frozen != null && message.hasOwnProperty("frozen")) {
                if (!Array.isArray(message.frozen))
                    return "frozen: array expected";
                for (var i = 0; i < message.frozen.length; ++i) {
                    var error = $root.protocol.Account.Frozen.verify(message.frozen[i]);
                    if (error)
                        return "frozen." + error;
                }
            }
            if (message.netUsage != null && message.hasOwnProperty("netUsage"))
                if (!$util.isInteger(message.netUsage) && !(message.netUsage && $util.isInteger(message.netUsage.low) && $util.isInteger(message.netUsage.high)))
                    return "netUsage: integer|Long expected";
            if (message.acquiredDelegatedFrozenBalanceForBandwidth != null && message.hasOwnProperty("acquiredDelegatedFrozenBalanceForBandwidth"))
                if (!$util.isInteger(message.acquiredDelegatedFrozenBalanceForBandwidth) && !(message.acquiredDelegatedFrozenBalanceForBandwidth && $util.isInteger(message.acquiredDelegatedFrozenBalanceForBandwidth.low) && $util.isInteger(message.acquiredDelegatedFrozenBalanceForBandwidth.high)))
                    return "acquiredDelegatedFrozenBalanceForBandwidth: integer|Long expected";
            if (message.delegatedFrozenBalanceForBandwidth != null && message.hasOwnProperty("delegatedFrozenBalanceForBandwidth"))
                if (!$util.isInteger(message.delegatedFrozenBalanceForBandwidth) && !(message.delegatedFrozenBalanceForBandwidth && $util.isInteger(message.delegatedFrozenBalanceForBandwidth.low) && $util.isInteger(message.delegatedFrozenBalanceForBandwidth.high)))
                    return "delegatedFrozenBalanceForBandwidth: integer|Long expected";
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                    return "createTime: integer|Long expected";
            if (message.latestOprationTime != null && message.hasOwnProperty("latestOprationTime"))
                if (!$util.isInteger(message.latestOprationTime) && !(message.latestOprationTime && $util.isInteger(message.latestOprationTime.low) && $util.isInteger(message.latestOprationTime.high)))
                    return "latestOprationTime: integer|Long expected";
            if (message.allowance != null && message.hasOwnProperty("allowance"))
                if (!$util.isInteger(message.allowance) && !(message.allowance && $util.isInteger(message.allowance.low) && $util.isInteger(message.allowance.high)))
                    return "allowance: integer|Long expected";
            if (message.latestWithdrawTime != null && message.hasOwnProperty("latestWithdrawTime"))
                if (!$util.isInteger(message.latestWithdrawTime) && !(message.latestWithdrawTime && $util.isInteger(message.latestWithdrawTime.low) && $util.isInteger(message.latestWithdrawTime.high)))
                    return "latestWithdrawTime: integer|Long expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!(message.code && typeof message.code.length === "number" || $util.isString(message.code)))
                    return "code: buffer expected";
            if (message.isWitness != null && message.hasOwnProperty("isWitness"))
                if (typeof message.isWitness !== "boolean")
                    return "isWitness: boolean expected";
            if (message.isCommittee != null && message.hasOwnProperty("isCommittee"))
                if (typeof message.isCommittee !== "boolean")
                    return "isCommittee: boolean expected";
            if (message.frozenSupply != null && message.hasOwnProperty("frozenSupply")) {
                if (!Array.isArray(message.frozenSupply))
                    return "frozenSupply: array expected";
                for (var i = 0; i < message.frozenSupply.length; ++i) {
                    var error = $root.protocol.Account.Frozen.verify(message.frozenSupply[i]);
                    if (error)
                        return "frozenSupply." + error;
                }
            }
            if (message.assetIssuedName != null && message.hasOwnProperty("assetIssuedName"))
                if (!(message.assetIssuedName && typeof message.assetIssuedName.length === "number" || $util.isString(message.assetIssuedName)))
                    return "assetIssuedName: buffer expected";
            if (message.assetIssued_ID != null && message.hasOwnProperty("assetIssued_ID"))
                if (!(message.assetIssued_ID && typeof message.assetIssued_ID.length === "number" || $util.isString(message.assetIssued_ID)))
                    return "assetIssued_ID: buffer expected";
            if (message.latestAssetOperationTime != null && message.hasOwnProperty("latestAssetOperationTime")) {
                if (!$util.isObject(message.latestAssetOperationTime))
                    return "latestAssetOperationTime: object expected";
                var key = Object.keys(message.latestAssetOperationTime);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.latestAssetOperationTime[key[i]]) && !(message.latestAssetOperationTime[key[i]] && $util.isInteger(message.latestAssetOperationTime[key[i]].low) && $util.isInteger(message.latestAssetOperationTime[key[i]].high)))
                        return "latestAssetOperationTime: integer|Long{k:string} expected";
            }
            if (message.latestAssetOperationTimeV2 != null && message.hasOwnProperty("latestAssetOperationTimeV2")) {
                if (!$util.isObject(message.latestAssetOperationTimeV2))
                    return "latestAssetOperationTimeV2: object expected";
                var key = Object.keys(message.latestAssetOperationTimeV2);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.latestAssetOperationTimeV2[key[i]]) && !(message.latestAssetOperationTimeV2[key[i]] && $util.isInteger(message.latestAssetOperationTimeV2[key[i]].low) && $util.isInteger(message.latestAssetOperationTimeV2[key[i]].high)))
                        return "latestAssetOperationTimeV2: integer|Long{k:string} expected";
            }
            if (message.freeNetUsage != null && message.hasOwnProperty("freeNetUsage"))
                if (!$util.isInteger(message.freeNetUsage) && !(message.freeNetUsage && $util.isInteger(message.freeNetUsage.low) && $util.isInteger(message.freeNetUsage.high)))
                    return "freeNetUsage: integer|Long expected";
            if (message.freeAssetNetUsage != null && message.hasOwnProperty("freeAssetNetUsage")) {
                if (!$util.isObject(message.freeAssetNetUsage))
                    return "freeAssetNetUsage: object expected";
                var key = Object.keys(message.freeAssetNetUsage);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.freeAssetNetUsage[key[i]]) && !(message.freeAssetNetUsage[key[i]] && $util.isInteger(message.freeAssetNetUsage[key[i]].low) && $util.isInteger(message.freeAssetNetUsage[key[i]].high)))
                        return "freeAssetNetUsage: integer|Long{k:string} expected";
            }
            if (message.freeAssetNetUsageV2 != null && message.hasOwnProperty("freeAssetNetUsageV2")) {
                if (!$util.isObject(message.freeAssetNetUsageV2))
                    return "freeAssetNetUsageV2: object expected";
                var key = Object.keys(message.freeAssetNetUsageV2);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.freeAssetNetUsageV2[key[i]]) && !(message.freeAssetNetUsageV2[key[i]] && $util.isInteger(message.freeAssetNetUsageV2[key[i]].low) && $util.isInteger(message.freeAssetNetUsageV2[key[i]].high)))
                        return "freeAssetNetUsageV2: integer|Long{k:string} expected";
            }
            if (message.latestConsumeTime != null && message.hasOwnProperty("latestConsumeTime"))
                if (!$util.isInteger(message.latestConsumeTime) && !(message.latestConsumeTime && $util.isInteger(message.latestConsumeTime.low) && $util.isInteger(message.latestConsumeTime.high)))
                    return "latestConsumeTime: integer|Long expected";
            if (message.latestConsumeFreeTime != null && message.hasOwnProperty("latestConsumeFreeTime"))
                if (!$util.isInteger(message.latestConsumeFreeTime) && !(message.latestConsumeFreeTime && $util.isInteger(message.latestConsumeFreeTime.low) && $util.isInteger(message.latestConsumeFreeTime.high)))
                    return "latestConsumeFreeTime: integer|Long expected";
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                    return "accountId: buffer expected";
            if (message.accountResource != null && message.hasOwnProperty("accountResource")) {
                var error = $root.protocol.Account.AccountResource.verify(message.accountResource);
                if (error)
                    return "accountResource." + error;
            }
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                if (!(message.codeHash && typeof message.codeHash.length === "number" || $util.isString(message.codeHash)))
                    return "codeHash: buffer expected";
            if (message.ownerPermission != null && message.hasOwnProperty("ownerPermission")) {
                var error = $root.protocol.Permission.verify(message.ownerPermission);
                if (error)
                    return "ownerPermission." + error;
            }
            if (message.witnessPermission != null && message.hasOwnProperty("witnessPermission")) {
                var error = $root.protocol.Permission.verify(message.witnessPermission);
                if (error)
                    return "witnessPermission." + error;
            }
            if (message.activePermission != null && message.hasOwnProperty("activePermission")) {
                if (!Array.isArray(message.activePermission))
                    return "activePermission: array expected";
                for (var i = 0; i < message.activePermission.length; ++i) {
                    var error = $root.protocol.Permission.verify(message.activePermission[i]);
                    if (error)
                        return "activePermission." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Account message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Account
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Account} Account
         */
        Account.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Account)
                return object;
            var message = new $root.protocol.Account();
            if (object.accountName != null)
                if (typeof object.accountName === "string")
                    $util.base64.decode(object.accountName, message.accountName = $util.newBuffer($util.base64.length(object.accountName)), 0);
                else if (object.accountName.length)
                    message.accountName = object.accountName;
            switch (object.type) {
            case "Normal":
            case 0:
                message.type = 0;
                break;
            case "AssetIssue":
            case 1:
                message.type = 1;
                break;
            case "Contract":
            case 2:
                message.type = 2;
                break;
            }
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.balance != null)
                if ($util.Long)
                    (message.balance = $util.Long.fromValue(object.balance)).unsigned = false;
                else if (typeof object.balance === "string")
                    message.balance = parseInt(object.balance, 10);
                else if (typeof object.balance === "number")
                    message.balance = object.balance;
                else if (typeof object.balance === "object")
                    message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber();
            if (object.votes) {
                if (!Array.isArray(object.votes))
                    throw TypeError(".protocol.Account.votes: array expected");
                message.votes = [];
                for (var i = 0; i < object.votes.length; ++i) {
                    if (typeof object.votes[i] !== "object")
                        throw TypeError(".protocol.Account.votes: object expected");
                    message.votes[i] = $root.protocol.Vote.fromObject(object.votes[i]);
                }
            }
            if (object.asset) {
                if (typeof object.asset !== "object")
                    throw TypeError(".protocol.Account.asset: object expected");
                message.asset = {};
                for (var keys = Object.keys(object.asset), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.asset[keys[i]] = $util.Long.fromValue(object.asset[keys[i]])).unsigned = false;
                    else if (typeof object.asset[keys[i]] === "string")
                        message.asset[keys[i]] = parseInt(object.asset[keys[i]], 10);
                    else if (typeof object.asset[keys[i]] === "number")
                        message.asset[keys[i]] = object.asset[keys[i]];
                    else if (typeof object.asset[keys[i]] === "object")
                        message.asset[keys[i]] = new $util.LongBits(object.asset[keys[i]].low >>> 0, object.asset[keys[i]].high >>> 0).toNumber();
            }
            if (object.assetV2) {
                if (typeof object.assetV2 !== "object")
                    throw TypeError(".protocol.Account.assetV2: object expected");
                message.assetV2 = {};
                for (var keys = Object.keys(object.assetV2), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.assetV2[keys[i]] = $util.Long.fromValue(object.assetV2[keys[i]])).unsigned = false;
                    else if (typeof object.assetV2[keys[i]] === "string")
                        message.assetV2[keys[i]] = parseInt(object.assetV2[keys[i]], 10);
                    else if (typeof object.assetV2[keys[i]] === "number")
                        message.assetV2[keys[i]] = object.assetV2[keys[i]];
                    else if (typeof object.assetV2[keys[i]] === "object")
                        message.assetV2[keys[i]] = new $util.LongBits(object.assetV2[keys[i]].low >>> 0, object.assetV2[keys[i]].high >>> 0).toNumber();
            }
            if (object.frozen) {
                if (!Array.isArray(object.frozen))
                    throw TypeError(".protocol.Account.frozen: array expected");
                message.frozen = [];
                for (var i = 0; i < object.frozen.length; ++i) {
                    if (typeof object.frozen[i] !== "object")
                        throw TypeError(".protocol.Account.frozen: object expected");
                    message.frozen[i] = $root.protocol.Account.Frozen.fromObject(object.frozen[i]);
                }
            }
            if (object.netUsage != null)
                if ($util.Long)
                    (message.netUsage = $util.Long.fromValue(object.netUsage)).unsigned = false;
                else if (typeof object.netUsage === "string")
                    message.netUsage = parseInt(object.netUsage, 10);
                else if (typeof object.netUsage === "number")
                    message.netUsage = object.netUsage;
                else if (typeof object.netUsage === "object")
                    message.netUsage = new $util.LongBits(object.netUsage.low >>> 0, object.netUsage.high >>> 0).toNumber();
            if (object.acquiredDelegatedFrozenBalanceForBandwidth != null)
                if ($util.Long)
                    (message.acquiredDelegatedFrozenBalanceForBandwidth = $util.Long.fromValue(object.acquiredDelegatedFrozenBalanceForBandwidth)).unsigned = false;
                else if (typeof object.acquiredDelegatedFrozenBalanceForBandwidth === "string")
                    message.acquiredDelegatedFrozenBalanceForBandwidth = parseInt(object.acquiredDelegatedFrozenBalanceForBandwidth, 10);
                else if (typeof object.acquiredDelegatedFrozenBalanceForBandwidth === "number")
                    message.acquiredDelegatedFrozenBalanceForBandwidth = object.acquiredDelegatedFrozenBalanceForBandwidth;
                else if (typeof object.acquiredDelegatedFrozenBalanceForBandwidth === "object")
                    message.acquiredDelegatedFrozenBalanceForBandwidth = new $util.LongBits(object.acquiredDelegatedFrozenBalanceForBandwidth.low >>> 0, object.acquiredDelegatedFrozenBalanceForBandwidth.high >>> 0).toNumber();
            if (object.delegatedFrozenBalanceForBandwidth != null)
                if ($util.Long)
                    (message.delegatedFrozenBalanceForBandwidth = $util.Long.fromValue(object.delegatedFrozenBalanceForBandwidth)).unsigned = false;
                else if (typeof object.delegatedFrozenBalanceForBandwidth === "string")
                    message.delegatedFrozenBalanceForBandwidth = parseInt(object.delegatedFrozenBalanceForBandwidth, 10);
                else if (typeof object.delegatedFrozenBalanceForBandwidth === "number")
                    message.delegatedFrozenBalanceForBandwidth = object.delegatedFrozenBalanceForBandwidth;
                else if (typeof object.delegatedFrozenBalanceForBandwidth === "object")
                    message.delegatedFrozenBalanceForBandwidth = new $util.LongBits(object.delegatedFrozenBalanceForBandwidth.low >>> 0, object.delegatedFrozenBalanceForBandwidth.high >>> 0).toNumber();
            if (object.createTime != null)
                if ($util.Long)
                    (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = false;
                else if (typeof object.createTime === "string")
                    message.createTime = parseInt(object.createTime, 10);
                else if (typeof object.createTime === "number")
                    message.createTime = object.createTime;
                else if (typeof object.createTime === "object")
                    message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber();
            if (object.latestOprationTime != null)
                if ($util.Long)
                    (message.latestOprationTime = $util.Long.fromValue(object.latestOprationTime)).unsigned = false;
                else if (typeof object.latestOprationTime === "string")
                    message.latestOprationTime = parseInt(object.latestOprationTime, 10);
                else if (typeof object.latestOprationTime === "number")
                    message.latestOprationTime = object.latestOprationTime;
                else if (typeof object.latestOprationTime === "object")
                    message.latestOprationTime = new $util.LongBits(object.latestOprationTime.low >>> 0, object.latestOprationTime.high >>> 0).toNumber();
            if (object.allowance != null)
                if ($util.Long)
                    (message.allowance = $util.Long.fromValue(object.allowance)).unsigned = false;
                else if (typeof object.allowance === "string")
                    message.allowance = parseInt(object.allowance, 10);
                else if (typeof object.allowance === "number")
                    message.allowance = object.allowance;
                else if (typeof object.allowance === "object")
                    message.allowance = new $util.LongBits(object.allowance.low >>> 0, object.allowance.high >>> 0).toNumber();
            if (object.latestWithdrawTime != null)
                if ($util.Long)
                    (message.latestWithdrawTime = $util.Long.fromValue(object.latestWithdrawTime)).unsigned = false;
                else if (typeof object.latestWithdrawTime === "string")
                    message.latestWithdrawTime = parseInt(object.latestWithdrawTime, 10);
                else if (typeof object.latestWithdrawTime === "number")
                    message.latestWithdrawTime = object.latestWithdrawTime;
                else if (typeof object.latestWithdrawTime === "object")
                    message.latestWithdrawTime = new $util.LongBits(object.latestWithdrawTime.low >>> 0, object.latestWithdrawTime.high >>> 0).toNumber();
            if (object.code != null)
                if (typeof object.code === "string")
                    $util.base64.decode(object.code, message.code = $util.newBuffer($util.base64.length(object.code)), 0);
                else if (object.code.length)
                    message.code = object.code;
            if (object.isWitness != null)
                message.isWitness = Boolean(object.isWitness);
            if (object.isCommittee != null)
                message.isCommittee = Boolean(object.isCommittee);
            if (object.frozenSupply) {
                if (!Array.isArray(object.frozenSupply))
                    throw TypeError(".protocol.Account.frozenSupply: array expected");
                message.frozenSupply = [];
                for (var i = 0; i < object.frozenSupply.length; ++i) {
                    if (typeof object.frozenSupply[i] !== "object")
                        throw TypeError(".protocol.Account.frozenSupply: object expected");
                    message.frozenSupply[i] = $root.protocol.Account.Frozen.fromObject(object.frozenSupply[i]);
                }
            }
            if (object.assetIssuedName != null)
                if (typeof object.assetIssuedName === "string")
                    $util.base64.decode(object.assetIssuedName, message.assetIssuedName = $util.newBuffer($util.base64.length(object.assetIssuedName)), 0);
                else if (object.assetIssuedName.length)
                    message.assetIssuedName = object.assetIssuedName;
            if (object.assetIssued_ID != null)
                if (typeof object.assetIssued_ID === "string")
                    $util.base64.decode(object.assetIssued_ID, message.assetIssued_ID = $util.newBuffer($util.base64.length(object.assetIssued_ID)), 0);
                else if (object.assetIssued_ID.length)
                    message.assetIssued_ID = object.assetIssued_ID;
            if (object.latestAssetOperationTime) {
                if (typeof object.latestAssetOperationTime !== "object")
                    throw TypeError(".protocol.Account.latestAssetOperationTime: object expected");
                message.latestAssetOperationTime = {};
                for (var keys = Object.keys(object.latestAssetOperationTime), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.latestAssetOperationTime[keys[i]] = $util.Long.fromValue(object.latestAssetOperationTime[keys[i]])).unsigned = false;
                    else if (typeof object.latestAssetOperationTime[keys[i]] === "string")
                        message.latestAssetOperationTime[keys[i]] = parseInt(object.latestAssetOperationTime[keys[i]], 10);
                    else if (typeof object.latestAssetOperationTime[keys[i]] === "number")
                        message.latestAssetOperationTime[keys[i]] = object.latestAssetOperationTime[keys[i]];
                    else if (typeof object.latestAssetOperationTime[keys[i]] === "object")
                        message.latestAssetOperationTime[keys[i]] = new $util.LongBits(object.latestAssetOperationTime[keys[i]].low >>> 0, object.latestAssetOperationTime[keys[i]].high >>> 0).toNumber();
            }
            if (object.latestAssetOperationTimeV2) {
                if (typeof object.latestAssetOperationTimeV2 !== "object")
                    throw TypeError(".protocol.Account.latestAssetOperationTimeV2: object expected");
                message.latestAssetOperationTimeV2 = {};
                for (var keys = Object.keys(object.latestAssetOperationTimeV2), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.latestAssetOperationTimeV2[keys[i]] = $util.Long.fromValue(object.latestAssetOperationTimeV2[keys[i]])).unsigned = false;
                    else if (typeof object.latestAssetOperationTimeV2[keys[i]] === "string")
                        message.latestAssetOperationTimeV2[keys[i]] = parseInt(object.latestAssetOperationTimeV2[keys[i]], 10);
                    else if (typeof object.latestAssetOperationTimeV2[keys[i]] === "number")
                        message.latestAssetOperationTimeV2[keys[i]] = object.latestAssetOperationTimeV2[keys[i]];
                    else if (typeof object.latestAssetOperationTimeV2[keys[i]] === "object")
                        message.latestAssetOperationTimeV2[keys[i]] = new $util.LongBits(object.latestAssetOperationTimeV2[keys[i]].low >>> 0, object.latestAssetOperationTimeV2[keys[i]].high >>> 0).toNumber();
            }
            if (object.freeNetUsage != null)
                if ($util.Long)
                    (message.freeNetUsage = $util.Long.fromValue(object.freeNetUsage)).unsigned = false;
                else if (typeof object.freeNetUsage === "string")
                    message.freeNetUsage = parseInt(object.freeNetUsage, 10);
                else if (typeof object.freeNetUsage === "number")
                    message.freeNetUsage = object.freeNetUsage;
                else if (typeof object.freeNetUsage === "object")
                    message.freeNetUsage = new $util.LongBits(object.freeNetUsage.low >>> 0, object.freeNetUsage.high >>> 0).toNumber();
            if (object.freeAssetNetUsage) {
                if (typeof object.freeAssetNetUsage !== "object")
                    throw TypeError(".protocol.Account.freeAssetNetUsage: object expected");
                message.freeAssetNetUsage = {};
                for (var keys = Object.keys(object.freeAssetNetUsage), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.freeAssetNetUsage[keys[i]] = $util.Long.fromValue(object.freeAssetNetUsage[keys[i]])).unsigned = false;
                    else if (typeof object.freeAssetNetUsage[keys[i]] === "string")
                        message.freeAssetNetUsage[keys[i]] = parseInt(object.freeAssetNetUsage[keys[i]], 10);
                    else if (typeof object.freeAssetNetUsage[keys[i]] === "number")
                        message.freeAssetNetUsage[keys[i]] = object.freeAssetNetUsage[keys[i]];
                    else if (typeof object.freeAssetNetUsage[keys[i]] === "object")
                        message.freeAssetNetUsage[keys[i]] = new $util.LongBits(object.freeAssetNetUsage[keys[i]].low >>> 0, object.freeAssetNetUsage[keys[i]].high >>> 0).toNumber();
            }
            if (object.freeAssetNetUsageV2) {
                if (typeof object.freeAssetNetUsageV2 !== "object")
                    throw TypeError(".protocol.Account.freeAssetNetUsageV2: object expected");
                message.freeAssetNetUsageV2 = {};
                for (var keys = Object.keys(object.freeAssetNetUsageV2), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.freeAssetNetUsageV2[keys[i]] = $util.Long.fromValue(object.freeAssetNetUsageV2[keys[i]])).unsigned = false;
                    else if (typeof object.freeAssetNetUsageV2[keys[i]] === "string")
                        message.freeAssetNetUsageV2[keys[i]] = parseInt(object.freeAssetNetUsageV2[keys[i]], 10);
                    else if (typeof object.freeAssetNetUsageV2[keys[i]] === "number")
                        message.freeAssetNetUsageV2[keys[i]] = object.freeAssetNetUsageV2[keys[i]];
                    else if (typeof object.freeAssetNetUsageV2[keys[i]] === "object")
                        message.freeAssetNetUsageV2[keys[i]] = new $util.LongBits(object.freeAssetNetUsageV2[keys[i]].low >>> 0, object.freeAssetNetUsageV2[keys[i]].high >>> 0).toNumber();
            }
            if (object.latestConsumeTime != null)
                if ($util.Long)
                    (message.latestConsumeTime = $util.Long.fromValue(object.latestConsumeTime)).unsigned = false;
                else if (typeof object.latestConsumeTime === "string")
                    message.latestConsumeTime = parseInt(object.latestConsumeTime, 10);
                else if (typeof object.latestConsumeTime === "number")
                    message.latestConsumeTime = object.latestConsumeTime;
                else if (typeof object.latestConsumeTime === "object")
                    message.latestConsumeTime = new $util.LongBits(object.latestConsumeTime.low >>> 0, object.latestConsumeTime.high >>> 0).toNumber();
            if (object.latestConsumeFreeTime != null)
                if ($util.Long)
                    (message.latestConsumeFreeTime = $util.Long.fromValue(object.latestConsumeFreeTime)).unsigned = false;
                else if (typeof object.latestConsumeFreeTime === "string")
                    message.latestConsumeFreeTime = parseInt(object.latestConsumeFreeTime, 10);
                else if (typeof object.latestConsumeFreeTime === "number")
                    message.latestConsumeFreeTime = object.latestConsumeFreeTime;
                else if (typeof object.latestConsumeFreeTime === "object")
                    message.latestConsumeFreeTime = new $util.LongBits(object.latestConsumeFreeTime.low >>> 0, object.latestConsumeFreeTime.high >>> 0).toNumber();
            if (object.accountId != null)
                if (typeof object.accountId === "string")
                    $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                else if (object.accountId.length)
                    message.accountId = object.accountId;
            if (object.accountResource != null) {
                if (typeof object.accountResource !== "object")
                    throw TypeError(".protocol.Account.accountResource: object expected");
                message.accountResource = $root.protocol.Account.AccountResource.fromObject(object.accountResource);
            }
            if (object.codeHash != null)
                if (typeof object.codeHash === "string")
                    $util.base64.decode(object.codeHash, message.codeHash = $util.newBuffer($util.base64.length(object.codeHash)), 0);
                else if (object.codeHash.length)
                    message.codeHash = object.codeHash;
            if (object.ownerPermission != null) {
                if (typeof object.ownerPermission !== "object")
                    throw TypeError(".protocol.Account.ownerPermission: object expected");
                message.ownerPermission = $root.protocol.Permission.fromObject(object.ownerPermission);
            }
            if (object.witnessPermission != null) {
                if (typeof object.witnessPermission !== "object")
                    throw TypeError(".protocol.Account.witnessPermission: object expected");
                message.witnessPermission = $root.protocol.Permission.fromObject(object.witnessPermission);
            }
            if (object.activePermission) {
                if (!Array.isArray(object.activePermission))
                    throw TypeError(".protocol.Account.activePermission: array expected");
                message.activePermission = [];
                for (var i = 0; i < object.activePermission.length; ++i) {
                    if (typeof object.activePermission[i] !== "object")
                        throw TypeError(".protocol.Account.activePermission: object expected");
                    message.activePermission[i] = $root.protocol.Permission.fromObject(object.activePermission[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Account message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Account
         * @static
         * @param {protocol.Account} message Account
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Account.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.votes = [];
                object.frozen = [];
                object.frozenSupply = [];
                object.activePermission = [];
            }
            if (options.objects || options.defaults) {
                object.asset = {};
                object.latestAssetOperationTime = {};
                object.freeAssetNetUsage = {};
                object.assetV2 = {};
                object.latestAssetOperationTimeV2 = {};
                object.freeAssetNetUsageV2 = {};
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.accountName = "";
                else {
                    object.accountName = [];
                    if (options.bytes !== Array)
                        object.accountName = $util.newBuffer(object.accountName);
                }
                object.type = options.enums === String ? "Normal" : 0;
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.balance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.netUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.netUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestOprationTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestOprationTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.allowance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.allowance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestWithdrawTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestWithdrawTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.code = "";
                else {
                    object.code = [];
                    if (options.bytes !== Array)
                        object.code = $util.newBuffer(object.code);
                }
                object.isWitness = false;
                object.isCommittee = false;
                if (options.bytes === String)
                    object.assetIssuedName = "";
                else {
                    object.assetIssuedName = [];
                    if (options.bytes !== Array)
                        object.assetIssuedName = $util.newBuffer(object.assetIssuedName);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.freeNetUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.freeNetUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestConsumeTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestConsumeTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestConsumeFreeTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestConsumeFreeTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.accountId = "";
                else {
                    object.accountId = [];
                    if (options.bytes !== Array)
                        object.accountId = $util.newBuffer(object.accountId);
                }
                object.accountResource = null;
                if (options.bytes === String)
                    object.codeHash = "";
                else {
                    object.codeHash = [];
                    if (options.bytes !== Array)
                        object.codeHash = $util.newBuffer(object.codeHash);
                }
                object.ownerPermission = null;
                object.witnessPermission = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.acquiredDelegatedFrozenBalanceForBandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.acquiredDelegatedFrozenBalanceForBandwidth = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.delegatedFrozenBalanceForBandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.delegatedFrozenBalanceForBandwidth = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.assetIssued_ID = "";
                else {
                    object.assetIssued_ID = [];
                    if (options.bytes !== Array)
                        object.assetIssued_ID = $util.newBuffer(object.assetIssued_ID);
                }
            }
            if (message.accountName != null && message.hasOwnProperty("accountName"))
                object.accountName = options.bytes === String ? $util.base64.encode(message.accountName, 0, message.accountName.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountName) : message.accountName;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.AccountType[message.type] : message.type;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (typeof message.balance === "number")
                    object.balance = options.longs === String ? String(message.balance) : message.balance;
                else
                    object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber() : message.balance;
            if (message.votes && message.votes.length) {
                object.votes = [];
                for (var j = 0; j < message.votes.length; ++j)
                    object.votes[j] = $root.protocol.Vote.toObject(message.votes[j], options);
            }
            var keys2;
            if (message.asset && (keys2 = Object.keys(message.asset)).length) {
                object.asset = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.asset[keys2[j]] === "number")
                        object.asset[keys2[j]] = options.longs === String ? String(message.asset[keys2[j]]) : message.asset[keys2[j]];
                    else
                        object.asset[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.asset[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.asset[keys2[j]].low >>> 0, message.asset[keys2[j]].high >>> 0).toNumber() : message.asset[keys2[j]];
            }
            if (message.frozen && message.frozen.length) {
                object.frozen = [];
                for (var j = 0; j < message.frozen.length; ++j)
                    object.frozen[j] = $root.protocol.Account.Frozen.toObject(message.frozen[j], options);
            }
            if (message.netUsage != null && message.hasOwnProperty("netUsage"))
                if (typeof message.netUsage === "number")
                    object.netUsage = options.longs === String ? String(message.netUsage) : message.netUsage;
                else
                    object.netUsage = options.longs === String ? $util.Long.prototype.toString.call(message.netUsage) : options.longs === Number ? new $util.LongBits(message.netUsage.low >>> 0, message.netUsage.high >>> 0).toNumber() : message.netUsage;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (typeof message.createTime === "number")
                    object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                else
                    object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber() : message.createTime;
            if (message.latestOprationTime != null && message.hasOwnProperty("latestOprationTime"))
                if (typeof message.latestOprationTime === "number")
                    object.latestOprationTime = options.longs === String ? String(message.latestOprationTime) : message.latestOprationTime;
                else
                    object.latestOprationTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestOprationTime) : options.longs === Number ? new $util.LongBits(message.latestOprationTime.low >>> 0, message.latestOprationTime.high >>> 0).toNumber() : message.latestOprationTime;
            if (message.allowance != null && message.hasOwnProperty("allowance"))
                if (typeof message.allowance === "number")
                    object.allowance = options.longs === String ? String(message.allowance) : message.allowance;
                else
                    object.allowance = options.longs === String ? $util.Long.prototype.toString.call(message.allowance) : options.longs === Number ? new $util.LongBits(message.allowance.low >>> 0, message.allowance.high >>> 0).toNumber() : message.allowance;
            if (message.latestWithdrawTime != null && message.hasOwnProperty("latestWithdrawTime"))
                if (typeof message.latestWithdrawTime === "number")
                    object.latestWithdrawTime = options.longs === String ? String(message.latestWithdrawTime) : message.latestWithdrawTime;
                else
                    object.latestWithdrawTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestWithdrawTime) : options.longs === Number ? new $util.LongBits(message.latestWithdrawTime.low >>> 0, message.latestWithdrawTime.high >>> 0).toNumber() : message.latestWithdrawTime;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = options.bytes === String ? $util.base64.encode(message.code, 0, message.code.length) : options.bytes === Array ? Array.prototype.slice.call(message.code) : message.code;
            if (message.isWitness != null && message.hasOwnProperty("isWitness"))
                object.isWitness = message.isWitness;
            if (message.isCommittee != null && message.hasOwnProperty("isCommittee"))
                object.isCommittee = message.isCommittee;
            if (message.frozenSupply && message.frozenSupply.length) {
                object.frozenSupply = [];
                for (var j = 0; j < message.frozenSupply.length; ++j)
                    object.frozenSupply[j] = $root.protocol.Account.Frozen.toObject(message.frozenSupply[j], options);
            }
            if (message.assetIssuedName != null && message.hasOwnProperty("assetIssuedName"))
                object.assetIssuedName = options.bytes === String ? $util.base64.encode(message.assetIssuedName, 0, message.assetIssuedName.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetIssuedName) : message.assetIssuedName;
            if (message.latestAssetOperationTime && (keys2 = Object.keys(message.latestAssetOperationTime)).length) {
                object.latestAssetOperationTime = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.latestAssetOperationTime[keys2[j]] === "number")
                        object.latestAssetOperationTime[keys2[j]] = options.longs === String ? String(message.latestAssetOperationTime[keys2[j]]) : message.latestAssetOperationTime[keys2[j]];
                    else
                        object.latestAssetOperationTime[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.latestAssetOperationTime[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.latestAssetOperationTime[keys2[j]].low >>> 0, message.latestAssetOperationTime[keys2[j]].high >>> 0).toNumber() : message.latestAssetOperationTime[keys2[j]];
            }
            if (message.freeNetUsage != null && message.hasOwnProperty("freeNetUsage"))
                if (typeof message.freeNetUsage === "number")
                    object.freeNetUsage = options.longs === String ? String(message.freeNetUsage) : message.freeNetUsage;
                else
                    object.freeNetUsage = options.longs === String ? $util.Long.prototype.toString.call(message.freeNetUsage) : options.longs === Number ? new $util.LongBits(message.freeNetUsage.low >>> 0, message.freeNetUsage.high >>> 0).toNumber() : message.freeNetUsage;
            if (message.freeAssetNetUsage && (keys2 = Object.keys(message.freeAssetNetUsage)).length) {
                object.freeAssetNetUsage = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.freeAssetNetUsage[keys2[j]] === "number")
                        object.freeAssetNetUsage[keys2[j]] = options.longs === String ? String(message.freeAssetNetUsage[keys2[j]]) : message.freeAssetNetUsage[keys2[j]];
                    else
                        object.freeAssetNetUsage[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.freeAssetNetUsage[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.freeAssetNetUsage[keys2[j]].low >>> 0, message.freeAssetNetUsage[keys2[j]].high >>> 0).toNumber() : message.freeAssetNetUsage[keys2[j]];
            }
            if (message.latestConsumeTime != null && message.hasOwnProperty("latestConsumeTime"))
                if (typeof message.latestConsumeTime === "number")
                    object.latestConsumeTime = options.longs === String ? String(message.latestConsumeTime) : message.latestConsumeTime;
                else
                    object.latestConsumeTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestConsumeTime) : options.longs === Number ? new $util.LongBits(message.latestConsumeTime.low >>> 0, message.latestConsumeTime.high >>> 0).toNumber() : message.latestConsumeTime;
            if (message.latestConsumeFreeTime != null && message.hasOwnProperty("latestConsumeFreeTime"))
                if (typeof message.latestConsumeFreeTime === "number")
                    object.latestConsumeFreeTime = options.longs === String ? String(message.latestConsumeFreeTime) : message.latestConsumeFreeTime;
                else
                    object.latestConsumeFreeTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestConsumeFreeTime) : options.longs === Number ? new $util.LongBits(message.latestConsumeFreeTime.low >>> 0, message.latestConsumeFreeTime.high >>> 0).toNumber() : message.latestConsumeFreeTime;
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
            if (message.accountResource != null && message.hasOwnProperty("accountResource"))
                object.accountResource = $root.protocol.Account.AccountResource.toObject(message.accountResource, options);
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                object.codeHash = options.bytes === String ? $util.base64.encode(message.codeHash, 0, message.codeHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.codeHash) : message.codeHash;
            if (message.ownerPermission != null && message.hasOwnProperty("ownerPermission"))
                object.ownerPermission = $root.protocol.Permission.toObject(message.ownerPermission, options);
            if (message.witnessPermission != null && message.hasOwnProperty("witnessPermission"))
                object.witnessPermission = $root.protocol.Permission.toObject(message.witnessPermission, options);
            if (message.activePermission && message.activePermission.length) {
                object.activePermission = [];
                for (var j = 0; j < message.activePermission.length; ++j)
                    object.activePermission[j] = $root.protocol.Permission.toObject(message.activePermission[j], options);
            }
            if (message.acquiredDelegatedFrozenBalanceForBandwidth != null && message.hasOwnProperty("acquiredDelegatedFrozenBalanceForBandwidth"))
                if (typeof message.acquiredDelegatedFrozenBalanceForBandwidth === "number")
                    object.acquiredDelegatedFrozenBalanceForBandwidth = options.longs === String ? String(message.acquiredDelegatedFrozenBalanceForBandwidth) : message.acquiredDelegatedFrozenBalanceForBandwidth;
                else
                    object.acquiredDelegatedFrozenBalanceForBandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.acquiredDelegatedFrozenBalanceForBandwidth) : options.longs === Number ? new $util.LongBits(message.acquiredDelegatedFrozenBalanceForBandwidth.low >>> 0, message.acquiredDelegatedFrozenBalanceForBandwidth.high >>> 0).toNumber() : message.acquiredDelegatedFrozenBalanceForBandwidth;
            if (message.delegatedFrozenBalanceForBandwidth != null && message.hasOwnProperty("delegatedFrozenBalanceForBandwidth"))
                if (typeof message.delegatedFrozenBalanceForBandwidth === "number")
                    object.delegatedFrozenBalanceForBandwidth = options.longs === String ? String(message.delegatedFrozenBalanceForBandwidth) : message.delegatedFrozenBalanceForBandwidth;
                else
                    object.delegatedFrozenBalanceForBandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.delegatedFrozenBalanceForBandwidth) : options.longs === Number ? new $util.LongBits(message.delegatedFrozenBalanceForBandwidth.low >>> 0, message.delegatedFrozenBalanceForBandwidth.high >>> 0).toNumber() : message.delegatedFrozenBalanceForBandwidth;
            if (message.assetV2 && (keys2 = Object.keys(message.assetV2)).length) {
                object.assetV2 = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.assetV2[keys2[j]] === "number")
                        object.assetV2[keys2[j]] = options.longs === String ? String(message.assetV2[keys2[j]]) : message.assetV2[keys2[j]];
                    else
                        object.assetV2[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.assetV2[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.assetV2[keys2[j]].low >>> 0, message.assetV2[keys2[j]].high >>> 0).toNumber() : message.assetV2[keys2[j]];
            }
            if (message.assetIssued_ID != null && message.hasOwnProperty("assetIssued_ID"))
                object.assetIssued_ID = options.bytes === String ? $util.base64.encode(message.assetIssued_ID, 0, message.assetIssued_ID.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetIssued_ID) : message.assetIssued_ID;
            if (message.latestAssetOperationTimeV2 && (keys2 = Object.keys(message.latestAssetOperationTimeV2)).length) {
                object.latestAssetOperationTimeV2 = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.latestAssetOperationTimeV2[keys2[j]] === "number")
                        object.latestAssetOperationTimeV2[keys2[j]] = options.longs === String ? String(message.latestAssetOperationTimeV2[keys2[j]]) : message.latestAssetOperationTimeV2[keys2[j]];
                    else
                        object.latestAssetOperationTimeV2[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.latestAssetOperationTimeV2[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.latestAssetOperationTimeV2[keys2[j]].low >>> 0, message.latestAssetOperationTimeV2[keys2[j]].high >>> 0).toNumber() : message.latestAssetOperationTimeV2[keys2[j]];
            }
            if (message.freeAssetNetUsageV2 && (keys2 = Object.keys(message.freeAssetNetUsageV2)).length) {
                object.freeAssetNetUsageV2 = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.freeAssetNetUsageV2[keys2[j]] === "number")
                        object.freeAssetNetUsageV2[keys2[j]] = options.longs === String ? String(message.freeAssetNetUsageV2[keys2[j]]) : message.freeAssetNetUsageV2[keys2[j]];
                    else
                        object.freeAssetNetUsageV2[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.freeAssetNetUsageV2[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.freeAssetNetUsageV2[keys2[j]].low >>> 0, message.freeAssetNetUsageV2[keys2[j]].high >>> 0).toNumber() : message.freeAssetNetUsageV2[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this Account to JSON.
         * @function toJSON
         * @memberof protocol.Account
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Account.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Account.Frozen = (function() {

            /**
             * Properties of a Frozen.
             * @memberof protocol.Account
             * @interface IFrozen
             * @property {number|Long|null} [frozenBalance] Frozen frozenBalance
             * @property {number|Long|null} [expireTime] Frozen expireTime
             */

            /**
             * Constructs a new Frozen.
             * @memberof protocol.Account
             * @classdesc Represents a Frozen.
             * @implements IFrozen
             * @constructor
             * @param {protocol.Account.IFrozen=} [properties] Properties to set
             */
            function Frozen(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Frozen frozenBalance.
             * @member {number|Long} frozenBalance
             * @memberof protocol.Account.Frozen
             * @instance
             */
            Frozen.prototype.frozenBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Frozen expireTime.
             * @member {number|Long} expireTime
             * @memberof protocol.Account.Frozen
             * @instance
             */
            Frozen.prototype.expireTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Frozen instance using the specified properties.
             * @function create
             * @memberof protocol.Account.Frozen
             * @static
             * @param {protocol.Account.IFrozen=} [properties] Properties to set
             * @returns {protocol.Account.Frozen} Frozen instance
             */
            Frozen.create = function create(properties) {
                return new Frozen(properties);
            };

            /**
             * Encodes the specified Frozen message. Does not implicitly {@link protocol.Account.Frozen.verify|verify} messages.
             * @function encode
             * @memberof protocol.Account.Frozen
             * @static
             * @param {protocol.Account.IFrozen} message Frozen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Frozen.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frozenBalance != null && Object.hasOwnProperty.call(message, "frozenBalance"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.frozenBalance);
                if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expireTime);
                return writer;
            };

            /**
             * Encodes the specified Frozen message, length delimited. Does not implicitly {@link protocol.Account.Frozen.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.Account.Frozen
             * @static
             * @param {protocol.Account.IFrozen} message Frozen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Frozen.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Frozen message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.Account.Frozen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.Account.Frozen} Frozen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Frozen.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Account.Frozen();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.frozenBalance = reader.int64();
                        break;
                    case 2:
                        message.expireTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Frozen message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.Account.Frozen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.Account.Frozen} Frozen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Frozen.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Frozen message.
             * @function verify
             * @memberof protocol.Account.Frozen
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Frozen.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.frozenBalance != null && message.hasOwnProperty("frozenBalance"))
                    if (!$util.isInteger(message.frozenBalance) && !(message.frozenBalance && $util.isInteger(message.frozenBalance.low) && $util.isInteger(message.frozenBalance.high)))
                        return "frozenBalance: integer|Long expected";
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    if (!$util.isInteger(message.expireTime) && !(message.expireTime && $util.isInteger(message.expireTime.low) && $util.isInteger(message.expireTime.high)))
                        return "expireTime: integer|Long expected";
                return null;
            };

            /**
             * Creates a Frozen message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.Account.Frozen
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.Account.Frozen} Frozen
             */
            Frozen.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Account.Frozen)
                    return object;
                var message = new $root.protocol.Account.Frozen();
                if (object.frozenBalance != null)
                    if ($util.Long)
                        (message.frozenBalance = $util.Long.fromValue(object.frozenBalance)).unsigned = false;
                    else if (typeof object.frozenBalance === "string")
                        message.frozenBalance = parseInt(object.frozenBalance, 10);
                    else if (typeof object.frozenBalance === "number")
                        message.frozenBalance = object.frozenBalance;
                    else if (typeof object.frozenBalance === "object")
                        message.frozenBalance = new $util.LongBits(object.frozenBalance.low >>> 0, object.frozenBalance.high >>> 0).toNumber();
                if (object.expireTime != null)
                    if ($util.Long)
                        (message.expireTime = $util.Long.fromValue(object.expireTime)).unsigned = false;
                    else if (typeof object.expireTime === "string")
                        message.expireTime = parseInt(object.expireTime, 10);
                    else if (typeof object.expireTime === "number")
                        message.expireTime = object.expireTime;
                    else if (typeof object.expireTime === "object")
                        message.expireTime = new $util.LongBits(object.expireTime.low >>> 0, object.expireTime.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Frozen message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.Account.Frozen
             * @static
             * @param {protocol.Account.Frozen} message Frozen
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Frozen.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.frozenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.frozenBalance = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expireTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expireTime = options.longs === String ? "0" : 0;
                }
                if (message.frozenBalance != null && message.hasOwnProperty("frozenBalance"))
                    if (typeof message.frozenBalance === "number")
                        object.frozenBalance = options.longs === String ? String(message.frozenBalance) : message.frozenBalance;
                    else
                        object.frozenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.frozenBalance) : options.longs === Number ? new $util.LongBits(message.frozenBalance.low >>> 0, message.frozenBalance.high >>> 0).toNumber() : message.frozenBalance;
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    if (typeof message.expireTime === "number")
                        object.expireTime = options.longs === String ? String(message.expireTime) : message.expireTime;
                    else
                        object.expireTime = options.longs === String ? $util.Long.prototype.toString.call(message.expireTime) : options.longs === Number ? new $util.LongBits(message.expireTime.low >>> 0, message.expireTime.high >>> 0).toNumber() : message.expireTime;
                return object;
            };

            /**
             * Converts this Frozen to JSON.
             * @function toJSON
             * @memberof protocol.Account.Frozen
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Frozen.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Frozen;
        })();

        Account.AccountResource = (function() {

            /**
             * Properties of an AccountResource.
             * @memberof protocol.Account
             * @interface IAccountResource
             * @property {number|Long|null} [energyUsage] AccountResource energyUsage
             * @property {protocol.Account.IFrozen|null} [frozenBalanceForEnergy] AccountResource frozenBalanceForEnergy
             * @property {number|Long|null} [latestConsumeTimeForEnergy] AccountResource latestConsumeTimeForEnergy
             * @property {number|Long|null} [acquiredDelegatedFrozenBalanceForEnergy] AccountResource acquiredDelegatedFrozenBalanceForEnergy
             * @property {number|Long|null} [delegatedFrozenBalanceForEnergy] AccountResource delegatedFrozenBalanceForEnergy
             * @property {number|Long|null} [storageLimit] AccountResource storageLimit
             * @property {number|Long|null} [storageUsage] AccountResource storageUsage
             * @property {number|Long|null} [latestExchangeStorageTime] AccountResource latestExchangeStorageTime
             */

            /**
             * Constructs a new AccountResource.
             * @memberof protocol.Account
             * @classdesc Represents an AccountResource.
             * @implements IAccountResource
             * @constructor
             * @param {protocol.Account.IAccountResource=} [properties] Properties to set
             */
            function AccountResource(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AccountResource energyUsage.
             * @member {number|Long} energyUsage
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.energyUsage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource frozenBalanceForEnergy.
             * @member {protocol.Account.IFrozen|null|undefined} frozenBalanceForEnergy
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.frozenBalanceForEnergy = null;

            /**
             * AccountResource latestConsumeTimeForEnergy.
             * @member {number|Long} latestConsumeTimeForEnergy
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.latestConsumeTimeForEnergy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource acquiredDelegatedFrozenBalanceForEnergy.
             * @member {number|Long} acquiredDelegatedFrozenBalanceForEnergy
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.acquiredDelegatedFrozenBalanceForEnergy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource delegatedFrozenBalanceForEnergy.
             * @member {number|Long} delegatedFrozenBalanceForEnergy
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.delegatedFrozenBalanceForEnergy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource storageLimit.
             * @member {number|Long} storageLimit
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.storageLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource storageUsage.
             * @member {number|Long} storageUsage
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.storageUsage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource latestExchangeStorageTime.
             * @member {number|Long} latestExchangeStorageTime
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.latestExchangeStorageTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new AccountResource instance using the specified properties.
             * @function create
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {protocol.Account.IAccountResource=} [properties] Properties to set
             * @returns {protocol.Account.AccountResource} AccountResource instance
             */
            AccountResource.create = function create(properties) {
                return new AccountResource(properties);
            };

            /**
             * Encodes the specified AccountResource message. Does not implicitly {@link protocol.Account.AccountResource.verify|verify} messages.
             * @function encode
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {protocol.Account.IAccountResource} message AccountResource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountResource.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.energyUsage != null && Object.hasOwnProperty.call(message, "energyUsage"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.energyUsage);
                if (message.frozenBalanceForEnergy != null && Object.hasOwnProperty.call(message, "frozenBalanceForEnergy"))
                    $root.protocol.Account.Frozen.encode(message.frozenBalanceForEnergy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.latestConsumeTimeForEnergy != null && Object.hasOwnProperty.call(message, "latestConsumeTimeForEnergy"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.latestConsumeTimeForEnergy);
                if (message.acquiredDelegatedFrozenBalanceForEnergy != null && Object.hasOwnProperty.call(message, "acquiredDelegatedFrozenBalanceForEnergy"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.acquiredDelegatedFrozenBalanceForEnergy);
                if (message.delegatedFrozenBalanceForEnergy != null && Object.hasOwnProperty.call(message, "delegatedFrozenBalanceForEnergy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.delegatedFrozenBalanceForEnergy);
                if (message.storageLimit != null && Object.hasOwnProperty.call(message, "storageLimit"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.storageLimit);
                if (message.storageUsage != null && Object.hasOwnProperty.call(message, "storageUsage"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.storageUsage);
                if (message.latestExchangeStorageTime != null && Object.hasOwnProperty.call(message, "latestExchangeStorageTime"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.latestExchangeStorageTime);
                return writer;
            };

            /**
             * Encodes the specified AccountResource message, length delimited. Does not implicitly {@link protocol.Account.AccountResource.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {protocol.Account.IAccountResource} message AccountResource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountResource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccountResource message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.Account.AccountResource} AccountResource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountResource.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Account.AccountResource();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.energyUsage = reader.int64();
                        break;
                    case 2:
                        message.frozenBalanceForEnergy = $root.protocol.Account.Frozen.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.latestConsumeTimeForEnergy = reader.int64();
                        break;
                    case 4:
                        message.acquiredDelegatedFrozenBalanceForEnergy = reader.int64();
                        break;
                    case 5:
                        message.delegatedFrozenBalanceForEnergy = reader.int64();
                        break;
                    case 6:
                        message.storageLimit = reader.int64();
                        break;
                    case 7:
                        message.storageUsage = reader.int64();
                        break;
                    case 8:
                        message.latestExchangeStorageTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccountResource message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.Account.AccountResource} AccountResource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountResource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccountResource message.
             * @function verify
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccountResource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.energyUsage != null && message.hasOwnProperty("energyUsage"))
                    if (!$util.isInteger(message.energyUsage) && !(message.energyUsage && $util.isInteger(message.energyUsage.low) && $util.isInteger(message.energyUsage.high)))
                        return "energyUsage: integer|Long expected";
                if (message.frozenBalanceForEnergy != null && message.hasOwnProperty("frozenBalanceForEnergy")) {
                    var error = $root.protocol.Account.Frozen.verify(message.frozenBalanceForEnergy);
                    if (error)
                        return "frozenBalanceForEnergy." + error;
                }
                if (message.latestConsumeTimeForEnergy != null && message.hasOwnProperty("latestConsumeTimeForEnergy"))
                    if (!$util.isInteger(message.latestConsumeTimeForEnergy) && !(message.latestConsumeTimeForEnergy && $util.isInteger(message.latestConsumeTimeForEnergy.low) && $util.isInteger(message.latestConsumeTimeForEnergy.high)))
                        return "latestConsumeTimeForEnergy: integer|Long expected";
                if (message.acquiredDelegatedFrozenBalanceForEnergy != null && message.hasOwnProperty("acquiredDelegatedFrozenBalanceForEnergy"))
                    if (!$util.isInteger(message.acquiredDelegatedFrozenBalanceForEnergy) && !(message.acquiredDelegatedFrozenBalanceForEnergy && $util.isInteger(message.acquiredDelegatedFrozenBalanceForEnergy.low) && $util.isInteger(message.acquiredDelegatedFrozenBalanceForEnergy.high)))
                        return "acquiredDelegatedFrozenBalanceForEnergy: integer|Long expected";
                if (message.delegatedFrozenBalanceForEnergy != null && message.hasOwnProperty("delegatedFrozenBalanceForEnergy"))
                    if (!$util.isInteger(message.delegatedFrozenBalanceForEnergy) && !(message.delegatedFrozenBalanceForEnergy && $util.isInteger(message.delegatedFrozenBalanceForEnergy.low) && $util.isInteger(message.delegatedFrozenBalanceForEnergy.high)))
                        return "delegatedFrozenBalanceForEnergy: integer|Long expected";
                if (message.storageLimit != null && message.hasOwnProperty("storageLimit"))
                    if (!$util.isInteger(message.storageLimit) && !(message.storageLimit && $util.isInteger(message.storageLimit.low) && $util.isInteger(message.storageLimit.high)))
                        return "storageLimit: integer|Long expected";
                if (message.storageUsage != null && message.hasOwnProperty("storageUsage"))
                    if (!$util.isInteger(message.storageUsage) && !(message.storageUsage && $util.isInteger(message.storageUsage.low) && $util.isInteger(message.storageUsage.high)))
                        return "storageUsage: integer|Long expected";
                if (message.latestExchangeStorageTime != null && message.hasOwnProperty("latestExchangeStorageTime"))
                    if (!$util.isInteger(message.latestExchangeStorageTime) && !(message.latestExchangeStorageTime && $util.isInteger(message.latestExchangeStorageTime.low) && $util.isInteger(message.latestExchangeStorageTime.high)))
                        return "latestExchangeStorageTime: integer|Long expected";
                return null;
            };

            /**
             * Creates an AccountResource message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.Account.AccountResource} AccountResource
             */
            AccountResource.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Account.AccountResource)
                    return object;
                var message = new $root.protocol.Account.AccountResource();
                if (object.energyUsage != null)
                    if ($util.Long)
                        (message.energyUsage = $util.Long.fromValue(object.energyUsage)).unsigned = false;
                    else if (typeof object.energyUsage === "string")
                        message.energyUsage = parseInt(object.energyUsage, 10);
                    else if (typeof object.energyUsage === "number")
                        message.energyUsage = object.energyUsage;
                    else if (typeof object.energyUsage === "object")
                        message.energyUsage = new $util.LongBits(object.energyUsage.low >>> 0, object.energyUsage.high >>> 0).toNumber();
                if (object.frozenBalanceForEnergy != null) {
                    if (typeof object.frozenBalanceForEnergy !== "object")
                        throw TypeError(".protocol.Account.AccountResource.frozenBalanceForEnergy: object expected");
                    message.frozenBalanceForEnergy = $root.protocol.Account.Frozen.fromObject(object.frozenBalanceForEnergy);
                }
                if (object.latestConsumeTimeForEnergy != null)
                    if ($util.Long)
                        (message.latestConsumeTimeForEnergy = $util.Long.fromValue(object.latestConsumeTimeForEnergy)).unsigned = false;
                    else if (typeof object.latestConsumeTimeForEnergy === "string")
                        message.latestConsumeTimeForEnergy = parseInt(object.latestConsumeTimeForEnergy, 10);
                    else if (typeof object.latestConsumeTimeForEnergy === "number")
                        message.latestConsumeTimeForEnergy = object.latestConsumeTimeForEnergy;
                    else if (typeof object.latestConsumeTimeForEnergy === "object")
                        message.latestConsumeTimeForEnergy = new $util.LongBits(object.latestConsumeTimeForEnergy.low >>> 0, object.latestConsumeTimeForEnergy.high >>> 0).toNumber();
                if (object.acquiredDelegatedFrozenBalanceForEnergy != null)
                    if ($util.Long)
                        (message.acquiredDelegatedFrozenBalanceForEnergy = $util.Long.fromValue(object.acquiredDelegatedFrozenBalanceForEnergy)).unsigned = false;
                    else if (typeof object.acquiredDelegatedFrozenBalanceForEnergy === "string")
                        message.acquiredDelegatedFrozenBalanceForEnergy = parseInt(object.acquiredDelegatedFrozenBalanceForEnergy, 10);
                    else if (typeof object.acquiredDelegatedFrozenBalanceForEnergy === "number")
                        message.acquiredDelegatedFrozenBalanceForEnergy = object.acquiredDelegatedFrozenBalanceForEnergy;
                    else if (typeof object.acquiredDelegatedFrozenBalanceForEnergy === "object")
                        message.acquiredDelegatedFrozenBalanceForEnergy = new $util.LongBits(object.acquiredDelegatedFrozenBalanceForEnergy.low >>> 0, object.acquiredDelegatedFrozenBalanceForEnergy.high >>> 0).toNumber();
                if (object.delegatedFrozenBalanceForEnergy != null)
                    if ($util.Long)
                        (message.delegatedFrozenBalanceForEnergy = $util.Long.fromValue(object.delegatedFrozenBalanceForEnergy)).unsigned = false;
                    else if (typeof object.delegatedFrozenBalanceForEnergy === "string")
                        message.delegatedFrozenBalanceForEnergy = parseInt(object.delegatedFrozenBalanceForEnergy, 10);
                    else if (typeof object.delegatedFrozenBalanceForEnergy === "number")
                        message.delegatedFrozenBalanceForEnergy = object.delegatedFrozenBalanceForEnergy;
                    else if (typeof object.delegatedFrozenBalanceForEnergy === "object")
                        message.delegatedFrozenBalanceForEnergy = new $util.LongBits(object.delegatedFrozenBalanceForEnergy.low >>> 0, object.delegatedFrozenBalanceForEnergy.high >>> 0).toNumber();
                if (object.storageLimit != null)
                    if ($util.Long)
                        (message.storageLimit = $util.Long.fromValue(object.storageLimit)).unsigned = false;
                    else if (typeof object.storageLimit === "string")
                        message.storageLimit = parseInt(object.storageLimit, 10);
                    else if (typeof object.storageLimit === "number")
                        message.storageLimit = object.storageLimit;
                    else if (typeof object.storageLimit === "object")
                        message.storageLimit = new $util.LongBits(object.storageLimit.low >>> 0, object.storageLimit.high >>> 0).toNumber();
                if (object.storageUsage != null)
                    if ($util.Long)
                        (message.storageUsage = $util.Long.fromValue(object.storageUsage)).unsigned = false;
                    else if (typeof object.storageUsage === "string")
                        message.storageUsage = parseInt(object.storageUsage, 10);
                    else if (typeof object.storageUsage === "number")
                        message.storageUsage = object.storageUsage;
                    else if (typeof object.storageUsage === "object")
                        message.storageUsage = new $util.LongBits(object.storageUsage.low >>> 0, object.storageUsage.high >>> 0).toNumber();
                if (object.latestExchangeStorageTime != null)
                    if ($util.Long)
                        (message.latestExchangeStorageTime = $util.Long.fromValue(object.latestExchangeStorageTime)).unsigned = false;
                    else if (typeof object.latestExchangeStorageTime === "string")
                        message.latestExchangeStorageTime = parseInt(object.latestExchangeStorageTime, 10);
                    else if (typeof object.latestExchangeStorageTime === "number")
                        message.latestExchangeStorageTime = object.latestExchangeStorageTime;
                    else if (typeof object.latestExchangeStorageTime === "object")
                        message.latestExchangeStorageTime = new $util.LongBits(object.latestExchangeStorageTime.low >>> 0, object.latestExchangeStorageTime.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an AccountResource message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {protocol.Account.AccountResource} message AccountResource
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccountResource.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.energyUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.energyUsage = options.longs === String ? "0" : 0;
                    object.frozenBalanceForEnergy = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.latestConsumeTimeForEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.latestConsumeTimeForEnergy = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.acquiredDelegatedFrozenBalanceForEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.acquiredDelegatedFrozenBalanceForEnergy = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.delegatedFrozenBalanceForEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.delegatedFrozenBalanceForEnergy = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.storageLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.storageLimit = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.storageUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.storageUsage = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.latestExchangeStorageTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.latestExchangeStorageTime = options.longs === String ? "0" : 0;
                }
                if (message.energyUsage != null && message.hasOwnProperty("energyUsage"))
                    if (typeof message.energyUsage === "number")
                        object.energyUsage = options.longs === String ? String(message.energyUsage) : message.energyUsage;
                    else
                        object.energyUsage = options.longs === String ? $util.Long.prototype.toString.call(message.energyUsage) : options.longs === Number ? new $util.LongBits(message.energyUsage.low >>> 0, message.energyUsage.high >>> 0).toNumber() : message.energyUsage;
                if (message.frozenBalanceForEnergy != null && message.hasOwnProperty("frozenBalanceForEnergy"))
                    object.frozenBalanceForEnergy = $root.protocol.Account.Frozen.toObject(message.frozenBalanceForEnergy, options);
                if (message.latestConsumeTimeForEnergy != null && message.hasOwnProperty("latestConsumeTimeForEnergy"))
                    if (typeof message.latestConsumeTimeForEnergy === "number")
                        object.latestConsumeTimeForEnergy = options.longs === String ? String(message.latestConsumeTimeForEnergy) : message.latestConsumeTimeForEnergy;
                    else
                        object.latestConsumeTimeForEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.latestConsumeTimeForEnergy) : options.longs === Number ? new $util.LongBits(message.latestConsumeTimeForEnergy.low >>> 0, message.latestConsumeTimeForEnergy.high >>> 0).toNumber() : message.latestConsumeTimeForEnergy;
                if (message.acquiredDelegatedFrozenBalanceForEnergy != null && message.hasOwnProperty("acquiredDelegatedFrozenBalanceForEnergy"))
                    if (typeof message.acquiredDelegatedFrozenBalanceForEnergy === "number")
                        object.acquiredDelegatedFrozenBalanceForEnergy = options.longs === String ? String(message.acquiredDelegatedFrozenBalanceForEnergy) : message.acquiredDelegatedFrozenBalanceForEnergy;
                    else
                        object.acquiredDelegatedFrozenBalanceForEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.acquiredDelegatedFrozenBalanceForEnergy) : options.longs === Number ? new $util.LongBits(message.acquiredDelegatedFrozenBalanceForEnergy.low >>> 0, message.acquiredDelegatedFrozenBalanceForEnergy.high >>> 0).toNumber() : message.acquiredDelegatedFrozenBalanceForEnergy;
                if (message.delegatedFrozenBalanceForEnergy != null && message.hasOwnProperty("delegatedFrozenBalanceForEnergy"))
                    if (typeof message.delegatedFrozenBalanceForEnergy === "number")
                        object.delegatedFrozenBalanceForEnergy = options.longs === String ? String(message.delegatedFrozenBalanceForEnergy) : message.delegatedFrozenBalanceForEnergy;
                    else
                        object.delegatedFrozenBalanceForEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.delegatedFrozenBalanceForEnergy) : options.longs === Number ? new $util.LongBits(message.delegatedFrozenBalanceForEnergy.low >>> 0, message.delegatedFrozenBalanceForEnergy.high >>> 0).toNumber() : message.delegatedFrozenBalanceForEnergy;
                if (message.storageLimit != null && message.hasOwnProperty("storageLimit"))
                    if (typeof message.storageLimit === "number")
                        object.storageLimit = options.longs === String ? String(message.storageLimit) : message.storageLimit;
                    else
                        object.storageLimit = options.longs === String ? $util.Long.prototype.toString.call(message.storageLimit) : options.longs === Number ? new $util.LongBits(message.storageLimit.low >>> 0, message.storageLimit.high >>> 0).toNumber() : message.storageLimit;
                if (message.storageUsage != null && message.hasOwnProperty("storageUsage"))
                    if (typeof message.storageUsage === "number")
                        object.storageUsage = options.longs === String ? String(message.storageUsage) : message.storageUsage;
                    else
                        object.storageUsage = options.longs === String ? $util.Long.prototype.toString.call(message.storageUsage) : options.longs === Number ? new $util.LongBits(message.storageUsage.low >>> 0, message.storageUsage.high >>> 0).toNumber() : message.storageUsage;
                if (message.latestExchangeStorageTime != null && message.hasOwnProperty("latestExchangeStorageTime"))
                    if (typeof message.latestExchangeStorageTime === "number")
                        object.latestExchangeStorageTime = options.longs === String ? String(message.latestExchangeStorageTime) : message.latestExchangeStorageTime;
                    else
                        object.latestExchangeStorageTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestExchangeStorageTime) : options.longs === Number ? new $util.LongBits(message.latestExchangeStorageTime.low >>> 0, message.latestExchangeStorageTime.high >>> 0).toNumber() : message.latestExchangeStorageTime;
                return object;
            };

            /**
             * Converts this AccountResource to JSON.
             * @function toJSON
             * @memberof protocol.Account.AccountResource
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccountResource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AccountResource;
        })();

        return Account;
    })();

    protocol.Key = (function() {

        /**
         * Properties of a Key.
         * @memberof protocol
         * @interface IKey
         * @property {Uint8Array|null} [address] Key address
         * @property {number|Long|null} [weight] Key weight
         */

        /**
         * Constructs a new Key.
         * @memberof protocol
         * @classdesc Represents a Key.
         * @implements IKey
         * @constructor
         * @param {protocol.IKey=} [properties] Properties to set
         */
        function Key(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Key address.
         * @member {Uint8Array} address
         * @memberof protocol.Key
         * @instance
         */
        Key.prototype.address = $util.newBuffer([]);

        /**
         * Key weight.
         * @member {number|Long} weight
         * @memberof protocol.Key
         * @instance
         */
        Key.prototype.weight = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Key instance using the specified properties.
         * @function create
         * @memberof protocol.Key
         * @static
         * @param {protocol.IKey=} [properties] Properties to set
         * @returns {protocol.Key} Key instance
         */
        Key.create = function create(properties) {
            return new Key(properties);
        };

        /**
         * Encodes the specified Key message. Does not implicitly {@link protocol.Key.verify|verify} messages.
         * @function encode
         * @memberof protocol.Key
         * @static
         * @param {protocol.IKey} message Key message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Key.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.weight);
            return writer;
        };

        /**
         * Encodes the specified Key message, length delimited. Does not implicitly {@link protocol.Key.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Key
         * @static
         * @param {protocol.IKey} message Key message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Key.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Key message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Key
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Key} Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Key.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Key();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.weight = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Key message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Key
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Key} Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Key.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Key message.
         * @function verify
         * @memberof protocol.Key
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Key.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight) && !(message.weight && $util.isInteger(message.weight.low) && $util.isInteger(message.weight.high)))
                    return "weight: integer|Long expected";
            return null;
        };

        /**
         * Creates a Key message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Key
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Key} Key
         */
        Key.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Key)
                return object;
            var message = new $root.protocol.Key();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.weight != null)
                if ($util.Long)
                    (message.weight = $util.Long.fromValue(object.weight)).unsigned = false;
                else if (typeof object.weight === "string")
                    message.weight = parseInt(object.weight, 10);
                else if (typeof object.weight === "number")
                    message.weight = object.weight;
                else if (typeof object.weight === "object")
                    message.weight = new $util.LongBits(object.weight.low >>> 0, object.weight.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Key message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Key
         * @static
         * @param {protocol.Key} message Key
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Key.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.weight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.weight = options.longs === String ? "0" : 0;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (typeof message.weight === "number")
                    object.weight = options.longs === String ? String(message.weight) : message.weight;
                else
                    object.weight = options.longs === String ? $util.Long.prototype.toString.call(message.weight) : options.longs === Number ? new $util.LongBits(message.weight.low >>> 0, message.weight.high >>> 0).toNumber() : message.weight;
            return object;
        };

        /**
         * Converts this Key to JSON.
         * @function toJSON
         * @memberof protocol.Key
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Key.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Key;
    })();

    protocol.DelegatedResource = (function() {

        /**
         * Properties of a DelegatedResource.
         * @memberof protocol
         * @interface IDelegatedResource
         * @property {Uint8Array|null} [from] DelegatedResource from
         * @property {Uint8Array|null} [to] DelegatedResource to
         * @property {number|Long|null} [frozenBalanceForBandwidth] DelegatedResource frozenBalanceForBandwidth
         * @property {number|Long|null} [frozenBalanceForEnergy] DelegatedResource frozenBalanceForEnergy
         * @property {number|Long|null} [expireTimeForBandwidth] DelegatedResource expireTimeForBandwidth
         * @property {number|Long|null} [expireTimeForEnergy] DelegatedResource expireTimeForEnergy
         */

        /**
         * Constructs a new DelegatedResource.
         * @memberof protocol
         * @classdesc Represents a DelegatedResource.
         * @implements IDelegatedResource
         * @constructor
         * @param {protocol.IDelegatedResource=} [properties] Properties to set
         */
        function DelegatedResource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedResource from.
         * @member {Uint8Array} from
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.from = $util.newBuffer([]);

        /**
         * DelegatedResource to.
         * @member {Uint8Array} to
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.to = $util.newBuffer([]);

        /**
         * DelegatedResource frozenBalanceForBandwidth.
         * @member {number|Long} frozenBalanceForBandwidth
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.frozenBalanceForBandwidth = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DelegatedResource frozenBalanceForEnergy.
         * @member {number|Long} frozenBalanceForEnergy
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.frozenBalanceForEnergy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DelegatedResource expireTimeForBandwidth.
         * @member {number|Long} expireTimeForBandwidth
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.expireTimeForBandwidth = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DelegatedResource expireTimeForEnergy.
         * @member {number|Long} expireTimeForEnergy
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.expireTimeForEnergy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DelegatedResource instance using the specified properties.
         * @function create
         * @memberof protocol.DelegatedResource
         * @static
         * @param {protocol.IDelegatedResource=} [properties] Properties to set
         * @returns {protocol.DelegatedResource} DelegatedResource instance
         */
        DelegatedResource.create = function create(properties) {
            return new DelegatedResource(properties);
        };

        /**
         * Encodes the specified DelegatedResource message. Does not implicitly {@link protocol.DelegatedResource.verify|verify} messages.
         * @function encode
         * @memberof protocol.DelegatedResource
         * @static
         * @param {protocol.IDelegatedResource} message DelegatedResource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedResource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.to);
            if (message.frozenBalanceForBandwidth != null && Object.hasOwnProperty.call(message, "frozenBalanceForBandwidth"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.frozenBalanceForBandwidth);
            if (message.frozenBalanceForEnergy != null && Object.hasOwnProperty.call(message, "frozenBalanceForEnergy"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.frozenBalanceForEnergy);
            if (message.expireTimeForBandwidth != null && Object.hasOwnProperty.call(message, "expireTimeForBandwidth"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expireTimeForBandwidth);
            if (message.expireTimeForEnergy != null && Object.hasOwnProperty.call(message, "expireTimeForEnergy"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.expireTimeForEnergy);
            return writer;
        };

        /**
         * Encodes the specified DelegatedResource message, length delimited. Does not implicitly {@link protocol.DelegatedResource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.DelegatedResource
         * @static
         * @param {protocol.IDelegatedResource} message DelegatedResource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedResource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedResource message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.DelegatedResource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.DelegatedResource} DelegatedResource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedResource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DelegatedResource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = reader.bytes();
                    break;
                case 2:
                    message.to = reader.bytes();
                    break;
                case 3:
                    message.frozenBalanceForBandwidth = reader.int64();
                    break;
                case 4:
                    message.frozenBalanceForEnergy = reader.int64();
                    break;
                case 5:
                    message.expireTimeForBandwidth = reader.int64();
                    break;
                case 6:
                    message.expireTimeForEnergy = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedResource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.DelegatedResource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.DelegatedResource} DelegatedResource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedResource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedResource message.
         * @function verify
         * @memberof protocol.DelegatedResource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedResource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                    return "from: buffer expected";
            if (message.to != null && message.hasOwnProperty("to"))
                if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                    return "to: buffer expected";
            if (message.frozenBalanceForBandwidth != null && message.hasOwnProperty("frozenBalanceForBandwidth"))
                if (!$util.isInteger(message.frozenBalanceForBandwidth) && !(message.frozenBalanceForBandwidth && $util.isInteger(message.frozenBalanceForBandwidth.low) && $util.isInteger(message.frozenBalanceForBandwidth.high)))
                    return "frozenBalanceForBandwidth: integer|Long expected";
            if (message.frozenBalanceForEnergy != null && message.hasOwnProperty("frozenBalanceForEnergy"))
                if (!$util.isInteger(message.frozenBalanceForEnergy) && !(message.frozenBalanceForEnergy && $util.isInteger(message.frozenBalanceForEnergy.low) && $util.isInteger(message.frozenBalanceForEnergy.high)))
                    return "frozenBalanceForEnergy: integer|Long expected";
            if (message.expireTimeForBandwidth != null && message.hasOwnProperty("expireTimeForBandwidth"))
                if (!$util.isInteger(message.expireTimeForBandwidth) && !(message.expireTimeForBandwidth && $util.isInteger(message.expireTimeForBandwidth.low) && $util.isInteger(message.expireTimeForBandwidth.high)))
                    return "expireTimeForBandwidth: integer|Long expected";
            if (message.expireTimeForEnergy != null && message.hasOwnProperty("expireTimeForEnergy"))
                if (!$util.isInteger(message.expireTimeForEnergy) && !(message.expireTimeForEnergy && $util.isInteger(message.expireTimeForEnergy.low) && $util.isInteger(message.expireTimeForEnergy.high)))
                    return "expireTimeForEnergy: integer|Long expected";
            return null;
        };

        /**
         * Creates a DelegatedResource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.DelegatedResource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.DelegatedResource} DelegatedResource
         */
        DelegatedResource.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DelegatedResource)
                return object;
            var message = new $root.protocol.DelegatedResource();
            if (object.from != null)
                if (typeof object.from === "string")
                    $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                else if (object.from.length)
                    message.from = object.from;
            if (object.to != null)
                if (typeof object.to === "string")
                    $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                else if (object.to.length)
                    message.to = object.to;
            if (object.frozenBalanceForBandwidth != null)
                if ($util.Long)
                    (message.frozenBalanceForBandwidth = $util.Long.fromValue(object.frozenBalanceForBandwidth)).unsigned = false;
                else if (typeof object.frozenBalanceForBandwidth === "string")
                    message.frozenBalanceForBandwidth = parseInt(object.frozenBalanceForBandwidth, 10);
                else if (typeof object.frozenBalanceForBandwidth === "number")
                    message.frozenBalanceForBandwidth = object.frozenBalanceForBandwidth;
                else if (typeof object.frozenBalanceForBandwidth === "object")
                    message.frozenBalanceForBandwidth = new $util.LongBits(object.frozenBalanceForBandwidth.low >>> 0, object.frozenBalanceForBandwidth.high >>> 0).toNumber();
            if (object.frozenBalanceForEnergy != null)
                if ($util.Long)
                    (message.frozenBalanceForEnergy = $util.Long.fromValue(object.frozenBalanceForEnergy)).unsigned = false;
                else if (typeof object.frozenBalanceForEnergy === "string")
                    message.frozenBalanceForEnergy = parseInt(object.frozenBalanceForEnergy, 10);
                else if (typeof object.frozenBalanceForEnergy === "number")
                    message.frozenBalanceForEnergy = object.frozenBalanceForEnergy;
                else if (typeof object.frozenBalanceForEnergy === "object")
                    message.frozenBalanceForEnergy = new $util.LongBits(object.frozenBalanceForEnergy.low >>> 0, object.frozenBalanceForEnergy.high >>> 0).toNumber();
            if (object.expireTimeForBandwidth != null)
                if ($util.Long)
                    (message.expireTimeForBandwidth = $util.Long.fromValue(object.expireTimeForBandwidth)).unsigned = false;
                else if (typeof object.expireTimeForBandwidth === "string")
                    message.expireTimeForBandwidth = parseInt(object.expireTimeForBandwidth, 10);
                else if (typeof object.expireTimeForBandwidth === "number")
                    message.expireTimeForBandwidth = object.expireTimeForBandwidth;
                else if (typeof object.expireTimeForBandwidth === "object")
                    message.expireTimeForBandwidth = new $util.LongBits(object.expireTimeForBandwidth.low >>> 0, object.expireTimeForBandwidth.high >>> 0).toNumber();
            if (object.expireTimeForEnergy != null)
                if ($util.Long)
                    (message.expireTimeForEnergy = $util.Long.fromValue(object.expireTimeForEnergy)).unsigned = false;
                else if (typeof object.expireTimeForEnergy === "string")
                    message.expireTimeForEnergy = parseInt(object.expireTimeForEnergy, 10);
                else if (typeof object.expireTimeForEnergy === "number")
                    message.expireTimeForEnergy = object.expireTimeForEnergy;
                else if (typeof object.expireTimeForEnergy === "object")
                    message.expireTimeForEnergy = new $util.LongBits(object.expireTimeForEnergy.low >>> 0, object.expireTimeForEnergy.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DelegatedResource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.DelegatedResource
         * @static
         * @param {protocol.DelegatedResource} message DelegatedResource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedResource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.from = "";
                else {
                    object.from = [];
                    if (options.bytes !== Array)
                        object.from = $util.newBuffer(object.from);
                }
                if (options.bytes === String)
                    object.to = "";
                else {
                    object.to = [];
                    if (options.bytes !== Array)
                        object.to = $util.newBuffer(object.to);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozenBalanceForBandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.frozenBalanceForBandwidth = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozenBalanceForEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.frozenBalanceForEnergy = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expireTimeForBandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expireTimeForBandwidth = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expireTimeForEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expireTimeForEnergy = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
            if (message.to != null && message.hasOwnProperty("to"))
                object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
            if (message.frozenBalanceForBandwidth != null && message.hasOwnProperty("frozenBalanceForBandwidth"))
                if (typeof message.frozenBalanceForBandwidth === "number")
                    object.frozenBalanceForBandwidth = options.longs === String ? String(message.frozenBalanceForBandwidth) : message.frozenBalanceForBandwidth;
                else
                    object.frozenBalanceForBandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.frozenBalanceForBandwidth) : options.longs === Number ? new $util.LongBits(message.frozenBalanceForBandwidth.low >>> 0, message.frozenBalanceForBandwidth.high >>> 0).toNumber() : message.frozenBalanceForBandwidth;
            if (message.frozenBalanceForEnergy != null && message.hasOwnProperty("frozenBalanceForEnergy"))
                if (typeof message.frozenBalanceForEnergy === "number")
                    object.frozenBalanceForEnergy = options.longs === String ? String(message.frozenBalanceForEnergy) : message.frozenBalanceForEnergy;
                else
                    object.frozenBalanceForEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.frozenBalanceForEnergy) : options.longs === Number ? new $util.LongBits(message.frozenBalanceForEnergy.low >>> 0, message.frozenBalanceForEnergy.high >>> 0).toNumber() : message.frozenBalanceForEnergy;
            if (message.expireTimeForBandwidth != null && message.hasOwnProperty("expireTimeForBandwidth"))
                if (typeof message.expireTimeForBandwidth === "number")
                    object.expireTimeForBandwidth = options.longs === String ? String(message.expireTimeForBandwidth) : message.expireTimeForBandwidth;
                else
                    object.expireTimeForBandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.expireTimeForBandwidth) : options.longs === Number ? new $util.LongBits(message.expireTimeForBandwidth.low >>> 0, message.expireTimeForBandwidth.high >>> 0).toNumber() : message.expireTimeForBandwidth;
            if (message.expireTimeForEnergy != null && message.hasOwnProperty("expireTimeForEnergy"))
                if (typeof message.expireTimeForEnergy === "number")
                    object.expireTimeForEnergy = options.longs === String ? String(message.expireTimeForEnergy) : message.expireTimeForEnergy;
                else
                    object.expireTimeForEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.expireTimeForEnergy) : options.longs === Number ? new $util.LongBits(message.expireTimeForEnergy.low >>> 0, message.expireTimeForEnergy.high >>> 0).toNumber() : message.expireTimeForEnergy;
            return object;
        };

        /**
         * Converts this DelegatedResource to JSON.
         * @function toJSON
         * @memberof protocol.DelegatedResource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedResource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedResource;
    })();

    protocol.authority = (function() {

        /**
         * Properties of an authority.
         * @memberof protocol
         * @interface Iauthority
         * @property {protocol.IAccountId|null} [account] authority account
         * @property {Uint8Array|null} [permissionName] authority permissionName
         */

        /**
         * Constructs a new authority.
         * @memberof protocol
         * @classdesc Represents an authority.
         * @implements Iauthority
         * @constructor
         * @param {protocol.Iauthority=} [properties] Properties to set
         */
        function authority(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * authority account.
         * @member {protocol.IAccountId|null|undefined} account
         * @memberof protocol.authority
         * @instance
         */
        authority.prototype.account = null;

        /**
         * authority permissionName.
         * @member {Uint8Array} permissionName
         * @memberof protocol.authority
         * @instance
         */
        authority.prototype.permissionName = $util.newBuffer([]);

        /**
         * Creates a new authority instance using the specified properties.
         * @function create
         * @memberof protocol.authority
         * @static
         * @param {protocol.Iauthority=} [properties] Properties to set
         * @returns {protocol.authority} authority instance
         */
        authority.create = function create(properties) {
            return new authority(properties);
        };

        /**
         * Encodes the specified authority message. Does not implicitly {@link protocol.authority.verify|verify} messages.
         * @function encode
         * @memberof protocol.authority
         * @static
         * @param {protocol.Iauthority} message authority message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        authority.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                $root.protocol.AccountId.encode(message.account, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.permissionName != null && Object.hasOwnProperty.call(message, "permissionName"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.permissionName);
            return writer;
        };

        /**
         * Encodes the specified authority message, length delimited. Does not implicitly {@link protocol.authority.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.authority
         * @static
         * @param {protocol.Iauthority} message authority message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        authority.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an authority message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.authority
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.authority} authority
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        authority.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.authority();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = $root.protocol.AccountId.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.permissionName = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an authority message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.authority
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.authority} authority
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        authority.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an authority message.
         * @function verify
         * @memberof protocol.authority
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        authority.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account")) {
                var error = $root.protocol.AccountId.verify(message.account);
                if (error)
                    return "account." + error;
            }
            if (message.permissionName != null && message.hasOwnProperty("permissionName"))
                if (!(message.permissionName && typeof message.permissionName.length === "number" || $util.isString(message.permissionName)))
                    return "permissionName: buffer expected";
            return null;
        };

        /**
         * Creates an authority message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.authority
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.authority} authority
         */
        authority.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.authority)
                return object;
            var message = new $root.protocol.authority();
            if (object.account != null) {
                if (typeof object.account !== "object")
                    throw TypeError(".protocol.authority.account: object expected");
                message.account = $root.protocol.AccountId.fromObject(object.account);
            }
            if (object.permissionName != null)
                if (typeof object.permissionName === "string")
                    $util.base64.decode(object.permissionName, message.permissionName = $util.newBuffer($util.base64.length(object.permissionName)), 0);
                else if (object.permissionName.length)
                    message.permissionName = object.permissionName;
            return message;
        };

        /**
         * Creates a plain object from an authority message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.authority
         * @static
         * @param {protocol.authority} message authority
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        authority.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.account = null;
                if (options.bytes === String)
                    object.permissionName = "";
                else {
                    object.permissionName = [];
                    if (options.bytes !== Array)
                        object.permissionName = $util.newBuffer(object.permissionName);
                }
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = $root.protocol.AccountId.toObject(message.account, options);
            if (message.permissionName != null && message.hasOwnProperty("permissionName"))
                object.permissionName = options.bytes === String ? $util.base64.encode(message.permissionName, 0, message.permissionName.length) : options.bytes === Array ? Array.prototype.slice.call(message.permissionName) : message.permissionName;
            return object;
        };

        /**
         * Converts this authority to JSON.
         * @function toJSON
         * @memberof protocol.authority
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        authority.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return authority;
    })();

    protocol.Permission = (function() {

        /**
         * Properties of a Permission.
         * @memberof protocol
         * @interface IPermission
         * @property {protocol.Permission.PermissionType|null} [type] Permission type
         * @property {number|null} [id] Permission id
         * @property {string|null} [permissionName] Permission permissionName
         * @property {number|Long|null} [threshold] Permission threshold
         * @property {number|null} [parentId] Permission parentId
         * @property {Uint8Array|null} [operations] Permission operations
         * @property {Array.<protocol.IKey>|null} [keys] Permission keys
         */

        /**
         * Constructs a new Permission.
         * @memberof protocol
         * @classdesc Represents a Permission.
         * @implements IPermission
         * @constructor
         * @param {protocol.IPermission=} [properties] Properties to set
         */
        function Permission(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Permission type.
         * @member {protocol.Permission.PermissionType} type
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.type = 0;

        /**
         * Permission id.
         * @member {number} id
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.id = 0;

        /**
         * Permission permissionName.
         * @member {string} permissionName
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.permissionName = "";

        /**
         * Permission threshold.
         * @member {number|Long} threshold
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.threshold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Permission parentId.
         * @member {number} parentId
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.parentId = 0;

        /**
         * Permission operations.
         * @member {Uint8Array} operations
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.operations = $util.newBuffer([]);

        /**
         * Permission keys.
         * @member {Array.<protocol.IKey>} keys
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.keys = $util.emptyArray;

        /**
         * Creates a new Permission instance using the specified properties.
         * @function create
         * @memberof protocol.Permission
         * @static
         * @param {protocol.IPermission=} [properties] Properties to set
         * @returns {protocol.Permission} Permission instance
         */
        Permission.create = function create(properties) {
            return new Permission(properties);
        };

        /**
         * Encodes the specified Permission message. Does not implicitly {@link protocol.Permission.verify|verify} messages.
         * @function encode
         * @memberof protocol.Permission
         * @static
         * @param {protocol.IPermission} message Permission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Permission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.permissionName != null && Object.hasOwnProperty.call(message, "permissionName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.permissionName);
            if (message.threshold != null && Object.hasOwnProperty.call(message, "threshold"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.threshold);
            if (message.parentId != null && Object.hasOwnProperty.call(message, "parentId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.parentId);
            if (message.operations != null && Object.hasOwnProperty.call(message, "operations"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.operations);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.protocol.Key.encode(message.keys[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Permission message, length delimited. Does not implicitly {@link protocol.Permission.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Permission
         * @static
         * @param {protocol.IPermission} message Permission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Permission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Permission message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Permission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Permission} Permission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Permission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Permission();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.id = reader.int32();
                    break;
                case 3:
                    message.permissionName = reader.string();
                    break;
                case 4:
                    message.threshold = reader.int64();
                    break;
                case 5:
                    message.parentId = reader.int32();
                    break;
                case 6:
                    message.operations = reader.bytes();
                    break;
                case 7:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.protocol.Key.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Permission message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Permission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Permission} Permission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Permission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Permission message.
         * @function verify
         * @memberof protocol.Permission
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Permission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.permissionName != null && message.hasOwnProperty("permissionName"))
                if (!$util.isString(message.permissionName))
                    return "permissionName: string expected";
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                if (!$util.isInteger(message.threshold) && !(message.threshold && $util.isInteger(message.threshold.low) && $util.isInteger(message.threshold.high)))
                    return "threshold: integer|Long expected";
            if (message.parentId != null && message.hasOwnProperty("parentId"))
                if (!$util.isInteger(message.parentId))
                    return "parentId: integer expected";
            if (message.operations != null && message.hasOwnProperty("operations"))
                if (!(message.operations && typeof message.operations.length === "number" || $util.isString(message.operations)))
                    return "operations: buffer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.protocol.Key.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Permission message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Permission
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Permission} Permission
         */
        Permission.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Permission)
                return object;
            var message = new $root.protocol.Permission();
            switch (object.type) {
            case "Owner":
            case 0:
                message.type = 0;
                break;
            case "Witness":
            case 1:
                message.type = 1;
                break;
            case "Active":
            case 2:
                message.type = 2;
                break;
            }
            if (object.id != null)
                message.id = object.id | 0;
            if (object.permissionName != null)
                message.permissionName = String(object.permissionName);
            if (object.threshold != null)
                if ($util.Long)
                    (message.threshold = $util.Long.fromValue(object.threshold)).unsigned = false;
                else if (typeof object.threshold === "string")
                    message.threshold = parseInt(object.threshold, 10);
                else if (typeof object.threshold === "number")
                    message.threshold = object.threshold;
                else if (typeof object.threshold === "object")
                    message.threshold = new $util.LongBits(object.threshold.low >>> 0, object.threshold.high >>> 0).toNumber();
            if (object.parentId != null)
                message.parentId = object.parentId | 0;
            if (object.operations != null)
                if (typeof object.operations === "string")
                    $util.base64.decode(object.operations, message.operations = $util.newBuffer($util.base64.length(object.operations)), 0);
                else if (object.operations.length)
                    message.operations = object.operations;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".protocol.Permission.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".protocol.Permission.keys: object expected");
                    message.keys[i] = $root.protocol.Key.fromObject(object.keys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Permission message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Permission
         * @static
         * @param {protocol.Permission} message Permission
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Permission.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.type = options.enums === String ? "Owner" : 0;
                object.id = 0;
                object.permissionName = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.threshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.threshold = options.longs === String ? "0" : 0;
                object.parentId = 0;
                if (options.bytes === String)
                    object.operations = "";
                else {
                    object.operations = [];
                    if (options.bytes !== Array)
                        object.operations = $util.newBuffer(object.operations);
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.Permission.PermissionType[message.type] : message.type;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.permissionName != null && message.hasOwnProperty("permissionName"))
                object.permissionName = message.permissionName;
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                if (typeof message.threshold === "number")
                    object.threshold = options.longs === String ? String(message.threshold) : message.threshold;
                else
                    object.threshold = options.longs === String ? $util.Long.prototype.toString.call(message.threshold) : options.longs === Number ? new $util.LongBits(message.threshold.low >>> 0, message.threshold.high >>> 0).toNumber() : message.threshold;
            if (message.parentId != null && message.hasOwnProperty("parentId"))
                object.parentId = message.parentId;
            if (message.operations != null && message.hasOwnProperty("operations"))
                object.operations = options.bytes === String ? $util.base64.encode(message.operations, 0, message.operations.length) : options.bytes === Array ? Array.prototype.slice.call(message.operations) : message.operations;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.protocol.Key.toObject(message.keys[j], options);
            }
            return object;
        };

        /**
         * Converts this Permission to JSON.
         * @function toJSON
         * @memberof protocol.Permission
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Permission.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PermissionType enum.
         * @name protocol.Permission.PermissionType
         * @enum {number}
         * @property {number} Owner=0 Owner value
         * @property {number} Witness=1 Witness value
         * @property {number} Active=2 Active value
         */
        Permission.PermissionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Owner"] = 0;
            values[valuesById[1] = "Witness"] = 1;
            values[valuesById[2] = "Active"] = 2;
            return values;
        })();

        return Permission;
    })();

    protocol.Witness = (function() {

        /**
         * Properties of a Witness.
         * @memberof protocol
         * @interface IWitness
         * @property {Uint8Array|null} [address] Witness address
         * @property {number|Long|null} [voteCount] Witness voteCount
         * @property {Uint8Array|null} [pubKey] Witness pubKey
         * @property {string|null} [url] Witness url
         * @property {number|Long|null} [totalProduced] Witness totalProduced
         * @property {number|Long|null} [totalMissed] Witness totalMissed
         * @property {number|Long|null} [latestBlockNum] Witness latestBlockNum
         * @property {number|Long|null} [latestSlotNum] Witness latestSlotNum
         * @property {boolean|null} [isJobs] Witness isJobs
         */

        /**
         * Constructs a new Witness.
         * @memberof protocol
         * @classdesc Represents a Witness.
         * @implements IWitness
         * @constructor
         * @param {protocol.IWitness=} [properties] Properties to set
         */
        function Witness(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Witness address.
         * @member {Uint8Array} address
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.address = $util.newBuffer([]);

        /**
         * Witness voteCount.
         * @member {number|Long} voteCount
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.voteCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Witness pubKey.
         * @member {Uint8Array} pubKey
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.pubKey = $util.newBuffer([]);

        /**
         * Witness url.
         * @member {string} url
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.url = "";

        /**
         * Witness totalProduced.
         * @member {number|Long} totalProduced
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.totalProduced = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Witness totalMissed.
         * @member {number|Long} totalMissed
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.totalMissed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Witness latestBlockNum.
         * @member {number|Long} latestBlockNum
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.latestBlockNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Witness latestSlotNum.
         * @member {number|Long} latestSlotNum
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.latestSlotNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Witness isJobs.
         * @member {boolean} isJobs
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.isJobs = false;

        /**
         * Creates a new Witness instance using the specified properties.
         * @function create
         * @memberof protocol.Witness
         * @static
         * @param {protocol.IWitness=} [properties] Properties to set
         * @returns {protocol.Witness} Witness instance
         */
        Witness.create = function create(properties) {
            return new Witness(properties);
        };

        /**
         * Encodes the specified Witness message. Does not implicitly {@link protocol.Witness.verify|verify} messages.
         * @function encode
         * @memberof protocol.Witness
         * @static
         * @param {protocol.IWitness} message Witness message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Witness.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.voteCount != null && Object.hasOwnProperty.call(message, "voteCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.voteCount);
            if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pubKey);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.url);
            if (message.totalProduced != null && Object.hasOwnProperty.call(message, "totalProduced"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.totalProduced);
            if (message.totalMissed != null && Object.hasOwnProperty.call(message, "totalMissed"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.totalMissed);
            if (message.latestBlockNum != null && Object.hasOwnProperty.call(message, "latestBlockNum"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.latestBlockNum);
            if (message.latestSlotNum != null && Object.hasOwnProperty.call(message, "latestSlotNum"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.latestSlotNum);
            if (message.isJobs != null && Object.hasOwnProperty.call(message, "isJobs"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isJobs);
            return writer;
        };

        /**
         * Encodes the specified Witness message, length delimited. Does not implicitly {@link protocol.Witness.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Witness
         * @static
         * @param {protocol.IWitness} message Witness message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Witness.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Witness message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Witness
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Witness} Witness
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Witness.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Witness();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.voteCount = reader.int64();
                    break;
                case 3:
                    message.pubKey = reader.bytes();
                    break;
                case 4:
                    message.url = reader.string();
                    break;
                case 5:
                    message.totalProduced = reader.int64();
                    break;
                case 6:
                    message.totalMissed = reader.int64();
                    break;
                case 7:
                    message.latestBlockNum = reader.int64();
                    break;
                case 8:
                    message.latestSlotNum = reader.int64();
                    break;
                case 9:
                    message.isJobs = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Witness message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Witness
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Witness} Witness
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Witness.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Witness message.
         * @function verify
         * @memberof protocol.Witness
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Witness.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                if (!$util.isInteger(message.voteCount) && !(message.voteCount && $util.isInteger(message.voteCount.low) && $util.isInteger(message.voteCount.high)))
                    return "voteCount: integer|Long expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!(message.pubKey && typeof message.pubKey.length === "number" || $util.isString(message.pubKey)))
                    return "pubKey: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.totalProduced != null && message.hasOwnProperty("totalProduced"))
                if (!$util.isInteger(message.totalProduced) && !(message.totalProduced && $util.isInteger(message.totalProduced.low) && $util.isInteger(message.totalProduced.high)))
                    return "totalProduced: integer|Long expected";
            if (message.totalMissed != null && message.hasOwnProperty("totalMissed"))
                if (!$util.isInteger(message.totalMissed) && !(message.totalMissed && $util.isInteger(message.totalMissed.low) && $util.isInteger(message.totalMissed.high)))
                    return "totalMissed: integer|Long expected";
            if (message.latestBlockNum != null && message.hasOwnProperty("latestBlockNum"))
                if (!$util.isInteger(message.latestBlockNum) && !(message.latestBlockNum && $util.isInteger(message.latestBlockNum.low) && $util.isInteger(message.latestBlockNum.high)))
                    return "latestBlockNum: integer|Long expected";
            if (message.latestSlotNum != null && message.hasOwnProperty("latestSlotNum"))
                if (!$util.isInteger(message.latestSlotNum) && !(message.latestSlotNum && $util.isInteger(message.latestSlotNum.low) && $util.isInteger(message.latestSlotNum.high)))
                    return "latestSlotNum: integer|Long expected";
            if (message.isJobs != null && message.hasOwnProperty("isJobs"))
                if (typeof message.isJobs !== "boolean")
                    return "isJobs: boolean expected";
            return null;
        };

        /**
         * Creates a Witness message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Witness
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Witness} Witness
         */
        Witness.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Witness)
                return object;
            var message = new $root.protocol.Witness();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.voteCount != null)
                if ($util.Long)
                    (message.voteCount = $util.Long.fromValue(object.voteCount)).unsigned = false;
                else if (typeof object.voteCount === "string")
                    message.voteCount = parseInt(object.voteCount, 10);
                else if (typeof object.voteCount === "number")
                    message.voteCount = object.voteCount;
                else if (typeof object.voteCount === "object")
                    message.voteCount = new $util.LongBits(object.voteCount.low >>> 0, object.voteCount.high >>> 0).toNumber();
            if (object.pubKey != null)
                if (typeof object.pubKey === "string")
                    $util.base64.decode(object.pubKey, message.pubKey = $util.newBuffer($util.base64.length(object.pubKey)), 0);
                else if (object.pubKey.length)
                    message.pubKey = object.pubKey;
            if (object.url != null)
                message.url = String(object.url);
            if (object.totalProduced != null)
                if ($util.Long)
                    (message.totalProduced = $util.Long.fromValue(object.totalProduced)).unsigned = false;
                else if (typeof object.totalProduced === "string")
                    message.totalProduced = parseInt(object.totalProduced, 10);
                else if (typeof object.totalProduced === "number")
                    message.totalProduced = object.totalProduced;
                else if (typeof object.totalProduced === "object")
                    message.totalProduced = new $util.LongBits(object.totalProduced.low >>> 0, object.totalProduced.high >>> 0).toNumber();
            if (object.totalMissed != null)
                if ($util.Long)
                    (message.totalMissed = $util.Long.fromValue(object.totalMissed)).unsigned = false;
                else if (typeof object.totalMissed === "string")
                    message.totalMissed = parseInt(object.totalMissed, 10);
                else if (typeof object.totalMissed === "number")
                    message.totalMissed = object.totalMissed;
                else if (typeof object.totalMissed === "object")
                    message.totalMissed = new $util.LongBits(object.totalMissed.low >>> 0, object.totalMissed.high >>> 0).toNumber();
            if (object.latestBlockNum != null)
                if ($util.Long)
                    (message.latestBlockNum = $util.Long.fromValue(object.latestBlockNum)).unsigned = false;
                else if (typeof object.latestBlockNum === "string")
                    message.latestBlockNum = parseInt(object.latestBlockNum, 10);
                else if (typeof object.latestBlockNum === "number")
                    message.latestBlockNum = object.latestBlockNum;
                else if (typeof object.latestBlockNum === "object")
                    message.latestBlockNum = new $util.LongBits(object.latestBlockNum.low >>> 0, object.latestBlockNum.high >>> 0).toNumber();
            if (object.latestSlotNum != null)
                if ($util.Long)
                    (message.latestSlotNum = $util.Long.fromValue(object.latestSlotNum)).unsigned = false;
                else if (typeof object.latestSlotNum === "string")
                    message.latestSlotNum = parseInt(object.latestSlotNum, 10);
                else if (typeof object.latestSlotNum === "number")
                    message.latestSlotNum = object.latestSlotNum;
                else if (typeof object.latestSlotNum === "object")
                    message.latestSlotNum = new $util.LongBits(object.latestSlotNum.low >>> 0, object.latestSlotNum.high >>> 0).toNumber();
            if (object.isJobs != null)
                message.isJobs = Boolean(object.isJobs);
            return message;
        };

        /**
         * Creates a plain object from a Witness message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Witness
         * @static
         * @param {protocol.Witness} message Witness
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Witness.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.voteCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.voteCount = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.pubKey = "";
                else {
                    object.pubKey = [];
                    if (options.bytes !== Array)
                        object.pubKey = $util.newBuffer(object.pubKey);
                }
                object.url = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalProduced = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalProduced = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalMissed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalMissed = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestBlockNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestBlockNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestSlotNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestSlotNum = options.longs === String ? "0" : 0;
                object.isJobs = false;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                if (typeof message.voteCount === "number")
                    object.voteCount = options.longs === String ? String(message.voteCount) : message.voteCount;
                else
                    object.voteCount = options.longs === String ? $util.Long.prototype.toString.call(message.voteCount) : options.longs === Number ? new $util.LongBits(message.voteCount.low >>> 0, message.voteCount.high >>> 0).toNumber() : message.voteCount;
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = options.bytes === String ? $util.base64.encode(message.pubKey, 0, message.pubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKey) : message.pubKey;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.totalProduced != null && message.hasOwnProperty("totalProduced"))
                if (typeof message.totalProduced === "number")
                    object.totalProduced = options.longs === String ? String(message.totalProduced) : message.totalProduced;
                else
                    object.totalProduced = options.longs === String ? $util.Long.prototype.toString.call(message.totalProduced) : options.longs === Number ? new $util.LongBits(message.totalProduced.low >>> 0, message.totalProduced.high >>> 0).toNumber() : message.totalProduced;
            if (message.totalMissed != null && message.hasOwnProperty("totalMissed"))
                if (typeof message.totalMissed === "number")
                    object.totalMissed = options.longs === String ? String(message.totalMissed) : message.totalMissed;
                else
                    object.totalMissed = options.longs === String ? $util.Long.prototype.toString.call(message.totalMissed) : options.longs === Number ? new $util.LongBits(message.totalMissed.low >>> 0, message.totalMissed.high >>> 0).toNumber() : message.totalMissed;
            if (message.latestBlockNum != null && message.hasOwnProperty("latestBlockNum"))
                if (typeof message.latestBlockNum === "number")
                    object.latestBlockNum = options.longs === String ? String(message.latestBlockNum) : message.latestBlockNum;
                else
                    object.latestBlockNum = options.longs === String ? $util.Long.prototype.toString.call(message.latestBlockNum) : options.longs === Number ? new $util.LongBits(message.latestBlockNum.low >>> 0, message.latestBlockNum.high >>> 0).toNumber() : message.latestBlockNum;
            if (message.latestSlotNum != null && message.hasOwnProperty("latestSlotNum"))
                if (typeof message.latestSlotNum === "number")
                    object.latestSlotNum = options.longs === String ? String(message.latestSlotNum) : message.latestSlotNum;
                else
                    object.latestSlotNum = options.longs === String ? $util.Long.prototype.toString.call(message.latestSlotNum) : options.longs === Number ? new $util.LongBits(message.latestSlotNum.low >>> 0, message.latestSlotNum.high >>> 0).toNumber() : message.latestSlotNum;
            if (message.isJobs != null && message.hasOwnProperty("isJobs"))
                object.isJobs = message.isJobs;
            return object;
        };

        /**
         * Converts this Witness to JSON.
         * @function toJSON
         * @memberof protocol.Witness
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Witness.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Witness;
    })();

    protocol.Votes = (function() {

        /**
         * Properties of a Votes.
         * @memberof protocol
         * @interface IVotes
         * @property {Uint8Array|null} [address] Votes address
         * @property {Array.<protocol.IVote>|null} [oldVotes] Votes oldVotes
         * @property {Array.<protocol.IVote>|null} [newVotes] Votes newVotes
         */

        /**
         * Constructs a new Votes.
         * @memberof protocol
         * @classdesc Represents a Votes.
         * @implements IVotes
         * @constructor
         * @param {protocol.IVotes=} [properties] Properties to set
         */
        function Votes(properties) {
            this.oldVotes = [];
            this.newVotes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Votes address.
         * @member {Uint8Array} address
         * @memberof protocol.Votes
         * @instance
         */
        Votes.prototype.address = $util.newBuffer([]);

        /**
         * Votes oldVotes.
         * @member {Array.<protocol.IVote>} oldVotes
         * @memberof protocol.Votes
         * @instance
         */
        Votes.prototype.oldVotes = $util.emptyArray;

        /**
         * Votes newVotes.
         * @member {Array.<protocol.IVote>} newVotes
         * @memberof protocol.Votes
         * @instance
         */
        Votes.prototype.newVotes = $util.emptyArray;

        /**
         * Creates a new Votes instance using the specified properties.
         * @function create
         * @memberof protocol.Votes
         * @static
         * @param {protocol.IVotes=} [properties] Properties to set
         * @returns {protocol.Votes} Votes instance
         */
        Votes.create = function create(properties) {
            return new Votes(properties);
        };

        /**
         * Encodes the specified Votes message. Does not implicitly {@link protocol.Votes.verify|verify} messages.
         * @function encode
         * @memberof protocol.Votes
         * @static
         * @param {protocol.IVotes} message Votes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Votes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.oldVotes != null && message.oldVotes.length)
                for (var i = 0; i < message.oldVotes.length; ++i)
                    $root.protocol.Vote.encode(message.oldVotes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.newVotes != null && message.newVotes.length)
                for (var i = 0; i < message.newVotes.length; ++i)
                    $root.protocol.Vote.encode(message.newVotes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Votes message, length delimited. Does not implicitly {@link protocol.Votes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Votes
         * @static
         * @param {protocol.IVotes} message Votes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Votes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Votes message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Votes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Votes} Votes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Votes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Votes();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    if (!(message.oldVotes && message.oldVotes.length))
                        message.oldVotes = [];
                    message.oldVotes.push($root.protocol.Vote.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.newVotes && message.newVotes.length))
                        message.newVotes = [];
                    message.newVotes.push($root.protocol.Vote.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Votes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Votes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Votes} Votes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Votes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Votes message.
         * @function verify
         * @memberof protocol.Votes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Votes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.oldVotes != null && message.hasOwnProperty("oldVotes")) {
                if (!Array.isArray(message.oldVotes))
                    return "oldVotes: array expected";
                for (var i = 0; i < message.oldVotes.length; ++i) {
                    var error = $root.protocol.Vote.verify(message.oldVotes[i]);
                    if (error)
                        return "oldVotes." + error;
                }
            }
            if (message.newVotes != null && message.hasOwnProperty("newVotes")) {
                if (!Array.isArray(message.newVotes))
                    return "newVotes: array expected";
                for (var i = 0; i < message.newVotes.length; ++i) {
                    var error = $root.protocol.Vote.verify(message.newVotes[i]);
                    if (error)
                        return "newVotes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Votes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Votes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Votes} Votes
         */
        Votes.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Votes)
                return object;
            var message = new $root.protocol.Votes();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.oldVotes) {
                if (!Array.isArray(object.oldVotes))
                    throw TypeError(".protocol.Votes.oldVotes: array expected");
                message.oldVotes = [];
                for (var i = 0; i < object.oldVotes.length; ++i) {
                    if (typeof object.oldVotes[i] !== "object")
                        throw TypeError(".protocol.Votes.oldVotes: object expected");
                    message.oldVotes[i] = $root.protocol.Vote.fromObject(object.oldVotes[i]);
                }
            }
            if (object.newVotes) {
                if (!Array.isArray(object.newVotes))
                    throw TypeError(".protocol.Votes.newVotes: array expected");
                message.newVotes = [];
                for (var i = 0; i < object.newVotes.length; ++i) {
                    if (typeof object.newVotes[i] !== "object")
                        throw TypeError(".protocol.Votes.newVotes: object expected");
                    message.newVotes[i] = $root.protocol.Vote.fromObject(object.newVotes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Votes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Votes
         * @static
         * @param {protocol.Votes} message Votes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Votes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.oldVotes = [];
                object.newVotes = [];
            }
            if (options.defaults)
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.oldVotes && message.oldVotes.length) {
                object.oldVotes = [];
                for (var j = 0; j < message.oldVotes.length; ++j)
                    object.oldVotes[j] = $root.protocol.Vote.toObject(message.oldVotes[j], options);
            }
            if (message.newVotes && message.newVotes.length) {
                object.newVotes = [];
                for (var j = 0; j < message.newVotes.length; ++j)
                    object.newVotes[j] = $root.protocol.Vote.toObject(message.newVotes[j], options);
            }
            return object;
        };

        /**
         * Converts this Votes to JSON.
         * @function toJSON
         * @memberof protocol.Votes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Votes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Votes;
    })();

    protocol.TXOutput = (function() {

        /**
         * Properties of a TXOutput.
         * @memberof protocol
         * @interface ITXOutput
         * @property {number|Long|null} [value] TXOutput value
         * @property {Uint8Array|null} [pubKeyHash] TXOutput pubKeyHash
         */

        /**
         * Constructs a new TXOutput.
         * @memberof protocol
         * @classdesc Represents a TXOutput.
         * @implements ITXOutput
         * @constructor
         * @param {protocol.ITXOutput=} [properties] Properties to set
         */
        function TXOutput(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TXOutput value.
         * @member {number|Long} value
         * @memberof protocol.TXOutput
         * @instance
         */
        TXOutput.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TXOutput pubKeyHash.
         * @member {Uint8Array} pubKeyHash
         * @memberof protocol.TXOutput
         * @instance
         */
        TXOutput.prototype.pubKeyHash = $util.newBuffer([]);

        /**
         * Creates a new TXOutput instance using the specified properties.
         * @function create
         * @memberof protocol.TXOutput
         * @static
         * @param {protocol.ITXOutput=} [properties] Properties to set
         * @returns {protocol.TXOutput} TXOutput instance
         */
        TXOutput.create = function create(properties) {
            return new TXOutput(properties);
        };

        /**
         * Encodes the specified TXOutput message. Does not implicitly {@link protocol.TXOutput.verify|verify} messages.
         * @function encode
         * @memberof protocol.TXOutput
         * @static
         * @param {protocol.ITXOutput} message TXOutput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXOutput.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
            if (message.pubKeyHash != null && Object.hasOwnProperty.call(message, "pubKeyHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.pubKeyHash);
            return writer;
        };

        /**
         * Encodes the specified TXOutput message, length delimited. Does not implicitly {@link protocol.TXOutput.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TXOutput
         * @static
         * @param {protocol.ITXOutput} message TXOutput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXOutput.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TXOutput message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TXOutput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TXOutput} TXOutput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXOutput.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXOutput();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.int64();
                    break;
                case 2:
                    message.pubKeyHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TXOutput message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TXOutput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TXOutput} TXOutput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXOutput.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TXOutput message.
         * @function verify
         * @memberof protocol.TXOutput
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TXOutput.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            if (message.pubKeyHash != null && message.hasOwnProperty("pubKeyHash"))
                if (!(message.pubKeyHash && typeof message.pubKeyHash.length === "number" || $util.isString(message.pubKeyHash)))
                    return "pubKeyHash: buffer expected";
            return null;
        };

        /**
         * Creates a TXOutput message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TXOutput
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TXOutput} TXOutput
         */
        TXOutput.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TXOutput)
                return object;
            var message = new $root.protocol.TXOutput();
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.pubKeyHash != null)
                if (typeof object.pubKeyHash === "string")
                    $util.base64.decode(object.pubKeyHash, message.pubKeyHash = $util.newBuffer($util.base64.length(object.pubKeyHash)), 0);
                else if (object.pubKeyHash.length)
                    message.pubKeyHash = object.pubKeyHash;
            return message;
        };

        /**
         * Creates a plain object from a TXOutput message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TXOutput
         * @static
         * @param {protocol.TXOutput} message TXOutput
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TXOutput.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.pubKeyHash = "";
                else {
                    object.pubKeyHash = [];
                    if (options.bytes !== Array)
                        object.pubKeyHash = $util.newBuffer(object.pubKeyHash);
                }
            }
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.pubKeyHash != null && message.hasOwnProperty("pubKeyHash"))
                object.pubKeyHash = options.bytes === String ? $util.base64.encode(message.pubKeyHash, 0, message.pubKeyHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKeyHash) : message.pubKeyHash;
            return object;
        };

        /**
         * Converts this TXOutput to JSON.
         * @function toJSON
         * @memberof protocol.TXOutput
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TXOutput.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TXOutput;
    })();

    protocol.TXInput = (function() {

        /**
         * Properties of a TXInput.
         * @memberof protocol
         * @interface ITXInput
         * @property {protocol.TXInput.Iraw|null} [rawData] TXInput rawData
         * @property {Uint8Array|null} [signature] TXInput signature
         */

        /**
         * Constructs a new TXInput.
         * @memberof protocol
         * @classdesc Represents a TXInput.
         * @implements ITXInput
         * @constructor
         * @param {protocol.ITXInput=} [properties] Properties to set
         */
        function TXInput(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TXInput rawData.
         * @member {protocol.TXInput.Iraw|null|undefined} rawData
         * @memberof protocol.TXInput
         * @instance
         */
        TXInput.prototype.rawData = null;

        /**
         * TXInput signature.
         * @member {Uint8Array} signature
         * @memberof protocol.TXInput
         * @instance
         */
        TXInput.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new TXInput instance using the specified properties.
         * @function create
         * @memberof protocol.TXInput
         * @static
         * @param {protocol.ITXInput=} [properties] Properties to set
         * @returns {protocol.TXInput} TXInput instance
         */
        TXInput.create = function create(properties) {
            return new TXInput(properties);
        };

        /**
         * Encodes the specified TXInput message. Does not implicitly {@link protocol.TXInput.verify|verify} messages.
         * @function encode
         * @memberof protocol.TXInput
         * @static
         * @param {protocol.ITXInput} message TXInput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXInput.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rawData != null && Object.hasOwnProperty.call(message, "rawData"))
                $root.protocol.TXInput.raw.encode(message.rawData, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified TXInput message, length delimited. Does not implicitly {@link protocol.TXInput.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TXInput
         * @static
         * @param {protocol.ITXInput} message TXInput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXInput.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TXInput message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TXInput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TXInput} TXInput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXInput.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXInput();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rawData = $root.protocol.TXInput.raw.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TXInput message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TXInput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TXInput} TXInput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXInput.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TXInput message.
         * @function verify
         * @memberof protocol.TXInput
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TXInput.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rawData != null && message.hasOwnProperty("rawData")) {
                var error = $root.protocol.TXInput.raw.verify(message.rawData);
                if (error)
                    return "rawData." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a TXInput message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TXInput
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TXInput} TXInput
         */
        TXInput.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TXInput)
                return object;
            var message = new $root.protocol.TXInput();
            if (object.rawData != null) {
                if (typeof object.rawData !== "object")
                    throw TypeError(".protocol.TXInput.rawData: object expected");
                message.rawData = $root.protocol.TXInput.raw.fromObject(object.rawData);
            }
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a TXInput message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TXInput
         * @static
         * @param {protocol.TXInput} message TXInput
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TXInput.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rawData = null;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                object.rawData = $root.protocol.TXInput.raw.toObject(message.rawData, options);
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this TXInput to JSON.
         * @function toJSON
         * @memberof protocol.TXInput
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TXInput.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        TXInput.raw = (function() {

            /**
             * Properties of a raw.
             * @memberof protocol.TXInput
             * @interface Iraw
             * @property {Uint8Array|null} [txID] raw txID
             * @property {number|Long|null} [vout] raw vout
             * @property {Uint8Array|null} [pubKey] raw pubKey
             */

            /**
             * Constructs a new raw.
             * @memberof protocol.TXInput
             * @classdesc Represents a raw.
             * @implements Iraw
             * @constructor
             * @param {protocol.TXInput.Iraw=} [properties] Properties to set
             */
            function raw(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * raw txID.
             * @member {Uint8Array} txID
             * @memberof protocol.TXInput.raw
             * @instance
             */
            raw.prototype.txID = $util.newBuffer([]);

            /**
             * raw vout.
             * @member {number|Long} vout
             * @memberof protocol.TXInput.raw
             * @instance
             */
            raw.prototype.vout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw pubKey.
             * @member {Uint8Array} pubKey
             * @memberof protocol.TXInput.raw
             * @instance
             */
            raw.prototype.pubKey = $util.newBuffer([]);

            /**
             * Creates a new raw instance using the specified properties.
             * @function create
             * @memberof protocol.TXInput.raw
             * @static
             * @param {protocol.TXInput.Iraw=} [properties] Properties to set
             * @returns {protocol.TXInput.raw} raw instance
             */
            raw.create = function create(properties) {
                return new raw(properties);
            };

            /**
             * Encodes the specified raw message. Does not implicitly {@link protocol.TXInput.raw.verify|verify} messages.
             * @function encode
             * @memberof protocol.TXInput.raw
             * @static
             * @param {protocol.TXInput.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txID != null && Object.hasOwnProperty.call(message, "txID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.txID);
                if (message.vout != null && Object.hasOwnProperty.call(message, "vout"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.vout);
                if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pubKey);
                return writer;
            };

            /**
             * Encodes the specified raw message, length delimited. Does not implicitly {@link protocol.TXInput.raw.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.TXInput.raw
             * @static
             * @param {protocol.TXInput.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a raw message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.TXInput.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.TXInput.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXInput.raw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txID = reader.bytes();
                        break;
                    case 2:
                        message.vout = reader.int64();
                        break;
                    case 3:
                        message.pubKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a raw message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.TXInput.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.TXInput.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a raw message.
             * @function verify
             * @memberof protocol.TXInput.raw
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            raw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txID != null && message.hasOwnProperty("txID"))
                    if (!(message.txID && typeof message.txID.length === "number" || $util.isString(message.txID)))
                        return "txID: buffer expected";
                if (message.vout != null && message.hasOwnProperty("vout"))
                    if (!$util.isInteger(message.vout) && !(message.vout && $util.isInteger(message.vout.low) && $util.isInteger(message.vout.high)))
                        return "vout: integer|Long expected";
                if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                    if (!(message.pubKey && typeof message.pubKey.length === "number" || $util.isString(message.pubKey)))
                        return "pubKey: buffer expected";
                return null;
            };

            /**
             * Creates a raw message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.TXInput.raw
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.TXInput.raw} raw
             */
            raw.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.TXInput.raw)
                    return object;
                var message = new $root.protocol.TXInput.raw();
                if (object.txID != null)
                    if (typeof object.txID === "string")
                        $util.base64.decode(object.txID, message.txID = $util.newBuffer($util.base64.length(object.txID)), 0);
                    else if (object.txID.length)
                        message.txID = object.txID;
                if (object.vout != null)
                    if ($util.Long)
                        (message.vout = $util.Long.fromValue(object.vout)).unsigned = false;
                    else if (typeof object.vout === "string")
                        message.vout = parseInt(object.vout, 10);
                    else if (typeof object.vout === "number")
                        message.vout = object.vout;
                    else if (typeof object.vout === "object")
                        message.vout = new $util.LongBits(object.vout.low >>> 0, object.vout.high >>> 0).toNumber();
                if (object.pubKey != null)
                    if (typeof object.pubKey === "string")
                        $util.base64.decode(object.pubKey, message.pubKey = $util.newBuffer($util.base64.length(object.pubKey)), 0);
                    else if (object.pubKey.length)
                        message.pubKey = object.pubKey;
                return message;
            };

            /**
             * Creates a plain object from a raw message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.TXInput.raw
             * @static
             * @param {protocol.TXInput.raw} message raw
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            raw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.txID = "";
                    else {
                        object.txID = [];
                        if (options.bytes !== Array)
                            object.txID = $util.newBuffer(object.txID);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.vout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.vout = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.pubKey = "";
                    else {
                        object.pubKey = [];
                        if (options.bytes !== Array)
                            object.pubKey = $util.newBuffer(object.pubKey);
                    }
                }
                if (message.txID != null && message.hasOwnProperty("txID"))
                    object.txID = options.bytes === String ? $util.base64.encode(message.txID, 0, message.txID.length) : options.bytes === Array ? Array.prototype.slice.call(message.txID) : message.txID;
                if (message.vout != null && message.hasOwnProperty("vout"))
                    if (typeof message.vout === "number")
                        object.vout = options.longs === String ? String(message.vout) : message.vout;
                    else
                        object.vout = options.longs === String ? $util.Long.prototype.toString.call(message.vout) : options.longs === Number ? new $util.LongBits(message.vout.low >>> 0, message.vout.high >>> 0).toNumber() : message.vout;
                if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                    object.pubKey = options.bytes === String ? $util.base64.encode(message.pubKey, 0, message.pubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKey) : message.pubKey;
                return object;
            };

            /**
             * Converts this raw to JSON.
             * @function toJSON
             * @memberof protocol.TXInput.raw
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            raw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return raw;
        })();

        return TXInput;
    })();

    protocol.TXOutputs = (function() {

        /**
         * Properties of a TXOutputs.
         * @memberof protocol
         * @interface ITXOutputs
         * @property {Array.<protocol.ITXOutput>|null} [outputs] TXOutputs outputs
         */

        /**
         * Constructs a new TXOutputs.
         * @memberof protocol
         * @classdesc Represents a TXOutputs.
         * @implements ITXOutputs
         * @constructor
         * @param {protocol.ITXOutputs=} [properties] Properties to set
         */
        function TXOutputs(properties) {
            this.outputs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TXOutputs outputs.
         * @member {Array.<protocol.ITXOutput>} outputs
         * @memberof protocol.TXOutputs
         * @instance
         */
        TXOutputs.prototype.outputs = $util.emptyArray;

        /**
         * Creates a new TXOutputs instance using the specified properties.
         * @function create
         * @memberof protocol.TXOutputs
         * @static
         * @param {protocol.ITXOutputs=} [properties] Properties to set
         * @returns {protocol.TXOutputs} TXOutputs instance
         */
        TXOutputs.create = function create(properties) {
            return new TXOutputs(properties);
        };

        /**
         * Encodes the specified TXOutputs message. Does not implicitly {@link protocol.TXOutputs.verify|verify} messages.
         * @function encode
         * @memberof protocol.TXOutputs
         * @static
         * @param {protocol.ITXOutputs} message TXOutputs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXOutputs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.outputs != null && message.outputs.length)
                for (var i = 0; i < message.outputs.length; ++i)
                    $root.protocol.TXOutput.encode(message.outputs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TXOutputs message, length delimited. Does not implicitly {@link protocol.TXOutputs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TXOutputs
         * @static
         * @param {protocol.ITXOutputs} message TXOutputs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXOutputs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TXOutputs message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TXOutputs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TXOutputs} TXOutputs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXOutputs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXOutputs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.outputs && message.outputs.length))
                        message.outputs = [];
                    message.outputs.push($root.protocol.TXOutput.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TXOutputs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TXOutputs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TXOutputs} TXOutputs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXOutputs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TXOutputs message.
         * @function verify
         * @memberof protocol.TXOutputs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TXOutputs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.outputs != null && message.hasOwnProperty("outputs")) {
                if (!Array.isArray(message.outputs))
                    return "outputs: array expected";
                for (var i = 0; i < message.outputs.length; ++i) {
                    var error = $root.protocol.TXOutput.verify(message.outputs[i]);
                    if (error)
                        return "outputs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TXOutputs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TXOutputs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TXOutputs} TXOutputs
         */
        TXOutputs.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TXOutputs)
                return object;
            var message = new $root.protocol.TXOutputs();
            if (object.outputs) {
                if (!Array.isArray(object.outputs))
                    throw TypeError(".protocol.TXOutputs.outputs: array expected");
                message.outputs = [];
                for (var i = 0; i < object.outputs.length; ++i) {
                    if (typeof object.outputs[i] !== "object")
                        throw TypeError(".protocol.TXOutputs.outputs: object expected");
                    message.outputs[i] = $root.protocol.TXOutput.fromObject(object.outputs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TXOutputs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TXOutputs
         * @static
         * @param {protocol.TXOutputs} message TXOutputs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TXOutputs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.outputs = [];
            if (message.outputs && message.outputs.length) {
                object.outputs = [];
                for (var j = 0; j < message.outputs.length; ++j)
                    object.outputs[j] = $root.protocol.TXOutput.toObject(message.outputs[j], options);
            }
            return object;
        };

        /**
         * Converts this TXOutputs to JSON.
         * @function toJSON
         * @memberof protocol.TXOutputs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TXOutputs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TXOutputs;
    })();

    protocol.ResourceReceipt = (function() {

        /**
         * Properties of a ResourceReceipt.
         * @memberof protocol
         * @interface IResourceReceipt
         * @property {number|Long|null} [energyUsage] ResourceReceipt energyUsage
         * @property {number|Long|null} [energyFee] ResourceReceipt energyFee
         * @property {number|Long|null} [originEnergyUsage] ResourceReceipt originEnergyUsage
         * @property {number|Long|null} [energyUsageTotal] ResourceReceipt energyUsageTotal
         * @property {number|Long|null} [netUsage] ResourceReceipt netUsage
         * @property {number|Long|null} [netFee] ResourceReceipt netFee
         * @property {protocol.Transaction.Result.contractResult|null} [result] ResourceReceipt result
         */

        /**
         * Constructs a new ResourceReceipt.
         * @memberof protocol
         * @classdesc Represents a ResourceReceipt.
         * @implements IResourceReceipt
         * @constructor
         * @param {protocol.IResourceReceipt=} [properties] Properties to set
         */
        function ResourceReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceReceipt energyUsage.
         * @member {number|Long} energyUsage
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.energyUsage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt energyFee.
         * @member {number|Long} energyFee
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.energyFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt originEnergyUsage.
         * @member {number|Long} originEnergyUsage
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.originEnergyUsage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt energyUsageTotal.
         * @member {number|Long} energyUsageTotal
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.energyUsageTotal = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt netUsage.
         * @member {number|Long} netUsage
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.netUsage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt netFee.
         * @member {number|Long} netFee
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.netFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt result.
         * @member {protocol.Transaction.Result.contractResult} result
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.result = 0;

        /**
         * Creates a new ResourceReceipt instance using the specified properties.
         * @function create
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {protocol.IResourceReceipt=} [properties] Properties to set
         * @returns {protocol.ResourceReceipt} ResourceReceipt instance
         */
        ResourceReceipt.create = function create(properties) {
            return new ResourceReceipt(properties);
        };

        /**
         * Encodes the specified ResourceReceipt message. Does not implicitly {@link protocol.ResourceReceipt.verify|verify} messages.
         * @function encode
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {protocol.IResourceReceipt} message ResourceReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.energyUsage != null && Object.hasOwnProperty.call(message, "energyUsage"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.energyUsage);
            if (message.energyFee != null && Object.hasOwnProperty.call(message, "energyFee"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.energyFee);
            if (message.originEnergyUsage != null && Object.hasOwnProperty.call(message, "originEnergyUsage"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.originEnergyUsage);
            if (message.energyUsageTotal != null && Object.hasOwnProperty.call(message, "energyUsageTotal"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.energyUsageTotal);
            if (message.netUsage != null && Object.hasOwnProperty.call(message, "netUsage"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.netUsage);
            if (message.netFee != null && Object.hasOwnProperty.call(message, "netFee"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.netFee);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified ResourceReceipt message, length delimited. Does not implicitly {@link protocol.ResourceReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {protocol.IResourceReceipt} message ResourceReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ResourceReceipt} ResourceReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ResourceReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.energyUsage = reader.int64();
                    break;
                case 2:
                    message.energyFee = reader.int64();
                    break;
                case 3:
                    message.originEnergyUsage = reader.int64();
                    break;
                case 4:
                    message.energyUsageTotal = reader.int64();
                    break;
                case 5:
                    message.netUsage = reader.int64();
                    break;
                case 6:
                    message.netFee = reader.int64();
                    break;
                case 7:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ResourceReceipt} ResourceReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceReceipt message.
         * @function verify
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.energyUsage != null && message.hasOwnProperty("energyUsage"))
                if (!$util.isInteger(message.energyUsage) && !(message.energyUsage && $util.isInteger(message.energyUsage.low) && $util.isInteger(message.energyUsage.high)))
                    return "energyUsage: integer|Long expected";
            if (message.energyFee != null && message.hasOwnProperty("energyFee"))
                if (!$util.isInteger(message.energyFee) && !(message.energyFee && $util.isInteger(message.energyFee.low) && $util.isInteger(message.energyFee.high)))
                    return "energyFee: integer|Long expected";
            if (message.originEnergyUsage != null && message.hasOwnProperty("originEnergyUsage"))
                if (!$util.isInteger(message.originEnergyUsage) && !(message.originEnergyUsage && $util.isInteger(message.originEnergyUsage.low) && $util.isInteger(message.originEnergyUsage.high)))
                    return "originEnergyUsage: integer|Long expected";
            if (message.energyUsageTotal != null && message.hasOwnProperty("energyUsageTotal"))
                if (!$util.isInteger(message.energyUsageTotal) && !(message.energyUsageTotal && $util.isInteger(message.energyUsageTotal.low) && $util.isInteger(message.energyUsageTotal.high)))
                    return "energyUsageTotal: integer|Long expected";
            if (message.netUsage != null && message.hasOwnProperty("netUsage"))
                if (!$util.isInteger(message.netUsage) && !(message.netUsage && $util.isInteger(message.netUsage.low) && $util.isInteger(message.netUsage.high)))
                    return "netUsage: integer|Long expected";
            if (message.netFee != null && message.hasOwnProperty("netFee"))
                if (!$util.isInteger(message.netFee) && !(message.netFee && $util.isInteger(message.netFee.low) && $util.isInteger(message.netFee.high)))
                    return "netFee: integer|Long expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                    break;
                }
            return null;
        };

        /**
         * Creates a ResourceReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ResourceReceipt} ResourceReceipt
         */
        ResourceReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ResourceReceipt)
                return object;
            var message = new $root.protocol.ResourceReceipt();
            if (object.energyUsage != null)
                if ($util.Long)
                    (message.energyUsage = $util.Long.fromValue(object.energyUsage)).unsigned = false;
                else if (typeof object.energyUsage === "string")
                    message.energyUsage = parseInt(object.energyUsage, 10);
                else if (typeof object.energyUsage === "number")
                    message.energyUsage = object.energyUsage;
                else if (typeof object.energyUsage === "object")
                    message.energyUsage = new $util.LongBits(object.energyUsage.low >>> 0, object.energyUsage.high >>> 0).toNumber();
            if (object.energyFee != null)
                if ($util.Long)
                    (message.energyFee = $util.Long.fromValue(object.energyFee)).unsigned = false;
                else if (typeof object.energyFee === "string")
                    message.energyFee = parseInt(object.energyFee, 10);
                else if (typeof object.energyFee === "number")
                    message.energyFee = object.energyFee;
                else if (typeof object.energyFee === "object")
                    message.energyFee = new $util.LongBits(object.energyFee.low >>> 0, object.energyFee.high >>> 0).toNumber();
            if (object.originEnergyUsage != null)
                if ($util.Long)
                    (message.originEnergyUsage = $util.Long.fromValue(object.originEnergyUsage)).unsigned = false;
                else if (typeof object.originEnergyUsage === "string")
                    message.originEnergyUsage = parseInt(object.originEnergyUsage, 10);
                else if (typeof object.originEnergyUsage === "number")
                    message.originEnergyUsage = object.originEnergyUsage;
                else if (typeof object.originEnergyUsage === "object")
                    message.originEnergyUsage = new $util.LongBits(object.originEnergyUsage.low >>> 0, object.originEnergyUsage.high >>> 0).toNumber();
            if (object.energyUsageTotal != null)
                if ($util.Long)
                    (message.energyUsageTotal = $util.Long.fromValue(object.energyUsageTotal)).unsigned = false;
                else if (typeof object.energyUsageTotal === "string")
                    message.energyUsageTotal = parseInt(object.energyUsageTotal, 10);
                else if (typeof object.energyUsageTotal === "number")
                    message.energyUsageTotal = object.energyUsageTotal;
                else if (typeof object.energyUsageTotal === "object")
                    message.energyUsageTotal = new $util.LongBits(object.energyUsageTotal.low >>> 0, object.energyUsageTotal.high >>> 0).toNumber();
            if (object.netUsage != null)
                if ($util.Long)
                    (message.netUsage = $util.Long.fromValue(object.netUsage)).unsigned = false;
                else if (typeof object.netUsage === "string")
                    message.netUsage = parseInt(object.netUsage, 10);
                else if (typeof object.netUsage === "number")
                    message.netUsage = object.netUsage;
                else if (typeof object.netUsage === "object")
                    message.netUsage = new $util.LongBits(object.netUsage.low >>> 0, object.netUsage.high >>> 0).toNumber();
            if (object.netFee != null)
                if ($util.Long)
                    (message.netFee = $util.Long.fromValue(object.netFee)).unsigned = false;
                else if (typeof object.netFee === "string")
                    message.netFee = parseInt(object.netFee, 10);
                else if (typeof object.netFee === "number")
                    message.netFee = object.netFee;
                else if (typeof object.netFee === "object")
                    message.netFee = new $util.LongBits(object.netFee.low >>> 0, object.netFee.high >>> 0).toNumber();
            switch (object.result) {
            case "DEFAULT":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "REVERT":
            case 2:
                message.result = 2;
                break;
            case "BAD_JUMP_DESTINATION":
            case 3:
                message.result = 3;
                break;
            case "OUT_OF_MEMORY":
            case 4:
                message.result = 4;
                break;
            case "PRECOMPILED_CONTRACT":
            case 5:
                message.result = 5;
                break;
            case "STACK_TOO_SMALL":
            case 6:
                message.result = 6;
                break;
            case "STACK_TOO_LARGE":
            case 7:
                message.result = 7;
                break;
            case "ILLEGAL_OPERATION":
            case 8:
                message.result = 8;
                break;
            case "STACK_OVERFLOW":
            case 9:
                message.result = 9;
                break;
            case "OUT_OF_ENERGY":
            case 10:
                message.result = 10;
                break;
            case "OUT_OF_TIME":
            case 11:
                message.result = 11;
                break;
            case "JVM_STACK_OVER_FLOW":
            case 12:
                message.result = 12;
                break;
            case "UNKNOWN":
            case 13:
                message.result = 13;
                break;
            case "TRANSFER_FAILED":
            case 14:
                message.result = 14;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {protocol.ResourceReceipt} message ResourceReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energyUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.energyUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energyFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.energyFee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.originEnergyUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.originEnergyUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energyUsageTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.energyUsageTotal = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.netUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.netUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.netFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.netFee = options.longs === String ? "0" : 0;
                object.result = options.enums === String ? "DEFAULT" : 0;
            }
            if (message.energyUsage != null && message.hasOwnProperty("energyUsage"))
                if (typeof message.energyUsage === "number")
                    object.energyUsage = options.longs === String ? String(message.energyUsage) : message.energyUsage;
                else
                    object.energyUsage = options.longs === String ? $util.Long.prototype.toString.call(message.energyUsage) : options.longs === Number ? new $util.LongBits(message.energyUsage.low >>> 0, message.energyUsage.high >>> 0).toNumber() : message.energyUsage;
            if (message.energyFee != null && message.hasOwnProperty("energyFee"))
                if (typeof message.energyFee === "number")
                    object.energyFee = options.longs === String ? String(message.energyFee) : message.energyFee;
                else
                    object.energyFee = options.longs === String ? $util.Long.prototype.toString.call(message.energyFee) : options.longs === Number ? new $util.LongBits(message.energyFee.low >>> 0, message.energyFee.high >>> 0).toNumber() : message.energyFee;
            if (message.originEnergyUsage != null && message.hasOwnProperty("originEnergyUsage"))
                if (typeof message.originEnergyUsage === "number")
                    object.originEnergyUsage = options.longs === String ? String(message.originEnergyUsage) : message.originEnergyUsage;
                else
                    object.originEnergyUsage = options.longs === String ? $util.Long.prototype.toString.call(message.originEnergyUsage) : options.longs === Number ? new $util.LongBits(message.originEnergyUsage.low >>> 0, message.originEnergyUsage.high >>> 0).toNumber() : message.originEnergyUsage;
            if (message.energyUsageTotal != null && message.hasOwnProperty("energyUsageTotal"))
                if (typeof message.energyUsageTotal === "number")
                    object.energyUsageTotal = options.longs === String ? String(message.energyUsageTotal) : message.energyUsageTotal;
                else
                    object.energyUsageTotal = options.longs === String ? $util.Long.prototype.toString.call(message.energyUsageTotal) : options.longs === Number ? new $util.LongBits(message.energyUsageTotal.low >>> 0, message.energyUsageTotal.high >>> 0).toNumber() : message.energyUsageTotal;
            if (message.netUsage != null && message.hasOwnProperty("netUsage"))
                if (typeof message.netUsage === "number")
                    object.netUsage = options.longs === String ? String(message.netUsage) : message.netUsage;
                else
                    object.netUsage = options.longs === String ? $util.Long.prototype.toString.call(message.netUsage) : options.longs === Number ? new $util.LongBits(message.netUsage.low >>> 0, message.netUsage.high >>> 0).toNumber() : message.netUsage;
            if (message.netFee != null && message.hasOwnProperty("netFee"))
                if (typeof message.netFee === "number")
                    object.netFee = options.longs === String ? String(message.netFee) : message.netFee;
                else
                    object.netFee = options.longs === String ? $util.Long.prototype.toString.call(message.netFee) : options.longs === Number ? new $util.LongBits(message.netFee.low >>> 0, message.netFee.high >>> 0).toNumber() : message.netFee;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.protocol.Transaction.Result.contractResult[message.result] : message.result;
            return object;
        };

        /**
         * Converts this ResourceReceipt to JSON.
         * @function toJSON
         * @memberof protocol.ResourceReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceReceipt;
    })();

    protocol.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof protocol
         * @interface ITransaction
         * @property {protocol.Transaction.Iraw|null} [rawData] Transaction rawData
         * @property {Array.<Uint8Array>|null} [signature] Transaction signature
         * @property {Array.<protocol.Transaction.IResult>|null} [ret] Transaction ret
         */

        /**
         * Constructs a new Transaction.
         * @memberof protocol
         * @classdesc Represents a Transaction.
         * @implements ITransaction
         * @constructor
         * @param {protocol.ITransaction=} [properties] Properties to set
         */
        function Transaction(properties) {
            this.signature = [];
            this.ret = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transaction rawData.
         * @member {protocol.Transaction.Iraw|null|undefined} rawData
         * @memberof protocol.Transaction
         * @instance
         */
        Transaction.prototype.rawData = null;

        /**
         * Transaction signature.
         * @member {Array.<Uint8Array>} signature
         * @memberof protocol.Transaction
         * @instance
         */
        Transaction.prototype.signature = $util.emptyArray;

        /**
         * Transaction ret.
         * @member {Array.<protocol.Transaction.IResult>} ret
         * @memberof protocol.Transaction
         * @instance
         */
        Transaction.prototype.ret = $util.emptyArray;

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof protocol.Transaction
         * @static
         * @param {protocol.ITransaction=} [properties] Properties to set
         * @returns {protocol.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link protocol.Transaction.verify|verify} messages.
         * @function encode
         * @memberof protocol.Transaction
         * @static
         * @param {protocol.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rawData != null && Object.hasOwnProperty.call(message, "rawData"))
                $root.protocol.Transaction.raw.encode(message.rawData, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.signature != null && message.signature.length)
                for (var i = 0; i < message.signature.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature[i]);
            if (message.ret != null && message.ret.length)
                for (var i = 0; i < message.ret.length; ++i)
                    $root.protocol.Transaction.Result.encode(message.ret[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Transaction message, length delimited. Does not implicitly {@link protocol.Transaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Transaction
         * @static
         * @param {protocol.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rawData = $root.protocol.Transaction.raw.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.signature && message.signature.length))
                        message.signature = [];
                    message.signature.push(reader.bytes());
                    break;
                case 5:
                    if (!(message.ret && message.ret.length))
                        message.ret = [];
                    message.ret.push($root.protocol.Transaction.Result.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transaction message.
         * @function verify
         * @memberof protocol.Transaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rawData != null && message.hasOwnProperty("rawData")) {
                var error = $root.protocol.Transaction.raw.verify(message.rawData);
                if (error)
                    return "rawData." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                if (!Array.isArray(message.signature))
                    return "signature: array expected";
                for (var i = 0; i < message.signature.length; ++i)
                    if (!(message.signature[i] && typeof message.signature[i].length === "number" || $util.isString(message.signature[i])))
                        return "signature: buffer[] expected";
            }
            if (message.ret != null && message.hasOwnProperty("ret")) {
                if (!Array.isArray(message.ret))
                    return "ret: array expected";
                for (var i = 0; i < message.ret.length; ++i) {
                    var error = $root.protocol.Transaction.Result.verify(message.ret[i]);
                    if (error)
                        return "ret." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Transaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Transaction} Transaction
         */
        Transaction.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Transaction)
                return object;
            var message = new $root.protocol.Transaction();
            if (object.rawData != null) {
                if (typeof object.rawData !== "object")
                    throw TypeError(".protocol.Transaction.rawData: object expected");
                message.rawData = $root.protocol.Transaction.raw.fromObject(object.rawData);
            }
            if (object.signature) {
                if (!Array.isArray(object.signature))
                    throw TypeError(".protocol.Transaction.signature: array expected");
                message.signature = [];
                for (var i = 0; i < object.signature.length; ++i)
                    if (typeof object.signature[i] === "string")
                        $util.base64.decode(object.signature[i], message.signature[i] = $util.newBuffer($util.base64.length(object.signature[i])), 0);
                    else if (object.signature[i].length)
                        message.signature[i] = object.signature[i];
            }
            if (object.ret) {
                if (!Array.isArray(object.ret))
                    throw TypeError(".protocol.Transaction.ret: array expected");
                message.ret = [];
                for (var i = 0; i < object.ret.length; ++i) {
                    if (typeof object.ret[i] !== "object")
                        throw TypeError(".protocol.Transaction.ret: object expected");
                    message.ret[i] = $root.protocol.Transaction.Result.fromObject(object.ret[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Transaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Transaction
         * @static
         * @param {protocol.Transaction} message Transaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.signature = [];
                object.ret = [];
            }
            if (options.defaults)
                object.rawData = null;
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                object.rawData = $root.protocol.Transaction.raw.toObject(message.rawData, options);
            if (message.signature && message.signature.length) {
                object.signature = [];
                for (var j = 0; j < message.signature.length; ++j)
                    object.signature[j] = options.bytes === String ? $util.base64.encode(message.signature[j], 0, message.signature[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.signature[j]) : message.signature[j];
            }
            if (message.ret && message.ret.length) {
                object.ret = [];
                for (var j = 0; j < message.ret.length; ++j)
                    object.ret[j] = $root.protocol.Transaction.Result.toObject(message.ret[j], options);
            }
            return object;
        };

        /**
         * Converts this Transaction to JSON.
         * @function toJSON
         * @memberof protocol.Transaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Transaction.Contract = (function() {

            /**
             * Properties of a Contract.
             * @memberof protocol.Transaction
             * @interface IContract
             * @property {protocol.Transaction.Contract.ContractType|null} [type] Contract type
             * @property {google.protobuf.IAny|null} [parameter] Contract parameter
             * @property {Uint8Array|null} [provider] Contract provider
             * @property {Uint8Array|null} [ContractName] Contract ContractName
             * @property {number|null} [PermissionId] Contract PermissionId
             */

            /**
             * Constructs a new Contract.
             * @memberof protocol.Transaction
             * @classdesc Represents a Contract.
             * @implements IContract
             * @constructor
             * @param {protocol.Transaction.IContract=} [properties] Properties to set
             */
            function Contract(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contract type.
             * @member {protocol.Transaction.Contract.ContractType} type
             * @memberof protocol.Transaction.Contract
             * @instance
             */
            Contract.prototype.type = 0;

            /**
             * Contract parameter.
             * @member {google.protobuf.IAny|null|undefined} parameter
             * @memberof protocol.Transaction.Contract
             * @instance
             */
            Contract.prototype.parameter = null;

            /**
             * Contract provider.
             * @member {Uint8Array} provider
             * @memberof protocol.Transaction.Contract
             * @instance
             */
            Contract.prototype.provider = $util.newBuffer([]);

            /**
             * Contract ContractName.
             * @member {Uint8Array} ContractName
             * @memberof protocol.Transaction.Contract
             * @instance
             */
            Contract.prototype.ContractName = $util.newBuffer([]);

            /**
             * Contract PermissionId.
             * @member {number} PermissionId
             * @memberof protocol.Transaction.Contract
             * @instance
             */
            Contract.prototype.PermissionId = 0;

            /**
             * Creates a new Contract instance using the specified properties.
             * @function create
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {protocol.Transaction.IContract=} [properties] Properties to set
             * @returns {protocol.Transaction.Contract} Contract instance
             */
            Contract.create = function create(properties) {
                return new Contract(properties);
            };

            /**
             * Encodes the specified Contract message. Does not implicitly {@link protocol.Transaction.Contract.verify|verify} messages.
             * @function encode
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {protocol.Transaction.IContract} message Contract message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contract.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.parameter != null && Object.hasOwnProperty.call(message, "parameter"))
                    $root.google.protobuf.Any.encode(message.parameter, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.provider);
                if (message.ContractName != null && Object.hasOwnProperty.call(message, "ContractName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ContractName);
                if (message.PermissionId != null && Object.hasOwnProperty.call(message, "PermissionId"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.PermissionId);
                return writer;
            };

            /**
             * Encodes the specified Contract message, length delimited. Does not implicitly {@link protocol.Transaction.Contract.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {protocol.Transaction.IContract} message Contract message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contract.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Contract message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.Transaction.Contract} Contract
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contract.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction.Contract();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.parameter = $root.google.protobuf.Any.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.provider = reader.bytes();
                        break;
                    case 4:
                        message.ContractName = reader.bytes();
                        break;
                    case 5:
                        message.PermissionId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Contract message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.Transaction.Contract} Contract
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contract.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Contract message.
             * @function verify
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Contract.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 48:
                        break;
                    }
                if (message.parameter != null && message.hasOwnProperty("parameter")) {
                    var error = $root.google.protobuf.Any.verify(message.parameter);
                    if (error)
                        return "parameter." + error;
                }
                if (message.provider != null && message.hasOwnProperty("provider"))
                    if (!(message.provider && typeof message.provider.length === "number" || $util.isString(message.provider)))
                        return "provider: buffer expected";
                if (message.ContractName != null && message.hasOwnProperty("ContractName"))
                    if (!(message.ContractName && typeof message.ContractName.length === "number" || $util.isString(message.ContractName)))
                        return "ContractName: buffer expected";
                if (message.PermissionId != null && message.hasOwnProperty("PermissionId"))
                    if (!$util.isInteger(message.PermissionId))
                        return "PermissionId: integer expected";
                return null;
            };

            /**
             * Creates a Contract message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.Transaction.Contract} Contract
             */
            Contract.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Transaction.Contract)
                    return object;
                var message = new $root.protocol.Transaction.Contract();
                switch (object.type) {
                case "AccountCreateContract":
                case 0:
                    message.type = 0;
                    break;
                case "TransferContract":
                case 1:
                    message.type = 1;
                    break;
                case "TransferAssetContract":
                case 2:
                    message.type = 2;
                    break;
                case "VoteAssetContract":
                case 3:
                    message.type = 3;
                    break;
                case "VoteWitnessContract":
                case 4:
                    message.type = 4;
                    break;
                case "WitnessCreateContract":
                case 5:
                    message.type = 5;
                    break;
                case "AssetIssueContract":
                case 6:
                    message.type = 6;
                    break;
                case "WitnessUpdateContract":
                case 8:
                    message.type = 8;
                    break;
                case "ParticipateAssetIssueContract":
                case 9:
                    message.type = 9;
                    break;
                case "AccountUpdateContract":
                case 10:
                    message.type = 10;
                    break;
                case "FreezeBalanceContract":
                case 11:
                    message.type = 11;
                    break;
                case "UnfreezeBalanceContract":
                case 12:
                    message.type = 12;
                    break;
                case "WithdrawBalanceContract":
                case 13:
                    message.type = 13;
                    break;
                case "UnfreezeAssetContract":
                case 14:
                    message.type = 14;
                    break;
                case "UpdateAssetContract":
                case 15:
                    message.type = 15;
                    break;
                case "ProposalCreateContract":
                case 16:
                    message.type = 16;
                    break;
                case "ProposalApproveContract":
                case 17:
                    message.type = 17;
                    break;
                case "ProposalDeleteContract":
                case 18:
                    message.type = 18;
                    break;
                case "SetAccountIdContract":
                case 19:
                    message.type = 19;
                    break;
                case "CustomContract":
                case 20:
                    message.type = 20;
                    break;
                case "CreateSmartContract":
                case 30:
                    message.type = 30;
                    break;
                case "TriggerSmartContract":
                case 31:
                    message.type = 31;
                    break;
                case "GetContract":
                case 32:
                    message.type = 32;
                    break;
                case "UpdateSettingContract":
                case 33:
                    message.type = 33;
                    break;
                case "ExchangeCreateContract":
                case 41:
                    message.type = 41;
                    break;
                case "ExchangeInjectContract":
                case 42:
                    message.type = 42;
                    break;
                case "ExchangeWithdrawContract":
                case 43:
                    message.type = 43;
                    break;
                case "ExchangeTransactionContract":
                case 44:
                    message.type = 44;
                    break;
                case "UpdateEnergyLimitContract":
                case 45:
                    message.type = 45;
                    break;
                case "AccountPermissionUpdateContract":
                case 46:
                    message.type = 46;
                    break;
                case "ClearABIContract":
                case 48:
                    message.type = 48;
                    break;
                }
                if (object.parameter != null) {
                    if (typeof object.parameter !== "object")
                        throw TypeError(".protocol.Transaction.Contract.parameter: object expected");
                    message.parameter = $root.google.protobuf.Any.fromObject(object.parameter);
                }
                if (object.provider != null)
                    if (typeof object.provider === "string")
                        $util.base64.decode(object.provider, message.provider = $util.newBuffer($util.base64.length(object.provider)), 0);
                    else if (object.provider.length)
                        message.provider = object.provider;
                if (object.ContractName != null)
                    if (typeof object.ContractName === "string")
                        $util.base64.decode(object.ContractName, message.ContractName = $util.newBuffer($util.base64.length(object.ContractName)), 0);
                    else if (object.ContractName.length)
                        message.ContractName = object.ContractName;
                if (object.PermissionId != null)
                    message.PermissionId = object.PermissionId | 0;
                return message;
            };

            /**
             * Creates a plain object from a Contract message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {protocol.Transaction.Contract} message Contract
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contract.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "AccountCreateContract" : 0;
                    object.parameter = null;
                    if (options.bytes === String)
                        object.provider = "";
                    else {
                        object.provider = [];
                        if (options.bytes !== Array)
                            object.provider = $util.newBuffer(object.provider);
                    }
                    if (options.bytes === String)
                        object.ContractName = "";
                    else {
                        object.ContractName = [];
                        if (options.bytes !== Array)
                            object.ContractName = $util.newBuffer(object.ContractName);
                    }
                    object.PermissionId = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protocol.Transaction.Contract.ContractType[message.type] : message.type;
                if (message.parameter != null && message.hasOwnProperty("parameter"))
                    object.parameter = $root.google.protobuf.Any.toObject(message.parameter, options);
                if (message.provider != null && message.hasOwnProperty("provider"))
                    object.provider = options.bytes === String ? $util.base64.encode(message.provider, 0, message.provider.length) : options.bytes === Array ? Array.prototype.slice.call(message.provider) : message.provider;
                if (message.ContractName != null && message.hasOwnProperty("ContractName"))
                    object.ContractName = options.bytes === String ? $util.base64.encode(message.ContractName, 0, message.ContractName.length) : options.bytes === Array ? Array.prototype.slice.call(message.ContractName) : message.ContractName;
                if (message.PermissionId != null && message.hasOwnProperty("PermissionId"))
                    object.PermissionId = message.PermissionId;
                return object;
            };

            /**
             * Converts this Contract to JSON.
             * @function toJSON
             * @memberof protocol.Transaction.Contract
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contract.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * ContractType enum.
             * @name protocol.Transaction.Contract.ContractType
             * @enum {number}
             * @property {number} AccountCreateContract=0 AccountCreateContract value
             * @property {number} TransferContract=1 TransferContract value
             * @property {number} TransferAssetContract=2 TransferAssetContract value
             * @property {number} VoteAssetContract=3 VoteAssetContract value
             * @property {number} VoteWitnessContract=4 VoteWitnessContract value
             * @property {number} WitnessCreateContract=5 WitnessCreateContract value
             * @property {number} AssetIssueContract=6 AssetIssueContract value
             * @property {number} WitnessUpdateContract=8 WitnessUpdateContract value
             * @property {number} ParticipateAssetIssueContract=9 ParticipateAssetIssueContract value
             * @property {number} AccountUpdateContract=10 AccountUpdateContract value
             * @property {number} FreezeBalanceContract=11 FreezeBalanceContract value
             * @property {number} UnfreezeBalanceContract=12 UnfreezeBalanceContract value
             * @property {number} WithdrawBalanceContract=13 WithdrawBalanceContract value
             * @property {number} UnfreezeAssetContract=14 UnfreezeAssetContract value
             * @property {number} UpdateAssetContract=15 UpdateAssetContract value
             * @property {number} ProposalCreateContract=16 ProposalCreateContract value
             * @property {number} ProposalApproveContract=17 ProposalApproveContract value
             * @property {number} ProposalDeleteContract=18 ProposalDeleteContract value
             * @property {number} SetAccountIdContract=19 SetAccountIdContract value
             * @property {number} CustomContract=20 CustomContract value
             * @property {number} CreateSmartContract=30 CreateSmartContract value
             * @property {number} TriggerSmartContract=31 TriggerSmartContract value
             * @property {number} GetContract=32 GetContract value
             * @property {number} UpdateSettingContract=33 UpdateSettingContract value
             * @property {number} ExchangeCreateContract=41 ExchangeCreateContract value
             * @property {number} ExchangeInjectContract=42 ExchangeInjectContract value
             * @property {number} ExchangeWithdrawContract=43 ExchangeWithdrawContract value
             * @property {number} ExchangeTransactionContract=44 ExchangeTransactionContract value
             * @property {number} UpdateEnergyLimitContract=45 UpdateEnergyLimitContract value
             * @property {number} AccountPermissionUpdateContract=46 AccountPermissionUpdateContract value
             * @property {number} ClearABIContract=48 ClearABIContract value
             */
            Contract.ContractType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "AccountCreateContract"] = 0;
                values[valuesById[1] = "TransferContract"] = 1;
                values[valuesById[2] = "TransferAssetContract"] = 2;
                values[valuesById[3] = "VoteAssetContract"] = 3;
                values[valuesById[4] = "VoteWitnessContract"] = 4;
                values[valuesById[5] = "WitnessCreateContract"] = 5;
                values[valuesById[6] = "AssetIssueContract"] = 6;
                values[valuesById[8] = "WitnessUpdateContract"] = 8;
                values[valuesById[9] = "ParticipateAssetIssueContract"] = 9;
                values[valuesById[10] = "AccountUpdateContract"] = 10;
                values[valuesById[11] = "FreezeBalanceContract"] = 11;
                values[valuesById[12] = "UnfreezeBalanceContract"] = 12;
                values[valuesById[13] = "WithdrawBalanceContract"] = 13;
                values[valuesById[14] = "UnfreezeAssetContract"] = 14;
                values[valuesById[15] = "UpdateAssetContract"] = 15;
                values[valuesById[16] = "ProposalCreateContract"] = 16;
                values[valuesById[17] = "ProposalApproveContract"] = 17;
                values[valuesById[18] = "ProposalDeleteContract"] = 18;
                values[valuesById[19] = "SetAccountIdContract"] = 19;
                values[valuesById[20] = "CustomContract"] = 20;
                values[valuesById[30] = "CreateSmartContract"] = 30;
                values[valuesById[31] = "TriggerSmartContract"] = 31;
                values[valuesById[32] = "GetContract"] = 32;
                values[valuesById[33] = "UpdateSettingContract"] = 33;
                values[valuesById[41] = "ExchangeCreateContract"] = 41;
                values[valuesById[42] = "ExchangeInjectContract"] = 42;
                values[valuesById[43] = "ExchangeWithdrawContract"] = 43;
                values[valuesById[44] = "ExchangeTransactionContract"] = 44;
                values[valuesById[45] = "UpdateEnergyLimitContract"] = 45;
                values[valuesById[46] = "AccountPermissionUpdateContract"] = 46;
                values[valuesById[48] = "ClearABIContract"] = 48;
                return values;
            })();

            return Contract;
        })();

        Transaction.Result = (function() {

            /**
             * Properties of a Result.
             * @memberof protocol.Transaction
             * @interface IResult
             * @property {number|Long|null} [fee] Result fee
             * @property {protocol.Transaction.Result.code|null} [ret] Result ret
             * @property {protocol.Transaction.Result.contractResult|null} [contractRet] Result contractRet
             * @property {string|null} [assetIssueID] Result assetIssueID
             * @property {number|Long|null} [withdrawAmount] Result withdrawAmount
             * @property {number|Long|null} [unfreezeAmount] Result unfreezeAmount
             * @property {number|Long|null} [exchangeReceivedAmount] Result exchangeReceivedAmount
             * @property {number|Long|null} [exchangeInjectAnotherAmount] Result exchangeInjectAnotherAmount
             * @property {number|Long|null} [exchangeWithdrawAnotherAmount] Result exchangeWithdrawAnotherAmount
             * @property {number|Long|null} [exchangeId] Result exchangeId
             */

            /**
             * Constructs a new Result.
             * @memberof protocol.Transaction
             * @classdesc Represents a Result.
             * @implements IResult
             * @constructor
             * @param {protocol.Transaction.IResult=} [properties] Properties to set
             */
            function Result(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Result fee.
             * @member {number|Long} fee
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result ret.
             * @member {protocol.Transaction.Result.code} ret
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.ret = 0;

            /**
             * Result contractRet.
             * @member {protocol.Transaction.Result.contractResult} contractRet
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.contractRet = 0;

            /**
             * Result assetIssueID.
             * @member {string} assetIssueID
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.assetIssueID = "";

            /**
             * Result withdrawAmount.
             * @member {number|Long} withdrawAmount
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.withdrawAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result unfreezeAmount.
             * @member {number|Long} unfreezeAmount
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.unfreezeAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result exchangeReceivedAmount.
             * @member {number|Long} exchangeReceivedAmount
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.exchangeReceivedAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result exchangeInjectAnotherAmount.
             * @member {number|Long} exchangeInjectAnotherAmount
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.exchangeInjectAnotherAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result exchangeWithdrawAnotherAmount.
             * @member {number|Long} exchangeWithdrawAnotherAmount
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.exchangeWithdrawAnotherAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result exchangeId.
             * @member {number|Long} exchangeId
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Result instance using the specified properties.
             * @function create
             * @memberof protocol.Transaction.Result
             * @static
             * @param {protocol.Transaction.IResult=} [properties] Properties to set
             * @returns {protocol.Transaction.Result} Result instance
             */
            Result.create = function create(properties) {
                return new Result(properties);
            };

            /**
             * Encodes the specified Result message. Does not implicitly {@link protocol.Transaction.Result.verify|verify} messages.
             * @function encode
             * @memberof protocol.Transaction.Result
             * @static
             * @param {protocol.Transaction.IResult} message Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Result.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.fee);
                if (message.ret != null && Object.hasOwnProperty.call(message, "ret"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ret);
                if (message.contractRet != null && Object.hasOwnProperty.call(message, "contractRet"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.contractRet);
                if (message.assetIssueID != null && Object.hasOwnProperty.call(message, "assetIssueID"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.assetIssueID);
                if (message.withdrawAmount != null && Object.hasOwnProperty.call(message, "withdrawAmount"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int64(message.withdrawAmount);
                if (message.unfreezeAmount != null && Object.hasOwnProperty.call(message, "unfreezeAmount"))
                    writer.uint32(/* id 16, wireType 0 =*/128).int64(message.unfreezeAmount);
                if (message.exchangeReceivedAmount != null && Object.hasOwnProperty.call(message, "exchangeReceivedAmount"))
                    writer.uint32(/* id 18, wireType 0 =*/144).int64(message.exchangeReceivedAmount);
                if (message.exchangeInjectAnotherAmount != null && Object.hasOwnProperty.call(message, "exchangeInjectAnotherAmount"))
                    writer.uint32(/* id 19, wireType 0 =*/152).int64(message.exchangeInjectAnotherAmount);
                if (message.exchangeWithdrawAnotherAmount != null && Object.hasOwnProperty.call(message, "exchangeWithdrawAnotherAmount"))
                    writer.uint32(/* id 20, wireType 0 =*/160).int64(message.exchangeWithdrawAnotherAmount);
                if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                    writer.uint32(/* id 21, wireType 0 =*/168).int64(message.exchangeId);
                return writer;
            };

            /**
             * Encodes the specified Result message, length delimited. Does not implicitly {@link protocol.Transaction.Result.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.Transaction.Result
             * @static
             * @param {protocol.Transaction.IResult} message Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Result.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Result message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.Transaction.Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.Transaction.Result} Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Result.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction.Result();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fee = reader.int64();
                        break;
                    case 2:
                        message.ret = reader.int32();
                        break;
                    case 3:
                        message.contractRet = reader.int32();
                        break;
                    case 14:
                        message.assetIssueID = reader.string();
                        break;
                    case 15:
                        message.withdrawAmount = reader.int64();
                        break;
                    case 16:
                        message.unfreezeAmount = reader.int64();
                        break;
                    case 18:
                        message.exchangeReceivedAmount = reader.int64();
                        break;
                    case 19:
                        message.exchangeInjectAnotherAmount = reader.int64();
                        break;
                    case 20:
                        message.exchangeWithdrawAnotherAmount = reader.int64();
                        break;
                    case 21:
                        message.exchangeId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Result message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.Transaction.Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.Transaction.Result} Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Result.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Result message.
             * @function verify
             * @memberof protocol.Transaction.Result
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Result.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fee != null && message.hasOwnProperty("fee"))
                    if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                        return "fee: integer|Long expected";
                if (message.ret != null && message.hasOwnProperty("ret"))
                    switch (message.ret) {
                    default:
                        return "ret: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.contractRet != null && message.hasOwnProperty("contractRet"))
                    switch (message.contractRet) {
                    default:
                        return "contractRet: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                        break;
                    }
                if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                    if (!$util.isString(message.assetIssueID))
                        return "assetIssueID: string expected";
                if (message.withdrawAmount != null && message.hasOwnProperty("withdrawAmount"))
                    if (!$util.isInteger(message.withdrawAmount) && !(message.withdrawAmount && $util.isInteger(message.withdrawAmount.low) && $util.isInteger(message.withdrawAmount.high)))
                        return "withdrawAmount: integer|Long expected";
                if (message.unfreezeAmount != null && message.hasOwnProperty("unfreezeAmount"))
                    if (!$util.isInteger(message.unfreezeAmount) && !(message.unfreezeAmount && $util.isInteger(message.unfreezeAmount.low) && $util.isInteger(message.unfreezeAmount.high)))
                        return "unfreezeAmount: integer|Long expected";
                if (message.exchangeReceivedAmount != null && message.hasOwnProperty("exchangeReceivedAmount"))
                    if (!$util.isInteger(message.exchangeReceivedAmount) && !(message.exchangeReceivedAmount && $util.isInteger(message.exchangeReceivedAmount.low) && $util.isInteger(message.exchangeReceivedAmount.high)))
                        return "exchangeReceivedAmount: integer|Long expected";
                if (message.exchangeInjectAnotherAmount != null && message.hasOwnProperty("exchangeInjectAnotherAmount"))
                    if (!$util.isInteger(message.exchangeInjectAnotherAmount) && !(message.exchangeInjectAnotherAmount && $util.isInteger(message.exchangeInjectAnotherAmount.low) && $util.isInteger(message.exchangeInjectAnotherAmount.high)))
                        return "exchangeInjectAnotherAmount: integer|Long expected";
                if (message.exchangeWithdrawAnotherAmount != null && message.hasOwnProperty("exchangeWithdrawAnotherAmount"))
                    if (!$util.isInteger(message.exchangeWithdrawAnotherAmount) && !(message.exchangeWithdrawAnotherAmount && $util.isInteger(message.exchangeWithdrawAnotherAmount.low) && $util.isInteger(message.exchangeWithdrawAnotherAmount.high)))
                        return "exchangeWithdrawAnotherAmount: integer|Long expected";
                if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                    if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                        return "exchangeId: integer|Long expected";
                return null;
            };

            /**
             * Creates a Result message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.Transaction.Result
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.Transaction.Result} Result
             */
            Result.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Transaction.Result)
                    return object;
                var message = new $root.protocol.Transaction.Result();
                if (object.fee != null)
                    if ($util.Long)
                        (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                    else if (typeof object.fee === "string")
                        message.fee = parseInt(object.fee, 10);
                    else if (typeof object.fee === "number")
                        message.fee = object.fee;
                    else if (typeof object.fee === "object")
                        message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                switch (object.ret) {
                case "SUCESS":
                case 0:
                    message.ret = 0;
                    break;
                case "FAILED":
                case 1:
                    message.ret = 1;
                    break;
                }
                switch (object.contractRet) {
                case "DEFAULT":
                case 0:
                    message.contractRet = 0;
                    break;
                case "SUCCESS":
                case 1:
                    message.contractRet = 1;
                    break;
                case "REVERT":
                case 2:
                    message.contractRet = 2;
                    break;
                case "BAD_JUMP_DESTINATION":
                case 3:
                    message.contractRet = 3;
                    break;
                case "OUT_OF_MEMORY":
                case 4:
                    message.contractRet = 4;
                    break;
                case "PRECOMPILED_CONTRACT":
                case 5:
                    message.contractRet = 5;
                    break;
                case "STACK_TOO_SMALL":
                case 6:
                    message.contractRet = 6;
                    break;
                case "STACK_TOO_LARGE":
                case 7:
                    message.contractRet = 7;
                    break;
                case "ILLEGAL_OPERATION":
                case 8:
                    message.contractRet = 8;
                    break;
                case "STACK_OVERFLOW":
                case 9:
                    message.contractRet = 9;
                    break;
                case "OUT_OF_ENERGY":
                case 10:
                    message.contractRet = 10;
                    break;
                case "OUT_OF_TIME":
                case 11:
                    message.contractRet = 11;
                    break;
                case "JVM_STACK_OVER_FLOW":
                case 12:
                    message.contractRet = 12;
                    break;
                case "UNKNOWN":
                case 13:
                    message.contractRet = 13;
                    break;
                case "TRANSFER_FAILED":
                case 14:
                    message.contractRet = 14;
                    break;
                }
                if (object.assetIssueID != null)
                    message.assetIssueID = String(object.assetIssueID);
                if (object.withdrawAmount != null)
                    if ($util.Long)
                        (message.withdrawAmount = $util.Long.fromValue(object.withdrawAmount)).unsigned = false;
                    else if (typeof object.withdrawAmount === "string")
                        message.withdrawAmount = parseInt(object.withdrawAmount, 10);
                    else if (typeof object.withdrawAmount === "number")
                        message.withdrawAmount = object.withdrawAmount;
                    else if (typeof object.withdrawAmount === "object")
                        message.withdrawAmount = new $util.LongBits(object.withdrawAmount.low >>> 0, object.withdrawAmount.high >>> 0).toNumber();
                if (object.unfreezeAmount != null)
                    if ($util.Long)
                        (message.unfreezeAmount = $util.Long.fromValue(object.unfreezeAmount)).unsigned = false;
                    else if (typeof object.unfreezeAmount === "string")
                        message.unfreezeAmount = parseInt(object.unfreezeAmount, 10);
                    else if (typeof object.unfreezeAmount === "number")
                        message.unfreezeAmount = object.unfreezeAmount;
                    else if (typeof object.unfreezeAmount === "object")
                        message.unfreezeAmount = new $util.LongBits(object.unfreezeAmount.low >>> 0, object.unfreezeAmount.high >>> 0).toNumber();
                if (object.exchangeReceivedAmount != null)
                    if ($util.Long)
                        (message.exchangeReceivedAmount = $util.Long.fromValue(object.exchangeReceivedAmount)).unsigned = false;
                    else if (typeof object.exchangeReceivedAmount === "string")
                        message.exchangeReceivedAmount = parseInt(object.exchangeReceivedAmount, 10);
                    else if (typeof object.exchangeReceivedAmount === "number")
                        message.exchangeReceivedAmount = object.exchangeReceivedAmount;
                    else if (typeof object.exchangeReceivedAmount === "object")
                        message.exchangeReceivedAmount = new $util.LongBits(object.exchangeReceivedAmount.low >>> 0, object.exchangeReceivedAmount.high >>> 0).toNumber();
                if (object.exchangeInjectAnotherAmount != null)
                    if ($util.Long)
                        (message.exchangeInjectAnotherAmount = $util.Long.fromValue(object.exchangeInjectAnotherAmount)).unsigned = false;
                    else if (typeof object.exchangeInjectAnotherAmount === "string")
                        message.exchangeInjectAnotherAmount = parseInt(object.exchangeInjectAnotherAmount, 10);
                    else if (typeof object.exchangeInjectAnotherAmount === "number")
                        message.exchangeInjectAnotherAmount = object.exchangeInjectAnotherAmount;
                    else if (typeof object.exchangeInjectAnotherAmount === "object")
                        message.exchangeInjectAnotherAmount = new $util.LongBits(object.exchangeInjectAnotherAmount.low >>> 0, object.exchangeInjectAnotherAmount.high >>> 0).toNumber();
                if (object.exchangeWithdrawAnotherAmount != null)
                    if ($util.Long)
                        (message.exchangeWithdrawAnotherAmount = $util.Long.fromValue(object.exchangeWithdrawAnotherAmount)).unsigned = false;
                    else if (typeof object.exchangeWithdrawAnotherAmount === "string")
                        message.exchangeWithdrawAnotherAmount = parseInt(object.exchangeWithdrawAnotherAmount, 10);
                    else if (typeof object.exchangeWithdrawAnotherAmount === "number")
                        message.exchangeWithdrawAnotherAmount = object.exchangeWithdrawAnotherAmount;
                    else if (typeof object.exchangeWithdrawAnotherAmount === "object")
                        message.exchangeWithdrawAnotherAmount = new $util.LongBits(object.exchangeWithdrawAnotherAmount.low >>> 0, object.exchangeWithdrawAnotherAmount.high >>> 0).toNumber();
                if (object.exchangeId != null)
                    if ($util.Long)
                        (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                    else if (typeof object.exchangeId === "string")
                        message.exchangeId = parseInt(object.exchangeId, 10);
                    else if (typeof object.exchangeId === "number")
                        message.exchangeId = object.exchangeId;
                    else if (typeof object.exchangeId === "object")
                        message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Result message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.Transaction.Result
             * @static
             * @param {protocol.Transaction.Result} message Result
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Result.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fee = options.longs === String ? "0" : 0;
                    object.ret = options.enums === String ? "SUCESS" : 0;
                    object.contractRet = options.enums === String ? "DEFAULT" : 0;
                    object.assetIssueID = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.withdrawAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.withdrawAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.unfreezeAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.unfreezeAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchangeReceivedAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.exchangeReceivedAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchangeInjectAnotherAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.exchangeInjectAnotherAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchangeWithdrawAnotherAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.exchangeWithdrawAnotherAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.exchangeId = options.longs === String ? "0" : 0;
                }
                if (message.fee != null && message.hasOwnProperty("fee"))
                    if (typeof message.fee === "number")
                        object.fee = options.longs === String ? String(message.fee) : message.fee;
                    else
                        object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                if (message.ret != null && message.hasOwnProperty("ret"))
                    object.ret = options.enums === String ? $root.protocol.Transaction.Result.code[message.ret] : message.ret;
                if (message.contractRet != null && message.hasOwnProperty("contractRet"))
                    object.contractRet = options.enums === String ? $root.protocol.Transaction.Result.contractResult[message.contractRet] : message.contractRet;
                if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                    object.assetIssueID = message.assetIssueID;
                if (message.withdrawAmount != null && message.hasOwnProperty("withdrawAmount"))
                    if (typeof message.withdrawAmount === "number")
                        object.withdrawAmount = options.longs === String ? String(message.withdrawAmount) : message.withdrawAmount;
                    else
                        object.withdrawAmount = options.longs === String ? $util.Long.prototype.toString.call(message.withdrawAmount) : options.longs === Number ? new $util.LongBits(message.withdrawAmount.low >>> 0, message.withdrawAmount.high >>> 0).toNumber() : message.withdrawAmount;
                if (message.unfreezeAmount != null && message.hasOwnProperty("unfreezeAmount"))
                    if (typeof message.unfreezeAmount === "number")
                        object.unfreezeAmount = options.longs === String ? String(message.unfreezeAmount) : message.unfreezeAmount;
                    else
                        object.unfreezeAmount = options.longs === String ? $util.Long.prototype.toString.call(message.unfreezeAmount) : options.longs === Number ? new $util.LongBits(message.unfreezeAmount.low >>> 0, message.unfreezeAmount.high >>> 0).toNumber() : message.unfreezeAmount;
                if (message.exchangeReceivedAmount != null && message.hasOwnProperty("exchangeReceivedAmount"))
                    if (typeof message.exchangeReceivedAmount === "number")
                        object.exchangeReceivedAmount = options.longs === String ? String(message.exchangeReceivedAmount) : message.exchangeReceivedAmount;
                    else
                        object.exchangeReceivedAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeReceivedAmount) : options.longs === Number ? new $util.LongBits(message.exchangeReceivedAmount.low >>> 0, message.exchangeReceivedAmount.high >>> 0).toNumber() : message.exchangeReceivedAmount;
                if (message.exchangeInjectAnotherAmount != null && message.hasOwnProperty("exchangeInjectAnotherAmount"))
                    if (typeof message.exchangeInjectAnotherAmount === "number")
                        object.exchangeInjectAnotherAmount = options.longs === String ? String(message.exchangeInjectAnotherAmount) : message.exchangeInjectAnotherAmount;
                    else
                        object.exchangeInjectAnotherAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeInjectAnotherAmount) : options.longs === Number ? new $util.LongBits(message.exchangeInjectAnotherAmount.low >>> 0, message.exchangeInjectAnotherAmount.high >>> 0).toNumber() : message.exchangeInjectAnotherAmount;
                if (message.exchangeWithdrawAnotherAmount != null && message.hasOwnProperty("exchangeWithdrawAnotherAmount"))
                    if (typeof message.exchangeWithdrawAnotherAmount === "number")
                        object.exchangeWithdrawAnotherAmount = options.longs === String ? String(message.exchangeWithdrawAnotherAmount) : message.exchangeWithdrawAnotherAmount;
                    else
                        object.exchangeWithdrawAnotherAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeWithdrawAnotherAmount) : options.longs === Number ? new $util.LongBits(message.exchangeWithdrawAnotherAmount.low >>> 0, message.exchangeWithdrawAnotherAmount.high >>> 0).toNumber() : message.exchangeWithdrawAnotherAmount;
                if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                    if (typeof message.exchangeId === "number")
                        object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                    else
                        object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
                return object;
            };

            /**
             * Converts this Result to JSON.
             * @function toJSON
             * @memberof protocol.Transaction.Result
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Result.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * code enum.
             * @name protocol.Transaction.Result.code
             * @enum {number}
             * @property {number} SUCESS=0 SUCESS value
             * @property {number} FAILED=1 FAILED value
             */
            Result.code = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SUCESS"] = 0;
                values[valuesById[1] = "FAILED"] = 1;
                return values;
            })();

            /**
             * contractResult enum.
             * @name protocol.Transaction.Result.contractResult
             * @enum {number}
             * @property {number} DEFAULT=0 DEFAULT value
             * @property {number} SUCCESS=1 SUCCESS value
             * @property {number} REVERT=2 REVERT value
             * @property {number} BAD_JUMP_DESTINATION=3 BAD_JUMP_DESTINATION value
             * @property {number} OUT_OF_MEMORY=4 OUT_OF_MEMORY value
             * @property {number} PRECOMPILED_CONTRACT=5 PRECOMPILED_CONTRACT value
             * @property {number} STACK_TOO_SMALL=6 STACK_TOO_SMALL value
             * @property {number} STACK_TOO_LARGE=7 STACK_TOO_LARGE value
             * @property {number} ILLEGAL_OPERATION=8 ILLEGAL_OPERATION value
             * @property {number} STACK_OVERFLOW=9 STACK_OVERFLOW value
             * @property {number} OUT_OF_ENERGY=10 OUT_OF_ENERGY value
             * @property {number} OUT_OF_TIME=11 OUT_OF_TIME value
             * @property {number} JVM_STACK_OVER_FLOW=12 JVM_STACK_OVER_FLOW value
             * @property {number} UNKNOWN=13 UNKNOWN value
             * @property {number} TRANSFER_FAILED=14 TRANSFER_FAILED value
             */
            Result.contractResult = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DEFAULT"] = 0;
                values[valuesById[1] = "SUCCESS"] = 1;
                values[valuesById[2] = "REVERT"] = 2;
                values[valuesById[3] = "BAD_JUMP_DESTINATION"] = 3;
                values[valuesById[4] = "OUT_OF_MEMORY"] = 4;
                values[valuesById[5] = "PRECOMPILED_CONTRACT"] = 5;
                values[valuesById[6] = "STACK_TOO_SMALL"] = 6;
                values[valuesById[7] = "STACK_TOO_LARGE"] = 7;
                values[valuesById[8] = "ILLEGAL_OPERATION"] = 8;
                values[valuesById[9] = "STACK_OVERFLOW"] = 9;
                values[valuesById[10] = "OUT_OF_ENERGY"] = 10;
                values[valuesById[11] = "OUT_OF_TIME"] = 11;
                values[valuesById[12] = "JVM_STACK_OVER_FLOW"] = 12;
                values[valuesById[13] = "UNKNOWN"] = 13;
                values[valuesById[14] = "TRANSFER_FAILED"] = 14;
                return values;
            })();

            return Result;
        })();

        Transaction.raw = (function() {

            /**
             * Properties of a raw.
             * @memberof protocol.Transaction
             * @interface Iraw
             * @property {Uint8Array|null} [refBlockBytes] raw refBlockBytes
             * @property {number|Long|null} [refBlockNum] raw refBlockNum
             * @property {Uint8Array|null} [refBlockHash] raw refBlockHash
             * @property {number|Long|null} [expiration] raw expiration
             * @property {Array.<protocol.Iauthority>|null} [auths] raw auths
             * @property {Uint8Array|null} [data] raw data
             * @property {Array.<protocol.Transaction.IContract>|null} [contract] raw contract
             * @property {Uint8Array|null} [scripts] raw scripts
             * @property {number|Long|null} [timestamp] raw timestamp
             * @property {number|Long|null} [feeLimit] raw feeLimit
             */

            /**
             * Constructs a new raw.
             * @memberof protocol.Transaction
             * @classdesc Represents a raw.
             * @implements Iraw
             * @constructor
             * @param {protocol.Transaction.Iraw=} [properties] Properties to set
             */
            function raw(properties) {
                this.auths = [];
                this.contract = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * raw refBlockBytes.
             * @member {Uint8Array} refBlockBytes
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.refBlockBytes = $util.newBuffer([]);

            /**
             * raw refBlockNum.
             * @member {number|Long} refBlockNum
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.refBlockNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw refBlockHash.
             * @member {Uint8Array} refBlockHash
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.refBlockHash = $util.newBuffer([]);

            /**
             * raw expiration.
             * @member {number|Long} expiration
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw auths.
             * @member {Array.<protocol.Iauthority>} auths
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.auths = $util.emptyArray;

            /**
             * raw data.
             * @member {Uint8Array} data
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.data = $util.newBuffer([]);

            /**
             * raw contract.
             * @member {Array.<protocol.Transaction.IContract>} contract
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.contract = $util.emptyArray;

            /**
             * raw scripts.
             * @member {Uint8Array} scripts
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.scripts = $util.newBuffer([]);

            /**
             * raw timestamp.
             * @member {number|Long} timestamp
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw feeLimit.
             * @member {number|Long} feeLimit
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.feeLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new raw instance using the specified properties.
             * @function create
             * @memberof protocol.Transaction.raw
             * @static
             * @param {protocol.Transaction.Iraw=} [properties] Properties to set
             * @returns {protocol.Transaction.raw} raw instance
             */
            raw.create = function create(properties) {
                return new raw(properties);
            };

            /**
             * Encodes the specified raw message. Does not implicitly {@link protocol.Transaction.raw.verify|verify} messages.
             * @function encode
             * @memberof protocol.Transaction.raw
             * @static
             * @param {protocol.Transaction.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.refBlockBytes != null && Object.hasOwnProperty.call(message, "refBlockBytes"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.refBlockBytes);
                if (message.refBlockNum != null && Object.hasOwnProperty.call(message, "refBlockNum"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.refBlockNum);
                if (message.refBlockHash != null && Object.hasOwnProperty.call(message, "refBlockHash"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.refBlockHash);
                if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.expiration);
                if (message.auths != null && message.auths.length)
                    for (var i = 0; i < message.auths.length; ++i)
                        $root.protocol.authority.encode(message.auths[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.data);
                if (message.contract != null && message.contract.length)
                    for (var i = 0; i < message.contract.length; ++i)
                        $root.protocol.Transaction.Contract.encode(message.contract[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.scripts != null && Object.hasOwnProperty.call(message, "scripts"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.scripts);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.timestamp);
                if (message.feeLimit != null && Object.hasOwnProperty.call(message, "feeLimit"))
                    writer.uint32(/* id 18, wireType 0 =*/144).int64(message.feeLimit);
                return writer;
            };

            /**
             * Encodes the specified raw message, length delimited. Does not implicitly {@link protocol.Transaction.raw.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.Transaction.raw
             * @static
             * @param {protocol.Transaction.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a raw message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.Transaction.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.Transaction.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction.raw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.refBlockBytes = reader.bytes();
                        break;
                    case 3:
                        message.refBlockNum = reader.int64();
                        break;
                    case 4:
                        message.refBlockHash = reader.bytes();
                        break;
                    case 8:
                        message.expiration = reader.int64();
                        break;
                    case 9:
                        if (!(message.auths && message.auths.length))
                            message.auths = [];
                        message.auths.push($root.protocol.authority.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        message.data = reader.bytes();
                        break;
                    case 11:
                        if (!(message.contract && message.contract.length))
                            message.contract = [];
                        message.contract.push($root.protocol.Transaction.Contract.decode(reader, reader.uint32()));
                        break;
                    case 12:
                        message.scripts = reader.bytes();
                        break;
                    case 14:
                        message.timestamp = reader.int64();
                        break;
                    case 18:
                        message.feeLimit = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a raw message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.Transaction.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.Transaction.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a raw message.
             * @function verify
             * @memberof protocol.Transaction.raw
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            raw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.refBlockBytes != null && message.hasOwnProperty("refBlockBytes"))
                    if (!(message.refBlockBytes && typeof message.refBlockBytes.length === "number" || $util.isString(message.refBlockBytes)))
                        return "refBlockBytes: buffer expected";
                if (message.refBlockNum != null && message.hasOwnProperty("refBlockNum"))
                    if (!$util.isInteger(message.refBlockNum) && !(message.refBlockNum && $util.isInteger(message.refBlockNum.low) && $util.isInteger(message.refBlockNum.high)))
                        return "refBlockNum: integer|Long expected";
                if (message.refBlockHash != null && message.hasOwnProperty("refBlockHash"))
                    if (!(message.refBlockHash && typeof message.refBlockHash.length === "number" || $util.isString(message.refBlockHash)))
                        return "refBlockHash: buffer expected";
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                        return "expiration: integer|Long expected";
                if (message.auths != null && message.hasOwnProperty("auths")) {
                    if (!Array.isArray(message.auths))
                        return "auths: array expected";
                    for (var i = 0; i < message.auths.length; ++i) {
                        var error = $root.protocol.authority.verify(message.auths[i]);
                        if (error)
                            return "auths." + error;
                    }
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                if (message.contract != null && message.hasOwnProperty("contract")) {
                    if (!Array.isArray(message.contract))
                        return "contract: array expected";
                    for (var i = 0; i < message.contract.length; ++i) {
                        var error = $root.protocol.Transaction.Contract.verify(message.contract[i]);
                        if (error)
                            return "contract." + error;
                    }
                }
                if (message.scripts != null && message.hasOwnProperty("scripts"))
                    if (!(message.scripts && typeof message.scripts.length === "number" || $util.isString(message.scripts)))
                        return "scripts: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                    if (!$util.isInteger(message.feeLimit) && !(message.feeLimit && $util.isInteger(message.feeLimit.low) && $util.isInteger(message.feeLimit.high)))
                        return "feeLimit: integer|Long expected";
                return null;
            };

            /**
             * Creates a raw message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.Transaction.raw
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.Transaction.raw} raw
             */
            raw.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Transaction.raw)
                    return object;
                var message = new $root.protocol.Transaction.raw();
                if (object.refBlockBytes != null)
                    if (typeof object.refBlockBytes === "string")
                        $util.base64.decode(object.refBlockBytes, message.refBlockBytes = $util.newBuffer($util.base64.length(object.refBlockBytes)), 0);
                    else if (object.refBlockBytes.length)
                        message.refBlockBytes = object.refBlockBytes;
                if (object.refBlockNum != null)
                    if ($util.Long)
                        (message.refBlockNum = $util.Long.fromValue(object.refBlockNum)).unsigned = false;
                    else if (typeof object.refBlockNum === "string")
                        message.refBlockNum = parseInt(object.refBlockNum, 10);
                    else if (typeof object.refBlockNum === "number")
                        message.refBlockNum = object.refBlockNum;
                    else if (typeof object.refBlockNum === "object")
                        message.refBlockNum = new $util.LongBits(object.refBlockNum.low >>> 0, object.refBlockNum.high >>> 0).toNumber();
                if (object.refBlockHash != null)
                    if (typeof object.refBlockHash === "string")
                        $util.base64.decode(object.refBlockHash, message.refBlockHash = $util.newBuffer($util.base64.length(object.refBlockHash)), 0);
                    else if (object.refBlockHash.length)
                        message.refBlockHash = object.refBlockHash;
                if (object.expiration != null)
                    if ($util.Long)
                        (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                    else if (typeof object.expiration === "string")
                        message.expiration = parseInt(object.expiration, 10);
                    else if (typeof object.expiration === "number")
                        message.expiration = object.expiration;
                    else if (typeof object.expiration === "object")
                        message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
                if (object.auths) {
                    if (!Array.isArray(object.auths))
                        throw TypeError(".protocol.Transaction.raw.auths: array expected");
                    message.auths = [];
                    for (var i = 0; i < object.auths.length; ++i) {
                        if (typeof object.auths[i] !== "object")
                            throw TypeError(".protocol.Transaction.raw.auths: object expected");
                        message.auths[i] = $root.protocol.authority.fromObject(object.auths[i]);
                    }
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                if (object.contract) {
                    if (!Array.isArray(object.contract))
                        throw TypeError(".protocol.Transaction.raw.contract: array expected");
                    message.contract = [];
                    for (var i = 0; i < object.contract.length; ++i) {
                        if (typeof object.contract[i] !== "object")
                            throw TypeError(".protocol.Transaction.raw.contract: object expected");
                        message.contract[i] = $root.protocol.Transaction.Contract.fromObject(object.contract[i]);
                    }
                }
                if (object.scripts != null)
                    if (typeof object.scripts === "string")
                        $util.base64.decode(object.scripts, message.scripts = $util.newBuffer($util.base64.length(object.scripts)), 0);
                    else if (object.scripts.length)
                        message.scripts = object.scripts;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.feeLimit != null)
                    if ($util.Long)
                        (message.feeLimit = $util.Long.fromValue(object.feeLimit)).unsigned = false;
                    else if (typeof object.feeLimit === "string")
                        message.feeLimit = parseInt(object.feeLimit, 10);
                    else if (typeof object.feeLimit === "number")
                        message.feeLimit = object.feeLimit;
                    else if (typeof object.feeLimit === "object")
                        message.feeLimit = new $util.LongBits(object.feeLimit.low >>> 0, object.feeLimit.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a raw message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.Transaction.raw
             * @static
             * @param {protocol.Transaction.raw} message raw
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            raw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.auths = [];
                    object.contract = [];
                }
                if (options.defaults) {
                    if (options.bytes === String)
                        object.refBlockBytes = "";
                    else {
                        object.refBlockBytes = [];
                        if (options.bytes !== Array)
                            object.refBlockBytes = $util.newBuffer(object.refBlockBytes);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.refBlockNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.refBlockNum = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.refBlockHash = "";
                    else {
                        object.refBlockHash = [];
                        if (options.bytes !== Array)
                            object.refBlockHash = $util.newBuffer(object.refBlockHash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expiration = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                    if (options.bytes === String)
                        object.scripts = "";
                    else {
                        object.scripts = [];
                        if (options.bytes !== Array)
                            object.scripts = $util.newBuffer(object.scripts);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.feeLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.feeLimit = options.longs === String ? "0" : 0;
                }
                if (message.refBlockBytes != null && message.hasOwnProperty("refBlockBytes"))
                    object.refBlockBytes = options.bytes === String ? $util.base64.encode(message.refBlockBytes, 0, message.refBlockBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.refBlockBytes) : message.refBlockBytes;
                if (message.refBlockNum != null && message.hasOwnProperty("refBlockNum"))
                    if (typeof message.refBlockNum === "number")
                        object.refBlockNum = options.longs === String ? String(message.refBlockNum) : message.refBlockNum;
                    else
                        object.refBlockNum = options.longs === String ? $util.Long.prototype.toString.call(message.refBlockNum) : options.longs === Number ? new $util.LongBits(message.refBlockNum.low >>> 0, message.refBlockNum.high >>> 0).toNumber() : message.refBlockNum;
                if (message.refBlockHash != null && message.hasOwnProperty("refBlockHash"))
                    object.refBlockHash = options.bytes === String ? $util.base64.encode(message.refBlockHash, 0, message.refBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.refBlockHash) : message.refBlockHash;
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (typeof message.expiration === "number")
                        object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                    else
                        object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
                if (message.auths && message.auths.length) {
                    object.auths = [];
                    for (var j = 0; j < message.auths.length; ++j)
                        object.auths[j] = $root.protocol.authority.toObject(message.auths[j], options);
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.contract && message.contract.length) {
                    object.contract = [];
                    for (var j = 0; j < message.contract.length; ++j)
                        object.contract[j] = $root.protocol.Transaction.Contract.toObject(message.contract[j], options);
                }
                if (message.scripts != null && message.hasOwnProperty("scripts"))
                    object.scripts = options.bytes === String ? $util.base64.encode(message.scripts, 0, message.scripts.length) : options.bytes === Array ? Array.prototype.slice.call(message.scripts) : message.scripts;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                    if (typeof message.feeLimit === "number")
                        object.feeLimit = options.longs === String ? String(message.feeLimit) : message.feeLimit;
                    else
                        object.feeLimit = options.longs === String ? $util.Long.prototype.toString.call(message.feeLimit) : options.longs === Number ? new $util.LongBits(message.feeLimit.low >>> 0, message.feeLimit.high >>> 0).toNumber() : message.feeLimit;
                return object;
            };

            /**
             * Converts this raw to JSON.
             * @function toJSON
             * @memberof protocol.Transaction.raw
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            raw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return raw;
        })();

        return Transaction;
    })();

    protocol.TransactionInfo = (function() {

        /**
         * Properties of a TransactionInfo.
         * @memberof protocol
         * @interface ITransactionInfo
         * @property {Uint8Array|null} [id] TransactionInfo id
         * @property {number|Long|null} [fee] TransactionInfo fee
         * @property {number|Long|null} [blockNumber] TransactionInfo blockNumber
         * @property {number|Long|null} [blockTimeStamp] TransactionInfo blockTimeStamp
         * @property {Array.<Uint8Array>|null} [contractResult] TransactionInfo contractResult
         * @property {Uint8Array|null} [contractAddress] TransactionInfo contractAddress
         * @property {protocol.IResourceReceipt|null} [receipt] TransactionInfo receipt
         * @property {Array.<protocol.TransactionInfo.ILog>|null} [log] TransactionInfo log
         * @property {protocol.TransactionInfo.code|null} [result] TransactionInfo result
         * @property {Uint8Array|null} [resMessage] TransactionInfo resMessage
         * @property {string|null} [assetIssueID] TransactionInfo assetIssueID
         * @property {number|Long|null} [withdrawAmount] TransactionInfo withdrawAmount
         * @property {number|Long|null} [unfreezeAmount] TransactionInfo unfreezeAmount
         * @property {Array.<protocol.IInternalTransaction>|null} [internalTransactions] TransactionInfo internalTransactions
         * @property {number|Long|null} [exchangeReceivedAmount] TransactionInfo exchangeReceivedAmount
         * @property {number|Long|null} [exchangeInjectAnotherAmount] TransactionInfo exchangeInjectAnotherAmount
         * @property {number|Long|null} [exchangeWithdrawAnotherAmount] TransactionInfo exchangeWithdrawAnotherAmount
         * @property {number|Long|null} [exchangeId] TransactionInfo exchangeId
         */

        /**
         * Constructs a new TransactionInfo.
         * @memberof protocol
         * @classdesc Represents a TransactionInfo.
         * @implements ITransactionInfo
         * @constructor
         * @param {protocol.ITransactionInfo=} [properties] Properties to set
         */
        function TransactionInfo(properties) {
            this.contractResult = [];
            this.log = [];
            this.internalTransactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionInfo id.
         * @member {Uint8Array} id
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.id = $util.newBuffer([]);

        /**
         * TransactionInfo fee.
         * @member {number|Long} fee
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo blockNumber.
         * @member {number|Long} blockNumber
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo blockTimeStamp.
         * @member {number|Long} blockTimeStamp
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.blockTimeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo contractResult.
         * @member {Array.<Uint8Array>} contractResult
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.contractResult = $util.emptyArray;

        /**
         * TransactionInfo contractAddress.
         * @member {Uint8Array} contractAddress
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.contractAddress = $util.newBuffer([]);

        /**
         * TransactionInfo receipt.
         * @member {protocol.IResourceReceipt|null|undefined} receipt
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.receipt = null;

        /**
         * TransactionInfo log.
         * @member {Array.<protocol.TransactionInfo.ILog>} log
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.log = $util.emptyArray;

        /**
         * TransactionInfo result.
         * @member {protocol.TransactionInfo.code} result
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.result = 0;

        /**
         * TransactionInfo resMessage.
         * @member {Uint8Array} resMessage
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.resMessage = $util.newBuffer([]);

        /**
         * TransactionInfo assetIssueID.
         * @member {string} assetIssueID
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.assetIssueID = "";

        /**
         * TransactionInfo withdrawAmount.
         * @member {number|Long} withdrawAmount
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.withdrawAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo unfreezeAmount.
         * @member {number|Long} unfreezeAmount
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.unfreezeAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo internalTransactions.
         * @member {Array.<protocol.IInternalTransaction>} internalTransactions
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.internalTransactions = $util.emptyArray;

        /**
         * TransactionInfo exchangeReceivedAmount.
         * @member {number|Long} exchangeReceivedAmount
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.exchangeReceivedAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo exchangeInjectAnotherAmount.
         * @member {number|Long} exchangeInjectAnotherAmount
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.exchangeInjectAnotherAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo exchangeWithdrawAnotherAmount.
         * @member {number|Long} exchangeWithdrawAnotherAmount
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.exchangeWithdrawAnotherAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo exchangeId.
         * @member {number|Long} exchangeId
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TransactionInfo instance using the specified properties.
         * @function create
         * @memberof protocol.TransactionInfo
         * @static
         * @param {protocol.ITransactionInfo=} [properties] Properties to set
         * @returns {protocol.TransactionInfo} TransactionInfo instance
         */
        TransactionInfo.create = function create(properties) {
            return new TransactionInfo(properties);
        };

        /**
         * Encodes the specified TransactionInfo message. Does not implicitly {@link protocol.TransactionInfo.verify|verify} messages.
         * @function encode
         * @memberof protocol.TransactionInfo
         * @static
         * @param {protocol.ITransactionInfo} message TransactionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fee);
            if (message.blockNumber != null && Object.hasOwnProperty.call(message, "blockNumber"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.blockNumber);
            if (message.blockTimeStamp != null && Object.hasOwnProperty.call(message, "blockTimeStamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.blockTimeStamp);
            if (message.contractResult != null && message.contractResult.length)
                for (var i = 0; i < message.contractResult.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.contractResult[i]);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.contractAddress);
            if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
                $root.protocol.ResourceReceipt.encode(message.receipt, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.log != null && message.log.length)
                for (var i = 0; i < message.log.length; ++i)
                    $root.protocol.TransactionInfo.Log.encode(message.log[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.result);
            if (message.resMessage != null && Object.hasOwnProperty.call(message, "resMessage"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.resMessage);
            if (message.assetIssueID != null && Object.hasOwnProperty.call(message, "assetIssueID"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.assetIssueID);
            if (message.withdrawAmount != null && Object.hasOwnProperty.call(message, "withdrawAmount"))
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.withdrawAmount);
            if (message.unfreezeAmount != null && Object.hasOwnProperty.call(message, "unfreezeAmount"))
                writer.uint32(/* id 16, wireType 0 =*/128).int64(message.unfreezeAmount);
            if (message.internalTransactions != null && message.internalTransactions.length)
                for (var i = 0; i < message.internalTransactions.length; ++i)
                    $root.protocol.InternalTransaction.encode(message.internalTransactions[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.exchangeReceivedAmount != null && Object.hasOwnProperty.call(message, "exchangeReceivedAmount"))
                writer.uint32(/* id 18, wireType 0 =*/144).int64(message.exchangeReceivedAmount);
            if (message.exchangeInjectAnotherAmount != null && Object.hasOwnProperty.call(message, "exchangeInjectAnotherAmount"))
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.exchangeInjectAnotherAmount);
            if (message.exchangeWithdrawAnotherAmount != null && Object.hasOwnProperty.call(message, "exchangeWithdrawAnotherAmount"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.exchangeWithdrawAnotherAmount);
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.exchangeId);
            return writer;
        };

        /**
         * Encodes the specified TransactionInfo message, length delimited. Does not implicitly {@link protocol.TransactionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TransactionInfo
         * @static
         * @param {protocol.ITransactionInfo} message TransactionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TransactionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TransactionInfo} TransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.fee = reader.int64();
                    break;
                case 3:
                    message.blockNumber = reader.int64();
                    break;
                case 4:
                    message.blockTimeStamp = reader.int64();
                    break;
                case 5:
                    if (!(message.contractResult && message.contractResult.length))
                        message.contractResult = [];
                    message.contractResult.push(reader.bytes());
                    break;
                case 6:
                    message.contractAddress = reader.bytes();
                    break;
                case 7:
                    message.receipt = $root.protocol.ResourceReceipt.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.log && message.log.length))
                        message.log = [];
                    message.log.push($root.protocol.TransactionInfo.Log.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.result = reader.int32();
                    break;
                case 10:
                    message.resMessage = reader.bytes();
                    break;
                case 14:
                    message.assetIssueID = reader.string();
                    break;
                case 15:
                    message.withdrawAmount = reader.int64();
                    break;
                case 16:
                    message.unfreezeAmount = reader.int64();
                    break;
                case 17:
                    if (!(message.internalTransactions && message.internalTransactions.length))
                        message.internalTransactions = [];
                    message.internalTransactions.push($root.protocol.InternalTransaction.decode(reader, reader.uint32()));
                    break;
                case 18:
                    message.exchangeReceivedAmount = reader.int64();
                    break;
                case 19:
                    message.exchangeInjectAnotherAmount = reader.int64();
                    break;
                case 20:
                    message.exchangeWithdrawAnotherAmount = reader.int64();
                    break;
                case 21:
                    message.exchangeId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TransactionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TransactionInfo} TransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionInfo message.
         * @function verify
         * @memberof protocol.TransactionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                    return "blockNumber: integer|Long expected";
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (!$util.isInteger(message.blockTimeStamp) && !(message.blockTimeStamp && $util.isInteger(message.blockTimeStamp.low) && $util.isInteger(message.blockTimeStamp.high)))
                    return "blockTimeStamp: integer|Long expected";
            if (message.contractResult != null && message.hasOwnProperty("contractResult")) {
                if (!Array.isArray(message.contractResult))
                    return "contractResult: array expected";
                for (var i = 0; i < message.contractResult.length; ++i)
                    if (!(message.contractResult[i] && typeof message.contractResult[i].length === "number" || $util.isString(message.contractResult[i])))
                        return "contractResult: buffer[] expected";
            }
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            if (message.receipt != null && message.hasOwnProperty("receipt")) {
                var error = $root.protocol.ResourceReceipt.verify(message.receipt);
                if (error)
                    return "receipt." + error;
            }
            if (message.log != null && message.hasOwnProperty("log")) {
                if (!Array.isArray(message.log))
                    return "log: array expected";
                for (var i = 0; i < message.log.length; ++i) {
                    var error = $root.protocol.TransactionInfo.Log.verify(message.log[i]);
                    if (error)
                        return "log." + error;
                }
            }
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.resMessage != null && message.hasOwnProperty("resMessage"))
                if (!(message.resMessage && typeof message.resMessage.length === "number" || $util.isString(message.resMessage)))
                    return "resMessage: buffer expected";
            if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                if (!$util.isString(message.assetIssueID))
                    return "assetIssueID: string expected";
            if (message.withdrawAmount != null && message.hasOwnProperty("withdrawAmount"))
                if (!$util.isInteger(message.withdrawAmount) && !(message.withdrawAmount && $util.isInteger(message.withdrawAmount.low) && $util.isInteger(message.withdrawAmount.high)))
                    return "withdrawAmount: integer|Long expected";
            if (message.unfreezeAmount != null && message.hasOwnProperty("unfreezeAmount"))
                if (!$util.isInteger(message.unfreezeAmount) && !(message.unfreezeAmount && $util.isInteger(message.unfreezeAmount.low) && $util.isInteger(message.unfreezeAmount.high)))
                    return "unfreezeAmount: integer|Long expected";
            if (message.internalTransactions != null && message.hasOwnProperty("internalTransactions")) {
                if (!Array.isArray(message.internalTransactions))
                    return "internalTransactions: array expected";
                for (var i = 0; i < message.internalTransactions.length; ++i) {
                    var error = $root.protocol.InternalTransaction.verify(message.internalTransactions[i]);
                    if (error)
                        return "internalTransactions." + error;
                }
            }
            if (message.exchangeReceivedAmount != null && message.hasOwnProperty("exchangeReceivedAmount"))
                if (!$util.isInteger(message.exchangeReceivedAmount) && !(message.exchangeReceivedAmount && $util.isInteger(message.exchangeReceivedAmount.low) && $util.isInteger(message.exchangeReceivedAmount.high)))
                    return "exchangeReceivedAmount: integer|Long expected";
            if (message.exchangeInjectAnotherAmount != null && message.hasOwnProperty("exchangeInjectAnotherAmount"))
                if (!$util.isInteger(message.exchangeInjectAnotherAmount) && !(message.exchangeInjectAnotherAmount && $util.isInteger(message.exchangeInjectAnotherAmount.low) && $util.isInteger(message.exchangeInjectAnotherAmount.high)))
                    return "exchangeInjectAnotherAmount: integer|Long expected";
            if (message.exchangeWithdrawAnotherAmount != null && message.hasOwnProperty("exchangeWithdrawAnotherAmount"))
                if (!$util.isInteger(message.exchangeWithdrawAnotherAmount) && !(message.exchangeWithdrawAnotherAmount && $util.isInteger(message.exchangeWithdrawAnotherAmount.low) && $util.isInteger(message.exchangeWithdrawAnotherAmount.high)))
                    return "exchangeWithdrawAnotherAmount: integer|Long expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            return null;
        };

        /**
         * Creates a TransactionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TransactionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TransactionInfo} TransactionInfo
         */
        TransactionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransactionInfo)
                return object;
            var message = new $root.protocol.TransactionInfo();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.blockNumber != null)
                if ($util.Long)
                    (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                else if (typeof object.blockNumber === "string")
                    message.blockNumber = parseInt(object.blockNumber, 10);
                else if (typeof object.blockNumber === "number")
                    message.blockNumber = object.blockNumber;
                else if (typeof object.blockNumber === "object")
                    message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
            if (object.blockTimeStamp != null)
                if ($util.Long)
                    (message.blockTimeStamp = $util.Long.fromValue(object.blockTimeStamp)).unsigned = false;
                else if (typeof object.blockTimeStamp === "string")
                    message.blockTimeStamp = parseInt(object.blockTimeStamp, 10);
                else if (typeof object.blockTimeStamp === "number")
                    message.blockTimeStamp = object.blockTimeStamp;
                else if (typeof object.blockTimeStamp === "object")
                    message.blockTimeStamp = new $util.LongBits(object.blockTimeStamp.low >>> 0, object.blockTimeStamp.high >>> 0).toNumber();
            if (object.contractResult) {
                if (!Array.isArray(object.contractResult))
                    throw TypeError(".protocol.TransactionInfo.contractResult: array expected");
                message.contractResult = [];
                for (var i = 0; i < object.contractResult.length; ++i)
                    if (typeof object.contractResult[i] === "string")
                        $util.base64.decode(object.contractResult[i], message.contractResult[i] = $util.newBuffer($util.base64.length(object.contractResult[i])), 0);
                    else if (object.contractResult[i].length)
                        message.contractResult[i] = object.contractResult[i];
            }
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            if (object.receipt != null) {
                if (typeof object.receipt !== "object")
                    throw TypeError(".protocol.TransactionInfo.receipt: object expected");
                message.receipt = $root.protocol.ResourceReceipt.fromObject(object.receipt);
            }
            if (object.log) {
                if (!Array.isArray(object.log))
                    throw TypeError(".protocol.TransactionInfo.log: array expected");
                message.log = [];
                for (var i = 0; i < object.log.length; ++i) {
                    if (typeof object.log[i] !== "object")
                        throw TypeError(".protocol.TransactionInfo.log: object expected");
                    message.log[i] = $root.protocol.TransactionInfo.Log.fromObject(object.log[i]);
                }
            }
            switch (object.result) {
            case "SUCESS":
            case 0:
                message.result = 0;
                break;
            case "FAILED":
            case 1:
                message.result = 1;
                break;
            }
            if (object.resMessage != null)
                if (typeof object.resMessage === "string")
                    $util.base64.decode(object.resMessage, message.resMessage = $util.newBuffer($util.base64.length(object.resMessage)), 0);
                else if (object.resMessage.length)
                    message.resMessage = object.resMessage;
            if (object.assetIssueID != null)
                message.assetIssueID = String(object.assetIssueID);
            if (object.withdrawAmount != null)
                if ($util.Long)
                    (message.withdrawAmount = $util.Long.fromValue(object.withdrawAmount)).unsigned = false;
                else if (typeof object.withdrawAmount === "string")
                    message.withdrawAmount = parseInt(object.withdrawAmount, 10);
                else if (typeof object.withdrawAmount === "number")
                    message.withdrawAmount = object.withdrawAmount;
                else if (typeof object.withdrawAmount === "object")
                    message.withdrawAmount = new $util.LongBits(object.withdrawAmount.low >>> 0, object.withdrawAmount.high >>> 0).toNumber();
            if (object.unfreezeAmount != null)
                if ($util.Long)
                    (message.unfreezeAmount = $util.Long.fromValue(object.unfreezeAmount)).unsigned = false;
                else if (typeof object.unfreezeAmount === "string")
                    message.unfreezeAmount = parseInt(object.unfreezeAmount, 10);
                else if (typeof object.unfreezeAmount === "number")
                    message.unfreezeAmount = object.unfreezeAmount;
                else if (typeof object.unfreezeAmount === "object")
                    message.unfreezeAmount = new $util.LongBits(object.unfreezeAmount.low >>> 0, object.unfreezeAmount.high >>> 0).toNumber();
            if (object.internalTransactions) {
                if (!Array.isArray(object.internalTransactions))
                    throw TypeError(".protocol.TransactionInfo.internalTransactions: array expected");
                message.internalTransactions = [];
                for (var i = 0; i < object.internalTransactions.length; ++i) {
                    if (typeof object.internalTransactions[i] !== "object")
                        throw TypeError(".protocol.TransactionInfo.internalTransactions: object expected");
                    message.internalTransactions[i] = $root.protocol.InternalTransaction.fromObject(object.internalTransactions[i]);
                }
            }
            if (object.exchangeReceivedAmount != null)
                if ($util.Long)
                    (message.exchangeReceivedAmount = $util.Long.fromValue(object.exchangeReceivedAmount)).unsigned = false;
                else if (typeof object.exchangeReceivedAmount === "string")
                    message.exchangeReceivedAmount = parseInt(object.exchangeReceivedAmount, 10);
                else if (typeof object.exchangeReceivedAmount === "number")
                    message.exchangeReceivedAmount = object.exchangeReceivedAmount;
                else if (typeof object.exchangeReceivedAmount === "object")
                    message.exchangeReceivedAmount = new $util.LongBits(object.exchangeReceivedAmount.low >>> 0, object.exchangeReceivedAmount.high >>> 0).toNumber();
            if (object.exchangeInjectAnotherAmount != null)
                if ($util.Long)
                    (message.exchangeInjectAnotherAmount = $util.Long.fromValue(object.exchangeInjectAnotherAmount)).unsigned = false;
                else if (typeof object.exchangeInjectAnotherAmount === "string")
                    message.exchangeInjectAnotherAmount = parseInt(object.exchangeInjectAnotherAmount, 10);
                else if (typeof object.exchangeInjectAnotherAmount === "number")
                    message.exchangeInjectAnotherAmount = object.exchangeInjectAnotherAmount;
                else if (typeof object.exchangeInjectAnotherAmount === "object")
                    message.exchangeInjectAnotherAmount = new $util.LongBits(object.exchangeInjectAnotherAmount.low >>> 0, object.exchangeInjectAnotherAmount.high >>> 0).toNumber();
            if (object.exchangeWithdrawAnotherAmount != null)
                if ($util.Long)
                    (message.exchangeWithdrawAnotherAmount = $util.Long.fromValue(object.exchangeWithdrawAnotherAmount)).unsigned = false;
                else if (typeof object.exchangeWithdrawAnotherAmount === "string")
                    message.exchangeWithdrawAnotherAmount = parseInt(object.exchangeWithdrawAnotherAmount, 10);
                else if (typeof object.exchangeWithdrawAnotherAmount === "number")
                    message.exchangeWithdrawAnotherAmount = object.exchangeWithdrawAnotherAmount;
                else if (typeof object.exchangeWithdrawAnotherAmount === "object")
                    message.exchangeWithdrawAnotherAmount = new $util.LongBits(object.exchangeWithdrawAnotherAmount.low >>> 0, object.exchangeWithdrawAnotherAmount.high >>> 0).toNumber();
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TransactionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TransactionInfo
         * @static
         * @param {protocol.TransactionInfo} message TransactionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.contractResult = [];
                object.log = [];
                object.internalTransactions = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockTimeStamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
                object.receipt = null;
                object.result = options.enums === String ? "SUCESS" : 0;
                if (options.bytes === String)
                    object.resMessage = "";
                else {
                    object.resMessage = [];
                    if (options.bytes !== Array)
                        object.resMessage = $util.newBuffer(object.resMessage);
                }
                object.assetIssueID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.withdrawAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.withdrawAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.unfreezeAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unfreezeAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeReceivedAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchangeReceivedAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeInjectAnotherAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchangeInjectAnotherAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeWithdrawAnotherAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchangeWithdrawAnotherAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchangeId = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (typeof message.blockNumber === "number")
                    object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                else
                    object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (typeof message.blockTimeStamp === "number")
                    object.blockTimeStamp = options.longs === String ? String(message.blockTimeStamp) : message.blockTimeStamp;
                else
                    object.blockTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.blockTimeStamp) : options.longs === Number ? new $util.LongBits(message.blockTimeStamp.low >>> 0, message.blockTimeStamp.high >>> 0).toNumber() : message.blockTimeStamp;
            if (message.contractResult && message.contractResult.length) {
                object.contractResult = [];
                for (var j = 0; j < message.contractResult.length; ++j)
                    object.contractResult[j] = options.bytes === String ? $util.base64.encode(message.contractResult[j], 0, message.contractResult[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.contractResult[j]) : message.contractResult[j];
            }
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            if (message.receipt != null && message.hasOwnProperty("receipt"))
                object.receipt = $root.protocol.ResourceReceipt.toObject(message.receipt, options);
            if (message.log && message.log.length) {
                object.log = [];
                for (var j = 0; j < message.log.length; ++j)
                    object.log[j] = $root.protocol.TransactionInfo.Log.toObject(message.log[j], options);
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.protocol.TransactionInfo.code[message.result] : message.result;
            if (message.resMessage != null && message.hasOwnProperty("resMessage"))
                object.resMessage = options.bytes === String ? $util.base64.encode(message.resMessage, 0, message.resMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.resMessage) : message.resMessage;
            if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                object.assetIssueID = message.assetIssueID;
            if (message.withdrawAmount != null && message.hasOwnProperty("withdrawAmount"))
                if (typeof message.withdrawAmount === "number")
                    object.withdrawAmount = options.longs === String ? String(message.withdrawAmount) : message.withdrawAmount;
                else
                    object.withdrawAmount = options.longs === String ? $util.Long.prototype.toString.call(message.withdrawAmount) : options.longs === Number ? new $util.LongBits(message.withdrawAmount.low >>> 0, message.withdrawAmount.high >>> 0).toNumber() : message.withdrawAmount;
            if (message.unfreezeAmount != null && message.hasOwnProperty("unfreezeAmount"))
                if (typeof message.unfreezeAmount === "number")
                    object.unfreezeAmount = options.longs === String ? String(message.unfreezeAmount) : message.unfreezeAmount;
                else
                    object.unfreezeAmount = options.longs === String ? $util.Long.prototype.toString.call(message.unfreezeAmount) : options.longs === Number ? new $util.LongBits(message.unfreezeAmount.low >>> 0, message.unfreezeAmount.high >>> 0).toNumber() : message.unfreezeAmount;
            if (message.internalTransactions && message.internalTransactions.length) {
                object.internalTransactions = [];
                for (var j = 0; j < message.internalTransactions.length; ++j)
                    object.internalTransactions[j] = $root.protocol.InternalTransaction.toObject(message.internalTransactions[j], options);
            }
            if (message.exchangeReceivedAmount != null && message.hasOwnProperty("exchangeReceivedAmount"))
                if (typeof message.exchangeReceivedAmount === "number")
                    object.exchangeReceivedAmount = options.longs === String ? String(message.exchangeReceivedAmount) : message.exchangeReceivedAmount;
                else
                    object.exchangeReceivedAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeReceivedAmount) : options.longs === Number ? new $util.LongBits(message.exchangeReceivedAmount.low >>> 0, message.exchangeReceivedAmount.high >>> 0).toNumber() : message.exchangeReceivedAmount;
            if (message.exchangeInjectAnotherAmount != null && message.hasOwnProperty("exchangeInjectAnotherAmount"))
                if (typeof message.exchangeInjectAnotherAmount === "number")
                    object.exchangeInjectAnotherAmount = options.longs === String ? String(message.exchangeInjectAnotherAmount) : message.exchangeInjectAnotherAmount;
                else
                    object.exchangeInjectAnotherAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeInjectAnotherAmount) : options.longs === Number ? new $util.LongBits(message.exchangeInjectAnotherAmount.low >>> 0, message.exchangeInjectAnotherAmount.high >>> 0).toNumber() : message.exchangeInjectAnotherAmount;
            if (message.exchangeWithdrawAnotherAmount != null && message.hasOwnProperty("exchangeWithdrawAnotherAmount"))
                if (typeof message.exchangeWithdrawAnotherAmount === "number")
                    object.exchangeWithdrawAnotherAmount = options.longs === String ? String(message.exchangeWithdrawAnotherAmount) : message.exchangeWithdrawAnotherAmount;
                else
                    object.exchangeWithdrawAnotherAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeWithdrawAnotherAmount) : options.longs === Number ? new $util.LongBits(message.exchangeWithdrawAnotherAmount.low >>> 0, message.exchangeWithdrawAnotherAmount.high >>> 0).toNumber() : message.exchangeWithdrawAnotherAmount;
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
            return object;
        };

        /**
         * Converts this TransactionInfo to JSON.
         * @function toJSON
         * @memberof protocol.TransactionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * code enum.
         * @name protocol.TransactionInfo.code
         * @enum {number}
         * @property {number} SUCESS=0 SUCESS value
         * @property {number} FAILED=1 FAILED value
         */
        TransactionInfo.code = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCESS"] = 0;
            values[valuesById[1] = "FAILED"] = 1;
            return values;
        })();

        TransactionInfo.Log = (function() {

            /**
             * Properties of a Log.
             * @memberof protocol.TransactionInfo
             * @interface ILog
             * @property {Uint8Array|null} [address] Log address
             * @property {Array.<Uint8Array>|null} [topics] Log topics
             * @property {Uint8Array|null} [data] Log data
             */

            /**
             * Constructs a new Log.
             * @memberof protocol.TransactionInfo
             * @classdesc Represents a Log.
             * @implements ILog
             * @constructor
             * @param {protocol.TransactionInfo.ILog=} [properties] Properties to set
             */
            function Log(properties) {
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Log address.
             * @member {Uint8Array} address
             * @memberof protocol.TransactionInfo.Log
             * @instance
             */
            Log.prototype.address = $util.newBuffer([]);

            /**
             * Log topics.
             * @member {Array.<Uint8Array>} topics
             * @memberof protocol.TransactionInfo.Log
             * @instance
             */
            Log.prototype.topics = $util.emptyArray;

            /**
             * Log data.
             * @member {Uint8Array} data
             * @memberof protocol.TransactionInfo.Log
             * @instance
             */
            Log.prototype.data = $util.newBuffer([]);

            /**
             * Creates a new Log instance using the specified properties.
             * @function create
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {protocol.TransactionInfo.ILog=} [properties] Properties to set
             * @returns {protocol.TransactionInfo.Log} Log instance
             */
            Log.create = function create(properties) {
                return new Log(properties);
            };

            /**
             * Encodes the specified Log message. Does not implicitly {@link protocol.TransactionInfo.Log.verify|verify} messages.
             * @function encode
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {protocol.TransactionInfo.ILog} message Log message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Log.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.topics[i]);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                return writer;
            };

            /**
             * Encodes the specified Log message, length delimited. Does not implicitly {@link protocol.TransactionInfo.Log.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {protocol.TransactionInfo.ILog} message Log message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Log.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Log message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.TransactionInfo.Log} Log
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Log.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionInfo.Log();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.bytes();
                        break;
                    case 2:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.bytes());
                        break;
                    case 3:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Log message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.TransactionInfo.Log} Log
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Log.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Log message.
             * @function verify
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Log.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                        return "address: buffer expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!(message.topics[i] && typeof message.topics[i].length === "number" || $util.isString(message.topics[i])))
                            return "topics: buffer[] expected";
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };

            /**
             * Creates a Log message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.TransactionInfo.Log} Log
             */
            Log.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.TransactionInfo.Log)
                    return object;
                var message = new $root.protocol.TransactionInfo.Log();
                if (object.address != null)
                    if (typeof object.address === "string")
                        $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                    else if (object.address.length)
                        message.address = object.address;
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protocol.TransactionInfo.Log.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        if (typeof object.topics[i] === "string")
                            $util.base64.decode(object.topics[i], message.topics[i] = $util.newBuffer($util.base64.length(object.topics[i])), 0);
                        else if (object.topics[i].length)
                            message.topics[i] = object.topics[i];
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };

            /**
             * Creates a plain object from a Log message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {protocol.TransactionInfo.Log} message Log
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Log.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.address = "";
                    else {
                        object.address = [];
                        if (options.bytes !== Array)
                            object.address = $util.newBuffer(object.address);
                    }
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = options.bytes === String ? $util.base64.encode(message.topics[j], 0, message.topics[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.topics[j]) : message.topics[j];
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };

            /**
             * Converts this Log to JSON.
             * @function toJSON
             * @memberof protocol.TransactionInfo.Log
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Log.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Log;
        })();

        return TransactionInfo;
    })();

    protocol.TransactionRet = (function() {

        /**
         * Properties of a TransactionRet.
         * @memberof protocol
         * @interface ITransactionRet
         * @property {number|Long|null} [blockNumber] TransactionRet blockNumber
         * @property {number|Long|null} [blockTimeStamp] TransactionRet blockTimeStamp
         * @property {Array.<protocol.ITransactionInfo>|null} [transactioninfo] TransactionRet transactioninfo
         */

        /**
         * Constructs a new TransactionRet.
         * @memberof protocol
         * @classdesc Represents a TransactionRet.
         * @implements ITransactionRet
         * @constructor
         * @param {protocol.ITransactionRet=} [properties] Properties to set
         */
        function TransactionRet(properties) {
            this.transactioninfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionRet blockNumber.
         * @member {number|Long} blockNumber
         * @memberof protocol.TransactionRet
         * @instance
         */
        TransactionRet.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionRet blockTimeStamp.
         * @member {number|Long} blockTimeStamp
         * @memberof protocol.TransactionRet
         * @instance
         */
        TransactionRet.prototype.blockTimeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionRet transactioninfo.
         * @member {Array.<protocol.ITransactionInfo>} transactioninfo
         * @memberof protocol.TransactionRet
         * @instance
         */
        TransactionRet.prototype.transactioninfo = $util.emptyArray;

        /**
         * Creates a new TransactionRet instance using the specified properties.
         * @function create
         * @memberof protocol.TransactionRet
         * @static
         * @param {protocol.ITransactionRet=} [properties] Properties to set
         * @returns {protocol.TransactionRet} TransactionRet instance
         */
        TransactionRet.create = function create(properties) {
            return new TransactionRet(properties);
        };

        /**
         * Encodes the specified TransactionRet message. Does not implicitly {@link protocol.TransactionRet.verify|verify} messages.
         * @function encode
         * @memberof protocol.TransactionRet
         * @static
         * @param {protocol.ITransactionRet} message TransactionRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionRet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockNumber != null && Object.hasOwnProperty.call(message, "blockNumber"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.blockNumber);
            if (message.blockTimeStamp != null && Object.hasOwnProperty.call(message, "blockTimeStamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.blockTimeStamp);
            if (message.transactioninfo != null && message.transactioninfo.length)
                for (var i = 0; i < message.transactioninfo.length; ++i)
                    $root.protocol.TransactionInfo.encode(message.transactioninfo[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransactionRet message, length delimited. Does not implicitly {@link protocol.TransactionRet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TransactionRet
         * @static
         * @param {protocol.ITransactionRet} message TransactionRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionRet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionRet message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TransactionRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TransactionRet} TransactionRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionRet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionRet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockNumber = reader.int64();
                    break;
                case 2:
                    message.blockTimeStamp = reader.int64();
                    break;
                case 3:
                    if (!(message.transactioninfo && message.transactioninfo.length))
                        message.transactioninfo = [];
                    message.transactioninfo.push($root.protocol.TransactionInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionRet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TransactionRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TransactionRet} TransactionRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionRet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionRet message.
         * @function verify
         * @memberof protocol.TransactionRet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionRet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                    return "blockNumber: integer|Long expected";
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (!$util.isInteger(message.blockTimeStamp) && !(message.blockTimeStamp && $util.isInteger(message.blockTimeStamp.low) && $util.isInteger(message.blockTimeStamp.high)))
                    return "blockTimeStamp: integer|Long expected";
            if (message.transactioninfo != null && message.hasOwnProperty("transactioninfo")) {
                if (!Array.isArray(message.transactioninfo))
                    return "transactioninfo: array expected";
                for (var i = 0; i < message.transactioninfo.length; ++i) {
                    var error = $root.protocol.TransactionInfo.verify(message.transactioninfo[i]);
                    if (error)
                        return "transactioninfo." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TransactionRet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TransactionRet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TransactionRet} TransactionRet
         */
        TransactionRet.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransactionRet)
                return object;
            var message = new $root.protocol.TransactionRet();
            if (object.blockNumber != null)
                if ($util.Long)
                    (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                else if (typeof object.blockNumber === "string")
                    message.blockNumber = parseInt(object.blockNumber, 10);
                else if (typeof object.blockNumber === "number")
                    message.blockNumber = object.blockNumber;
                else if (typeof object.blockNumber === "object")
                    message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
            if (object.blockTimeStamp != null)
                if ($util.Long)
                    (message.blockTimeStamp = $util.Long.fromValue(object.blockTimeStamp)).unsigned = false;
                else if (typeof object.blockTimeStamp === "string")
                    message.blockTimeStamp = parseInt(object.blockTimeStamp, 10);
                else if (typeof object.blockTimeStamp === "number")
                    message.blockTimeStamp = object.blockTimeStamp;
                else if (typeof object.blockTimeStamp === "object")
                    message.blockTimeStamp = new $util.LongBits(object.blockTimeStamp.low >>> 0, object.blockTimeStamp.high >>> 0).toNumber();
            if (object.transactioninfo) {
                if (!Array.isArray(object.transactioninfo))
                    throw TypeError(".protocol.TransactionRet.transactioninfo: array expected");
                message.transactioninfo = [];
                for (var i = 0; i < object.transactioninfo.length; ++i) {
                    if (typeof object.transactioninfo[i] !== "object")
                        throw TypeError(".protocol.TransactionRet.transactioninfo: object expected");
                    message.transactioninfo[i] = $root.protocol.TransactionInfo.fromObject(object.transactioninfo[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TransactionRet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TransactionRet
         * @static
         * @param {protocol.TransactionRet} message TransactionRet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionRet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactioninfo = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockTimeStamp = options.longs === String ? "0" : 0;
            }
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (typeof message.blockNumber === "number")
                    object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                else
                    object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (typeof message.blockTimeStamp === "number")
                    object.blockTimeStamp = options.longs === String ? String(message.blockTimeStamp) : message.blockTimeStamp;
                else
                    object.blockTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.blockTimeStamp) : options.longs === Number ? new $util.LongBits(message.blockTimeStamp.low >>> 0, message.blockTimeStamp.high >>> 0).toNumber() : message.blockTimeStamp;
            if (message.transactioninfo && message.transactioninfo.length) {
                object.transactioninfo = [];
                for (var j = 0; j < message.transactioninfo.length; ++j)
                    object.transactioninfo[j] = $root.protocol.TransactionInfo.toObject(message.transactioninfo[j], options);
            }
            return object;
        };

        /**
         * Converts this TransactionRet to JSON.
         * @function toJSON
         * @memberof protocol.TransactionRet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionRet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionRet;
    })();

    protocol.Transactions = (function() {

        /**
         * Properties of a Transactions.
         * @memberof protocol
         * @interface ITransactions
         * @property {Array.<protocol.ITransaction>|null} [transactions] Transactions transactions
         */

        /**
         * Constructs a new Transactions.
         * @memberof protocol
         * @classdesc Represents a Transactions.
         * @implements ITransactions
         * @constructor
         * @param {protocol.ITransactions=} [properties] Properties to set
         */
        function Transactions(properties) {
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transactions transactions.
         * @member {Array.<protocol.ITransaction>} transactions
         * @memberof protocol.Transactions
         * @instance
         */
        Transactions.prototype.transactions = $util.emptyArray;

        /**
         * Creates a new Transactions instance using the specified properties.
         * @function create
         * @memberof protocol.Transactions
         * @static
         * @param {protocol.ITransactions=} [properties] Properties to set
         * @returns {protocol.Transactions} Transactions instance
         */
        Transactions.create = function create(properties) {
            return new Transactions(properties);
        };

        /**
         * Encodes the specified Transactions message. Does not implicitly {@link protocol.Transactions.verify|verify} messages.
         * @function encode
         * @memberof protocol.Transactions
         * @static
         * @param {protocol.ITransactions} message Transactions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transactions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.protocol.Transaction.encode(message.transactions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Transactions message, length delimited. Does not implicitly {@link protocol.Transactions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Transactions
         * @static
         * @param {protocol.ITransactions} message Transactions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transactions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transactions message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Transactions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Transactions} Transactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transactions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transactions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.transactions && message.transactions.length))
                        message.transactions = [];
                    message.transactions.push($root.protocol.Transaction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transactions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Transactions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Transactions} Transactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transactions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transactions message.
         * @function verify
         * @memberof protocol.Transactions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transactions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.protocol.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Transactions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Transactions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Transactions} Transactions
         */
        Transactions.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Transactions)
                return object;
            var message = new $root.protocol.Transactions();
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".protocol.Transactions.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".protocol.Transactions.transactions: object expected");
                    message.transactions[i] = $root.protocol.Transaction.fromObject(object.transactions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Transactions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Transactions
         * @static
         * @param {protocol.Transactions} message Transactions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transactions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactions = [];
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.protocol.Transaction.toObject(message.transactions[j], options);
            }
            return object;
        };

        /**
         * Converts this Transactions to JSON.
         * @function toJSON
         * @memberof protocol.Transactions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transactions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transactions;
    })();

    protocol.TransactionSign = (function() {

        /**
         * Properties of a TransactionSign.
         * @memberof protocol
         * @interface ITransactionSign
         * @property {protocol.ITransaction|null} [transaction] TransactionSign transaction
         * @property {Uint8Array|null} [privateKey] TransactionSign privateKey
         */

        /**
         * Constructs a new TransactionSign.
         * @memberof protocol
         * @classdesc Represents a TransactionSign.
         * @implements ITransactionSign
         * @constructor
         * @param {protocol.ITransactionSign=} [properties] Properties to set
         */
        function TransactionSign(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionSign transaction.
         * @member {protocol.ITransaction|null|undefined} transaction
         * @memberof protocol.TransactionSign
         * @instance
         */
        TransactionSign.prototype.transaction = null;

        /**
         * TransactionSign privateKey.
         * @member {Uint8Array} privateKey
         * @memberof protocol.TransactionSign
         * @instance
         */
        TransactionSign.prototype.privateKey = $util.newBuffer([]);

        /**
         * Creates a new TransactionSign instance using the specified properties.
         * @function create
         * @memberof protocol.TransactionSign
         * @static
         * @param {protocol.ITransactionSign=} [properties] Properties to set
         * @returns {protocol.TransactionSign} TransactionSign instance
         */
        TransactionSign.create = function create(properties) {
            return new TransactionSign(properties);
        };

        /**
         * Encodes the specified TransactionSign message. Does not implicitly {@link protocol.TransactionSign.verify|verify} messages.
         * @function encode
         * @memberof protocol.TransactionSign
         * @static
         * @param {protocol.ITransactionSign} message TransactionSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionSign.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.protocol.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
            return writer;
        };

        /**
         * Encodes the specified TransactionSign message, length delimited. Does not implicitly {@link protocol.TransactionSign.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TransactionSign
         * @static
         * @param {protocol.ITransactionSign} message TransactionSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionSign.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionSign message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TransactionSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TransactionSign} TransactionSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionSign.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionSign();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.transaction = $root.protocol.Transaction.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.privateKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionSign message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TransactionSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TransactionSign} TransactionSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionSign.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionSign message.
         * @function verify
         * @memberof protocol.TransactionSign
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionSign.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                var error = $root.protocol.Transaction.verify(message.transaction);
                if (error)
                    return "transaction." + error;
            }
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                    return "privateKey: buffer expected";
            return null;
        };

        /**
         * Creates a TransactionSign message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TransactionSign
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TransactionSign} TransactionSign
         */
        TransactionSign.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransactionSign)
                return object;
            var message = new $root.protocol.TransactionSign();
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".protocol.TransactionSign.transaction: object expected");
                message.transaction = $root.protocol.Transaction.fromObject(object.transaction);
            }
            if (object.privateKey != null)
                if (typeof object.privateKey === "string")
                    $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                else if (object.privateKey.length)
                    message.privateKey = object.privateKey;
            return message;
        };

        /**
         * Creates a plain object from a TransactionSign message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TransactionSign
         * @static
         * @param {protocol.TransactionSign} message TransactionSign
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionSign.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.transaction = null;
                if (options.bytes === String)
                    object.privateKey = "";
                else {
                    object.privateKey = [];
                    if (options.bytes !== Array)
                        object.privateKey = $util.newBuffer(object.privateKey);
                }
            }
            if (message.transaction != null && message.hasOwnProperty("transaction"))
                object.transaction = $root.protocol.Transaction.toObject(message.transaction, options);
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
            return object;
        };

        /**
         * Converts this TransactionSign to JSON.
         * @function toJSON
         * @memberof protocol.TransactionSign
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionSign.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionSign;
    })();

    protocol.BlockHeader = (function() {

        /**
         * Properties of a BlockHeader.
         * @memberof protocol
         * @interface IBlockHeader
         * @property {protocol.BlockHeader.Iraw|null} [rawData] BlockHeader rawData
         * @property {Uint8Array|null} [witnessSignature] BlockHeader witnessSignature
         */

        /**
         * Constructs a new BlockHeader.
         * @memberof protocol
         * @classdesc Represents a BlockHeader.
         * @implements IBlockHeader
         * @constructor
         * @param {protocol.IBlockHeader=} [properties] Properties to set
         */
        function BlockHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockHeader rawData.
         * @member {protocol.BlockHeader.Iraw|null|undefined} rawData
         * @memberof protocol.BlockHeader
         * @instance
         */
        BlockHeader.prototype.rawData = null;

        /**
         * BlockHeader witnessSignature.
         * @member {Uint8Array} witnessSignature
         * @memberof protocol.BlockHeader
         * @instance
         */
        BlockHeader.prototype.witnessSignature = $util.newBuffer([]);

        /**
         * Creates a new BlockHeader instance using the specified properties.
         * @function create
         * @memberof protocol.BlockHeader
         * @static
         * @param {protocol.IBlockHeader=} [properties] Properties to set
         * @returns {protocol.BlockHeader} BlockHeader instance
         */
        BlockHeader.create = function create(properties) {
            return new BlockHeader(properties);
        };

        /**
         * Encodes the specified BlockHeader message. Does not implicitly {@link protocol.BlockHeader.verify|verify} messages.
         * @function encode
         * @memberof protocol.BlockHeader
         * @static
         * @param {protocol.IBlockHeader} message BlockHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rawData != null && Object.hasOwnProperty.call(message, "rawData"))
                $root.protocol.BlockHeader.raw.encode(message.rawData, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.witnessSignature != null && Object.hasOwnProperty.call(message, "witnessSignature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.witnessSignature);
            return writer;
        };

        /**
         * Encodes the specified BlockHeader message, length delimited. Does not implicitly {@link protocol.BlockHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.BlockHeader
         * @static
         * @param {protocol.IBlockHeader} message BlockHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockHeader message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.BlockHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.BlockHeader} BlockHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rawData = $root.protocol.BlockHeader.raw.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.witnessSignature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.BlockHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.BlockHeader} BlockHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockHeader message.
         * @function verify
         * @memberof protocol.BlockHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rawData != null && message.hasOwnProperty("rawData")) {
                var error = $root.protocol.BlockHeader.raw.verify(message.rawData);
                if (error)
                    return "rawData." + error;
            }
            if (message.witnessSignature != null && message.hasOwnProperty("witnessSignature"))
                if (!(message.witnessSignature && typeof message.witnessSignature.length === "number" || $util.isString(message.witnessSignature)))
                    return "witnessSignature: buffer expected";
            return null;
        };

        /**
         * Creates a BlockHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.BlockHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.BlockHeader} BlockHeader
         */
        BlockHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BlockHeader)
                return object;
            var message = new $root.protocol.BlockHeader();
            if (object.rawData != null) {
                if (typeof object.rawData !== "object")
                    throw TypeError(".protocol.BlockHeader.rawData: object expected");
                message.rawData = $root.protocol.BlockHeader.raw.fromObject(object.rawData);
            }
            if (object.witnessSignature != null)
                if (typeof object.witnessSignature === "string")
                    $util.base64.decode(object.witnessSignature, message.witnessSignature = $util.newBuffer($util.base64.length(object.witnessSignature)), 0);
                else if (object.witnessSignature.length)
                    message.witnessSignature = object.witnessSignature;
            return message;
        };

        /**
         * Creates a plain object from a BlockHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.BlockHeader
         * @static
         * @param {protocol.BlockHeader} message BlockHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rawData = null;
                if (options.bytes === String)
                    object.witnessSignature = "";
                else {
                    object.witnessSignature = [];
                    if (options.bytes !== Array)
                        object.witnessSignature = $util.newBuffer(object.witnessSignature);
                }
            }
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                object.rawData = $root.protocol.BlockHeader.raw.toObject(message.rawData, options);
            if (message.witnessSignature != null && message.hasOwnProperty("witnessSignature"))
                object.witnessSignature = options.bytes === String ? $util.base64.encode(message.witnessSignature, 0, message.witnessSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.witnessSignature) : message.witnessSignature;
            return object;
        };

        /**
         * Converts this BlockHeader to JSON.
         * @function toJSON
         * @memberof protocol.BlockHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        BlockHeader.raw = (function() {

            /**
             * Properties of a raw.
             * @memberof protocol.BlockHeader
             * @interface Iraw
             * @property {number|Long|null} [timestamp] raw timestamp
             * @property {Uint8Array|null} [txTrieRoot] raw txTrieRoot
             * @property {Uint8Array|null} [parentHash] raw parentHash
             * @property {number|Long|null} [number] raw number
             * @property {number|Long|null} [witnessId] raw witnessId
             * @property {Uint8Array|null} [witnessAddress] raw witnessAddress
             * @property {number|null} [version] raw version
             * @property {Uint8Array|null} [accountStateRoot] raw accountStateRoot
             */

            /**
             * Constructs a new raw.
             * @memberof protocol.BlockHeader
             * @classdesc Represents a raw.
             * @implements Iraw
             * @constructor
             * @param {protocol.BlockHeader.Iraw=} [properties] Properties to set
             */
            function raw(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * raw timestamp.
             * @member {number|Long} timestamp
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw txTrieRoot.
             * @member {Uint8Array} txTrieRoot
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.txTrieRoot = $util.newBuffer([]);

            /**
             * raw parentHash.
             * @member {Uint8Array} parentHash
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.parentHash = $util.newBuffer([]);

            /**
             * raw number.
             * @member {number|Long} number
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw witnessId.
             * @member {number|Long} witnessId
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.witnessId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw witnessAddress.
             * @member {Uint8Array} witnessAddress
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.witnessAddress = $util.newBuffer([]);

            /**
             * raw version.
             * @member {number} version
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.version = 0;

            /**
             * raw accountStateRoot.
             * @member {Uint8Array} accountStateRoot
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.accountStateRoot = $util.newBuffer([]);

            /**
             * Creates a new raw instance using the specified properties.
             * @function create
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {protocol.BlockHeader.Iraw=} [properties] Properties to set
             * @returns {protocol.BlockHeader.raw} raw instance
             */
            raw.create = function create(properties) {
                return new raw(properties);
            };

            /**
             * Encodes the specified raw message. Does not implicitly {@link protocol.BlockHeader.raw.verify|verify} messages.
             * @function encode
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {protocol.BlockHeader.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                if (message.txTrieRoot != null && Object.hasOwnProperty.call(message, "txTrieRoot"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.txTrieRoot);
                if (message.parentHash != null && Object.hasOwnProperty.call(message, "parentHash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.parentHash);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.number);
                if (message.witnessId != null && Object.hasOwnProperty.call(message, "witnessId"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.witnessId);
                if (message.witnessAddress != null && Object.hasOwnProperty.call(message, "witnessAddress"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.witnessAddress);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.version);
                if (message.accountStateRoot != null && Object.hasOwnProperty.call(message, "accountStateRoot"))
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.accountStateRoot);
                return writer;
            };

            /**
             * Encodes the specified raw message, length delimited. Does not implicitly {@link protocol.BlockHeader.raw.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {protocol.BlockHeader.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a raw message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.BlockHeader.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockHeader.raw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = reader.int64();
                        break;
                    case 2:
                        message.txTrieRoot = reader.bytes();
                        break;
                    case 3:
                        message.parentHash = reader.bytes();
                        break;
                    case 7:
                        message.number = reader.int64();
                        break;
                    case 8:
                        message.witnessId = reader.int64();
                        break;
                    case 9:
                        message.witnessAddress = reader.bytes();
                        break;
                    case 10:
                        message.version = reader.int32();
                        break;
                    case 11:
                        message.accountStateRoot = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a raw message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.BlockHeader.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a raw message.
             * @function verify
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            raw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                    if (!(message.txTrieRoot && typeof message.txTrieRoot.length === "number" || $util.isString(message.txTrieRoot)))
                        return "txTrieRoot: buffer expected";
                if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                    if (!(message.parentHash && typeof message.parentHash.length === "number" || $util.isString(message.parentHash)))
                        return "parentHash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                if (message.witnessId != null && message.hasOwnProperty("witnessId"))
                    if (!$util.isInteger(message.witnessId) && !(message.witnessId && $util.isInteger(message.witnessId.low) && $util.isInteger(message.witnessId.high)))
                        return "witnessId: integer|Long expected";
                if (message.witnessAddress != null && message.hasOwnProperty("witnessAddress"))
                    if (!(message.witnessAddress && typeof message.witnessAddress.length === "number" || $util.isString(message.witnessAddress)))
                        return "witnessAddress: buffer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.accountStateRoot != null && message.hasOwnProperty("accountStateRoot"))
                    if (!(message.accountStateRoot && typeof message.accountStateRoot.length === "number" || $util.isString(message.accountStateRoot)))
                        return "accountStateRoot: buffer expected";
                return null;
            };

            /**
             * Creates a raw message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.BlockHeader.raw} raw
             */
            raw.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.BlockHeader.raw)
                    return object;
                var message = new $root.protocol.BlockHeader.raw();
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.txTrieRoot != null)
                    if (typeof object.txTrieRoot === "string")
                        $util.base64.decode(object.txTrieRoot, message.txTrieRoot = $util.newBuffer($util.base64.length(object.txTrieRoot)), 0);
                    else if (object.txTrieRoot.length)
                        message.txTrieRoot = object.txTrieRoot;
                if (object.parentHash != null)
                    if (typeof object.parentHash === "string")
                        $util.base64.decode(object.parentHash, message.parentHash = $util.newBuffer($util.base64.length(object.parentHash)), 0);
                    else if (object.parentHash.length)
                        message.parentHash = object.parentHash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                if (object.witnessId != null)
                    if ($util.Long)
                        (message.witnessId = $util.Long.fromValue(object.witnessId)).unsigned = false;
                    else if (typeof object.witnessId === "string")
                        message.witnessId = parseInt(object.witnessId, 10);
                    else if (typeof object.witnessId === "number")
                        message.witnessId = object.witnessId;
                    else if (typeof object.witnessId === "object")
                        message.witnessId = new $util.LongBits(object.witnessId.low >>> 0, object.witnessId.high >>> 0).toNumber();
                if (object.witnessAddress != null)
                    if (typeof object.witnessAddress === "string")
                        $util.base64.decode(object.witnessAddress, message.witnessAddress = $util.newBuffer($util.base64.length(object.witnessAddress)), 0);
                    else if (object.witnessAddress.length)
                        message.witnessAddress = object.witnessAddress;
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.accountStateRoot != null)
                    if (typeof object.accountStateRoot === "string")
                        $util.base64.decode(object.accountStateRoot, message.accountStateRoot = $util.newBuffer($util.base64.length(object.accountStateRoot)), 0);
                    else if (object.accountStateRoot.length)
                        message.accountStateRoot = object.accountStateRoot;
                return message;
            };

            /**
             * Creates a plain object from a raw message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {protocol.BlockHeader.raw} message raw
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            raw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.txTrieRoot = "";
                    else {
                        object.txTrieRoot = [];
                        if (options.bytes !== Array)
                            object.txTrieRoot = $util.newBuffer(object.txTrieRoot);
                    }
                    if (options.bytes === String)
                        object.parentHash = "";
                    else {
                        object.parentHash = [];
                        if (options.bytes !== Array)
                            object.parentHash = $util.newBuffer(object.parentHash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.witnessId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.witnessId = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.witnessAddress = "";
                    else {
                        object.witnessAddress = [];
                        if (options.bytes !== Array)
                            object.witnessAddress = $util.newBuffer(object.witnessAddress);
                    }
                    object.version = 0;
                    if (options.bytes === String)
                        object.accountStateRoot = "";
                    else {
                        object.accountStateRoot = [];
                        if (options.bytes !== Array)
                            object.accountStateRoot = $util.newBuffer(object.accountStateRoot);
                    }
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                    object.txTrieRoot = options.bytes === String ? $util.base64.encode(message.txTrieRoot, 0, message.txTrieRoot.length) : options.bytes === Array ? Array.prototype.slice.call(message.txTrieRoot) : message.txTrieRoot;
                if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                    object.parentHash = options.bytes === String ? $util.base64.encode(message.parentHash, 0, message.parentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentHash) : message.parentHash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                if (message.witnessId != null && message.hasOwnProperty("witnessId"))
                    if (typeof message.witnessId === "number")
                        object.witnessId = options.longs === String ? String(message.witnessId) : message.witnessId;
                    else
                        object.witnessId = options.longs === String ? $util.Long.prototype.toString.call(message.witnessId) : options.longs === Number ? new $util.LongBits(message.witnessId.low >>> 0, message.witnessId.high >>> 0).toNumber() : message.witnessId;
                if (message.witnessAddress != null && message.hasOwnProperty("witnessAddress"))
                    object.witnessAddress = options.bytes === String ? $util.base64.encode(message.witnessAddress, 0, message.witnessAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.witnessAddress) : message.witnessAddress;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.accountStateRoot != null && message.hasOwnProperty("accountStateRoot"))
                    object.accountStateRoot = options.bytes === String ? $util.base64.encode(message.accountStateRoot, 0, message.accountStateRoot.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountStateRoot) : message.accountStateRoot;
                return object;
            };

            /**
             * Converts this raw to JSON.
             * @function toJSON
             * @memberof protocol.BlockHeader.raw
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            raw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return raw;
        })();

        return BlockHeader;
    })();

    protocol.Block = (function() {

        /**
         * Properties of a Block.
         * @memberof protocol
         * @interface IBlock
         * @property {Array.<protocol.ITransaction>|null} [transactions] Block transactions
         * @property {protocol.IBlockHeader|null} [blockHeader] Block blockHeader
         */

        /**
         * Constructs a new Block.
         * @memberof protocol
         * @classdesc Represents a Block.
         * @implements IBlock
         * @constructor
         * @param {protocol.IBlock=} [properties] Properties to set
         */
        function Block(properties) {
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Block transactions.
         * @member {Array.<protocol.ITransaction>} transactions
         * @memberof protocol.Block
         * @instance
         */
        Block.prototype.transactions = $util.emptyArray;

        /**
         * Block blockHeader.
         * @member {protocol.IBlockHeader|null|undefined} blockHeader
         * @memberof protocol.Block
         * @instance
         */
        Block.prototype.blockHeader = null;

        /**
         * Creates a new Block instance using the specified properties.
         * @function create
         * @memberof protocol.Block
         * @static
         * @param {protocol.IBlock=} [properties] Properties to set
         * @returns {protocol.Block} Block instance
         */
        Block.create = function create(properties) {
            return new Block(properties);
        };

        /**
         * Encodes the specified Block message. Does not implicitly {@link protocol.Block.verify|verify} messages.
         * @function encode
         * @memberof protocol.Block
         * @static
         * @param {protocol.IBlock} message Block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Block.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.protocol.Transaction.encode(message.transactions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.blockHeader != null && Object.hasOwnProperty.call(message, "blockHeader"))
                $root.protocol.BlockHeader.encode(message.blockHeader, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Block message, length delimited. Does not implicitly {@link protocol.Block.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Block
         * @static
         * @param {protocol.IBlock} message Block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Block.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Block message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Block} Block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Block.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Block();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.transactions && message.transactions.length))
                        message.transactions = [];
                    message.transactions.push($root.protocol.Transaction.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.blockHeader = $root.protocol.BlockHeader.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Block message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Block} Block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Block.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Block message.
         * @function verify
         * @memberof protocol.Block
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Block.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.protocol.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            if (message.blockHeader != null && message.hasOwnProperty("blockHeader")) {
                var error = $root.protocol.BlockHeader.verify(message.blockHeader);
                if (error)
                    return "blockHeader." + error;
            }
            return null;
        };

        /**
         * Creates a Block message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Block
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Block} Block
         */
        Block.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Block)
                return object;
            var message = new $root.protocol.Block();
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".protocol.Block.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".protocol.Block.transactions: object expected");
                    message.transactions[i] = $root.protocol.Transaction.fromObject(object.transactions[i]);
                }
            }
            if (object.blockHeader != null) {
                if (typeof object.blockHeader !== "object")
                    throw TypeError(".protocol.Block.blockHeader: object expected");
                message.blockHeader = $root.protocol.BlockHeader.fromObject(object.blockHeader);
            }
            return message;
        };

        /**
         * Creates a plain object from a Block message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Block
         * @static
         * @param {protocol.Block} message Block
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Block.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactions = [];
            if (options.defaults)
                object.blockHeader = null;
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.protocol.Transaction.toObject(message.transactions[j], options);
            }
            if (message.blockHeader != null && message.hasOwnProperty("blockHeader"))
                object.blockHeader = $root.protocol.BlockHeader.toObject(message.blockHeader, options);
            return object;
        };

        /**
         * Converts this Block to JSON.
         * @function toJSON
         * @memberof protocol.Block
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Block.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Block;
    })();

    protocol.ChainInventory = (function() {

        /**
         * Properties of a ChainInventory.
         * @memberof protocol
         * @interface IChainInventory
         * @property {Array.<protocol.ChainInventory.IBlockId>|null} [ids] ChainInventory ids
         * @property {number|Long|null} [remainNum] ChainInventory remainNum
         */

        /**
         * Constructs a new ChainInventory.
         * @memberof protocol
         * @classdesc Represents a ChainInventory.
         * @implements IChainInventory
         * @constructor
         * @param {protocol.IChainInventory=} [properties] Properties to set
         */
        function ChainInventory(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChainInventory ids.
         * @member {Array.<protocol.ChainInventory.IBlockId>} ids
         * @memberof protocol.ChainInventory
         * @instance
         */
        ChainInventory.prototype.ids = $util.emptyArray;

        /**
         * ChainInventory remainNum.
         * @member {number|Long} remainNum
         * @memberof protocol.ChainInventory
         * @instance
         */
        ChainInventory.prototype.remainNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ChainInventory instance using the specified properties.
         * @function create
         * @memberof protocol.ChainInventory
         * @static
         * @param {protocol.IChainInventory=} [properties] Properties to set
         * @returns {protocol.ChainInventory} ChainInventory instance
         */
        ChainInventory.create = function create(properties) {
            return new ChainInventory(properties);
        };

        /**
         * Encodes the specified ChainInventory message. Does not implicitly {@link protocol.ChainInventory.verify|verify} messages.
         * @function encode
         * @memberof protocol.ChainInventory
         * @static
         * @param {protocol.IChainInventory} message ChainInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainInventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.protocol.ChainInventory.BlockId.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.remainNum != null && Object.hasOwnProperty.call(message, "remainNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.remainNum);
            return writer;
        };

        /**
         * Encodes the specified ChainInventory message, length delimited. Does not implicitly {@link protocol.ChainInventory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ChainInventory
         * @static
         * @param {protocol.IChainInventory} message ChainInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainInventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChainInventory message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ChainInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ChainInventory} ChainInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainInventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainInventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.protocol.ChainInventory.BlockId.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.remainNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChainInventory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ChainInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ChainInventory} ChainInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainInventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChainInventory message.
         * @function verify
         * @memberof protocol.ChainInventory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChainInventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.protocol.ChainInventory.BlockId.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                if (!$util.isInteger(message.remainNum) && !(message.remainNum && $util.isInteger(message.remainNum.low) && $util.isInteger(message.remainNum.high)))
                    return "remainNum: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChainInventory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ChainInventory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ChainInventory} ChainInventory
         */
        ChainInventory.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ChainInventory)
                return object;
            var message = new $root.protocol.ChainInventory();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".protocol.ChainInventory.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".protocol.ChainInventory.ids: object expected");
                    message.ids[i] = $root.protocol.ChainInventory.BlockId.fromObject(object.ids[i]);
                }
            }
            if (object.remainNum != null)
                if ($util.Long)
                    (message.remainNum = $util.Long.fromValue(object.remainNum)).unsigned = false;
                else if (typeof object.remainNum === "string")
                    message.remainNum = parseInt(object.remainNum, 10);
                else if (typeof object.remainNum === "number")
                    message.remainNum = object.remainNum;
                else if (typeof object.remainNum === "object")
                    message.remainNum = new $util.LongBits(object.remainNum.low >>> 0, object.remainNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ChainInventory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ChainInventory
         * @static
         * @param {protocol.ChainInventory} message ChainInventory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChainInventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.remainNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.remainNum = options.longs === String ? "0" : 0;
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.protocol.ChainInventory.BlockId.toObject(message.ids[j], options);
            }
            if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                if (typeof message.remainNum === "number")
                    object.remainNum = options.longs === String ? String(message.remainNum) : message.remainNum;
                else
                    object.remainNum = options.longs === String ? $util.Long.prototype.toString.call(message.remainNum) : options.longs === Number ? new $util.LongBits(message.remainNum.low >>> 0, message.remainNum.high >>> 0).toNumber() : message.remainNum;
            return object;
        };

        /**
         * Converts this ChainInventory to JSON.
         * @function toJSON
         * @memberof protocol.ChainInventory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChainInventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ChainInventory.BlockId = (function() {

            /**
             * Properties of a BlockId.
             * @memberof protocol.ChainInventory
             * @interface IBlockId
             * @property {Uint8Array|null} [hash] BlockId hash
             * @property {number|Long|null} [number] BlockId number
             */

            /**
             * Constructs a new BlockId.
             * @memberof protocol.ChainInventory
             * @classdesc Represents a BlockId.
             * @implements IBlockId
             * @constructor
             * @param {protocol.ChainInventory.IBlockId=} [properties] Properties to set
             */
            function BlockId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BlockId hash.
             * @member {Uint8Array} hash
             * @memberof protocol.ChainInventory.BlockId
             * @instance
             */
            BlockId.prototype.hash = $util.newBuffer([]);

            /**
             * BlockId number.
             * @member {number|Long} number
             * @memberof protocol.ChainInventory.BlockId
             * @instance
             */
            BlockId.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new BlockId instance using the specified properties.
             * @function create
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {protocol.ChainInventory.IBlockId=} [properties] Properties to set
             * @returns {protocol.ChainInventory.BlockId} BlockId instance
             */
            BlockId.create = function create(properties) {
                return new BlockId(properties);
            };

            /**
             * Encodes the specified BlockId message. Does not implicitly {@link protocol.ChainInventory.BlockId.verify|verify} messages.
             * @function encode
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {protocol.ChainInventory.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.number);
                return writer;
            };

            /**
             * Encodes the specified BlockId message, length delimited. Does not implicitly {@link protocol.ChainInventory.BlockId.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {protocol.ChainInventory.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.ChainInventory.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainInventory.BlockId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.number = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.ChainInventory.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BlockId message.
             * @function verify
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };

            /**
             * Creates a BlockId message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.ChainInventory.BlockId} BlockId
             */
            BlockId.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.ChainInventory.BlockId)
                    return object;
                var message = new $root.protocol.ChainInventory.BlockId();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a BlockId message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {protocol.ChainInventory.BlockId} message BlockId
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                return object;
            };

            /**
             * Converts this BlockId to JSON.
             * @function toJSON
             * @memberof protocol.ChainInventory.BlockId
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BlockId;
        })();

        return ChainInventory;
    })();

    protocol.BlockInventory = (function() {

        /**
         * Properties of a BlockInventory.
         * @memberof protocol
         * @interface IBlockInventory
         * @property {Array.<protocol.BlockInventory.IBlockId>|null} [ids] BlockInventory ids
         * @property {protocol.BlockInventory.Type|null} [type] BlockInventory type
         */

        /**
         * Constructs a new BlockInventory.
         * @memberof protocol
         * @classdesc Represents a BlockInventory.
         * @implements IBlockInventory
         * @constructor
         * @param {protocol.IBlockInventory=} [properties] Properties to set
         */
        function BlockInventory(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockInventory ids.
         * @member {Array.<protocol.BlockInventory.IBlockId>} ids
         * @memberof protocol.BlockInventory
         * @instance
         */
        BlockInventory.prototype.ids = $util.emptyArray;

        /**
         * BlockInventory type.
         * @member {protocol.BlockInventory.Type} type
         * @memberof protocol.BlockInventory
         * @instance
         */
        BlockInventory.prototype.type = 0;

        /**
         * Creates a new BlockInventory instance using the specified properties.
         * @function create
         * @memberof protocol.BlockInventory
         * @static
         * @param {protocol.IBlockInventory=} [properties] Properties to set
         * @returns {protocol.BlockInventory} BlockInventory instance
         */
        BlockInventory.create = function create(properties) {
            return new BlockInventory(properties);
        };

        /**
         * Encodes the specified BlockInventory message. Does not implicitly {@link protocol.BlockInventory.verify|verify} messages.
         * @function encode
         * @memberof protocol.BlockInventory
         * @static
         * @param {protocol.IBlockInventory} message BlockInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockInventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.protocol.BlockInventory.BlockId.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified BlockInventory message, length delimited. Does not implicitly {@link protocol.BlockInventory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.BlockInventory
         * @static
         * @param {protocol.IBlockInventory} message BlockInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockInventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockInventory message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.BlockInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.BlockInventory} BlockInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockInventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockInventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.protocol.BlockInventory.BlockId.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockInventory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.BlockInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.BlockInventory} BlockInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockInventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockInventory message.
         * @function verify
         * @memberof protocol.BlockInventory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockInventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.protocol.BlockInventory.BlockId.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a BlockInventory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.BlockInventory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.BlockInventory} BlockInventory
         */
        BlockInventory.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BlockInventory)
                return object;
            var message = new $root.protocol.BlockInventory();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".protocol.BlockInventory.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".protocol.BlockInventory.ids: object expected");
                    message.ids[i] = $root.protocol.BlockInventory.BlockId.fromObject(object.ids[i]);
                }
            }
            switch (object.type) {
            case "SYNC":
            case 0:
                message.type = 0;
                break;
            case "ADVTISE":
            case 1:
                message.type = 1;
                break;
            case "FETCH":
            case 2:
                message.type = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a BlockInventory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.BlockInventory
         * @static
         * @param {protocol.BlockInventory} message BlockInventory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockInventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults)
                object.type = options.enums === String ? "SYNC" : 0;
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.protocol.BlockInventory.BlockId.toObject(message.ids[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.BlockInventory.Type[message.type] : message.type;
            return object;
        };

        /**
         * Converts this BlockInventory to JSON.
         * @function toJSON
         * @memberof protocol.BlockInventory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockInventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name protocol.BlockInventory.Type
         * @enum {number}
         * @property {number} SYNC=0 SYNC value
         * @property {number} ADVTISE=1 ADVTISE value
         * @property {number} FETCH=2 FETCH value
         */
        BlockInventory.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SYNC"] = 0;
            values[valuesById[1] = "ADVTISE"] = 1;
            values[valuesById[2] = "FETCH"] = 2;
            return values;
        })();

        BlockInventory.BlockId = (function() {

            /**
             * Properties of a BlockId.
             * @memberof protocol.BlockInventory
             * @interface IBlockId
             * @property {Uint8Array|null} [hash] BlockId hash
             * @property {number|Long|null} [number] BlockId number
             */

            /**
             * Constructs a new BlockId.
             * @memberof protocol.BlockInventory
             * @classdesc Represents a BlockId.
             * @implements IBlockId
             * @constructor
             * @param {protocol.BlockInventory.IBlockId=} [properties] Properties to set
             */
            function BlockId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BlockId hash.
             * @member {Uint8Array} hash
             * @memberof protocol.BlockInventory.BlockId
             * @instance
             */
            BlockId.prototype.hash = $util.newBuffer([]);

            /**
             * BlockId number.
             * @member {number|Long} number
             * @memberof protocol.BlockInventory.BlockId
             * @instance
             */
            BlockId.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new BlockId instance using the specified properties.
             * @function create
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {protocol.BlockInventory.IBlockId=} [properties] Properties to set
             * @returns {protocol.BlockInventory.BlockId} BlockId instance
             */
            BlockId.create = function create(properties) {
                return new BlockId(properties);
            };

            /**
             * Encodes the specified BlockId message. Does not implicitly {@link protocol.BlockInventory.BlockId.verify|verify} messages.
             * @function encode
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {protocol.BlockInventory.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.number);
                return writer;
            };

            /**
             * Encodes the specified BlockId message, length delimited. Does not implicitly {@link protocol.BlockInventory.BlockId.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {protocol.BlockInventory.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.BlockInventory.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockInventory.BlockId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.number = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.BlockInventory.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BlockId message.
             * @function verify
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };

            /**
             * Creates a BlockId message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.BlockInventory.BlockId} BlockId
             */
            BlockId.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.BlockInventory.BlockId)
                    return object;
                var message = new $root.protocol.BlockInventory.BlockId();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a BlockId message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {protocol.BlockInventory.BlockId} message BlockId
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                return object;
            };

            /**
             * Converts this BlockId to JSON.
             * @function toJSON
             * @memberof protocol.BlockInventory.BlockId
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BlockId;
        })();

        return BlockInventory;
    })();

    protocol.Inventory = (function() {

        /**
         * Properties of an Inventory.
         * @memberof protocol
         * @interface IInventory
         * @property {protocol.Inventory.InventoryType|null} [type] Inventory type
         * @property {Array.<Uint8Array>|null} [ids] Inventory ids
         */

        /**
         * Constructs a new Inventory.
         * @memberof protocol
         * @classdesc Represents an Inventory.
         * @implements IInventory
         * @constructor
         * @param {protocol.IInventory=} [properties] Properties to set
         */
        function Inventory(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Inventory type.
         * @member {protocol.Inventory.InventoryType} type
         * @memberof protocol.Inventory
         * @instance
         */
        Inventory.prototype.type = 0;

        /**
         * Inventory ids.
         * @member {Array.<Uint8Array>} ids
         * @memberof protocol.Inventory
         * @instance
         */
        Inventory.prototype.ids = $util.emptyArray;

        /**
         * Creates a new Inventory instance using the specified properties.
         * @function create
         * @memberof protocol.Inventory
         * @static
         * @param {protocol.IInventory=} [properties] Properties to set
         * @returns {protocol.Inventory} Inventory instance
         */
        Inventory.create = function create(properties) {
            return new Inventory(properties);
        };

        /**
         * Encodes the specified Inventory message. Does not implicitly {@link protocol.Inventory.verify|verify} messages.
         * @function encode
         * @memberof protocol.Inventory
         * @static
         * @param {protocol.IInventory} message Inventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Inventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ids[i]);
            return writer;
        };

        /**
         * Encodes the specified Inventory message, length delimited. Does not implicitly {@link protocol.Inventory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Inventory
         * @static
         * @param {protocol.IInventory} message Inventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Inventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Inventory message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Inventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Inventory} Inventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Inventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Inventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Inventory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Inventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Inventory} Inventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Inventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Inventory message.
         * @function verify
         * @memberof protocol.Inventory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Inventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i)
                    if (!(message.ids[i] && typeof message.ids[i].length === "number" || $util.isString(message.ids[i])))
                        return "ids: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an Inventory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Inventory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Inventory} Inventory
         */
        Inventory.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Inventory)
                return object;
            var message = new $root.protocol.Inventory();
            switch (object.type) {
            case "TRX":
            case 0:
                message.type = 0;
                break;
            case "BLOCK":
            case 1:
                message.type = 1;
                break;
            }
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".protocol.Inventory.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i)
                    if (typeof object.ids[i] === "string")
                        $util.base64.decode(object.ids[i], message.ids[i] = $util.newBuffer($util.base64.length(object.ids[i])), 0);
                    else if (object.ids[i].length)
                        message.ids[i] = object.ids[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an Inventory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Inventory
         * @static
         * @param {protocol.Inventory} message Inventory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Inventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults)
                object.type = options.enums === String ? "TRX" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.Inventory.InventoryType[message.type] : message.type;
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = options.bytes === String ? $util.base64.encode(message.ids[j], 0, message.ids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.ids[j]) : message.ids[j];
            }
            return object;
        };

        /**
         * Converts this Inventory to JSON.
         * @function toJSON
         * @memberof protocol.Inventory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Inventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * InventoryType enum.
         * @name protocol.Inventory.InventoryType
         * @enum {number}
         * @property {number} TRX=0 TRX value
         * @property {number} BLOCK=1 BLOCK value
         */
        Inventory.InventoryType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TRX"] = 0;
            values[valuesById[1] = "BLOCK"] = 1;
            return values;
        })();

        return Inventory;
    })();

    protocol.Items = (function() {

        /**
         * Properties of an Items.
         * @memberof protocol
         * @interface IItems
         * @property {protocol.Items.ItemType|null} [type] Items type
         * @property {Array.<protocol.IBlock>|null} [blocks] Items blocks
         * @property {Array.<protocol.IBlockHeader>|null} [blockHeaders] Items blockHeaders
         * @property {Array.<protocol.ITransaction>|null} [transactions] Items transactions
         */

        /**
         * Constructs a new Items.
         * @memberof protocol
         * @classdesc Represents an Items.
         * @implements IItems
         * @constructor
         * @param {protocol.IItems=} [properties] Properties to set
         */
        function Items(properties) {
            this.blocks = [];
            this.blockHeaders = [];
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Items type.
         * @member {protocol.Items.ItemType} type
         * @memberof protocol.Items
         * @instance
         */
        Items.prototype.type = 0;

        /**
         * Items blocks.
         * @member {Array.<protocol.IBlock>} blocks
         * @memberof protocol.Items
         * @instance
         */
        Items.prototype.blocks = $util.emptyArray;

        /**
         * Items blockHeaders.
         * @member {Array.<protocol.IBlockHeader>} blockHeaders
         * @memberof protocol.Items
         * @instance
         */
        Items.prototype.blockHeaders = $util.emptyArray;

        /**
         * Items transactions.
         * @member {Array.<protocol.ITransaction>} transactions
         * @memberof protocol.Items
         * @instance
         */
        Items.prototype.transactions = $util.emptyArray;

        /**
         * Creates a new Items instance using the specified properties.
         * @function create
         * @memberof protocol.Items
         * @static
         * @param {protocol.IItems=} [properties] Properties to set
         * @returns {protocol.Items} Items instance
         */
        Items.create = function create(properties) {
            return new Items(properties);
        };

        /**
         * Encodes the specified Items message. Does not implicitly {@link protocol.Items.verify|verify} messages.
         * @function encode
         * @memberof protocol.Items
         * @static
         * @param {protocol.IItems} message Items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Items.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.blocks != null && message.blocks.length)
                for (var i = 0; i < message.blocks.length; ++i)
                    $root.protocol.Block.encode(message.blocks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.blockHeaders != null && message.blockHeaders.length)
                for (var i = 0; i < message.blockHeaders.length; ++i)
                    $root.protocol.BlockHeader.encode(message.blockHeaders[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.protocol.Transaction.encode(message.transactions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Items message, length delimited. Does not implicitly {@link protocol.Items.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Items
         * @static
         * @param {protocol.IItems} message Items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Items.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Items message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Items} Items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Items.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Items();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.blocks && message.blocks.length))
                        message.blocks = [];
                    message.blocks.push($root.protocol.Block.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.blockHeaders && message.blockHeaders.length))
                        message.blockHeaders = [];
                    message.blockHeaders.push($root.protocol.BlockHeader.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.transactions && message.transactions.length))
                        message.transactions = [];
                    message.transactions.push($root.protocol.Transaction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Items message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Items} Items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Items.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Items message.
         * @function verify
         * @memberof protocol.Items
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Items.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.blocks != null && message.hasOwnProperty("blocks")) {
                if (!Array.isArray(message.blocks))
                    return "blocks: array expected";
                for (var i = 0; i < message.blocks.length; ++i) {
                    var error = $root.protocol.Block.verify(message.blocks[i]);
                    if (error)
                        return "blocks." + error;
                }
            }
            if (message.blockHeaders != null && message.hasOwnProperty("blockHeaders")) {
                if (!Array.isArray(message.blockHeaders))
                    return "blockHeaders: array expected";
                for (var i = 0; i < message.blockHeaders.length; ++i) {
                    var error = $root.protocol.BlockHeader.verify(message.blockHeaders[i]);
                    if (error)
                        return "blockHeaders." + error;
                }
            }
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.protocol.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Items message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Items
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Items} Items
         */
        Items.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Items)
                return object;
            var message = new $root.protocol.Items();
            switch (object.type) {
            case "ERR":
            case 0:
                message.type = 0;
                break;
            case "TRX":
            case 1:
                message.type = 1;
                break;
            case "BLOCK":
            case 2:
                message.type = 2;
                break;
            case "BLOCKHEADER":
            case 3:
                message.type = 3;
                break;
            }
            if (object.blocks) {
                if (!Array.isArray(object.blocks))
                    throw TypeError(".protocol.Items.blocks: array expected");
                message.blocks = [];
                for (var i = 0; i < object.blocks.length; ++i) {
                    if (typeof object.blocks[i] !== "object")
                        throw TypeError(".protocol.Items.blocks: object expected");
                    message.blocks[i] = $root.protocol.Block.fromObject(object.blocks[i]);
                }
            }
            if (object.blockHeaders) {
                if (!Array.isArray(object.blockHeaders))
                    throw TypeError(".protocol.Items.blockHeaders: array expected");
                message.blockHeaders = [];
                for (var i = 0; i < object.blockHeaders.length; ++i) {
                    if (typeof object.blockHeaders[i] !== "object")
                        throw TypeError(".protocol.Items.blockHeaders: object expected");
                    message.blockHeaders[i] = $root.protocol.BlockHeader.fromObject(object.blockHeaders[i]);
                }
            }
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".protocol.Items.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".protocol.Items.transactions: object expected");
                    message.transactions[i] = $root.protocol.Transaction.fromObject(object.transactions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Items message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Items
         * @static
         * @param {protocol.Items} message Items
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Items.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.blocks = [];
                object.blockHeaders = [];
                object.transactions = [];
            }
            if (options.defaults)
                object.type = options.enums === String ? "ERR" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.Items.ItemType[message.type] : message.type;
            if (message.blocks && message.blocks.length) {
                object.blocks = [];
                for (var j = 0; j < message.blocks.length; ++j)
                    object.blocks[j] = $root.protocol.Block.toObject(message.blocks[j], options);
            }
            if (message.blockHeaders && message.blockHeaders.length) {
                object.blockHeaders = [];
                for (var j = 0; j < message.blockHeaders.length; ++j)
                    object.blockHeaders[j] = $root.protocol.BlockHeader.toObject(message.blockHeaders[j], options);
            }
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.protocol.Transaction.toObject(message.transactions[j], options);
            }
            return object;
        };

        /**
         * Converts this Items to JSON.
         * @function toJSON
         * @memberof protocol.Items
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Items.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ItemType enum.
         * @name protocol.Items.ItemType
         * @enum {number}
         * @property {number} ERR=0 ERR value
         * @property {number} TRX=1 TRX value
         * @property {number} BLOCK=2 BLOCK value
         * @property {number} BLOCKHEADER=3 BLOCKHEADER value
         */
        Items.ItemType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ERR"] = 0;
            values[valuesById[1] = "TRX"] = 1;
            values[valuesById[2] = "BLOCK"] = 2;
            values[valuesById[3] = "BLOCKHEADER"] = 3;
            return values;
        })();

        return Items;
    })();

    protocol.DynamicProperties = (function() {

        /**
         * Properties of a DynamicProperties.
         * @memberof protocol
         * @interface IDynamicProperties
         * @property {number|Long|null} [lastSolidityBlockNum] DynamicProperties lastSolidityBlockNum
         */

        /**
         * Constructs a new DynamicProperties.
         * @memberof protocol
         * @classdesc Represents a DynamicProperties.
         * @implements IDynamicProperties
         * @constructor
         * @param {protocol.IDynamicProperties=} [properties] Properties to set
         */
        function DynamicProperties(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DynamicProperties lastSolidityBlockNum.
         * @member {number|Long} lastSolidityBlockNum
         * @memberof protocol.DynamicProperties
         * @instance
         */
        DynamicProperties.prototype.lastSolidityBlockNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DynamicProperties instance using the specified properties.
         * @function create
         * @memberof protocol.DynamicProperties
         * @static
         * @param {protocol.IDynamicProperties=} [properties] Properties to set
         * @returns {protocol.DynamicProperties} DynamicProperties instance
         */
        DynamicProperties.create = function create(properties) {
            return new DynamicProperties(properties);
        };

        /**
         * Encodes the specified DynamicProperties message. Does not implicitly {@link protocol.DynamicProperties.verify|verify} messages.
         * @function encode
         * @memberof protocol.DynamicProperties
         * @static
         * @param {protocol.IDynamicProperties} message DynamicProperties message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynamicProperties.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastSolidityBlockNum != null && Object.hasOwnProperty.call(message, "lastSolidityBlockNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lastSolidityBlockNum);
            return writer;
        };

        /**
         * Encodes the specified DynamicProperties message, length delimited. Does not implicitly {@link protocol.DynamicProperties.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.DynamicProperties
         * @static
         * @param {protocol.IDynamicProperties} message DynamicProperties message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynamicProperties.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DynamicProperties message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.DynamicProperties
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.DynamicProperties} DynamicProperties
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynamicProperties.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DynamicProperties();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastSolidityBlockNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DynamicProperties message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.DynamicProperties
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.DynamicProperties} DynamicProperties
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynamicProperties.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DynamicProperties message.
         * @function verify
         * @memberof protocol.DynamicProperties
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DynamicProperties.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastSolidityBlockNum != null && message.hasOwnProperty("lastSolidityBlockNum"))
                if (!$util.isInteger(message.lastSolidityBlockNum) && !(message.lastSolidityBlockNum && $util.isInteger(message.lastSolidityBlockNum.low) && $util.isInteger(message.lastSolidityBlockNum.high)))
                    return "lastSolidityBlockNum: integer|Long expected";
            return null;
        };

        /**
         * Creates a DynamicProperties message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.DynamicProperties
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.DynamicProperties} DynamicProperties
         */
        DynamicProperties.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DynamicProperties)
                return object;
            var message = new $root.protocol.DynamicProperties();
            if (object.lastSolidityBlockNum != null)
                if ($util.Long)
                    (message.lastSolidityBlockNum = $util.Long.fromValue(object.lastSolidityBlockNum)).unsigned = false;
                else if (typeof object.lastSolidityBlockNum === "string")
                    message.lastSolidityBlockNum = parseInt(object.lastSolidityBlockNum, 10);
                else if (typeof object.lastSolidityBlockNum === "number")
                    message.lastSolidityBlockNum = object.lastSolidityBlockNum;
                else if (typeof object.lastSolidityBlockNum === "object")
                    message.lastSolidityBlockNum = new $util.LongBits(object.lastSolidityBlockNum.low >>> 0, object.lastSolidityBlockNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DynamicProperties message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.DynamicProperties
         * @static
         * @param {protocol.DynamicProperties} message DynamicProperties
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DynamicProperties.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastSolidityBlockNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastSolidityBlockNum = options.longs === String ? "0" : 0;
            if (message.lastSolidityBlockNum != null && message.hasOwnProperty("lastSolidityBlockNum"))
                if (typeof message.lastSolidityBlockNum === "number")
                    object.lastSolidityBlockNum = options.longs === String ? String(message.lastSolidityBlockNum) : message.lastSolidityBlockNum;
                else
                    object.lastSolidityBlockNum = options.longs === String ? $util.Long.prototype.toString.call(message.lastSolidityBlockNum) : options.longs === Number ? new $util.LongBits(message.lastSolidityBlockNum.low >>> 0, message.lastSolidityBlockNum.high >>> 0).toNumber() : message.lastSolidityBlockNum;
            return object;
        };

        /**
         * Converts this DynamicProperties to JSON.
         * @function toJSON
         * @memberof protocol.DynamicProperties
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DynamicProperties.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DynamicProperties;
    })();

    /**
     * ReasonCode enum.
     * @name protocol.ReasonCode
     * @enum {number}
     * @property {number} REQUESTED=0 REQUESTED value
     * @property {number} BAD_PROTOCOL=2 BAD_PROTOCOL value
     * @property {number} TOO_MANY_PEERS=4 TOO_MANY_PEERS value
     * @property {number} DUPLICATE_PEER=5 DUPLICATE_PEER value
     * @property {number} INCOMPATIBLE_PROTOCOL=6 INCOMPATIBLE_PROTOCOL value
     * @property {number} NULL_IDENTITY=7 NULL_IDENTITY value
     * @property {number} PEER_QUITING=8 PEER_QUITING value
     * @property {number} UNEXPECTED_IDENTITY=9 UNEXPECTED_IDENTITY value
     * @property {number} LOCAL_IDENTITY=10 LOCAL_IDENTITY value
     * @property {number} PING_TIMEOUT=11 PING_TIMEOUT value
     * @property {number} USER_REASON=16 USER_REASON value
     * @property {number} RESET=17 RESET value
     * @property {number} SYNC_FAIL=18 SYNC_FAIL value
     * @property {number} FETCH_FAIL=19 FETCH_FAIL value
     * @property {number} BAD_TX=20 BAD_TX value
     * @property {number} BAD_BLOCK=21 BAD_BLOCK value
     * @property {number} FORKED=22 FORKED value
     * @property {number} UNLINKABLE=23 UNLINKABLE value
     * @property {number} INCOMPATIBLE_VERSION=24 INCOMPATIBLE_VERSION value
     * @property {number} INCOMPATIBLE_CHAIN=25 INCOMPATIBLE_CHAIN value
     * @property {number} TIME_OUT=32 TIME_OUT value
     * @property {number} CONNECT_FAIL=33 CONNECT_FAIL value
     * @property {number} TOO_MANY_PEERS_WITH_SAME_IP=34 TOO_MANY_PEERS_WITH_SAME_IP value
     * @property {number} UNKNOWN=255 UNKNOWN value
     */
    protocol.ReasonCode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "REQUESTED"] = 0;
        values[valuesById[2] = "BAD_PROTOCOL"] = 2;
        values[valuesById[4] = "TOO_MANY_PEERS"] = 4;
        values[valuesById[5] = "DUPLICATE_PEER"] = 5;
        values[valuesById[6] = "INCOMPATIBLE_PROTOCOL"] = 6;
        values[valuesById[7] = "NULL_IDENTITY"] = 7;
        values[valuesById[8] = "PEER_QUITING"] = 8;
        values[valuesById[9] = "UNEXPECTED_IDENTITY"] = 9;
        values[valuesById[10] = "LOCAL_IDENTITY"] = 10;
        values[valuesById[11] = "PING_TIMEOUT"] = 11;
        values[valuesById[16] = "USER_REASON"] = 16;
        values[valuesById[17] = "RESET"] = 17;
        values[valuesById[18] = "SYNC_FAIL"] = 18;
        values[valuesById[19] = "FETCH_FAIL"] = 19;
        values[valuesById[20] = "BAD_TX"] = 20;
        values[valuesById[21] = "BAD_BLOCK"] = 21;
        values[valuesById[22] = "FORKED"] = 22;
        values[valuesById[23] = "UNLINKABLE"] = 23;
        values[valuesById[24] = "INCOMPATIBLE_VERSION"] = 24;
        values[valuesById[25] = "INCOMPATIBLE_CHAIN"] = 25;
        values[valuesById[32] = "TIME_OUT"] = 32;
        values[valuesById[33] = "CONNECT_FAIL"] = 33;
        values[valuesById[34] = "TOO_MANY_PEERS_WITH_SAME_IP"] = 34;
        values[valuesById[255] = "UNKNOWN"] = 255;
        return values;
    })();

    protocol.DisconnectMessage = (function() {

        /**
         * Properties of a DisconnectMessage.
         * @memberof protocol
         * @interface IDisconnectMessage
         * @property {protocol.ReasonCode|null} [reason] DisconnectMessage reason
         */

        /**
         * Constructs a new DisconnectMessage.
         * @memberof protocol
         * @classdesc Represents a DisconnectMessage.
         * @implements IDisconnectMessage
         * @constructor
         * @param {protocol.IDisconnectMessage=} [properties] Properties to set
         */
        function DisconnectMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DisconnectMessage reason.
         * @member {protocol.ReasonCode} reason
         * @memberof protocol.DisconnectMessage
         * @instance
         */
        DisconnectMessage.prototype.reason = 0;

        /**
         * Creates a new DisconnectMessage instance using the specified properties.
         * @function create
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {protocol.IDisconnectMessage=} [properties] Properties to set
         * @returns {protocol.DisconnectMessage} DisconnectMessage instance
         */
        DisconnectMessage.create = function create(properties) {
            return new DisconnectMessage(properties);
        };

        /**
         * Encodes the specified DisconnectMessage message. Does not implicitly {@link protocol.DisconnectMessage.verify|verify} messages.
         * @function encode
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {protocol.IDisconnectMessage} message DisconnectMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified DisconnectMessage message, length delimited. Does not implicitly {@link protocol.DisconnectMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {protocol.IDisconnectMessage} message DisconnectMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisconnectMessage message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.DisconnectMessage} DisconnectMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DisconnectMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisconnectMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.DisconnectMessage} DisconnectMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisconnectMessage message.
         * @function verify
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisconnectMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 2:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 32:
                case 33:
                case 34:
                case 255:
                    break;
                }
            return null;
        };

        /**
         * Creates a DisconnectMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.DisconnectMessage} DisconnectMessage
         */
        DisconnectMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DisconnectMessage)
                return object;
            var message = new $root.protocol.DisconnectMessage();
            switch (object.reason) {
            case "REQUESTED":
            case 0:
                message.reason = 0;
                break;
            case "BAD_PROTOCOL":
            case 2:
                message.reason = 2;
                break;
            case "TOO_MANY_PEERS":
            case 4:
                message.reason = 4;
                break;
            case "DUPLICATE_PEER":
            case 5:
                message.reason = 5;
                break;
            case "INCOMPATIBLE_PROTOCOL":
            case 6:
                message.reason = 6;
                break;
            case "NULL_IDENTITY":
            case 7:
                message.reason = 7;
                break;
            case "PEER_QUITING":
            case 8:
                message.reason = 8;
                break;
            case "UNEXPECTED_IDENTITY":
            case 9:
                message.reason = 9;
                break;
            case "LOCAL_IDENTITY":
            case 10:
                message.reason = 10;
                break;
            case "PING_TIMEOUT":
            case 11:
                message.reason = 11;
                break;
            case "USER_REASON":
            case 16:
                message.reason = 16;
                break;
            case "RESET":
            case 17:
                message.reason = 17;
                break;
            case "SYNC_FAIL":
            case 18:
                message.reason = 18;
                break;
            case "FETCH_FAIL":
            case 19:
                message.reason = 19;
                break;
            case "BAD_TX":
            case 20:
                message.reason = 20;
                break;
            case "BAD_BLOCK":
            case 21:
                message.reason = 21;
                break;
            case "FORKED":
            case 22:
                message.reason = 22;
                break;
            case "UNLINKABLE":
            case 23:
                message.reason = 23;
                break;
            case "INCOMPATIBLE_VERSION":
            case 24:
                message.reason = 24;
                break;
            case "INCOMPATIBLE_CHAIN":
            case 25:
                message.reason = 25;
                break;
            case "TIME_OUT":
            case 32:
                message.reason = 32;
                break;
            case "CONNECT_FAIL":
            case 33:
                message.reason = 33;
                break;
            case "TOO_MANY_PEERS_WITH_SAME_IP":
            case 34:
                message.reason = 34;
                break;
            case "UNKNOWN":
            case 255:
                message.reason = 255;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DisconnectMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {protocol.DisconnectMessage} message DisconnectMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisconnectMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = options.enums === String ? "REQUESTED" : 0;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.protocol.ReasonCode[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this DisconnectMessage to JSON.
         * @function toJSON
         * @memberof protocol.DisconnectMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisconnectMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DisconnectMessage;
    })();

    protocol.HelloMessage = (function() {

        /**
         * Properties of a HelloMessage.
         * @memberof protocol
         * @interface IHelloMessage
         * @property {protocol.IEndpoint|null} [from] HelloMessage from
         * @property {number|null} [version] HelloMessage version
         * @property {number|Long|null} [timestamp] HelloMessage timestamp
         * @property {protocol.HelloMessage.IBlockId|null} [genesisBlockId] HelloMessage genesisBlockId
         * @property {protocol.HelloMessage.IBlockId|null} [solidBlockId] HelloMessage solidBlockId
         * @property {protocol.HelloMessage.IBlockId|null} [headBlockId] HelloMessage headBlockId
         */

        /**
         * Constructs a new HelloMessage.
         * @memberof protocol
         * @classdesc Represents a HelloMessage.
         * @implements IHelloMessage
         * @constructor
         * @param {protocol.IHelloMessage=} [properties] Properties to set
         */
        function HelloMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HelloMessage from.
         * @member {protocol.IEndpoint|null|undefined} from
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.from = null;

        /**
         * HelloMessage version.
         * @member {number} version
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.version = 0;

        /**
         * HelloMessage timestamp.
         * @member {number|Long} timestamp
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HelloMessage genesisBlockId.
         * @member {protocol.HelloMessage.IBlockId|null|undefined} genesisBlockId
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.genesisBlockId = null;

        /**
         * HelloMessage solidBlockId.
         * @member {protocol.HelloMessage.IBlockId|null|undefined} solidBlockId
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.solidBlockId = null;

        /**
         * HelloMessage headBlockId.
         * @member {protocol.HelloMessage.IBlockId|null|undefined} headBlockId
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.headBlockId = null;

        /**
         * Creates a new HelloMessage instance using the specified properties.
         * @function create
         * @memberof protocol.HelloMessage
         * @static
         * @param {protocol.IHelloMessage=} [properties] Properties to set
         * @returns {protocol.HelloMessage} HelloMessage instance
         */
        HelloMessage.create = function create(properties) {
            return new HelloMessage(properties);
        };

        /**
         * Encodes the specified HelloMessage message. Does not implicitly {@link protocol.HelloMessage.verify|verify} messages.
         * @function encode
         * @memberof protocol.HelloMessage
         * @static
         * @param {protocol.IHelloMessage} message HelloMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelloMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.version);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            if (message.genesisBlockId != null && Object.hasOwnProperty.call(message, "genesisBlockId"))
                $root.protocol.HelloMessage.BlockId.encode(message.genesisBlockId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.solidBlockId != null && Object.hasOwnProperty.call(message, "solidBlockId"))
                $root.protocol.HelloMessage.BlockId.encode(message.solidBlockId, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.headBlockId != null && Object.hasOwnProperty.call(message, "headBlockId"))
                $root.protocol.HelloMessage.BlockId.encode(message.headBlockId, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HelloMessage message, length delimited. Does not implicitly {@link protocol.HelloMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.HelloMessage
         * @static
         * @param {protocol.IHelloMessage} message HelloMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelloMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HelloMessage message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.HelloMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.HelloMessage} HelloMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelloMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.HelloMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.version = reader.int32();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                case 4:
                    message.genesisBlockId = $root.protocol.HelloMessage.BlockId.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.solidBlockId = $root.protocol.HelloMessage.BlockId.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.headBlockId = $root.protocol.HelloMessage.BlockId.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HelloMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.HelloMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.HelloMessage} HelloMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelloMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HelloMessage message.
         * @function verify
         * @memberof protocol.HelloMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HelloMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.genesisBlockId != null && message.hasOwnProperty("genesisBlockId")) {
                var error = $root.protocol.HelloMessage.BlockId.verify(message.genesisBlockId);
                if (error)
                    return "genesisBlockId." + error;
            }
            if (message.solidBlockId != null && message.hasOwnProperty("solidBlockId")) {
                var error = $root.protocol.HelloMessage.BlockId.verify(message.solidBlockId);
                if (error)
                    return "solidBlockId." + error;
            }
            if (message.headBlockId != null && message.hasOwnProperty("headBlockId")) {
                var error = $root.protocol.HelloMessage.BlockId.verify(message.headBlockId);
                if (error)
                    return "headBlockId." + error;
            }
            return null;
        };

        /**
         * Creates a HelloMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.HelloMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.HelloMessage} HelloMessage
         */
        HelloMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.HelloMessage)
                return object;
            var message = new $root.protocol.HelloMessage();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.HelloMessage.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.version != null)
                message.version = object.version | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.genesisBlockId != null) {
                if (typeof object.genesisBlockId !== "object")
                    throw TypeError(".protocol.HelloMessage.genesisBlockId: object expected");
                message.genesisBlockId = $root.protocol.HelloMessage.BlockId.fromObject(object.genesisBlockId);
            }
            if (object.solidBlockId != null) {
                if (typeof object.solidBlockId !== "object")
                    throw TypeError(".protocol.HelloMessage.solidBlockId: object expected");
                message.solidBlockId = $root.protocol.HelloMessage.BlockId.fromObject(object.solidBlockId);
            }
            if (object.headBlockId != null) {
                if (typeof object.headBlockId !== "object")
                    throw TypeError(".protocol.HelloMessage.headBlockId: object expected");
                message.headBlockId = $root.protocol.HelloMessage.BlockId.fromObject(object.headBlockId);
            }
            return message;
        };

        /**
         * Creates a plain object from a HelloMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.HelloMessage
         * @static
         * @param {protocol.HelloMessage} message HelloMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HelloMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                object.version = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.genesisBlockId = null;
                object.solidBlockId = null;
                object.headBlockId = null;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.genesisBlockId != null && message.hasOwnProperty("genesisBlockId"))
                object.genesisBlockId = $root.protocol.HelloMessage.BlockId.toObject(message.genesisBlockId, options);
            if (message.solidBlockId != null && message.hasOwnProperty("solidBlockId"))
                object.solidBlockId = $root.protocol.HelloMessage.BlockId.toObject(message.solidBlockId, options);
            if (message.headBlockId != null && message.hasOwnProperty("headBlockId"))
                object.headBlockId = $root.protocol.HelloMessage.BlockId.toObject(message.headBlockId, options);
            return object;
        };

        /**
         * Converts this HelloMessage to JSON.
         * @function toJSON
         * @memberof protocol.HelloMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HelloMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        HelloMessage.BlockId = (function() {

            /**
             * Properties of a BlockId.
             * @memberof protocol.HelloMessage
             * @interface IBlockId
             * @property {Uint8Array|null} [hash] BlockId hash
             * @property {number|Long|null} [number] BlockId number
             */

            /**
             * Constructs a new BlockId.
             * @memberof protocol.HelloMessage
             * @classdesc Represents a BlockId.
             * @implements IBlockId
             * @constructor
             * @param {protocol.HelloMessage.IBlockId=} [properties] Properties to set
             */
            function BlockId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BlockId hash.
             * @member {Uint8Array} hash
             * @memberof protocol.HelloMessage.BlockId
             * @instance
             */
            BlockId.prototype.hash = $util.newBuffer([]);

            /**
             * BlockId number.
             * @member {number|Long} number
             * @memberof protocol.HelloMessage.BlockId
             * @instance
             */
            BlockId.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new BlockId instance using the specified properties.
             * @function create
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {protocol.HelloMessage.IBlockId=} [properties] Properties to set
             * @returns {protocol.HelloMessage.BlockId} BlockId instance
             */
            BlockId.create = function create(properties) {
                return new BlockId(properties);
            };

            /**
             * Encodes the specified BlockId message. Does not implicitly {@link protocol.HelloMessage.BlockId.verify|verify} messages.
             * @function encode
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {protocol.HelloMessage.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.number);
                return writer;
            };

            /**
             * Encodes the specified BlockId message, length delimited. Does not implicitly {@link protocol.HelloMessage.BlockId.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {protocol.HelloMessage.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.HelloMessage.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.HelloMessage.BlockId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.number = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.HelloMessage.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BlockId message.
             * @function verify
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };

            /**
             * Creates a BlockId message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.HelloMessage.BlockId} BlockId
             */
            BlockId.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.HelloMessage.BlockId)
                    return object;
                var message = new $root.protocol.HelloMessage.BlockId();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a BlockId message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {protocol.HelloMessage.BlockId} message BlockId
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                return object;
            };

            /**
             * Converts this BlockId to JSON.
             * @function toJSON
             * @memberof protocol.HelloMessage.BlockId
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BlockId;
        })();

        return HelloMessage;
    })();

    protocol.SmartContract = (function() {

        /**
         * Properties of a SmartContract.
         * @memberof protocol
         * @interface ISmartContract
         * @property {Uint8Array|null} [originAddress] SmartContract originAddress
         * @property {Uint8Array|null} [contractAddress] SmartContract contractAddress
         * @property {protocol.SmartContract.IABI|null} [abi] SmartContract abi
         * @property {Uint8Array|null} [bytecode] SmartContract bytecode
         * @property {number|Long|null} [callValue] SmartContract callValue
         * @property {number|Long|null} [consumeUserResourcePercent] SmartContract consumeUserResourcePercent
         * @property {string|null} [name] SmartContract name
         * @property {number|Long|null} [originEnergyLimit] SmartContract originEnergyLimit
         * @property {Uint8Array|null} [codeHash] SmartContract codeHash
         * @property {Uint8Array|null} [trxHash] SmartContract trxHash
         */

        /**
         * Constructs a new SmartContract.
         * @memberof protocol
         * @classdesc Represents a SmartContract.
         * @implements ISmartContract
         * @constructor
         * @param {protocol.ISmartContract=} [properties] Properties to set
         */
        function SmartContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmartContract originAddress.
         * @member {Uint8Array} originAddress
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.originAddress = $util.newBuffer([]);

        /**
         * SmartContract contractAddress.
         * @member {Uint8Array} contractAddress
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.contractAddress = $util.newBuffer([]);

        /**
         * SmartContract abi.
         * @member {protocol.SmartContract.IABI|null|undefined} abi
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.abi = null;

        /**
         * SmartContract bytecode.
         * @member {Uint8Array} bytecode
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.bytecode = $util.newBuffer([]);

        /**
         * SmartContract callValue.
         * @member {number|Long} callValue
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.callValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SmartContract consumeUserResourcePercent.
         * @member {number|Long} consumeUserResourcePercent
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.consumeUserResourcePercent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SmartContract name.
         * @member {string} name
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.name = "";

        /**
         * SmartContract originEnergyLimit.
         * @member {number|Long} originEnergyLimit
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.originEnergyLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SmartContract codeHash.
         * @member {Uint8Array} codeHash
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.codeHash = $util.newBuffer([]);

        /**
         * SmartContract trxHash.
         * @member {Uint8Array} trxHash
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.trxHash = $util.newBuffer([]);

        /**
         * Creates a new SmartContract instance using the specified properties.
         * @function create
         * @memberof protocol.SmartContract
         * @static
         * @param {protocol.ISmartContract=} [properties] Properties to set
         * @returns {protocol.SmartContract} SmartContract instance
         */
        SmartContract.create = function create(properties) {
            return new SmartContract(properties);
        };

        /**
         * Encodes the specified SmartContract message. Does not implicitly {@link protocol.SmartContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.SmartContract
         * @static
         * @param {protocol.ISmartContract} message SmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmartContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.originAddress != null && Object.hasOwnProperty.call(message, "originAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.originAddress);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contractAddress);
            if (message.abi != null && Object.hasOwnProperty.call(message, "abi"))
                $root.protocol.SmartContract.ABI.encode(message.abi, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.bytecode != null && Object.hasOwnProperty.call(message, "bytecode"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bytecode);
            if (message.callValue != null && Object.hasOwnProperty.call(message, "callValue"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.callValue);
            if (message.consumeUserResourcePercent != null && Object.hasOwnProperty.call(message, "consumeUserResourcePercent"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.consumeUserResourcePercent);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            if (message.originEnergyLimit != null && Object.hasOwnProperty.call(message, "originEnergyLimit"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.originEnergyLimit);
            if (message.codeHash != null && Object.hasOwnProperty.call(message, "codeHash"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.codeHash);
            if (message.trxHash != null && Object.hasOwnProperty.call(message, "trxHash"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.trxHash);
            return writer;
        };

        /**
         * Encodes the specified SmartContract message, length delimited. Does not implicitly {@link protocol.SmartContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.SmartContract
         * @static
         * @param {protocol.ISmartContract} message SmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmartContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SmartContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.SmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.SmartContract} SmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmartContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.originAddress = reader.bytes();
                    break;
                case 2:
                    message.contractAddress = reader.bytes();
                    break;
                case 3:
                    message.abi = $root.protocol.SmartContract.ABI.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.bytecode = reader.bytes();
                    break;
                case 5:
                    message.callValue = reader.int64();
                    break;
                case 6:
                    message.consumeUserResourcePercent = reader.int64();
                    break;
                case 7:
                    message.name = reader.string();
                    break;
                case 8:
                    message.originEnergyLimit = reader.int64();
                    break;
                case 9:
                    message.codeHash = reader.bytes();
                    break;
                case 10:
                    message.trxHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SmartContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.SmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.SmartContract} SmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmartContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SmartContract message.
         * @function verify
         * @memberof protocol.SmartContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SmartContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.originAddress != null && message.hasOwnProperty("originAddress"))
                if (!(message.originAddress && typeof message.originAddress.length === "number" || $util.isString(message.originAddress)))
                    return "originAddress: buffer expected";
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            if (message.abi != null && message.hasOwnProperty("abi")) {
                var error = $root.protocol.SmartContract.ABI.verify(message.abi);
                if (error)
                    return "abi." + error;
            }
            if (message.bytecode != null && message.hasOwnProperty("bytecode"))
                if (!(message.bytecode && typeof message.bytecode.length === "number" || $util.isString(message.bytecode)))
                    return "bytecode: buffer expected";
            if (message.callValue != null && message.hasOwnProperty("callValue"))
                if (!$util.isInteger(message.callValue) && !(message.callValue && $util.isInteger(message.callValue.low) && $util.isInteger(message.callValue.high)))
                    return "callValue: integer|Long expected";
            if (message.consumeUserResourcePercent != null && message.hasOwnProperty("consumeUserResourcePercent"))
                if (!$util.isInteger(message.consumeUserResourcePercent) && !(message.consumeUserResourcePercent && $util.isInteger(message.consumeUserResourcePercent.low) && $util.isInteger(message.consumeUserResourcePercent.high)))
                    return "consumeUserResourcePercent: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.originEnergyLimit != null && message.hasOwnProperty("originEnergyLimit"))
                if (!$util.isInteger(message.originEnergyLimit) && !(message.originEnergyLimit && $util.isInteger(message.originEnergyLimit.low) && $util.isInteger(message.originEnergyLimit.high)))
                    return "originEnergyLimit: integer|Long expected";
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                if (!(message.codeHash && typeof message.codeHash.length === "number" || $util.isString(message.codeHash)))
                    return "codeHash: buffer expected";
            if (message.trxHash != null && message.hasOwnProperty("trxHash"))
                if (!(message.trxHash && typeof message.trxHash.length === "number" || $util.isString(message.trxHash)))
                    return "trxHash: buffer expected";
            return null;
        };

        /**
         * Creates a SmartContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.SmartContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.SmartContract} SmartContract
         */
        SmartContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.SmartContract)
                return object;
            var message = new $root.protocol.SmartContract();
            if (object.originAddress != null)
                if (typeof object.originAddress === "string")
                    $util.base64.decode(object.originAddress, message.originAddress = $util.newBuffer($util.base64.length(object.originAddress)), 0);
                else if (object.originAddress.length)
                    message.originAddress = object.originAddress;
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            if (object.abi != null) {
                if (typeof object.abi !== "object")
                    throw TypeError(".protocol.SmartContract.abi: object expected");
                message.abi = $root.protocol.SmartContract.ABI.fromObject(object.abi);
            }
            if (object.bytecode != null)
                if (typeof object.bytecode === "string")
                    $util.base64.decode(object.bytecode, message.bytecode = $util.newBuffer($util.base64.length(object.bytecode)), 0);
                else if (object.bytecode.length)
                    message.bytecode = object.bytecode;
            if (object.callValue != null)
                if ($util.Long)
                    (message.callValue = $util.Long.fromValue(object.callValue)).unsigned = false;
                else if (typeof object.callValue === "string")
                    message.callValue = parseInt(object.callValue, 10);
                else if (typeof object.callValue === "number")
                    message.callValue = object.callValue;
                else if (typeof object.callValue === "object")
                    message.callValue = new $util.LongBits(object.callValue.low >>> 0, object.callValue.high >>> 0).toNumber();
            if (object.consumeUserResourcePercent != null)
                if ($util.Long)
                    (message.consumeUserResourcePercent = $util.Long.fromValue(object.consumeUserResourcePercent)).unsigned = false;
                else if (typeof object.consumeUserResourcePercent === "string")
                    message.consumeUserResourcePercent = parseInt(object.consumeUserResourcePercent, 10);
                else if (typeof object.consumeUserResourcePercent === "number")
                    message.consumeUserResourcePercent = object.consumeUserResourcePercent;
                else if (typeof object.consumeUserResourcePercent === "object")
                    message.consumeUserResourcePercent = new $util.LongBits(object.consumeUserResourcePercent.low >>> 0, object.consumeUserResourcePercent.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.originEnergyLimit != null)
                if ($util.Long)
                    (message.originEnergyLimit = $util.Long.fromValue(object.originEnergyLimit)).unsigned = false;
                else if (typeof object.originEnergyLimit === "string")
                    message.originEnergyLimit = parseInt(object.originEnergyLimit, 10);
                else if (typeof object.originEnergyLimit === "number")
                    message.originEnergyLimit = object.originEnergyLimit;
                else if (typeof object.originEnergyLimit === "object")
                    message.originEnergyLimit = new $util.LongBits(object.originEnergyLimit.low >>> 0, object.originEnergyLimit.high >>> 0).toNumber();
            if (object.codeHash != null)
                if (typeof object.codeHash === "string")
                    $util.base64.decode(object.codeHash, message.codeHash = $util.newBuffer($util.base64.length(object.codeHash)), 0);
                else if (object.codeHash.length)
                    message.codeHash = object.codeHash;
            if (object.trxHash != null)
                if (typeof object.trxHash === "string")
                    $util.base64.decode(object.trxHash, message.trxHash = $util.newBuffer($util.base64.length(object.trxHash)), 0);
                else if (object.trxHash.length)
                    message.trxHash = object.trxHash;
            return message;
        };

        /**
         * Creates a plain object from a SmartContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.SmartContract
         * @static
         * @param {protocol.SmartContract} message SmartContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SmartContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.originAddress = "";
                else {
                    object.originAddress = [];
                    if (options.bytes !== Array)
                        object.originAddress = $util.newBuffer(object.originAddress);
                }
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
                object.abi = null;
                if (options.bytes === String)
                    object.bytecode = "";
                else {
                    object.bytecode = [];
                    if (options.bytes !== Array)
                        object.bytecode = $util.newBuffer(object.bytecode);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.callValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.callValue = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.consumeUserResourcePercent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.consumeUserResourcePercent = options.longs === String ? "0" : 0;
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.originEnergyLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.originEnergyLimit = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.codeHash = "";
                else {
                    object.codeHash = [];
                    if (options.bytes !== Array)
                        object.codeHash = $util.newBuffer(object.codeHash);
                }
                if (options.bytes === String)
                    object.trxHash = "";
                else {
                    object.trxHash = [];
                    if (options.bytes !== Array)
                        object.trxHash = $util.newBuffer(object.trxHash);
                }
            }
            if (message.originAddress != null && message.hasOwnProperty("originAddress"))
                object.originAddress = options.bytes === String ? $util.base64.encode(message.originAddress, 0, message.originAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.originAddress) : message.originAddress;
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            if (message.abi != null && message.hasOwnProperty("abi"))
                object.abi = $root.protocol.SmartContract.ABI.toObject(message.abi, options);
            if (message.bytecode != null && message.hasOwnProperty("bytecode"))
                object.bytecode = options.bytes === String ? $util.base64.encode(message.bytecode, 0, message.bytecode.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytecode) : message.bytecode;
            if (message.callValue != null && message.hasOwnProperty("callValue"))
                if (typeof message.callValue === "number")
                    object.callValue = options.longs === String ? String(message.callValue) : message.callValue;
                else
                    object.callValue = options.longs === String ? $util.Long.prototype.toString.call(message.callValue) : options.longs === Number ? new $util.LongBits(message.callValue.low >>> 0, message.callValue.high >>> 0).toNumber() : message.callValue;
            if (message.consumeUserResourcePercent != null && message.hasOwnProperty("consumeUserResourcePercent"))
                if (typeof message.consumeUserResourcePercent === "number")
                    object.consumeUserResourcePercent = options.longs === String ? String(message.consumeUserResourcePercent) : message.consumeUserResourcePercent;
                else
                    object.consumeUserResourcePercent = options.longs === String ? $util.Long.prototype.toString.call(message.consumeUserResourcePercent) : options.longs === Number ? new $util.LongBits(message.consumeUserResourcePercent.low >>> 0, message.consumeUserResourcePercent.high >>> 0).toNumber() : message.consumeUserResourcePercent;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.originEnergyLimit != null && message.hasOwnProperty("originEnergyLimit"))
                if (typeof message.originEnergyLimit === "number")
                    object.originEnergyLimit = options.longs === String ? String(message.originEnergyLimit) : message.originEnergyLimit;
                else
                    object.originEnergyLimit = options.longs === String ? $util.Long.prototype.toString.call(message.originEnergyLimit) : options.longs === Number ? new $util.LongBits(message.originEnergyLimit.low >>> 0, message.originEnergyLimit.high >>> 0).toNumber() : message.originEnergyLimit;
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                object.codeHash = options.bytes === String ? $util.base64.encode(message.codeHash, 0, message.codeHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.codeHash) : message.codeHash;
            if (message.trxHash != null && message.hasOwnProperty("trxHash"))
                object.trxHash = options.bytes === String ? $util.base64.encode(message.trxHash, 0, message.trxHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.trxHash) : message.trxHash;
            return object;
        };

        /**
         * Converts this SmartContract to JSON.
         * @function toJSON
         * @memberof protocol.SmartContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SmartContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        SmartContract.ABI = (function() {

            /**
             * Properties of a ABI.
             * @memberof protocol.SmartContract
             * @interface IABI
             * @property {Array.<protocol.SmartContract.ABI.IEntry>|null} [entrys] ABI entrys
             */

            /**
             * Constructs a new ABI.
             * @memberof protocol.SmartContract
             * @classdesc Represents a ABI.
             * @implements IABI
             * @constructor
             * @param {protocol.SmartContract.IABI=} [properties] Properties to set
             */
            function ABI(properties) {
                this.entrys = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ABI entrys.
             * @member {Array.<protocol.SmartContract.ABI.IEntry>} entrys
             * @memberof protocol.SmartContract.ABI
             * @instance
             */
            ABI.prototype.entrys = $util.emptyArray;

            /**
             * Creates a new ABI instance using the specified properties.
             * @function create
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {protocol.SmartContract.IABI=} [properties] Properties to set
             * @returns {protocol.SmartContract.ABI} ABI instance
             */
            ABI.create = function create(properties) {
                return new ABI(properties);
            };

            /**
             * Encodes the specified ABI message. Does not implicitly {@link protocol.SmartContract.ABI.verify|verify} messages.
             * @function encode
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {protocol.SmartContract.IABI} message ABI message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ABI.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entrys != null && message.entrys.length)
                    for (var i = 0; i < message.entrys.length; ++i)
                        $root.protocol.SmartContract.ABI.Entry.encode(message.entrys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ABI message, length delimited. Does not implicitly {@link protocol.SmartContract.ABI.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {protocol.SmartContract.IABI} message ABI message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ABI.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ABI message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.SmartContract.ABI} ABI
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ABI.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract.ABI();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.entrys && message.entrys.length))
                            message.entrys = [];
                        message.entrys.push($root.protocol.SmartContract.ABI.Entry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ABI message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.SmartContract.ABI} ABI
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ABI.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ABI message.
             * @function verify
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ABI.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entrys != null && message.hasOwnProperty("entrys")) {
                    if (!Array.isArray(message.entrys))
                        return "entrys: array expected";
                    for (var i = 0; i < message.entrys.length; ++i) {
                        var error = $root.protocol.SmartContract.ABI.Entry.verify(message.entrys[i]);
                        if (error)
                            return "entrys." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ABI message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.SmartContract.ABI} ABI
             */
            ABI.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.SmartContract.ABI)
                    return object;
                var message = new $root.protocol.SmartContract.ABI();
                if (object.entrys) {
                    if (!Array.isArray(object.entrys))
                        throw TypeError(".protocol.SmartContract.ABI.entrys: array expected");
                    message.entrys = [];
                    for (var i = 0; i < object.entrys.length; ++i) {
                        if (typeof object.entrys[i] !== "object")
                            throw TypeError(".protocol.SmartContract.ABI.entrys: object expected");
                        message.entrys[i] = $root.protocol.SmartContract.ABI.Entry.fromObject(object.entrys[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ABI message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {protocol.SmartContract.ABI} message ABI
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ABI.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entrys = [];
                if (message.entrys && message.entrys.length) {
                    object.entrys = [];
                    for (var j = 0; j < message.entrys.length; ++j)
                        object.entrys[j] = $root.protocol.SmartContract.ABI.Entry.toObject(message.entrys[j], options);
                }
                return object;
            };

            /**
             * Converts this ABI to JSON.
             * @function toJSON
             * @memberof protocol.SmartContract.ABI
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ABI.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ABI.Entry = (function() {

                /**
                 * Properties of an Entry.
                 * @memberof protocol.SmartContract.ABI
                 * @interface IEntry
                 * @property {boolean|null} [anonymous] Entry anonymous
                 * @property {boolean|null} [constant] Entry constant
                 * @property {string|null} [name] Entry name
                 * @property {Array.<protocol.SmartContract.ABI.Entry.IParam>|null} [inputs] Entry inputs
                 * @property {Array.<protocol.SmartContract.ABI.Entry.IParam>|null} [outputs] Entry outputs
                 * @property {protocol.SmartContract.ABI.Entry.EntryType|null} [type] Entry type
                 * @property {boolean|null} [payable] Entry payable
                 * @property {protocol.SmartContract.ABI.Entry.StateMutabilityType|null} [stateMutability] Entry stateMutability
                 */

                /**
                 * Constructs a new Entry.
                 * @memberof protocol.SmartContract.ABI
                 * @classdesc Represents an Entry.
                 * @implements IEntry
                 * @constructor
                 * @param {protocol.SmartContract.ABI.IEntry=} [properties] Properties to set
                 */
                function Entry(properties) {
                    this.inputs = [];
                    this.outputs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Entry anonymous.
                 * @member {boolean} anonymous
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.anonymous = false;

                /**
                 * Entry constant.
                 * @member {boolean} constant
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.constant = false;

                /**
                 * Entry name.
                 * @member {string} name
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.name = "";

                /**
                 * Entry inputs.
                 * @member {Array.<protocol.SmartContract.ABI.Entry.IParam>} inputs
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.inputs = $util.emptyArray;

                /**
                 * Entry outputs.
                 * @member {Array.<protocol.SmartContract.ABI.Entry.IParam>} outputs
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.outputs = $util.emptyArray;

                /**
                 * Entry type.
                 * @member {protocol.SmartContract.ABI.Entry.EntryType} type
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.type = 0;

                /**
                 * Entry payable.
                 * @member {boolean} payable
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.payable = false;

                /**
                 * Entry stateMutability.
                 * @member {protocol.SmartContract.ABI.Entry.StateMutabilityType} stateMutability
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.stateMutability = 0;

                /**
                 * Creates a new Entry instance using the specified properties.
                 * @function create
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {protocol.SmartContract.ABI.IEntry=} [properties] Properties to set
                 * @returns {protocol.SmartContract.ABI.Entry} Entry instance
                 */
                Entry.create = function create(properties) {
                    return new Entry(properties);
                };

                /**
                 * Encodes the specified Entry message. Does not implicitly {@link protocol.SmartContract.ABI.Entry.verify|verify} messages.
                 * @function encode
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {protocol.SmartContract.ABI.IEntry} message Entry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Entry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.anonymous != null && Object.hasOwnProperty.call(message, "anonymous"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.anonymous);
                    if (message.constant != null && Object.hasOwnProperty.call(message, "constant"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.constant);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.inputs != null && message.inputs.length)
                        for (var i = 0; i < message.inputs.length; ++i)
                            $root.protocol.SmartContract.ABI.Entry.Param.encode(message.inputs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.outputs != null && message.outputs.length)
                        for (var i = 0; i < message.outputs.length; ++i)
                            $root.protocol.SmartContract.ABI.Entry.Param.encode(message.outputs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
                    if (message.payable != null && Object.hasOwnProperty.call(message, "payable"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.payable);
                    if (message.stateMutability != null && Object.hasOwnProperty.call(message, "stateMutability"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.stateMutability);
                    return writer;
                };

                /**
                 * Encodes the specified Entry message, length delimited. Does not implicitly {@link protocol.SmartContract.ABI.Entry.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {protocol.SmartContract.ABI.IEntry} message Entry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Entry.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Entry message from the specified reader or buffer.
                 * @function decode
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {protocol.SmartContract.ABI.Entry} Entry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Entry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract.ABI.Entry();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.anonymous = reader.bool();
                            break;
                        case 2:
                            message.constant = reader.bool();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            if (!(message.inputs && message.inputs.length))
                                message.inputs = [];
                            message.inputs.push($root.protocol.SmartContract.ABI.Entry.Param.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.outputs && message.outputs.length))
                                message.outputs = [];
                            message.outputs.push($root.protocol.SmartContract.ABI.Entry.Param.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.type = reader.int32();
                            break;
                        case 7:
                            message.payable = reader.bool();
                            break;
                        case 8:
                            message.stateMutability = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Entry message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {protocol.SmartContract.ABI.Entry} Entry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Entry.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Entry message.
                 * @function verify
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Entry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.anonymous != null && message.hasOwnProperty("anonymous"))
                        if (typeof message.anonymous !== "boolean")
                            return "anonymous: boolean expected";
                    if (message.constant != null && message.hasOwnProperty("constant"))
                        if (typeof message.constant !== "boolean")
                            return "constant: boolean expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        if (!Array.isArray(message.inputs))
                            return "inputs: array expected";
                        for (var i = 0; i < message.inputs.length; ++i) {
                            var error = $root.protocol.SmartContract.ABI.Entry.Param.verify(message.inputs[i]);
                            if (error)
                                return "inputs." + error;
                        }
                    }
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        if (!Array.isArray(message.outputs))
                            return "outputs: array expected";
                        for (var i = 0; i < message.outputs.length; ++i) {
                            var error = $root.protocol.SmartContract.ABI.Entry.Param.verify(message.outputs[i]);
                            if (error)
                                return "outputs." + error;
                        }
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.payable != null && message.hasOwnProperty("payable"))
                        if (typeof message.payable !== "boolean")
                            return "payable: boolean expected";
                    if (message.stateMutability != null && message.hasOwnProperty("stateMutability"))
                        switch (message.stateMutability) {
                        default:
                            return "stateMutability: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates an Entry message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {protocol.SmartContract.ABI.Entry} Entry
                 */
                Entry.fromObject = function fromObject(object) {
                    if (object instanceof $root.protocol.SmartContract.ABI.Entry)
                        return object;
                    var message = new $root.protocol.SmartContract.ABI.Entry();
                    if (object.anonymous != null)
                        message.anonymous = Boolean(object.anonymous);
                    if (object.constant != null)
                        message.constant = Boolean(object.constant);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.inputs) {
                        if (!Array.isArray(object.inputs))
                            throw TypeError(".protocol.SmartContract.ABI.Entry.inputs: array expected");
                        message.inputs = [];
                        for (var i = 0; i < object.inputs.length; ++i) {
                            if (typeof object.inputs[i] !== "object")
                                throw TypeError(".protocol.SmartContract.ABI.Entry.inputs: object expected");
                            message.inputs[i] = $root.protocol.SmartContract.ABI.Entry.Param.fromObject(object.inputs[i]);
                        }
                    }
                    if (object.outputs) {
                        if (!Array.isArray(object.outputs))
                            throw TypeError(".protocol.SmartContract.ABI.Entry.outputs: array expected");
                        message.outputs = [];
                        for (var i = 0; i < object.outputs.length; ++i) {
                            if (typeof object.outputs[i] !== "object")
                                throw TypeError(".protocol.SmartContract.ABI.Entry.outputs: object expected");
                            message.outputs[i] = $root.protocol.SmartContract.ABI.Entry.Param.fromObject(object.outputs[i]);
                        }
                    }
                    switch (object.type) {
                    case "UnknownEntryType":
                    case 0:
                        message.type = 0;
                        break;
                    case "Constructor":
                    case 1:
                        message.type = 1;
                        break;
                    case "Function":
                    case 2:
                        message.type = 2;
                        break;
                    case "Event":
                    case 3:
                        message.type = 3;
                        break;
                    case "Fallback":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.payable != null)
                        message.payable = Boolean(object.payable);
                    switch (object.stateMutability) {
                    case "UnknownMutabilityType":
                    case 0:
                        message.stateMutability = 0;
                        break;
                    case "Pure":
                    case 1:
                        message.stateMutability = 1;
                        break;
                    case "View":
                    case 2:
                        message.stateMutability = 2;
                        break;
                    case "Nonpayable":
                    case 3:
                        message.stateMutability = 3;
                        break;
                    case "Payable":
                    case 4:
                        message.stateMutability = 4;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Entry message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {protocol.SmartContract.ABI.Entry} message Entry
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Entry.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.inputs = [];
                        object.outputs = [];
                    }
                    if (options.defaults) {
                        object.anonymous = false;
                        object.constant = false;
                        object.name = "";
                        object.type = options.enums === String ? "UnknownEntryType" : 0;
                        object.payable = false;
                        object.stateMutability = options.enums === String ? "UnknownMutabilityType" : 0;
                    }
                    if (message.anonymous != null && message.hasOwnProperty("anonymous"))
                        object.anonymous = message.anonymous;
                    if (message.constant != null && message.hasOwnProperty("constant"))
                        object.constant = message.constant;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.inputs && message.inputs.length) {
                        object.inputs = [];
                        for (var j = 0; j < message.inputs.length; ++j)
                            object.inputs[j] = $root.protocol.SmartContract.ABI.Entry.Param.toObject(message.inputs[j], options);
                    }
                    if (message.outputs && message.outputs.length) {
                        object.outputs = [];
                        for (var j = 0; j < message.outputs.length; ++j)
                            object.outputs[j] = $root.protocol.SmartContract.ABI.Entry.Param.toObject(message.outputs[j], options);
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.protocol.SmartContract.ABI.Entry.EntryType[message.type] : message.type;
                    if (message.payable != null && message.hasOwnProperty("payable"))
                        object.payable = message.payable;
                    if (message.stateMutability != null && message.hasOwnProperty("stateMutability"))
                        object.stateMutability = options.enums === String ? $root.protocol.SmartContract.ABI.Entry.StateMutabilityType[message.stateMutability] : message.stateMutability;
                    return object;
                };

                /**
                 * Converts this Entry to JSON.
                 * @function toJSON
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Entry.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * EntryType enum.
                 * @name protocol.SmartContract.ABI.Entry.EntryType
                 * @enum {number}
                 * @property {number} UnknownEntryType=0 UnknownEntryType value
                 * @property {number} Constructor=1 Constructor value
                 * @property {number} Function=2 Function value
                 * @property {number} Event=3 Event value
                 * @property {number} Fallback=4 Fallback value
                 */
                Entry.EntryType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UnknownEntryType"] = 0;
                    values[valuesById[1] = "Constructor"] = 1;
                    values[valuesById[2] = "Function"] = 2;
                    values[valuesById[3] = "Event"] = 3;
                    values[valuesById[4] = "Fallback"] = 4;
                    return values;
                })();

                Entry.Param = (function() {

                    /**
                     * Properties of a Param.
                     * @memberof protocol.SmartContract.ABI.Entry
                     * @interface IParam
                     * @property {boolean|null} [indexed] Param indexed
                     * @property {string|null} [name] Param name
                     * @property {string|null} [type] Param type
                     */

                    /**
                     * Constructs a new Param.
                     * @memberof protocol.SmartContract.ABI.Entry
                     * @classdesc Represents a Param.
                     * @implements IParam
                     * @constructor
                     * @param {protocol.SmartContract.ABI.Entry.IParam=} [properties] Properties to set
                     */
                    function Param(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Param indexed.
                     * @member {boolean} indexed
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @instance
                     */
                    Param.prototype.indexed = false;

                    /**
                     * Param name.
                     * @member {string} name
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @instance
                     */
                    Param.prototype.name = "";

                    /**
                     * Param type.
                     * @member {string} type
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @instance
                     */
                    Param.prototype.type = "";

                    /**
                     * Creates a new Param instance using the specified properties.
                     * @function create
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {protocol.SmartContract.ABI.Entry.IParam=} [properties] Properties to set
                     * @returns {protocol.SmartContract.ABI.Entry.Param} Param instance
                     */
                    Param.create = function create(properties) {
                        return new Param(properties);
                    };

                    /**
                     * Encodes the specified Param message. Does not implicitly {@link protocol.SmartContract.ABI.Entry.Param.verify|verify} messages.
                     * @function encode
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {protocol.SmartContract.ABI.Entry.IParam} message Param message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Param.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.indexed != null && Object.hasOwnProperty.call(message, "indexed"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.indexed);
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified Param message, length delimited. Does not implicitly {@link protocol.SmartContract.ABI.Entry.Param.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {protocol.SmartContract.ABI.Entry.IParam} message Param message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Param.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Param message from the specified reader or buffer.
                     * @function decode
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {protocol.SmartContract.ABI.Entry.Param} Param
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Param.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract.ABI.Entry.Param();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.indexed = reader.bool();
                                break;
                            case 2:
                                message.name = reader.string();
                                break;
                            case 3:
                                message.type = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Param message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {protocol.SmartContract.ABI.Entry.Param} Param
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Param.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Param message.
                     * @function verify
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Param.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.indexed != null && message.hasOwnProperty("indexed"))
                            if (typeof message.indexed !== "boolean")
                                return "indexed: boolean expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        return null;
                    };

                    /**
                     * Creates a Param message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {protocol.SmartContract.ABI.Entry.Param} Param
                     */
                    Param.fromObject = function fromObject(object) {
                        if (object instanceof $root.protocol.SmartContract.ABI.Entry.Param)
                            return object;
                        var message = new $root.protocol.SmartContract.ABI.Entry.Param();
                        if (object.indexed != null)
                            message.indexed = Boolean(object.indexed);
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.type != null)
                            message.type = String(object.type);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Param message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {protocol.SmartContract.ABI.Entry.Param} message Param
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Param.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.indexed = false;
                            object.name = "";
                            object.type = "";
                        }
                        if (message.indexed != null && message.hasOwnProperty("indexed"))
                            object.indexed = message.indexed;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        return object;
                    };

                    /**
                     * Converts this Param to JSON.
                     * @function toJSON
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Param.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Param;
                })();

                /**
                 * StateMutabilityType enum.
                 * @name protocol.SmartContract.ABI.Entry.StateMutabilityType
                 * @enum {number}
                 * @property {number} UnknownMutabilityType=0 UnknownMutabilityType value
                 * @property {number} Pure=1 Pure value
                 * @property {number} View=2 View value
                 * @property {number} Nonpayable=3 Nonpayable value
                 * @property {number} Payable=4 Payable value
                 */
                Entry.StateMutabilityType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UnknownMutabilityType"] = 0;
                    values[valuesById[1] = "Pure"] = 1;
                    values[valuesById[2] = "View"] = 2;
                    values[valuesById[3] = "Nonpayable"] = 3;
                    values[valuesById[4] = "Payable"] = 4;
                    return values;
                })();

                return Entry;
            })();

            return ABI;
        })();

        return SmartContract;
    })();

    protocol.InternalTransaction = (function() {

        /**
         * Properties of an InternalTransaction.
         * @memberof protocol
         * @interface IInternalTransaction
         * @property {Uint8Array|null} [hash] InternalTransaction hash
         * @property {Uint8Array|null} [callerAddress] InternalTransaction callerAddress
         * @property {Uint8Array|null} [transferToAddress] InternalTransaction transferToAddress
         * @property {Array.<protocol.InternalTransaction.ICallValueInfo>|null} [callValueInfo] InternalTransaction callValueInfo
         * @property {Uint8Array|null} [note] InternalTransaction note
         * @property {boolean|null} [rejected] InternalTransaction rejected
         */

        /**
         * Constructs a new InternalTransaction.
         * @memberof protocol
         * @classdesc Represents an InternalTransaction.
         * @implements IInternalTransaction
         * @constructor
         * @param {protocol.IInternalTransaction=} [properties] Properties to set
         */
        function InternalTransaction(properties) {
            this.callValueInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InternalTransaction hash.
         * @member {Uint8Array} hash
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.hash = $util.newBuffer([]);

        /**
         * InternalTransaction callerAddress.
         * @member {Uint8Array} callerAddress
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.callerAddress = $util.newBuffer([]);

        /**
         * InternalTransaction transferToAddress.
         * @member {Uint8Array} transferToAddress
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.transferToAddress = $util.newBuffer([]);

        /**
         * InternalTransaction callValueInfo.
         * @member {Array.<protocol.InternalTransaction.ICallValueInfo>} callValueInfo
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.callValueInfo = $util.emptyArray;

        /**
         * InternalTransaction note.
         * @member {Uint8Array} note
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.note = $util.newBuffer([]);

        /**
         * InternalTransaction rejected.
         * @member {boolean} rejected
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.rejected = false;

        /**
         * Creates a new InternalTransaction instance using the specified properties.
         * @function create
         * @memberof protocol.InternalTransaction
         * @static
         * @param {protocol.IInternalTransaction=} [properties] Properties to set
         * @returns {protocol.InternalTransaction} InternalTransaction instance
         */
        InternalTransaction.create = function create(properties) {
            return new InternalTransaction(properties);
        };

        /**
         * Encodes the specified InternalTransaction message. Does not implicitly {@link protocol.InternalTransaction.verify|verify} messages.
         * @function encode
         * @memberof protocol.InternalTransaction
         * @static
         * @param {protocol.IInternalTransaction} message InternalTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InternalTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            if (message.callerAddress != null && Object.hasOwnProperty.call(message, "callerAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.callerAddress);
            if (message.transferToAddress != null && Object.hasOwnProperty.call(message, "transferToAddress"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.transferToAddress);
            if (message.callValueInfo != null && message.callValueInfo.length)
                for (var i = 0; i < message.callValueInfo.length; ++i)
                    $root.protocol.InternalTransaction.CallValueInfo.encode(message.callValueInfo[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.note != null && Object.hasOwnProperty.call(message, "note"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.note);
            if (message.rejected != null && Object.hasOwnProperty.call(message, "rejected"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.rejected);
            return writer;
        };

        /**
         * Encodes the specified InternalTransaction message, length delimited. Does not implicitly {@link protocol.InternalTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.InternalTransaction
         * @static
         * @param {protocol.IInternalTransaction} message InternalTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InternalTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InternalTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.InternalTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.InternalTransaction} InternalTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InternalTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.InternalTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                case 2:
                    message.callerAddress = reader.bytes();
                    break;
                case 3:
                    message.transferToAddress = reader.bytes();
                    break;
                case 4:
                    if (!(message.callValueInfo && message.callValueInfo.length))
                        message.callValueInfo = [];
                    message.callValueInfo.push($root.protocol.InternalTransaction.CallValueInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.note = reader.bytes();
                    break;
                case 6:
                    message.rejected = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InternalTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.InternalTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.InternalTransaction} InternalTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InternalTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InternalTransaction message.
         * @function verify
         * @memberof protocol.InternalTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InternalTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.callerAddress != null && message.hasOwnProperty("callerAddress"))
                if (!(message.callerAddress && typeof message.callerAddress.length === "number" || $util.isString(message.callerAddress)))
                    return "callerAddress: buffer expected";
            if (message.transferToAddress != null && message.hasOwnProperty("transferToAddress"))
                if (!(message.transferToAddress && typeof message.transferToAddress.length === "number" || $util.isString(message.transferToAddress)))
                    return "transferToAddress: buffer expected";
            if (message.callValueInfo != null && message.hasOwnProperty("callValueInfo")) {
                if (!Array.isArray(message.callValueInfo))
                    return "callValueInfo: array expected";
                for (var i = 0; i < message.callValueInfo.length; ++i) {
                    var error = $root.protocol.InternalTransaction.CallValueInfo.verify(message.callValueInfo[i]);
                    if (error)
                        return "callValueInfo." + error;
                }
            }
            if (message.note != null && message.hasOwnProperty("note"))
                if (!(message.note && typeof message.note.length === "number" || $util.isString(message.note)))
                    return "note: buffer expected";
            if (message.rejected != null && message.hasOwnProperty("rejected"))
                if (typeof message.rejected !== "boolean")
                    return "rejected: boolean expected";
            return null;
        };

        /**
         * Creates an InternalTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.InternalTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.InternalTransaction} InternalTransaction
         */
        InternalTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.InternalTransaction)
                return object;
            var message = new $root.protocol.InternalTransaction();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.callerAddress != null)
                if (typeof object.callerAddress === "string")
                    $util.base64.decode(object.callerAddress, message.callerAddress = $util.newBuffer($util.base64.length(object.callerAddress)), 0);
                else if (object.callerAddress.length)
                    message.callerAddress = object.callerAddress;
            if (object.transferToAddress != null)
                if (typeof object.transferToAddress === "string")
                    $util.base64.decode(object.transferToAddress, message.transferToAddress = $util.newBuffer($util.base64.length(object.transferToAddress)), 0);
                else if (object.transferToAddress.length)
                    message.transferToAddress = object.transferToAddress;
            if (object.callValueInfo) {
                if (!Array.isArray(object.callValueInfo))
                    throw TypeError(".protocol.InternalTransaction.callValueInfo: array expected");
                message.callValueInfo = [];
                for (var i = 0; i < object.callValueInfo.length; ++i) {
                    if (typeof object.callValueInfo[i] !== "object")
                        throw TypeError(".protocol.InternalTransaction.callValueInfo: object expected");
                    message.callValueInfo[i] = $root.protocol.InternalTransaction.CallValueInfo.fromObject(object.callValueInfo[i]);
                }
            }
            if (object.note != null)
                if (typeof object.note === "string")
                    $util.base64.decode(object.note, message.note = $util.newBuffer($util.base64.length(object.note)), 0);
                else if (object.note.length)
                    message.note = object.note;
            if (object.rejected != null)
                message.rejected = Boolean(object.rejected);
            return message;
        };

        /**
         * Creates a plain object from an InternalTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.InternalTransaction
         * @static
         * @param {protocol.InternalTransaction} message InternalTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InternalTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.callValueInfo = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
                if (options.bytes === String)
                    object.callerAddress = "";
                else {
                    object.callerAddress = [];
                    if (options.bytes !== Array)
                        object.callerAddress = $util.newBuffer(object.callerAddress);
                }
                if (options.bytes === String)
                    object.transferToAddress = "";
                else {
                    object.transferToAddress = [];
                    if (options.bytes !== Array)
                        object.transferToAddress = $util.newBuffer(object.transferToAddress);
                }
                if (options.bytes === String)
                    object.note = "";
                else {
                    object.note = [];
                    if (options.bytes !== Array)
                        object.note = $util.newBuffer(object.note);
                }
                object.rejected = false;
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.callerAddress != null && message.hasOwnProperty("callerAddress"))
                object.callerAddress = options.bytes === String ? $util.base64.encode(message.callerAddress, 0, message.callerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.callerAddress) : message.callerAddress;
            if (message.transferToAddress != null && message.hasOwnProperty("transferToAddress"))
                object.transferToAddress = options.bytes === String ? $util.base64.encode(message.transferToAddress, 0, message.transferToAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.transferToAddress) : message.transferToAddress;
            if (message.callValueInfo && message.callValueInfo.length) {
                object.callValueInfo = [];
                for (var j = 0; j < message.callValueInfo.length; ++j)
                    object.callValueInfo[j] = $root.protocol.InternalTransaction.CallValueInfo.toObject(message.callValueInfo[j], options);
            }
            if (message.note != null && message.hasOwnProperty("note"))
                object.note = options.bytes === String ? $util.base64.encode(message.note, 0, message.note.length) : options.bytes === Array ? Array.prototype.slice.call(message.note) : message.note;
            if (message.rejected != null && message.hasOwnProperty("rejected"))
                object.rejected = message.rejected;
            return object;
        };

        /**
         * Converts this InternalTransaction to JSON.
         * @function toJSON
         * @memberof protocol.InternalTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InternalTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        InternalTransaction.CallValueInfo = (function() {

            /**
             * Properties of a CallValueInfo.
             * @memberof protocol.InternalTransaction
             * @interface ICallValueInfo
             * @property {number|Long|null} [callValue] CallValueInfo callValue
             * @property {string|null} [tokenId] CallValueInfo tokenId
             */

            /**
             * Constructs a new CallValueInfo.
             * @memberof protocol.InternalTransaction
             * @classdesc Represents a CallValueInfo.
             * @implements ICallValueInfo
             * @constructor
             * @param {protocol.InternalTransaction.ICallValueInfo=} [properties] Properties to set
             */
            function CallValueInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CallValueInfo callValue.
             * @member {number|Long} callValue
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @instance
             */
            CallValueInfo.prototype.callValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * CallValueInfo tokenId.
             * @member {string} tokenId
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @instance
             */
            CallValueInfo.prototype.tokenId = "";

            /**
             * Creates a new CallValueInfo instance using the specified properties.
             * @function create
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {protocol.InternalTransaction.ICallValueInfo=} [properties] Properties to set
             * @returns {protocol.InternalTransaction.CallValueInfo} CallValueInfo instance
             */
            CallValueInfo.create = function create(properties) {
                return new CallValueInfo(properties);
            };

            /**
             * Encodes the specified CallValueInfo message. Does not implicitly {@link protocol.InternalTransaction.CallValueInfo.verify|verify} messages.
             * @function encode
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {protocol.InternalTransaction.ICallValueInfo} message CallValueInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallValueInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.callValue != null && Object.hasOwnProperty.call(message, "callValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.callValue);
                if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tokenId);
                return writer;
            };

            /**
             * Encodes the specified CallValueInfo message, length delimited. Does not implicitly {@link protocol.InternalTransaction.CallValueInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {protocol.InternalTransaction.ICallValueInfo} message CallValueInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallValueInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CallValueInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.InternalTransaction.CallValueInfo} CallValueInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallValueInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.InternalTransaction.CallValueInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.callValue = reader.int64();
                        break;
                    case 2:
                        message.tokenId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CallValueInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.InternalTransaction.CallValueInfo} CallValueInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallValueInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CallValueInfo message.
             * @function verify
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CallValueInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.callValue != null && message.hasOwnProperty("callValue"))
                    if (!$util.isInteger(message.callValue) && !(message.callValue && $util.isInteger(message.callValue.low) && $util.isInteger(message.callValue.high)))
                        return "callValue: integer|Long expected";
                if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                    if (!$util.isString(message.tokenId))
                        return "tokenId: string expected";
                return null;
            };

            /**
             * Creates a CallValueInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.InternalTransaction.CallValueInfo} CallValueInfo
             */
            CallValueInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.InternalTransaction.CallValueInfo)
                    return object;
                var message = new $root.protocol.InternalTransaction.CallValueInfo();
                if (object.callValue != null)
                    if ($util.Long)
                        (message.callValue = $util.Long.fromValue(object.callValue)).unsigned = false;
                    else if (typeof object.callValue === "string")
                        message.callValue = parseInt(object.callValue, 10);
                    else if (typeof object.callValue === "number")
                        message.callValue = object.callValue;
                    else if (typeof object.callValue === "object")
                        message.callValue = new $util.LongBits(object.callValue.low >>> 0, object.callValue.high >>> 0).toNumber();
                if (object.tokenId != null)
                    message.tokenId = String(object.tokenId);
                return message;
            };

            /**
             * Creates a plain object from a CallValueInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {protocol.InternalTransaction.CallValueInfo} message CallValueInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CallValueInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.callValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callValue = options.longs === String ? "0" : 0;
                    object.tokenId = "";
                }
                if (message.callValue != null && message.hasOwnProperty("callValue"))
                    if (typeof message.callValue === "number")
                        object.callValue = options.longs === String ? String(message.callValue) : message.callValue;
                    else
                        object.callValue = options.longs === String ? $util.Long.prototype.toString.call(message.callValue) : options.longs === Number ? new $util.LongBits(message.callValue.low >>> 0, message.callValue.high >>> 0).toNumber() : message.callValue;
                if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                    object.tokenId = message.tokenId;
                return object;
            };

            /**
             * Converts this CallValueInfo to JSON.
             * @function toJSON
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CallValueInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CallValueInfo;
        })();

        return InternalTransaction;
    })();

    protocol.DelegatedResourceAccountIndex = (function() {

        /**
         * Properties of a DelegatedResourceAccountIndex.
         * @memberof protocol
         * @interface IDelegatedResourceAccountIndex
         * @property {Uint8Array|null} [account] DelegatedResourceAccountIndex account
         * @property {Array.<Uint8Array>|null} [fromAccounts] DelegatedResourceAccountIndex fromAccounts
         * @property {Array.<Uint8Array>|null} [toAccounts] DelegatedResourceAccountIndex toAccounts
         */

        /**
         * Constructs a new DelegatedResourceAccountIndex.
         * @memberof protocol
         * @classdesc Represents a DelegatedResourceAccountIndex.
         * @implements IDelegatedResourceAccountIndex
         * @constructor
         * @param {protocol.IDelegatedResourceAccountIndex=} [properties] Properties to set
         */
        function DelegatedResourceAccountIndex(properties) {
            this.fromAccounts = [];
            this.toAccounts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedResourceAccountIndex account.
         * @member {Uint8Array} account
         * @memberof protocol.DelegatedResourceAccountIndex
         * @instance
         */
        DelegatedResourceAccountIndex.prototype.account = $util.newBuffer([]);

        /**
         * DelegatedResourceAccountIndex fromAccounts.
         * @member {Array.<Uint8Array>} fromAccounts
         * @memberof protocol.DelegatedResourceAccountIndex
         * @instance
         */
        DelegatedResourceAccountIndex.prototype.fromAccounts = $util.emptyArray;

        /**
         * DelegatedResourceAccountIndex toAccounts.
         * @member {Array.<Uint8Array>} toAccounts
         * @memberof protocol.DelegatedResourceAccountIndex
         * @instance
         */
        DelegatedResourceAccountIndex.prototype.toAccounts = $util.emptyArray;

        /**
         * Creates a new DelegatedResourceAccountIndex instance using the specified properties.
         * @function create
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {protocol.IDelegatedResourceAccountIndex=} [properties] Properties to set
         * @returns {protocol.DelegatedResourceAccountIndex} DelegatedResourceAccountIndex instance
         */
        DelegatedResourceAccountIndex.create = function create(properties) {
            return new DelegatedResourceAccountIndex(properties);
        };

        /**
         * Encodes the specified DelegatedResourceAccountIndex message. Does not implicitly {@link protocol.DelegatedResourceAccountIndex.verify|verify} messages.
         * @function encode
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {protocol.IDelegatedResourceAccountIndex} message DelegatedResourceAccountIndex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedResourceAccountIndex.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account);
            if (message.fromAccounts != null && message.fromAccounts.length)
                for (var i = 0; i < message.fromAccounts.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.fromAccounts[i]);
            if (message.toAccounts != null && message.toAccounts.length)
                for (var i = 0; i < message.toAccounts.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.toAccounts[i]);
            return writer;
        };

        /**
         * Encodes the specified DelegatedResourceAccountIndex message, length delimited. Does not implicitly {@link protocol.DelegatedResourceAccountIndex.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {protocol.IDelegatedResourceAccountIndex} message DelegatedResourceAccountIndex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedResourceAccountIndex.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedResourceAccountIndex message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.DelegatedResourceAccountIndex} DelegatedResourceAccountIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedResourceAccountIndex.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DelegatedResourceAccountIndex();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.bytes();
                    break;
                case 2:
                    if (!(message.fromAccounts && message.fromAccounts.length))
                        message.fromAccounts = [];
                    message.fromAccounts.push(reader.bytes());
                    break;
                case 3:
                    if (!(message.toAccounts && message.toAccounts.length))
                        message.toAccounts = [];
                    message.toAccounts.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedResourceAccountIndex message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.DelegatedResourceAccountIndex} DelegatedResourceAccountIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedResourceAccountIndex.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedResourceAccountIndex message.
         * @function verify
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedResourceAccountIndex.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                    return "account: buffer expected";
            if (message.fromAccounts != null && message.hasOwnProperty("fromAccounts")) {
                if (!Array.isArray(message.fromAccounts))
                    return "fromAccounts: array expected";
                for (var i = 0; i < message.fromAccounts.length; ++i)
                    if (!(message.fromAccounts[i] && typeof message.fromAccounts[i].length === "number" || $util.isString(message.fromAccounts[i])))
                        return "fromAccounts: buffer[] expected";
            }
            if (message.toAccounts != null && message.hasOwnProperty("toAccounts")) {
                if (!Array.isArray(message.toAccounts))
                    return "toAccounts: array expected";
                for (var i = 0; i < message.toAccounts.length; ++i)
                    if (!(message.toAccounts[i] && typeof message.toAccounts[i].length === "number" || $util.isString(message.toAccounts[i])))
                        return "toAccounts: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a DelegatedResourceAccountIndex message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.DelegatedResourceAccountIndex} DelegatedResourceAccountIndex
         */
        DelegatedResourceAccountIndex.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DelegatedResourceAccountIndex)
                return object;
            var message = new $root.protocol.DelegatedResourceAccountIndex();
            if (object.account != null)
                if (typeof object.account === "string")
                    $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                else if (object.account.length)
                    message.account = object.account;
            if (object.fromAccounts) {
                if (!Array.isArray(object.fromAccounts))
                    throw TypeError(".protocol.DelegatedResourceAccountIndex.fromAccounts: array expected");
                message.fromAccounts = [];
                for (var i = 0; i < object.fromAccounts.length; ++i)
                    if (typeof object.fromAccounts[i] === "string")
                        $util.base64.decode(object.fromAccounts[i], message.fromAccounts[i] = $util.newBuffer($util.base64.length(object.fromAccounts[i])), 0);
                    else if (object.fromAccounts[i].length)
                        message.fromAccounts[i] = object.fromAccounts[i];
            }
            if (object.toAccounts) {
                if (!Array.isArray(object.toAccounts))
                    throw TypeError(".protocol.DelegatedResourceAccountIndex.toAccounts: array expected");
                message.toAccounts = [];
                for (var i = 0; i < object.toAccounts.length; ++i)
                    if (typeof object.toAccounts[i] === "string")
                        $util.base64.decode(object.toAccounts[i], message.toAccounts[i] = $util.newBuffer($util.base64.length(object.toAccounts[i])), 0);
                    else if (object.toAccounts[i].length)
                        message.toAccounts[i] = object.toAccounts[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a DelegatedResourceAccountIndex message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {protocol.DelegatedResourceAccountIndex} message DelegatedResourceAccountIndex
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedResourceAccountIndex.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fromAccounts = [];
                object.toAccounts = [];
            }
            if (options.defaults)
                if (options.bytes === String)
                    object.account = "";
                else {
                    object.account = [];
                    if (options.bytes !== Array)
                        object.account = $util.newBuffer(object.account);
                }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
            if (message.fromAccounts && message.fromAccounts.length) {
                object.fromAccounts = [];
                for (var j = 0; j < message.fromAccounts.length; ++j)
                    object.fromAccounts[j] = options.bytes === String ? $util.base64.encode(message.fromAccounts[j], 0, message.fromAccounts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.fromAccounts[j]) : message.fromAccounts[j];
            }
            if (message.toAccounts && message.toAccounts.length) {
                object.toAccounts = [];
                for (var j = 0; j < message.toAccounts.length; ++j)
                    object.toAccounts[j] = options.bytes === String ? $util.base64.encode(message.toAccounts[j], 0, message.toAccounts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.toAccounts[j]) : message.toAccounts[j];
            }
            return object;
        };

        /**
         * Converts this DelegatedResourceAccountIndex to JSON.
         * @function toJSON
         * @memberof protocol.DelegatedResourceAccountIndex
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedResourceAccountIndex.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedResourceAccountIndex;
    })();

    protocol.NodeInfo = (function() {

        /**
         * Properties of a NodeInfo.
         * @memberof protocol
         * @interface INodeInfo
         * @property {number|Long|null} [beginSyncNum] NodeInfo beginSyncNum
         * @property {string|null} [block] NodeInfo block
         * @property {string|null} [solidityBlock] NodeInfo solidityBlock
         * @property {number|null} [currentConnectCount] NodeInfo currentConnectCount
         * @property {number|null} [activeConnectCount] NodeInfo activeConnectCount
         * @property {number|null} [passiveConnectCount] NodeInfo passiveConnectCount
         * @property {number|Long|null} [totalFlow] NodeInfo totalFlow
         * @property {Array.<protocol.NodeInfo.IPeerInfo>|null} [peerInfoList] NodeInfo peerInfoList
         * @property {protocol.NodeInfo.IConfigNodeInfo|null} [configNodeInfo] NodeInfo configNodeInfo
         * @property {protocol.NodeInfo.IMachineInfo|null} [machineInfo] NodeInfo machineInfo
         * @property {Object.<string,string>|null} [cheatWitnessInfoMap] NodeInfo cheatWitnessInfoMap
         */

        /**
         * Constructs a new NodeInfo.
         * @memberof protocol
         * @classdesc Represents a NodeInfo.
         * @implements INodeInfo
         * @constructor
         * @param {protocol.INodeInfo=} [properties] Properties to set
         */
        function NodeInfo(properties) {
            this.peerInfoList = [];
            this.cheatWitnessInfoMap = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeInfo beginSyncNum.
         * @member {number|Long} beginSyncNum
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.beginSyncNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NodeInfo block.
         * @member {string} block
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.block = "";

        /**
         * NodeInfo solidityBlock.
         * @member {string} solidityBlock
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.solidityBlock = "";

        /**
         * NodeInfo currentConnectCount.
         * @member {number} currentConnectCount
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.currentConnectCount = 0;

        /**
         * NodeInfo activeConnectCount.
         * @member {number} activeConnectCount
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.activeConnectCount = 0;

        /**
         * NodeInfo passiveConnectCount.
         * @member {number} passiveConnectCount
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.passiveConnectCount = 0;

        /**
         * NodeInfo totalFlow.
         * @member {number|Long} totalFlow
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.totalFlow = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NodeInfo peerInfoList.
         * @member {Array.<protocol.NodeInfo.IPeerInfo>} peerInfoList
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.peerInfoList = $util.emptyArray;

        /**
         * NodeInfo configNodeInfo.
         * @member {protocol.NodeInfo.IConfigNodeInfo|null|undefined} configNodeInfo
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.configNodeInfo = null;

        /**
         * NodeInfo machineInfo.
         * @member {protocol.NodeInfo.IMachineInfo|null|undefined} machineInfo
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.machineInfo = null;

        /**
         * NodeInfo cheatWitnessInfoMap.
         * @member {Object.<string,string>} cheatWitnessInfoMap
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.cheatWitnessInfoMap = $util.emptyObject;

        /**
         * Creates a new NodeInfo instance using the specified properties.
         * @function create
         * @memberof protocol.NodeInfo
         * @static
         * @param {protocol.INodeInfo=} [properties] Properties to set
         * @returns {protocol.NodeInfo} NodeInfo instance
         */
        NodeInfo.create = function create(properties) {
            return new NodeInfo(properties);
        };

        /**
         * Encodes the specified NodeInfo message. Does not implicitly {@link protocol.NodeInfo.verify|verify} messages.
         * @function encode
         * @memberof protocol.NodeInfo
         * @static
         * @param {protocol.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.beginSyncNum != null && Object.hasOwnProperty.call(message, "beginSyncNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.beginSyncNum);
            if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.block);
            if (message.solidityBlock != null && Object.hasOwnProperty.call(message, "solidityBlock"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.solidityBlock);
            if (message.currentConnectCount != null && Object.hasOwnProperty.call(message, "currentConnectCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.currentConnectCount);
            if (message.activeConnectCount != null && Object.hasOwnProperty.call(message, "activeConnectCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.activeConnectCount);
            if (message.passiveConnectCount != null && Object.hasOwnProperty.call(message, "passiveConnectCount"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.passiveConnectCount);
            if (message.totalFlow != null && Object.hasOwnProperty.call(message, "totalFlow"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.totalFlow);
            if (message.peerInfoList != null && message.peerInfoList.length)
                for (var i = 0; i < message.peerInfoList.length; ++i)
                    $root.protocol.NodeInfo.PeerInfo.encode(message.peerInfoList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.configNodeInfo != null && Object.hasOwnProperty.call(message, "configNodeInfo"))
                $root.protocol.NodeInfo.ConfigNodeInfo.encode(message.configNodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.machineInfo != null && Object.hasOwnProperty.call(message, "machineInfo"))
                $root.protocol.NodeInfo.MachineInfo.encode(message.machineInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.cheatWitnessInfoMap != null && Object.hasOwnProperty.call(message, "cheatWitnessInfoMap"))
                for (var keys = Object.keys(message.cheatWitnessInfoMap), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.cheatWitnessInfoMap[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NodeInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.NodeInfo
         * @static
         * @param {protocol.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.beginSyncNum = reader.int64();
                    break;
                case 2:
                    message.block = reader.string();
                    break;
                case 3:
                    message.solidityBlock = reader.string();
                    break;
                case 4:
                    message.currentConnectCount = reader.int32();
                    break;
                case 5:
                    message.activeConnectCount = reader.int32();
                    break;
                case 6:
                    message.passiveConnectCount = reader.int32();
                    break;
                case 7:
                    message.totalFlow = reader.int64();
                    break;
                case 8:
                    if (!(message.peerInfoList && message.peerInfoList.length))
                        message.peerInfoList = [];
                    message.peerInfoList.push($root.protocol.NodeInfo.PeerInfo.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.configNodeInfo = $root.protocol.NodeInfo.ConfigNodeInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.machineInfo = $root.protocol.NodeInfo.MachineInfo.decode(reader, reader.uint32());
                    break;
                case 11:
                    reader.skip().pos++;
                    if (message.cheatWitnessInfoMap === $util.emptyObject)
                        message.cheatWitnessInfoMap = {};
                    key = reader.string();
                    reader.pos++;
                    message.cheatWitnessInfoMap[key] = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeInfo message.
         * @function verify
         * @memberof protocol.NodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.beginSyncNum != null && message.hasOwnProperty("beginSyncNum"))
                if (!$util.isInteger(message.beginSyncNum) && !(message.beginSyncNum && $util.isInteger(message.beginSyncNum.low) && $util.isInteger(message.beginSyncNum.high)))
                    return "beginSyncNum: integer|Long expected";
            if (message.block != null && message.hasOwnProperty("block"))
                if (!$util.isString(message.block))
                    return "block: string expected";
            if (message.solidityBlock != null && message.hasOwnProperty("solidityBlock"))
                if (!$util.isString(message.solidityBlock))
                    return "solidityBlock: string expected";
            if (message.currentConnectCount != null && message.hasOwnProperty("currentConnectCount"))
                if (!$util.isInteger(message.currentConnectCount))
                    return "currentConnectCount: integer expected";
            if (message.activeConnectCount != null && message.hasOwnProperty("activeConnectCount"))
                if (!$util.isInteger(message.activeConnectCount))
                    return "activeConnectCount: integer expected";
            if (message.passiveConnectCount != null && message.hasOwnProperty("passiveConnectCount"))
                if (!$util.isInteger(message.passiveConnectCount))
                    return "passiveConnectCount: integer expected";
            if (message.totalFlow != null && message.hasOwnProperty("totalFlow"))
                if (!$util.isInteger(message.totalFlow) && !(message.totalFlow && $util.isInteger(message.totalFlow.low) && $util.isInteger(message.totalFlow.high)))
                    return "totalFlow: integer|Long expected";
            if (message.peerInfoList != null && message.hasOwnProperty("peerInfoList")) {
                if (!Array.isArray(message.peerInfoList))
                    return "peerInfoList: array expected";
                for (var i = 0; i < message.peerInfoList.length; ++i) {
                    var error = $root.protocol.NodeInfo.PeerInfo.verify(message.peerInfoList[i]);
                    if (error)
                        return "peerInfoList." + error;
                }
            }
            if (message.configNodeInfo != null && message.hasOwnProperty("configNodeInfo")) {
                var error = $root.protocol.NodeInfo.ConfigNodeInfo.verify(message.configNodeInfo);
                if (error)
                    return "configNodeInfo." + error;
            }
            if (message.machineInfo != null && message.hasOwnProperty("machineInfo")) {
                var error = $root.protocol.NodeInfo.MachineInfo.verify(message.machineInfo);
                if (error)
                    return "machineInfo." + error;
            }
            if (message.cheatWitnessInfoMap != null && message.hasOwnProperty("cheatWitnessInfoMap")) {
                if (!$util.isObject(message.cheatWitnessInfoMap))
                    return "cheatWitnessInfoMap: object expected";
                var key = Object.keys(message.cheatWitnessInfoMap);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.cheatWitnessInfoMap[key[i]]))
                        return "cheatWitnessInfoMap: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a NodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.NodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.NodeInfo} NodeInfo
         */
        NodeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.NodeInfo)
                return object;
            var message = new $root.protocol.NodeInfo();
            if (object.beginSyncNum != null)
                if ($util.Long)
                    (message.beginSyncNum = $util.Long.fromValue(object.beginSyncNum)).unsigned = false;
                else if (typeof object.beginSyncNum === "string")
                    message.beginSyncNum = parseInt(object.beginSyncNum, 10);
                else if (typeof object.beginSyncNum === "number")
                    message.beginSyncNum = object.beginSyncNum;
                else if (typeof object.beginSyncNum === "object")
                    message.beginSyncNum = new $util.LongBits(object.beginSyncNum.low >>> 0, object.beginSyncNum.high >>> 0).toNumber();
            if (object.block != null)
                message.block = String(object.block);
            if (object.solidityBlock != null)
                message.solidityBlock = String(object.solidityBlock);
            if (object.currentConnectCount != null)
                message.currentConnectCount = object.currentConnectCount | 0;
            if (object.activeConnectCount != null)
                message.activeConnectCount = object.activeConnectCount | 0;
            if (object.passiveConnectCount != null)
                message.passiveConnectCount = object.passiveConnectCount | 0;
            if (object.totalFlow != null)
                if ($util.Long)
                    (message.totalFlow = $util.Long.fromValue(object.totalFlow)).unsigned = false;
                else if (typeof object.totalFlow === "string")
                    message.totalFlow = parseInt(object.totalFlow, 10);
                else if (typeof object.totalFlow === "number")
                    message.totalFlow = object.totalFlow;
                else if (typeof object.totalFlow === "object")
                    message.totalFlow = new $util.LongBits(object.totalFlow.low >>> 0, object.totalFlow.high >>> 0).toNumber();
            if (object.peerInfoList) {
                if (!Array.isArray(object.peerInfoList))
                    throw TypeError(".protocol.NodeInfo.peerInfoList: array expected");
                message.peerInfoList = [];
                for (var i = 0; i < object.peerInfoList.length; ++i) {
                    if (typeof object.peerInfoList[i] !== "object")
                        throw TypeError(".protocol.NodeInfo.peerInfoList: object expected");
                    message.peerInfoList[i] = $root.protocol.NodeInfo.PeerInfo.fromObject(object.peerInfoList[i]);
                }
            }
            if (object.configNodeInfo != null) {
                if (typeof object.configNodeInfo !== "object")
                    throw TypeError(".protocol.NodeInfo.configNodeInfo: object expected");
                message.configNodeInfo = $root.protocol.NodeInfo.ConfigNodeInfo.fromObject(object.configNodeInfo);
            }
            if (object.machineInfo != null) {
                if (typeof object.machineInfo !== "object")
                    throw TypeError(".protocol.NodeInfo.machineInfo: object expected");
                message.machineInfo = $root.protocol.NodeInfo.MachineInfo.fromObject(object.machineInfo);
            }
            if (object.cheatWitnessInfoMap) {
                if (typeof object.cheatWitnessInfoMap !== "object")
                    throw TypeError(".protocol.NodeInfo.cheatWitnessInfoMap: object expected");
                message.cheatWitnessInfoMap = {};
                for (var keys = Object.keys(object.cheatWitnessInfoMap), i = 0; i < keys.length; ++i)
                    message.cheatWitnessInfoMap[keys[i]] = String(object.cheatWitnessInfoMap[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.NodeInfo
         * @static
         * @param {protocol.NodeInfo} message NodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.peerInfoList = [];
            if (options.objects || options.defaults)
                object.cheatWitnessInfoMap = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.beginSyncNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.beginSyncNum = options.longs === String ? "0" : 0;
                object.block = "";
                object.solidityBlock = "";
                object.currentConnectCount = 0;
                object.activeConnectCount = 0;
                object.passiveConnectCount = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalFlow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFlow = options.longs === String ? "0" : 0;
                object.configNodeInfo = null;
                object.machineInfo = null;
            }
            if (message.beginSyncNum != null && message.hasOwnProperty("beginSyncNum"))
                if (typeof message.beginSyncNum === "number")
                    object.beginSyncNum = options.longs === String ? String(message.beginSyncNum) : message.beginSyncNum;
                else
                    object.beginSyncNum = options.longs === String ? $util.Long.prototype.toString.call(message.beginSyncNum) : options.longs === Number ? new $util.LongBits(message.beginSyncNum.low >>> 0, message.beginSyncNum.high >>> 0).toNumber() : message.beginSyncNum;
            if (message.block != null && message.hasOwnProperty("block"))
                object.block = message.block;
            if (message.solidityBlock != null && message.hasOwnProperty("solidityBlock"))
                object.solidityBlock = message.solidityBlock;
            if (message.currentConnectCount != null && message.hasOwnProperty("currentConnectCount"))
                object.currentConnectCount = message.currentConnectCount;
            if (message.activeConnectCount != null && message.hasOwnProperty("activeConnectCount"))
                object.activeConnectCount = message.activeConnectCount;
            if (message.passiveConnectCount != null && message.hasOwnProperty("passiveConnectCount"))
                object.passiveConnectCount = message.passiveConnectCount;
            if (message.totalFlow != null && message.hasOwnProperty("totalFlow"))
                if (typeof message.totalFlow === "number")
                    object.totalFlow = options.longs === String ? String(message.totalFlow) : message.totalFlow;
                else
                    object.totalFlow = options.longs === String ? $util.Long.prototype.toString.call(message.totalFlow) : options.longs === Number ? new $util.LongBits(message.totalFlow.low >>> 0, message.totalFlow.high >>> 0).toNumber() : message.totalFlow;
            if (message.peerInfoList && message.peerInfoList.length) {
                object.peerInfoList = [];
                for (var j = 0; j < message.peerInfoList.length; ++j)
                    object.peerInfoList[j] = $root.protocol.NodeInfo.PeerInfo.toObject(message.peerInfoList[j], options);
            }
            if (message.configNodeInfo != null && message.hasOwnProperty("configNodeInfo"))
                object.configNodeInfo = $root.protocol.NodeInfo.ConfigNodeInfo.toObject(message.configNodeInfo, options);
            if (message.machineInfo != null && message.hasOwnProperty("machineInfo"))
                object.machineInfo = $root.protocol.NodeInfo.MachineInfo.toObject(message.machineInfo, options);
            var keys2;
            if (message.cheatWitnessInfoMap && (keys2 = Object.keys(message.cheatWitnessInfoMap)).length) {
                object.cheatWitnessInfoMap = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.cheatWitnessInfoMap[keys2[j]] = message.cheatWitnessInfoMap[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this NodeInfo to JSON.
         * @function toJSON
         * @memberof protocol.NodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        NodeInfo.PeerInfo = (function() {

            /**
             * Properties of a PeerInfo.
             * @memberof protocol.NodeInfo
             * @interface IPeerInfo
             * @property {string|null} [lastSyncBlock] PeerInfo lastSyncBlock
             * @property {number|Long|null} [remainNum] PeerInfo remainNum
             * @property {number|Long|null} [lastBlockUpdateTime] PeerInfo lastBlockUpdateTime
             * @property {boolean|null} [syncFlag] PeerInfo syncFlag
             * @property {number|Long|null} [headBlockTimeWeBothHave] PeerInfo headBlockTimeWeBothHave
             * @property {boolean|null} [needSyncFromPeer] PeerInfo needSyncFromPeer
             * @property {boolean|null} [needSyncFromUs] PeerInfo needSyncFromUs
             * @property {string|null} [host] PeerInfo host
             * @property {number|null} [port] PeerInfo port
             * @property {string|null} [nodeId] PeerInfo nodeId
             * @property {number|Long|null} [connectTime] PeerInfo connectTime
             * @property {number|null} [avgLatency] PeerInfo avgLatency
             * @property {number|null} [syncToFetchSize] PeerInfo syncToFetchSize
             * @property {number|Long|null} [syncToFetchSizePeekNum] PeerInfo syncToFetchSizePeekNum
             * @property {number|null} [syncBlockRequestedSize] PeerInfo syncBlockRequestedSize
             * @property {number|Long|null} [unFetchSynNum] PeerInfo unFetchSynNum
             * @property {number|null} [blockInPorcSize] PeerInfo blockInPorcSize
             * @property {string|null} [headBlockWeBothHave] PeerInfo headBlockWeBothHave
             * @property {boolean|null} [isActive] PeerInfo isActive
             * @property {number|null} [score] PeerInfo score
             * @property {number|null} [nodeCount] PeerInfo nodeCount
             * @property {number|Long|null} [inFlow] PeerInfo inFlow
             * @property {number|null} [disconnectTimes] PeerInfo disconnectTimes
             * @property {string|null} [localDisconnectReason] PeerInfo localDisconnectReason
             * @property {string|null} [remoteDisconnectReason] PeerInfo remoteDisconnectReason
             */

            /**
             * Constructs a new PeerInfo.
             * @memberof protocol.NodeInfo
             * @classdesc Represents a PeerInfo.
             * @implements IPeerInfo
             * @constructor
             * @param {protocol.NodeInfo.IPeerInfo=} [properties] Properties to set
             */
            function PeerInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PeerInfo lastSyncBlock.
             * @member {string} lastSyncBlock
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.lastSyncBlock = "";

            /**
             * PeerInfo remainNum.
             * @member {number|Long} remainNum
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.remainNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo lastBlockUpdateTime.
             * @member {number|Long} lastBlockUpdateTime
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.lastBlockUpdateTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo syncFlag.
             * @member {boolean} syncFlag
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.syncFlag = false;

            /**
             * PeerInfo headBlockTimeWeBothHave.
             * @member {number|Long} headBlockTimeWeBothHave
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.headBlockTimeWeBothHave = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo needSyncFromPeer.
             * @member {boolean} needSyncFromPeer
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.needSyncFromPeer = false;

            /**
             * PeerInfo needSyncFromUs.
             * @member {boolean} needSyncFromUs
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.needSyncFromUs = false;

            /**
             * PeerInfo host.
             * @member {string} host
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.host = "";

            /**
             * PeerInfo port.
             * @member {number} port
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.port = 0;

            /**
             * PeerInfo nodeId.
             * @member {string} nodeId
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.nodeId = "";

            /**
             * PeerInfo connectTime.
             * @member {number|Long} connectTime
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.connectTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo avgLatency.
             * @member {number} avgLatency
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.avgLatency = 0;

            /**
             * PeerInfo syncToFetchSize.
             * @member {number} syncToFetchSize
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.syncToFetchSize = 0;

            /**
             * PeerInfo syncToFetchSizePeekNum.
             * @member {number|Long} syncToFetchSizePeekNum
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.syncToFetchSizePeekNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo syncBlockRequestedSize.
             * @member {number} syncBlockRequestedSize
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.syncBlockRequestedSize = 0;

            /**
             * PeerInfo unFetchSynNum.
             * @member {number|Long} unFetchSynNum
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.unFetchSynNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo blockInPorcSize.
             * @member {number} blockInPorcSize
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.blockInPorcSize = 0;

            /**
             * PeerInfo headBlockWeBothHave.
             * @member {string} headBlockWeBothHave
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.headBlockWeBothHave = "";

            /**
             * PeerInfo isActive.
             * @member {boolean} isActive
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.isActive = false;

            /**
             * PeerInfo score.
             * @member {number} score
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.score = 0;

            /**
             * PeerInfo nodeCount.
             * @member {number} nodeCount
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.nodeCount = 0;

            /**
             * PeerInfo inFlow.
             * @member {number|Long} inFlow
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.inFlow = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo disconnectTimes.
             * @member {number} disconnectTimes
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.disconnectTimes = 0;

            /**
             * PeerInfo localDisconnectReason.
             * @member {string} localDisconnectReason
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.localDisconnectReason = "";

            /**
             * PeerInfo remoteDisconnectReason.
             * @member {string} remoteDisconnectReason
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.remoteDisconnectReason = "";

            /**
             * Creates a new PeerInfo instance using the specified properties.
             * @function create
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {protocol.NodeInfo.IPeerInfo=} [properties] Properties to set
             * @returns {protocol.NodeInfo.PeerInfo} PeerInfo instance
             */
            PeerInfo.create = function create(properties) {
                return new PeerInfo(properties);
            };

            /**
             * Encodes the specified PeerInfo message. Does not implicitly {@link protocol.NodeInfo.PeerInfo.verify|verify} messages.
             * @function encode
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {protocol.NodeInfo.IPeerInfo} message PeerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lastSyncBlock != null && Object.hasOwnProperty.call(message, "lastSyncBlock"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.lastSyncBlock);
                if (message.remainNum != null && Object.hasOwnProperty.call(message, "remainNum"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.remainNum);
                if (message.lastBlockUpdateTime != null && Object.hasOwnProperty.call(message, "lastBlockUpdateTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastBlockUpdateTime);
                if (message.syncFlag != null && Object.hasOwnProperty.call(message, "syncFlag"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.syncFlag);
                if (message.headBlockTimeWeBothHave != null && Object.hasOwnProperty.call(message, "headBlockTimeWeBothHave"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.headBlockTimeWeBothHave);
                if (message.needSyncFromPeer != null && Object.hasOwnProperty.call(message, "needSyncFromPeer"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.needSyncFromPeer);
                if (message.needSyncFromUs != null && Object.hasOwnProperty.call(message, "needSyncFromUs"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.needSyncFromUs);
                if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.host);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.port);
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.nodeId);
                if (message.connectTime != null && Object.hasOwnProperty.call(message, "connectTime"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int64(message.connectTime);
                if (message.avgLatency != null && Object.hasOwnProperty.call(message, "avgLatency"))
                    writer.uint32(/* id 12, wireType 1 =*/97).double(message.avgLatency);
                if (message.syncToFetchSize != null && Object.hasOwnProperty.call(message, "syncToFetchSize"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.syncToFetchSize);
                if (message.syncToFetchSizePeekNum != null && Object.hasOwnProperty.call(message, "syncToFetchSizePeekNum"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.syncToFetchSizePeekNum);
                if (message.syncBlockRequestedSize != null && Object.hasOwnProperty.call(message, "syncBlockRequestedSize"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.syncBlockRequestedSize);
                if (message.unFetchSynNum != null && Object.hasOwnProperty.call(message, "unFetchSynNum"))
                    writer.uint32(/* id 16, wireType 0 =*/128).int64(message.unFetchSynNum);
                if (message.blockInPorcSize != null && Object.hasOwnProperty.call(message, "blockInPorcSize"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int32(message.blockInPorcSize);
                if (message.headBlockWeBothHave != null && Object.hasOwnProperty.call(message, "headBlockWeBothHave"))
                    writer.uint32(/* id 18, wireType 2 =*/146).string(message.headBlockWeBothHave);
                if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                    writer.uint32(/* id 19, wireType 0 =*/152).bool(message.isActive);
                if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                    writer.uint32(/* id 20, wireType 0 =*/160).int32(message.score);
                if (message.nodeCount != null && Object.hasOwnProperty.call(message, "nodeCount"))
                    writer.uint32(/* id 21, wireType 0 =*/168).int32(message.nodeCount);
                if (message.inFlow != null && Object.hasOwnProperty.call(message, "inFlow"))
                    writer.uint32(/* id 22, wireType 0 =*/176).int64(message.inFlow);
                if (message.disconnectTimes != null && Object.hasOwnProperty.call(message, "disconnectTimes"))
                    writer.uint32(/* id 23, wireType 0 =*/184).int32(message.disconnectTimes);
                if (message.localDisconnectReason != null && Object.hasOwnProperty.call(message, "localDisconnectReason"))
                    writer.uint32(/* id 24, wireType 2 =*/194).string(message.localDisconnectReason);
                if (message.remoteDisconnectReason != null && Object.hasOwnProperty.call(message, "remoteDisconnectReason"))
                    writer.uint32(/* id 25, wireType 2 =*/202).string(message.remoteDisconnectReason);
                return writer;
            };

            /**
             * Encodes the specified PeerInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.PeerInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {protocol.NodeInfo.IPeerInfo} message PeerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PeerInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.NodeInfo.PeerInfo} PeerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.PeerInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lastSyncBlock = reader.string();
                        break;
                    case 2:
                        message.remainNum = reader.int64();
                        break;
                    case 3:
                        message.lastBlockUpdateTime = reader.int64();
                        break;
                    case 4:
                        message.syncFlag = reader.bool();
                        break;
                    case 5:
                        message.headBlockTimeWeBothHave = reader.int64();
                        break;
                    case 6:
                        message.needSyncFromPeer = reader.bool();
                        break;
                    case 7:
                        message.needSyncFromUs = reader.bool();
                        break;
                    case 8:
                        message.host = reader.string();
                        break;
                    case 9:
                        message.port = reader.int32();
                        break;
                    case 10:
                        message.nodeId = reader.string();
                        break;
                    case 11:
                        message.connectTime = reader.int64();
                        break;
                    case 12:
                        message.avgLatency = reader.double();
                        break;
                    case 13:
                        message.syncToFetchSize = reader.int32();
                        break;
                    case 14:
                        message.syncToFetchSizePeekNum = reader.int64();
                        break;
                    case 15:
                        message.syncBlockRequestedSize = reader.int32();
                        break;
                    case 16:
                        message.unFetchSynNum = reader.int64();
                        break;
                    case 17:
                        message.blockInPorcSize = reader.int32();
                        break;
                    case 18:
                        message.headBlockWeBothHave = reader.string();
                        break;
                    case 19:
                        message.isActive = reader.bool();
                        break;
                    case 20:
                        message.score = reader.int32();
                        break;
                    case 21:
                        message.nodeCount = reader.int32();
                        break;
                    case 22:
                        message.inFlow = reader.int64();
                        break;
                    case 23:
                        message.disconnectTimes = reader.int32();
                        break;
                    case 24:
                        message.localDisconnectReason = reader.string();
                        break;
                    case 25:
                        message.remoteDisconnectReason = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PeerInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.NodeInfo.PeerInfo} PeerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PeerInfo message.
             * @function verify
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lastSyncBlock != null && message.hasOwnProperty("lastSyncBlock"))
                    if (!$util.isString(message.lastSyncBlock))
                        return "lastSyncBlock: string expected";
                if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                    if (!$util.isInteger(message.remainNum) && !(message.remainNum && $util.isInteger(message.remainNum.low) && $util.isInteger(message.remainNum.high)))
                        return "remainNum: integer|Long expected";
                if (message.lastBlockUpdateTime != null && message.hasOwnProperty("lastBlockUpdateTime"))
                    if (!$util.isInteger(message.lastBlockUpdateTime) && !(message.lastBlockUpdateTime && $util.isInteger(message.lastBlockUpdateTime.low) && $util.isInteger(message.lastBlockUpdateTime.high)))
                        return "lastBlockUpdateTime: integer|Long expected";
                if (message.syncFlag != null && message.hasOwnProperty("syncFlag"))
                    if (typeof message.syncFlag !== "boolean")
                        return "syncFlag: boolean expected";
                if (message.headBlockTimeWeBothHave != null && message.hasOwnProperty("headBlockTimeWeBothHave"))
                    if (!$util.isInteger(message.headBlockTimeWeBothHave) && !(message.headBlockTimeWeBothHave && $util.isInteger(message.headBlockTimeWeBothHave.low) && $util.isInteger(message.headBlockTimeWeBothHave.high)))
                        return "headBlockTimeWeBothHave: integer|Long expected";
                if (message.needSyncFromPeer != null && message.hasOwnProperty("needSyncFromPeer"))
                    if (typeof message.needSyncFromPeer !== "boolean")
                        return "needSyncFromPeer: boolean expected";
                if (message.needSyncFromUs != null && message.hasOwnProperty("needSyncFromUs"))
                    if (typeof message.needSyncFromUs !== "boolean")
                        return "needSyncFromUs: boolean expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.connectTime != null && message.hasOwnProperty("connectTime"))
                    if (!$util.isInteger(message.connectTime) && !(message.connectTime && $util.isInteger(message.connectTime.low) && $util.isInteger(message.connectTime.high)))
                        return "connectTime: integer|Long expected";
                if (message.avgLatency != null && message.hasOwnProperty("avgLatency"))
                    if (typeof message.avgLatency !== "number")
                        return "avgLatency: number expected";
                if (message.syncToFetchSize != null && message.hasOwnProperty("syncToFetchSize"))
                    if (!$util.isInteger(message.syncToFetchSize))
                        return "syncToFetchSize: integer expected";
                if (message.syncToFetchSizePeekNum != null && message.hasOwnProperty("syncToFetchSizePeekNum"))
                    if (!$util.isInteger(message.syncToFetchSizePeekNum) && !(message.syncToFetchSizePeekNum && $util.isInteger(message.syncToFetchSizePeekNum.low) && $util.isInteger(message.syncToFetchSizePeekNum.high)))
                        return "syncToFetchSizePeekNum: integer|Long expected";
                if (message.syncBlockRequestedSize != null && message.hasOwnProperty("syncBlockRequestedSize"))
                    if (!$util.isInteger(message.syncBlockRequestedSize))
                        return "syncBlockRequestedSize: integer expected";
                if (message.unFetchSynNum != null && message.hasOwnProperty("unFetchSynNum"))
                    if (!$util.isInteger(message.unFetchSynNum) && !(message.unFetchSynNum && $util.isInteger(message.unFetchSynNum.low) && $util.isInteger(message.unFetchSynNum.high)))
                        return "unFetchSynNum: integer|Long expected";
                if (message.blockInPorcSize != null && message.hasOwnProperty("blockInPorcSize"))
                    if (!$util.isInteger(message.blockInPorcSize))
                        return "blockInPorcSize: integer expected";
                if (message.headBlockWeBothHave != null && message.hasOwnProperty("headBlockWeBothHave"))
                    if (!$util.isString(message.headBlockWeBothHave))
                        return "headBlockWeBothHave: string expected";
                if (message.isActive != null && message.hasOwnProperty("isActive"))
                    if (typeof message.isActive !== "boolean")
                        return "isActive: boolean expected";
                if (message.score != null && message.hasOwnProperty("score"))
                    if (!$util.isInteger(message.score))
                        return "score: integer expected";
                if (message.nodeCount != null && message.hasOwnProperty("nodeCount"))
                    if (!$util.isInteger(message.nodeCount))
                        return "nodeCount: integer expected";
                if (message.inFlow != null && message.hasOwnProperty("inFlow"))
                    if (!$util.isInteger(message.inFlow) && !(message.inFlow && $util.isInteger(message.inFlow.low) && $util.isInteger(message.inFlow.high)))
                        return "inFlow: integer|Long expected";
                if (message.disconnectTimes != null && message.hasOwnProperty("disconnectTimes"))
                    if (!$util.isInteger(message.disconnectTimes))
                        return "disconnectTimes: integer expected";
                if (message.localDisconnectReason != null && message.hasOwnProperty("localDisconnectReason"))
                    if (!$util.isString(message.localDisconnectReason))
                        return "localDisconnectReason: string expected";
                if (message.remoteDisconnectReason != null && message.hasOwnProperty("remoteDisconnectReason"))
                    if (!$util.isString(message.remoteDisconnectReason))
                        return "remoteDisconnectReason: string expected";
                return null;
            };

            /**
             * Creates a PeerInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.NodeInfo.PeerInfo} PeerInfo
             */
            PeerInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.NodeInfo.PeerInfo)
                    return object;
                var message = new $root.protocol.NodeInfo.PeerInfo();
                if (object.lastSyncBlock != null)
                    message.lastSyncBlock = String(object.lastSyncBlock);
                if (object.remainNum != null)
                    if ($util.Long)
                        (message.remainNum = $util.Long.fromValue(object.remainNum)).unsigned = false;
                    else if (typeof object.remainNum === "string")
                        message.remainNum = parseInt(object.remainNum, 10);
                    else if (typeof object.remainNum === "number")
                        message.remainNum = object.remainNum;
                    else if (typeof object.remainNum === "object")
                        message.remainNum = new $util.LongBits(object.remainNum.low >>> 0, object.remainNum.high >>> 0).toNumber();
                if (object.lastBlockUpdateTime != null)
                    if ($util.Long)
                        (message.lastBlockUpdateTime = $util.Long.fromValue(object.lastBlockUpdateTime)).unsigned = false;
                    else if (typeof object.lastBlockUpdateTime === "string")
                        message.lastBlockUpdateTime = parseInt(object.lastBlockUpdateTime, 10);
                    else if (typeof object.lastBlockUpdateTime === "number")
                        message.lastBlockUpdateTime = object.lastBlockUpdateTime;
                    else if (typeof object.lastBlockUpdateTime === "object")
                        message.lastBlockUpdateTime = new $util.LongBits(object.lastBlockUpdateTime.low >>> 0, object.lastBlockUpdateTime.high >>> 0).toNumber();
                if (object.syncFlag != null)
                    message.syncFlag = Boolean(object.syncFlag);
                if (object.headBlockTimeWeBothHave != null)
                    if ($util.Long)
                        (message.headBlockTimeWeBothHave = $util.Long.fromValue(object.headBlockTimeWeBothHave)).unsigned = false;
                    else if (typeof object.headBlockTimeWeBothHave === "string")
                        message.headBlockTimeWeBothHave = parseInt(object.headBlockTimeWeBothHave, 10);
                    else if (typeof object.headBlockTimeWeBothHave === "number")
                        message.headBlockTimeWeBothHave = object.headBlockTimeWeBothHave;
                    else if (typeof object.headBlockTimeWeBothHave === "object")
                        message.headBlockTimeWeBothHave = new $util.LongBits(object.headBlockTimeWeBothHave.low >>> 0, object.headBlockTimeWeBothHave.high >>> 0).toNumber();
                if (object.needSyncFromPeer != null)
                    message.needSyncFromPeer = Boolean(object.needSyncFromPeer);
                if (object.needSyncFromUs != null)
                    message.needSyncFromUs = Boolean(object.needSyncFromUs);
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port | 0;
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.connectTime != null)
                    if ($util.Long)
                        (message.connectTime = $util.Long.fromValue(object.connectTime)).unsigned = false;
                    else if (typeof object.connectTime === "string")
                        message.connectTime = parseInt(object.connectTime, 10);
                    else if (typeof object.connectTime === "number")
                        message.connectTime = object.connectTime;
                    else if (typeof object.connectTime === "object")
                        message.connectTime = new $util.LongBits(object.connectTime.low >>> 0, object.connectTime.high >>> 0).toNumber();
                if (object.avgLatency != null)
                    message.avgLatency = Number(object.avgLatency);
                if (object.syncToFetchSize != null)
                    message.syncToFetchSize = object.syncToFetchSize | 0;
                if (object.syncToFetchSizePeekNum != null)
                    if ($util.Long)
                        (message.syncToFetchSizePeekNum = $util.Long.fromValue(object.syncToFetchSizePeekNum)).unsigned = false;
                    else if (typeof object.syncToFetchSizePeekNum === "string")
                        message.syncToFetchSizePeekNum = parseInt(object.syncToFetchSizePeekNum, 10);
                    else if (typeof object.syncToFetchSizePeekNum === "number")
                        message.syncToFetchSizePeekNum = object.syncToFetchSizePeekNum;
                    else if (typeof object.syncToFetchSizePeekNum === "object")
                        message.syncToFetchSizePeekNum = new $util.LongBits(object.syncToFetchSizePeekNum.low >>> 0, object.syncToFetchSizePeekNum.high >>> 0).toNumber();
                if (object.syncBlockRequestedSize != null)
                    message.syncBlockRequestedSize = object.syncBlockRequestedSize | 0;
                if (object.unFetchSynNum != null)
                    if ($util.Long)
                        (message.unFetchSynNum = $util.Long.fromValue(object.unFetchSynNum)).unsigned = false;
                    else if (typeof object.unFetchSynNum === "string")
                        message.unFetchSynNum = parseInt(object.unFetchSynNum, 10);
                    else if (typeof object.unFetchSynNum === "number")
                        message.unFetchSynNum = object.unFetchSynNum;
                    else if (typeof object.unFetchSynNum === "object")
                        message.unFetchSynNum = new $util.LongBits(object.unFetchSynNum.low >>> 0, object.unFetchSynNum.high >>> 0).toNumber();
                if (object.blockInPorcSize != null)
                    message.blockInPorcSize = object.blockInPorcSize | 0;
                if (object.headBlockWeBothHave != null)
                    message.headBlockWeBothHave = String(object.headBlockWeBothHave);
                if (object.isActive != null)
                    message.isActive = Boolean(object.isActive);
                if (object.score != null)
                    message.score = object.score | 0;
                if (object.nodeCount != null)
                    message.nodeCount = object.nodeCount | 0;
                if (object.inFlow != null)
                    if ($util.Long)
                        (message.inFlow = $util.Long.fromValue(object.inFlow)).unsigned = false;
                    else if (typeof object.inFlow === "string")
                        message.inFlow = parseInt(object.inFlow, 10);
                    else if (typeof object.inFlow === "number")
                        message.inFlow = object.inFlow;
                    else if (typeof object.inFlow === "object")
                        message.inFlow = new $util.LongBits(object.inFlow.low >>> 0, object.inFlow.high >>> 0).toNumber();
                if (object.disconnectTimes != null)
                    message.disconnectTimes = object.disconnectTimes | 0;
                if (object.localDisconnectReason != null)
                    message.localDisconnectReason = String(object.localDisconnectReason);
                if (object.remoteDisconnectReason != null)
                    message.remoteDisconnectReason = String(object.remoteDisconnectReason);
                return message;
            };

            /**
             * Creates a plain object from a PeerInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {protocol.NodeInfo.PeerInfo} message PeerInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.lastSyncBlock = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.remainNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.remainNum = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastBlockUpdateTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastBlockUpdateTime = options.longs === String ? "0" : 0;
                    object.syncFlag = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.headBlockTimeWeBothHave = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.headBlockTimeWeBothHave = options.longs === String ? "0" : 0;
                    object.needSyncFromPeer = false;
                    object.needSyncFromUs = false;
                    object.host = "";
                    object.port = 0;
                    object.nodeId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.connectTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.connectTime = options.longs === String ? "0" : 0;
                    object.avgLatency = 0;
                    object.syncToFetchSize = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.syncToFetchSizePeekNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.syncToFetchSizePeekNum = options.longs === String ? "0" : 0;
                    object.syncBlockRequestedSize = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.unFetchSynNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.unFetchSynNum = options.longs === String ? "0" : 0;
                    object.blockInPorcSize = 0;
                    object.headBlockWeBothHave = "";
                    object.isActive = false;
                    object.score = 0;
                    object.nodeCount = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.inFlow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.inFlow = options.longs === String ? "0" : 0;
                    object.disconnectTimes = 0;
                    object.localDisconnectReason = "";
                    object.remoteDisconnectReason = "";
                }
                if (message.lastSyncBlock != null && message.hasOwnProperty("lastSyncBlock"))
                    object.lastSyncBlock = message.lastSyncBlock;
                if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                    if (typeof message.remainNum === "number")
                        object.remainNum = options.longs === String ? String(message.remainNum) : message.remainNum;
                    else
                        object.remainNum = options.longs === String ? $util.Long.prototype.toString.call(message.remainNum) : options.longs === Number ? new $util.LongBits(message.remainNum.low >>> 0, message.remainNum.high >>> 0).toNumber() : message.remainNum;
                if (message.lastBlockUpdateTime != null && message.hasOwnProperty("lastBlockUpdateTime"))
                    if (typeof message.lastBlockUpdateTime === "number")
                        object.lastBlockUpdateTime = options.longs === String ? String(message.lastBlockUpdateTime) : message.lastBlockUpdateTime;
                    else
                        object.lastBlockUpdateTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastBlockUpdateTime) : options.longs === Number ? new $util.LongBits(message.lastBlockUpdateTime.low >>> 0, message.lastBlockUpdateTime.high >>> 0).toNumber() : message.lastBlockUpdateTime;
                if (message.syncFlag != null && message.hasOwnProperty("syncFlag"))
                    object.syncFlag = message.syncFlag;
                if (message.headBlockTimeWeBothHave != null && message.hasOwnProperty("headBlockTimeWeBothHave"))
                    if (typeof message.headBlockTimeWeBothHave === "number")
                        object.headBlockTimeWeBothHave = options.longs === String ? String(message.headBlockTimeWeBothHave) : message.headBlockTimeWeBothHave;
                    else
                        object.headBlockTimeWeBothHave = options.longs === String ? $util.Long.prototype.toString.call(message.headBlockTimeWeBothHave) : options.longs === Number ? new $util.LongBits(message.headBlockTimeWeBothHave.low >>> 0, message.headBlockTimeWeBothHave.high >>> 0).toNumber() : message.headBlockTimeWeBothHave;
                if (message.needSyncFromPeer != null && message.hasOwnProperty("needSyncFromPeer"))
                    object.needSyncFromPeer = message.needSyncFromPeer;
                if (message.needSyncFromUs != null && message.hasOwnProperty("needSyncFromUs"))
                    object.needSyncFromUs = message.needSyncFromUs;
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.connectTime != null && message.hasOwnProperty("connectTime"))
                    if (typeof message.connectTime === "number")
                        object.connectTime = options.longs === String ? String(message.connectTime) : message.connectTime;
                    else
                        object.connectTime = options.longs === String ? $util.Long.prototype.toString.call(message.connectTime) : options.longs === Number ? new $util.LongBits(message.connectTime.low >>> 0, message.connectTime.high >>> 0).toNumber() : message.connectTime;
                if (message.avgLatency != null && message.hasOwnProperty("avgLatency"))
                    object.avgLatency = options.json && !isFinite(message.avgLatency) ? String(message.avgLatency) : message.avgLatency;
                if (message.syncToFetchSize != null && message.hasOwnProperty("syncToFetchSize"))
                    object.syncToFetchSize = message.syncToFetchSize;
                if (message.syncToFetchSizePeekNum != null && message.hasOwnProperty("syncToFetchSizePeekNum"))
                    if (typeof message.syncToFetchSizePeekNum === "number")
                        object.syncToFetchSizePeekNum = options.longs === String ? String(message.syncToFetchSizePeekNum) : message.syncToFetchSizePeekNum;
                    else
                        object.syncToFetchSizePeekNum = options.longs === String ? $util.Long.prototype.toString.call(message.syncToFetchSizePeekNum) : options.longs === Number ? new $util.LongBits(message.syncToFetchSizePeekNum.low >>> 0, message.syncToFetchSizePeekNum.high >>> 0).toNumber() : message.syncToFetchSizePeekNum;
                if (message.syncBlockRequestedSize != null && message.hasOwnProperty("syncBlockRequestedSize"))
                    object.syncBlockRequestedSize = message.syncBlockRequestedSize;
                if (message.unFetchSynNum != null && message.hasOwnProperty("unFetchSynNum"))
                    if (typeof message.unFetchSynNum === "number")
                        object.unFetchSynNum = options.longs === String ? String(message.unFetchSynNum) : message.unFetchSynNum;
                    else
                        object.unFetchSynNum = options.longs === String ? $util.Long.prototype.toString.call(message.unFetchSynNum) : options.longs === Number ? new $util.LongBits(message.unFetchSynNum.low >>> 0, message.unFetchSynNum.high >>> 0).toNumber() : message.unFetchSynNum;
                if (message.blockInPorcSize != null && message.hasOwnProperty("blockInPorcSize"))
                    object.blockInPorcSize = message.blockInPorcSize;
                if (message.headBlockWeBothHave != null && message.hasOwnProperty("headBlockWeBothHave"))
                    object.headBlockWeBothHave = message.headBlockWeBothHave;
                if (message.isActive != null && message.hasOwnProperty("isActive"))
                    object.isActive = message.isActive;
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = message.score;
                if (message.nodeCount != null && message.hasOwnProperty("nodeCount"))
                    object.nodeCount = message.nodeCount;
                if (message.inFlow != null && message.hasOwnProperty("inFlow"))
                    if (typeof message.inFlow === "number")
                        object.inFlow = options.longs === String ? String(message.inFlow) : message.inFlow;
                    else
                        object.inFlow = options.longs === String ? $util.Long.prototype.toString.call(message.inFlow) : options.longs === Number ? new $util.LongBits(message.inFlow.low >>> 0, message.inFlow.high >>> 0).toNumber() : message.inFlow;
                if (message.disconnectTimes != null && message.hasOwnProperty("disconnectTimes"))
                    object.disconnectTimes = message.disconnectTimes;
                if (message.localDisconnectReason != null && message.hasOwnProperty("localDisconnectReason"))
                    object.localDisconnectReason = message.localDisconnectReason;
                if (message.remoteDisconnectReason != null && message.hasOwnProperty("remoteDisconnectReason"))
                    object.remoteDisconnectReason = message.remoteDisconnectReason;
                return object;
            };

            /**
             * Converts this PeerInfo to JSON.
             * @function toJSON
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PeerInfo;
        })();

        NodeInfo.ConfigNodeInfo = (function() {

            /**
             * Properties of a ConfigNodeInfo.
             * @memberof protocol.NodeInfo
             * @interface IConfigNodeInfo
             * @property {string|null} [codeVersion] ConfigNodeInfo codeVersion
             * @property {string|null} [p2pVersion] ConfigNodeInfo p2pVersion
             * @property {number|null} [listenPort] ConfigNodeInfo listenPort
             * @property {boolean|null} [discoverEnable] ConfigNodeInfo discoverEnable
             * @property {number|null} [activeNodeSize] ConfigNodeInfo activeNodeSize
             * @property {number|null} [passiveNodeSize] ConfigNodeInfo passiveNodeSize
             * @property {number|null} [sendNodeSize] ConfigNodeInfo sendNodeSize
             * @property {number|null} [maxConnectCount] ConfigNodeInfo maxConnectCount
             * @property {number|null} [sameIpMaxConnectCount] ConfigNodeInfo sameIpMaxConnectCount
             * @property {number|null} [backupListenPort] ConfigNodeInfo backupListenPort
             * @property {number|null} [backupMemberSize] ConfigNodeInfo backupMemberSize
             * @property {number|null} [backupPriority] ConfigNodeInfo backupPriority
             * @property {number|null} [dbVersion] ConfigNodeInfo dbVersion
             * @property {number|null} [minParticipationRate] ConfigNodeInfo minParticipationRate
             * @property {boolean|null} [supportConstant] ConfigNodeInfo supportConstant
             * @property {number|null} [minTimeRatio] ConfigNodeInfo minTimeRatio
             * @property {number|null} [maxTimeRatio] ConfigNodeInfo maxTimeRatio
             * @property {number|Long|null} [allowCreationOfContracts] ConfigNodeInfo allowCreationOfContracts
             * @property {number|Long|null} [allowAdaptiveEnergy] ConfigNodeInfo allowAdaptiveEnergy
             */

            /**
             * Constructs a new ConfigNodeInfo.
             * @memberof protocol.NodeInfo
             * @classdesc Represents a ConfigNodeInfo.
             * @implements IConfigNodeInfo
             * @constructor
             * @param {protocol.NodeInfo.IConfigNodeInfo=} [properties] Properties to set
             */
            function ConfigNodeInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConfigNodeInfo codeVersion.
             * @member {string} codeVersion
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.codeVersion = "";

            /**
             * ConfigNodeInfo p2pVersion.
             * @member {string} p2pVersion
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.p2pVersion = "";

            /**
             * ConfigNodeInfo listenPort.
             * @member {number} listenPort
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.listenPort = 0;

            /**
             * ConfigNodeInfo discoverEnable.
             * @member {boolean} discoverEnable
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.discoverEnable = false;

            /**
             * ConfigNodeInfo activeNodeSize.
             * @member {number} activeNodeSize
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.activeNodeSize = 0;

            /**
             * ConfigNodeInfo passiveNodeSize.
             * @member {number} passiveNodeSize
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.passiveNodeSize = 0;

            /**
             * ConfigNodeInfo sendNodeSize.
             * @member {number} sendNodeSize
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.sendNodeSize = 0;

            /**
             * ConfigNodeInfo maxConnectCount.
             * @member {number} maxConnectCount
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.maxConnectCount = 0;

            /**
             * ConfigNodeInfo sameIpMaxConnectCount.
             * @member {number} sameIpMaxConnectCount
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.sameIpMaxConnectCount = 0;

            /**
             * ConfigNodeInfo backupListenPort.
             * @member {number} backupListenPort
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.backupListenPort = 0;

            /**
             * ConfigNodeInfo backupMemberSize.
             * @member {number} backupMemberSize
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.backupMemberSize = 0;

            /**
             * ConfigNodeInfo backupPriority.
             * @member {number} backupPriority
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.backupPriority = 0;

            /**
             * ConfigNodeInfo dbVersion.
             * @member {number} dbVersion
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.dbVersion = 0;

            /**
             * ConfigNodeInfo minParticipationRate.
             * @member {number} minParticipationRate
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.minParticipationRate = 0;

            /**
             * ConfigNodeInfo supportConstant.
             * @member {boolean} supportConstant
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.supportConstant = false;

            /**
             * ConfigNodeInfo minTimeRatio.
             * @member {number} minTimeRatio
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.minTimeRatio = 0;

            /**
             * ConfigNodeInfo maxTimeRatio.
             * @member {number} maxTimeRatio
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.maxTimeRatio = 0;

            /**
             * ConfigNodeInfo allowCreationOfContracts.
             * @member {number|Long} allowCreationOfContracts
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.allowCreationOfContracts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ConfigNodeInfo allowAdaptiveEnergy.
             * @member {number|Long} allowAdaptiveEnergy
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.allowAdaptiveEnergy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ConfigNodeInfo instance using the specified properties.
             * @function create
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {protocol.NodeInfo.IConfigNodeInfo=} [properties] Properties to set
             * @returns {protocol.NodeInfo.ConfigNodeInfo} ConfigNodeInfo instance
             */
            ConfigNodeInfo.create = function create(properties) {
                return new ConfigNodeInfo(properties);
            };

            /**
             * Encodes the specified ConfigNodeInfo message. Does not implicitly {@link protocol.NodeInfo.ConfigNodeInfo.verify|verify} messages.
             * @function encode
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {protocol.NodeInfo.IConfigNodeInfo} message ConfigNodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigNodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.codeVersion != null && Object.hasOwnProperty.call(message, "codeVersion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.codeVersion);
                if (message.p2pVersion != null && Object.hasOwnProperty.call(message, "p2pVersion"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.p2pVersion);
                if (message.listenPort != null && Object.hasOwnProperty.call(message, "listenPort"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.listenPort);
                if (message.discoverEnable != null && Object.hasOwnProperty.call(message, "discoverEnable"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.discoverEnable);
                if (message.activeNodeSize != null && Object.hasOwnProperty.call(message, "activeNodeSize"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.activeNodeSize);
                if (message.passiveNodeSize != null && Object.hasOwnProperty.call(message, "passiveNodeSize"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.passiveNodeSize);
                if (message.sendNodeSize != null && Object.hasOwnProperty.call(message, "sendNodeSize"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.sendNodeSize);
                if (message.maxConnectCount != null && Object.hasOwnProperty.call(message, "maxConnectCount"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.maxConnectCount);
                if (message.sameIpMaxConnectCount != null && Object.hasOwnProperty.call(message, "sameIpMaxConnectCount"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.sameIpMaxConnectCount);
                if (message.backupListenPort != null && Object.hasOwnProperty.call(message, "backupListenPort"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.backupListenPort);
                if (message.backupMemberSize != null && Object.hasOwnProperty.call(message, "backupMemberSize"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.backupMemberSize);
                if (message.backupPriority != null && Object.hasOwnProperty.call(message, "backupPriority"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.backupPriority);
                if (message.dbVersion != null && Object.hasOwnProperty.call(message, "dbVersion"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.dbVersion);
                if (message.minParticipationRate != null && Object.hasOwnProperty.call(message, "minParticipationRate"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.minParticipationRate);
                if (message.supportConstant != null && Object.hasOwnProperty.call(message, "supportConstant"))
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.supportConstant);
                if (message.minTimeRatio != null && Object.hasOwnProperty.call(message, "minTimeRatio"))
                    writer.uint32(/* id 16, wireType 1 =*/129).double(message.minTimeRatio);
                if (message.maxTimeRatio != null && Object.hasOwnProperty.call(message, "maxTimeRatio"))
                    writer.uint32(/* id 17, wireType 1 =*/137).double(message.maxTimeRatio);
                if (message.allowCreationOfContracts != null && Object.hasOwnProperty.call(message, "allowCreationOfContracts"))
                    writer.uint32(/* id 18, wireType 0 =*/144).int64(message.allowCreationOfContracts);
                if (message.allowAdaptiveEnergy != null && Object.hasOwnProperty.call(message, "allowAdaptiveEnergy"))
                    writer.uint32(/* id 19, wireType 0 =*/152).int64(message.allowAdaptiveEnergy);
                return writer;
            };

            /**
             * Encodes the specified ConfigNodeInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.ConfigNodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {protocol.NodeInfo.IConfigNodeInfo} message ConfigNodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigNodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConfigNodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.NodeInfo.ConfigNodeInfo} ConfigNodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigNodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.ConfigNodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.codeVersion = reader.string();
                        break;
                    case 2:
                        message.p2pVersion = reader.string();
                        break;
                    case 3:
                        message.listenPort = reader.int32();
                        break;
                    case 4:
                        message.discoverEnable = reader.bool();
                        break;
                    case 5:
                        message.activeNodeSize = reader.int32();
                        break;
                    case 6:
                        message.passiveNodeSize = reader.int32();
                        break;
                    case 7:
                        message.sendNodeSize = reader.int32();
                        break;
                    case 8:
                        message.maxConnectCount = reader.int32();
                        break;
                    case 9:
                        message.sameIpMaxConnectCount = reader.int32();
                        break;
                    case 10:
                        message.backupListenPort = reader.int32();
                        break;
                    case 11:
                        message.backupMemberSize = reader.int32();
                        break;
                    case 12:
                        message.backupPriority = reader.int32();
                        break;
                    case 13:
                        message.dbVersion = reader.int32();
                        break;
                    case 14:
                        message.minParticipationRate = reader.int32();
                        break;
                    case 15:
                        message.supportConstant = reader.bool();
                        break;
                    case 16:
                        message.minTimeRatio = reader.double();
                        break;
                    case 17:
                        message.maxTimeRatio = reader.double();
                        break;
                    case 18:
                        message.allowCreationOfContracts = reader.int64();
                        break;
                    case 19:
                        message.allowAdaptiveEnergy = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConfigNodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.NodeInfo.ConfigNodeInfo} ConfigNodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigNodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConfigNodeInfo message.
             * @function verify
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigNodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.codeVersion != null && message.hasOwnProperty("codeVersion"))
                    if (!$util.isString(message.codeVersion))
                        return "codeVersion: string expected";
                if (message.p2pVersion != null && message.hasOwnProperty("p2pVersion"))
                    if (!$util.isString(message.p2pVersion))
                        return "p2pVersion: string expected";
                if (message.listenPort != null && message.hasOwnProperty("listenPort"))
                    if (!$util.isInteger(message.listenPort))
                        return "listenPort: integer expected";
                if (message.discoverEnable != null && message.hasOwnProperty("discoverEnable"))
                    if (typeof message.discoverEnable !== "boolean")
                        return "discoverEnable: boolean expected";
                if (message.activeNodeSize != null && message.hasOwnProperty("activeNodeSize"))
                    if (!$util.isInteger(message.activeNodeSize))
                        return "activeNodeSize: integer expected";
                if (message.passiveNodeSize != null && message.hasOwnProperty("passiveNodeSize"))
                    if (!$util.isInteger(message.passiveNodeSize))
                        return "passiveNodeSize: integer expected";
                if (message.sendNodeSize != null && message.hasOwnProperty("sendNodeSize"))
                    if (!$util.isInteger(message.sendNodeSize))
                        return "sendNodeSize: integer expected";
                if (message.maxConnectCount != null && message.hasOwnProperty("maxConnectCount"))
                    if (!$util.isInteger(message.maxConnectCount))
                        return "maxConnectCount: integer expected";
                if (message.sameIpMaxConnectCount != null && message.hasOwnProperty("sameIpMaxConnectCount"))
                    if (!$util.isInteger(message.sameIpMaxConnectCount))
                        return "sameIpMaxConnectCount: integer expected";
                if (message.backupListenPort != null && message.hasOwnProperty("backupListenPort"))
                    if (!$util.isInteger(message.backupListenPort))
                        return "backupListenPort: integer expected";
                if (message.backupMemberSize != null && message.hasOwnProperty("backupMemberSize"))
                    if (!$util.isInteger(message.backupMemberSize))
                        return "backupMemberSize: integer expected";
                if (message.backupPriority != null && message.hasOwnProperty("backupPriority"))
                    if (!$util.isInteger(message.backupPriority))
                        return "backupPriority: integer expected";
                if (message.dbVersion != null && message.hasOwnProperty("dbVersion"))
                    if (!$util.isInteger(message.dbVersion))
                        return "dbVersion: integer expected";
                if (message.minParticipationRate != null && message.hasOwnProperty("minParticipationRate"))
                    if (!$util.isInteger(message.minParticipationRate))
                        return "minParticipationRate: integer expected";
                if (message.supportConstant != null && message.hasOwnProperty("supportConstant"))
                    if (typeof message.supportConstant !== "boolean")
                        return "supportConstant: boolean expected";
                if (message.minTimeRatio != null && message.hasOwnProperty("minTimeRatio"))
                    if (typeof message.minTimeRatio !== "number")
                        return "minTimeRatio: number expected";
                if (message.maxTimeRatio != null && message.hasOwnProperty("maxTimeRatio"))
                    if (typeof message.maxTimeRatio !== "number")
                        return "maxTimeRatio: number expected";
                if (message.allowCreationOfContracts != null && message.hasOwnProperty("allowCreationOfContracts"))
                    if (!$util.isInteger(message.allowCreationOfContracts) && !(message.allowCreationOfContracts && $util.isInteger(message.allowCreationOfContracts.low) && $util.isInteger(message.allowCreationOfContracts.high)))
                        return "allowCreationOfContracts: integer|Long expected";
                if (message.allowAdaptiveEnergy != null && message.hasOwnProperty("allowAdaptiveEnergy"))
                    if (!$util.isInteger(message.allowAdaptiveEnergy) && !(message.allowAdaptiveEnergy && $util.isInteger(message.allowAdaptiveEnergy.low) && $util.isInteger(message.allowAdaptiveEnergy.high)))
                        return "allowAdaptiveEnergy: integer|Long expected";
                return null;
            };

            /**
             * Creates a ConfigNodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.NodeInfo.ConfigNodeInfo} ConfigNodeInfo
             */
            ConfigNodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.NodeInfo.ConfigNodeInfo)
                    return object;
                var message = new $root.protocol.NodeInfo.ConfigNodeInfo();
                if (object.codeVersion != null)
                    message.codeVersion = String(object.codeVersion);
                if (object.p2pVersion != null)
                    message.p2pVersion = String(object.p2pVersion);
                if (object.listenPort != null)
                    message.listenPort = object.listenPort | 0;
                if (object.discoverEnable != null)
                    message.discoverEnable = Boolean(object.discoverEnable);
                if (object.activeNodeSize != null)
                    message.activeNodeSize = object.activeNodeSize | 0;
                if (object.passiveNodeSize != null)
                    message.passiveNodeSize = object.passiveNodeSize | 0;
                if (object.sendNodeSize != null)
                    message.sendNodeSize = object.sendNodeSize | 0;
                if (object.maxConnectCount != null)
                    message.maxConnectCount = object.maxConnectCount | 0;
                if (object.sameIpMaxConnectCount != null)
                    message.sameIpMaxConnectCount = object.sameIpMaxConnectCount | 0;
                if (object.backupListenPort != null)
                    message.backupListenPort = object.backupListenPort | 0;
                if (object.backupMemberSize != null)
                    message.backupMemberSize = object.backupMemberSize | 0;
                if (object.backupPriority != null)
                    message.backupPriority = object.backupPriority | 0;
                if (object.dbVersion != null)
                    message.dbVersion = object.dbVersion | 0;
                if (object.minParticipationRate != null)
                    message.minParticipationRate = object.minParticipationRate | 0;
                if (object.supportConstant != null)
                    message.supportConstant = Boolean(object.supportConstant);
                if (object.minTimeRatio != null)
                    message.minTimeRatio = Number(object.minTimeRatio);
                if (object.maxTimeRatio != null)
                    message.maxTimeRatio = Number(object.maxTimeRatio);
                if (object.allowCreationOfContracts != null)
                    if ($util.Long)
                        (message.allowCreationOfContracts = $util.Long.fromValue(object.allowCreationOfContracts)).unsigned = false;
                    else if (typeof object.allowCreationOfContracts === "string")
                        message.allowCreationOfContracts = parseInt(object.allowCreationOfContracts, 10);
                    else if (typeof object.allowCreationOfContracts === "number")
                        message.allowCreationOfContracts = object.allowCreationOfContracts;
                    else if (typeof object.allowCreationOfContracts === "object")
                        message.allowCreationOfContracts = new $util.LongBits(object.allowCreationOfContracts.low >>> 0, object.allowCreationOfContracts.high >>> 0).toNumber();
                if (object.allowAdaptiveEnergy != null)
                    if ($util.Long)
                        (message.allowAdaptiveEnergy = $util.Long.fromValue(object.allowAdaptiveEnergy)).unsigned = false;
                    else if (typeof object.allowAdaptiveEnergy === "string")
                        message.allowAdaptiveEnergy = parseInt(object.allowAdaptiveEnergy, 10);
                    else if (typeof object.allowAdaptiveEnergy === "number")
                        message.allowAdaptiveEnergy = object.allowAdaptiveEnergy;
                    else if (typeof object.allowAdaptiveEnergy === "object")
                        message.allowAdaptiveEnergy = new $util.LongBits(object.allowAdaptiveEnergy.low >>> 0, object.allowAdaptiveEnergy.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a ConfigNodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {protocol.NodeInfo.ConfigNodeInfo} message ConfigNodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigNodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.codeVersion = "";
                    object.p2pVersion = "";
                    object.listenPort = 0;
                    object.discoverEnable = false;
                    object.activeNodeSize = 0;
                    object.passiveNodeSize = 0;
                    object.sendNodeSize = 0;
                    object.maxConnectCount = 0;
                    object.sameIpMaxConnectCount = 0;
                    object.backupListenPort = 0;
                    object.backupMemberSize = 0;
                    object.backupPriority = 0;
                    object.dbVersion = 0;
                    object.minParticipationRate = 0;
                    object.supportConstant = false;
                    object.minTimeRatio = 0;
                    object.maxTimeRatio = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.allowCreationOfContracts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.allowCreationOfContracts = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.allowAdaptiveEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.allowAdaptiveEnergy = options.longs === String ? "0" : 0;
                }
                if (message.codeVersion != null && message.hasOwnProperty("codeVersion"))
                    object.codeVersion = message.codeVersion;
                if (message.p2pVersion != null && message.hasOwnProperty("p2pVersion"))
                    object.p2pVersion = message.p2pVersion;
                if (message.listenPort != null && message.hasOwnProperty("listenPort"))
                    object.listenPort = message.listenPort;
                if (message.discoverEnable != null && message.hasOwnProperty("discoverEnable"))
                    object.discoverEnable = message.discoverEnable;
                if (message.activeNodeSize != null && message.hasOwnProperty("activeNodeSize"))
                    object.activeNodeSize = message.activeNodeSize;
                if (message.passiveNodeSize != null && message.hasOwnProperty("passiveNodeSize"))
                    object.passiveNodeSize = message.passiveNodeSize;
                if (message.sendNodeSize != null && message.hasOwnProperty("sendNodeSize"))
                    object.sendNodeSize = message.sendNodeSize;
                if (message.maxConnectCount != null && message.hasOwnProperty("maxConnectCount"))
                    object.maxConnectCount = message.maxConnectCount;
                if (message.sameIpMaxConnectCount != null && message.hasOwnProperty("sameIpMaxConnectCount"))
                    object.sameIpMaxConnectCount = message.sameIpMaxConnectCount;
                if (message.backupListenPort != null && message.hasOwnProperty("backupListenPort"))
                    object.backupListenPort = message.backupListenPort;
                if (message.backupMemberSize != null && message.hasOwnProperty("backupMemberSize"))
                    object.backupMemberSize = message.backupMemberSize;
                if (message.backupPriority != null && message.hasOwnProperty("backupPriority"))
                    object.backupPriority = message.backupPriority;
                if (message.dbVersion != null && message.hasOwnProperty("dbVersion"))
                    object.dbVersion = message.dbVersion;
                if (message.minParticipationRate != null && message.hasOwnProperty("minParticipationRate"))
                    object.minParticipationRate = message.minParticipationRate;
                if (message.supportConstant != null && message.hasOwnProperty("supportConstant"))
                    object.supportConstant = message.supportConstant;
                if (message.minTimeRatio != null && message.hasOwnProperty("minTimeRatio"))
                    object.minTimeRatio = options.json && !isFinite(message.minTimeRatio) ? String(message.minTimeRatio) : message.minTimeRatio;
                if (message.maxTimeRatio != null && message.hasOwnProperty("maxTimeRatio"))
                    object.maxTimeRatio = options.json && !isFinite(message.maxTimeRatio) ? String(message.maxTimeRatio) : message.maxTimeRatio;
                if (message.allowCreationOfContracts != null && message.hasOwnProperty("allowCreationOfContracts"))
                    if (typeof message.allowCreationOfContracts === "number")
                        object.allowCreationOfContracts = options.longs === String ? String(message.allowCreationOfContracts) : message.allowCreationOfContracts;
                    else
                        object.allowCreationOfContracts = options.longs === String ? $util.Long.prototype.toString.call(message.allowCreationOfContracts) : options.longs === Number ? new $util.LongBits(message.allowCreationOfContracts.low >>> 0, message.allowCreationOfContracts.high >>> 0).toNumber() : message.allowCreationOfContracts;
                if (message.allowAdaptiveEnergy != null && message.hasOwnProperty("allowAdaptiveEnergy"))
                    if (typeof message.allowAdaptiveEnergy === "number")
                        object.allowAdaptiveEnergy = options.longs === String ? String(message.allowAdaptiveEnergy) : message.allowAdaptiveEnergy;
                    else
                        object.allowAdaptiveEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.allowAdaptiveEnergy) : options.longs === Number ? new $util.LongBits(message.allowAdaptiveEnergy.low >>> 0, message.allowAdaptiveEnergy.high >>> 0).toNumber() : message.allowAdaptiveEnergy;
                return object;
            };

            /**
             * Converts this ConfigNodeInfo to JSON.
             * @function toJSON
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigNodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ConfigNodeInfo;
        })();

        NodeInfo.MachineInfo = (function() {

            /**
             * Properties of a MachineInfo.
             * @memberof protocol.NodeInfo
             * @interface IMachineInfo
             * @property {number|null} [threadCount] MachineInfo threadCount
             * @property {number|null} [deadLockThreadCount] MachineInfo deadLockThreadCount
             * @property {number|null} [cpuCount] MachineInfo cpuCount
             * @property {number|Long|null} [totalMemory] MachineInfo totalMemory
             * @property {number|Long|null} [freeMemory] MachineInfo freeMemory
             * @property {number|null} [cpuRate] MachineInfo cpuRate
             * @property {string|null} [javaVersion] MachineInfo javaVersion
             * @property {string|null} [osName] MachineInfo osName
             * @property {number|Long|null} [jvmTotalMemoery] MachineInfo jvmTotalMemoery
             * @property {number|Long|null} [jvmFreeMemory] MachineInfo jvmFreeMemory
             * @property {number|null} [processCpuRate] MachineInfo processCpuRate
             * @property {Array.<protocol.NodeInfo.MachineInfo.IMemoryDescInfo>|null} [memoryDescInfoList] MachineInfo memoryDescInfoList
             * @property {Array.<protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo>|null} [deadLockThreadInfoList] MachineInfo deadLockThreadInfoList
             */

            /**
             * Constructs a new MachineInfo.
             * @memberof protocol.NodeInfo
             * @classdesc Represents a MachineInfo.
             * @implements IMachineInfo
             * @constructor
             * @param {protocol.NodeInfo.IMachineInfo=} [properties] Properties to set
             */
            function MachineInfo(properties) {
                this.memoryDescInfoList = [];
                this.deadLockThreadInfoList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MachineInfo threadCount.
             * @member {number} threadCount
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.threadCount = 0;

            /**
             * MachineInfo deadLockThreadCount.
             * @member {number} deadLockThreadCount
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.deadLockThreadCount = 0;

            /**
             * MachineInfo cpuCount.
             * @member {number} cpuCount
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.cpuCount = 0;

            /**
             * MachineInfo totalMemory.
             * @member {number|Long} totalMemory
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.totalMemory = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MachineInfo freeMemory.
             * @member {number|Long} freeMemory
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.freeMemory = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MachineInfo cpuRate.
             * @member {number} cpuRate
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.cpuRate = 0;

            /**
             * MachineInfo javaVersion.
             * @member {string} javaVersion
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.javaVersion = "";

            /**
             * MachineInfo osName.
             * @member {string} osName
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.osName = "";

            /**
             * MachineInfo jvmTotalMemoery.
             * @member {number|Long} jvmTotalMemoery
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.jvmTotalMemoery = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MachineInfo jvmFreeMemory.
             * @member {number|Long} jvmFreeMemory
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.jvmFreeMemory = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MachineInfo processCpuRate.
             * @member {number} processCpuRate
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.processCpuRate = 0;

            /**
             * MachineInfo memoryDescInfoList.
             * @member {Array.<protocol.NodeInfo.MachineInfo.IMemoryDescInfo>} memoryDescInfoList
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.memoryDescInfoList = $util.emptyArray;

            /**
             * MachineInfo deadLockThreadInfoList.
             * @member {Array.<protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo>} deadLockThreadInfoList
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.deadLockThreadInfoList = $util.emptyArray;

            /**
             * Creates a new MachineInfo instance using the specified properties.
             * @function create
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {protocol.NodeInfo.IMachineInfo=} [properties] Properties to set
             * @returns {protocol.NodeInfo.MachineInfo} MachineInfo instance
             */
            MachineInfo.create = function create(properties) {
                return new MachineInfo(properties);
            };

            /**
             * Encodes the specified MachineInfo message. Does not implicitly {@link protocol.NodeInfo.MachineInfo.verify|verify} messages.
             * @function encode
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {protocol.NodeInfo.IMachineInfo} message MachineInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MachineInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadCount != null && Object.hasOwnProperty.call(message, "threadCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.threadCount);
                if (message.deadLockThreadCount != null && Object.hasOwnProperty.call(message, "deadLockThreadCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.deadLockThreadCount);
                if (message.cpuCount != null && Object.hasOwnProperty.call(message, "cpuCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cpuCount);
                if (message.totalMemory != null && Object.hasOwnProperty.call(message, "totalMemory"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.totalMemory);
                if (message.freeMemory != null && Object.hasOwnProperty.call(message, "freeMemory"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.freeMemory);
                if (message.cpuRate != null && Object.hasOwnProperty.call(message, "cpuRate"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.cpuRate);
                if (message.javaVersion != null && Object.hasOwnProperty.call(message, "javaVersion"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.javaVersion);
                if (message.osName != null && Object.hasOwnProperty.call(message, "osName"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.osName);
                if (message.jvmTotalMemoery != null && Object.hasOwnProperty.call(message, "jvmTotalMemoery"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.jvmTotalMemoery);
                if (message.jvmFreeMemory != null && Object.hasOwnProperty.call(message, "jvmFreeMemory"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.jvmFreeMemory);
                if (message.processCpuRate != null && Object.hasOwnProperty.call(message, "processCpuRate"))
                    writer.uint32(/* id 11, wireType 1 =*/89).double(message.processCpuRate);
                if (message.memoryDescInfoList != null && message.memoryDescInfoList.length)
                    for (var i = 0; i < message.memoryDescInfoList.length; ++i)
                        $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.encode(message.memoryDescInfoList[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.deadLockThreadInfoList != null && message.deadLockThreadInfoList.length)
                    for (var i = 0; i < message.deadLockThreadInfoList.length; ++i)
                        $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.encode(message.deadLockThreadInfoList[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MachineInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.MachineInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {protocol.NodeInfo.IMachineInfo} message MachineInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MachineInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MachineInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.NodeInfo.MachineInfo} MachineInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MachineInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.MachineInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.threadCount = reader.int32();
                        break;
                    case 2:
                        message.deadLockThreadCount = reader.int32();
                        break;
                    case 3:
                        message.cpuCount = reader.int32();
                        break;
                    case 4:
                        message.totalMemory = reader.int64();
                        break;
                    case 5:
                        message.freeMemory = reader.int64();
                        break;
                    case 6:
                        message.cpuRate = reader.double();
                        break;
                    case 7:
                        message.javaVersion = reader.string();
                        break;
                    case 8:
                        message.osName = reader.string();
                        break;
                    case 9:
                        message.jvmTotalMemoery = reader.int64();
                        break;
                    case 10:
                        message.jvmFreeMemory = reader.int64();
                        break;
                    case 11:
                        message.processCpuRate = reader.double();
                        break;
                    case 12:
                        if (!(message.memoryDescInfoList && message.memoryDescInfoList.length))
                            message.memoryDescInfoList = [];
                        message.memoryDescInfoList.push($root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.decode(reader, reader.uint32()));
                        break;
                    case 13:
                        if (!(message.deadLockThreadInfoList && message.deadLockThreadInfoList.length))
                            message.deadLockThreadInfoList = [];
                        message.deadLockThreadInfoList.push($root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MachineInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.NodeInfo.MachineInfo} MachineInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MachineInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MachineInfo message.
             * @function verify
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MachineInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadCount != null && message.hasOwnProperty("threadCount"))
                    if (!$util.isInteger(message.threadCount))
                        return "threadCount: integer expected";
                if (message.deadLockThreadCount != null && message.hasOwnProperty("deadLockThreadCount"))
                    if (!$util.isInteger(message.deadLockThreadCount))
                        return "deadLockThreadCount: integer expected";
                if (message.cpuCount != null && message.hasOwnProperty("cpuCount"))
                    if (!$util.isInteger(message.cpuCount))
                        return "cpuCount: integer expected";
                if (message.totalMemory != null && message.hasOwnProperty("totalMemory"))
                    if (!$util.isInteger(message.totalMemory) && !(message.totalMemory && $util.isInteger(message.totalMemory.low) && $util.isInteger(message.totalMemory.high)))
                        return "totalMemory: integer|Long expected";
                if (message.freeMemory != null && message.hasOwnProperty("freeMemory"))
                    if (!$util.isInteger(message.freeMemory) && !(message.freeMemory && $util.isInteger(message.freeMemory.low) && $util.isInteger(message.freeMemory.high)))
                        return "freeMemory: integer|Long expected";
                if (message.cpuRate != null && message.hasOwnProperty("cpuRate"))
                    if (typeof message.cpuRate !== "number")
                        return "cpuRate: number expected";
                if (message.javaVersion != null && message.hasOwnProperty("javaVersion"))
                    if (!$util.isString(message.javaVersion))
                        return "javaVersion: string expected";
                if (message.osName != null && message.hasOwnProperty("osName"))
                    if (!$util.isString(message.osName))
                        return "osName: string expected";
                if (message.jvmTotalMemoery != null && message.hasOwnProperty("jvmTotalMemoery"))
                    if (!$util.isInteger(message.jvmTotalMemoery) && !(message.jvmTotalMemoery && $util.isInteger(message.jvmTotalMemoery.low) && $util.isInteger(message.jvmTotalMemoery.high)))
                        return "jvmTotalMemoery: integer|Long expected";
                if (message.jvmFreeMemory != null && message.hasOwnProperty("jvmFreeMemory"))
                    if (!$util.isInteger(message.jvmFreeMemory) && !(message.jvmFreeMemory && $util.isInteger(message.jvmFreeMemory.low) && $util.isInteger(message.jvmFreeMemory.high)))
                        return "jvmFreeMemory: integer|Long expected";
                if (message.processCpuRate != null && message.hasOwnProperty("processCpuRate"))
                    if (typeof message.processCpuRate !== "number")
                        return "processCpuRate: number expected";
                if (message.memoryDescInfoList != null && message.hasOwnProperty("memoryDescInfoList")) {
                    if (!Array.isArray(message.memoryDescInfoList))
                        return "memoryDescInfoList: array expected";
                    for (var i = 0; i < message.memoryDescInfoList.length; ++i) {
                        var error = $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.verify(message.memoryDescInfoList[i]);
                        if (error)
                            return "memoryDescInfoList." + error;
                    }
                }
                if (message.deadLockThreadInfoList != null && message.hasOwnProperty("deadLockThreadInfoList")) {
                    if (!Array.isArray(message.deadLockThreadInfoList))
                        return "deadLockThreadInfoList: array expected";
                    for (var i = 0; i < message.deadLockThreadInfoList.length; ++i) {
                        var error = $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.verify(message.deadLockThreadInfoList[i]);
                        if (error)
                            return "deadLockThreadInfoList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MachineInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.NodeInfo.MachineInfo} MachineInfo
             */
            MachineInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.NodeInfo.MachineInfo)
                    return object;
                var message = new $root.protocol.NodeInfo.MachineInfo();
                if (object.threadCount != null)
                    message.threadCount = object.threadCount | 0;
                if (object.deadLockThreadCount != null)
                    message.deadLockThreadCount = object.deadLockThreadCount | 0;
                if (object.cpuCount != null)
                    message.cpuCount = object.cpuCount | 0;
                if (object.totalMemory != null)
                    if ($util.Long)
                        (message.totalMemory = $util.Long.fromValue(object.totalMemory)).unsigned = false;
                    else if (typeof object.totalMemory === "string")
                        message.totalMemory = parseInt(object.totalMemory, 10);
                    else if (typeof object.totalMemory === "number")
                        message.totalMemory = object.totalMemory;
                    else if (typeof object.totalMemory === "object")
                        message.totalMemory = new $util.LongBits(object.totalMemory.low >>> 0, object.totalMemory.high >>> 0).toNumber();
                if (object.freeMemory != null)
                    if ($util.Long)
                        (message.freeMemory = $util.Long.fromValue(object.freeMemory)).unsigned = false;
                    else if (typeof object.freeMemory === "string")
                        message.freeMemory = parseInt(object.freeMemory, 10);
                    else if (typeof object.freeMemory === "number")
                        message.freeMemory = object.freeMemory;
                    else if (typeof object.freeMemory === "object")
                        message.freeMemory = new $util.LongBits(object.freeMemory.low >>> 0, object.freeMemory.high >>> 0).toNumber();
                if (object.cpuRate != null)
                    message.cpuRate = Number(object.cpuRate);
                if (object.javaVersion != null)
                    message.javaVersion = String(object.javaVersion);
                if (object.osName != null)
                    message.osName = String(object.osName);
                if (object.jvmTotalMemoery != null)
                    if ($util.Long)
                        (message.jvmTotalMemoery = $util.Long.fromValue(object.jvmTotalMemoery)).unsigned = false;
                    else if (typeof object.jvmTotalMemoery === "string")
                        message.jvmTotalMemoery = parseInt(object.jvmTotalMemoery, 10);
                    else if (typeof object.jvmTotalMemoery === "number")
                        message.jvmTotalMemoery = object.jvmTotalMemoery;
                    else if (typeof object.jvmTotalMemoery === "object")
                        message.jvmTotalMemoery = new $util.LongBits(object.jvmTotalMemoery.low >>> 0, object.jvmTotalMemoery.high >>> 0).toNumber();
                if (object.jvmFreeMemory != null)
                    if ($util.Long)
                        (message.jvmFreeMemory = $util.Long.fromValue(object.jvmFreeMemory)).unsigned = false;
                    else if (typeof object.jvmFreeMemory === "string")
                        message.jvmFreeMemory = parseInt(object.jvmFreeMemory, 10);
                    else if (typeof object.jvmFreeMemory === "number")
                        message.jvmFreeMemory = object.jvmFreeMemory;
                    else if (typeof object.jvmFreeMemory === "object")
                        message.jvmFreeMemory = new $util.LongBits(object.jvmFreeMemory.low >>> 0, object.jvmFreeMemory.high >>> 0).toNumber();
                if (object.processCpuRate != null)
                    message.processCpuRate = Number(object.processCpuRate);
                if (object.memoryDescInfoList) {
                    if (!Array.isArray(object.memoryDescInfoList))
                        throw TypeError(".protocol.NodeInfo.MachineInfo.memoryDescInfoList: array expected");
                    message.memoryDescInfoList = [];
                    for (var i = 0; i < object.memoryDescInfoList.length; ++i) {
                        if (typeof object.memoryDescInfoList[i] !== "object")
                            throw TypeError(".protocol.NodeInfo.MachineInfo.memoryDescInfoList: object expected");
                        message.memoryDescInfoList[i] = $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.fromObject(object.memoryDescInfoList[i]);
                    }
                }
                if (object.deadLockThreadInfoList) {
                    if (!Array.isArray(object.deadLockThreadInfoList))
                        throw TypeError(".protocol.NodeInfo.MachineInfo.deadLockThreadInfoList: array expected");
                    message.deadLockThreadInfoList = [];
                    for (var i = 0; i < object.deadLockThreadInfoList.length; ++i) {
                        if (typeof object.deadLockThreadInfoList[i] !== "object")
                            throw TypeError(".protocol.NodeInfo.MachineInfo.deadLockThreadInfoList: object expected");
                        message.deadLockThreadInfoList[i] = $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.fromObject(object.deadLockThreadInfoList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MachineInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {protocol.NodeInfo.MachineInfo} message MachineInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MachineInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.memoryDescInfoList = [];
                    object.deadLockThreadInfoList = [];
                }
                if (options.defaults) {
                    object.threadCount = 0;
                    object.deadLockThreadCount = 0;
                    object.cpuCount = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.totalMemory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.totalMemory = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.freeMemory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.freeMemory = options.longs === String ? "0" : 0;
                    object.cpuRate = 0;
                    object.javaVersion = "";
                    object.osName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.jvmTotalMemoery = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.jvmTotalMemoery = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.jvmFreeMemory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.jvmFreeMemory = options.longs === String ? "0" : 0;
                    object.processCpuRate = 0;
                }
                if (message.threadCount != null && message.hasOwnProperty("threadCount"))
                    object.threadCount = message.threadCount;
                if (message.deadLockThreadCount != null && message.hasOwnProperty("deadLockThreadCount"))
                    object.deadLockThreadCount = message.deadLockThreadCount;
                if (message.cpuCount != null && message.hasOwnProperty("cpuCount"))
                    object.cpuCount = message.cpuCount;
                if (message.totalMemory != null && message.hasOwnProperty("totalMemory"))
                    if (typeof message.totalMemory === "number")
                        object.totalMemory = options.longs === String ? String(message.totalMemory) : message.totalMemory;
                    else
                        object.totalMemory = options.longs === String ? $util.Long.prototype.toString.call(message.totalMemory) : options.longs === Number ? new $util.LongBits(message.totalMemory.low >>> 0, message.totalMemory.high >>> 0).toNumber() : message.totalMemory;
                if (message.freeMemory != null && message.hasOwnProperty("freeMemory"))
                    if (typeof message.freeMemory === "number")
                        object.freeMemory = options.longs === String ? String(message.freeMemory) : message.freeMemory;
                    else
                        object.freeMemory = options.longs === String ? $util.Long.prototype.toString.call(message.freeMemory) : options.longs === Number ? new $util.LongBits(message.freeMemory.low >>> 0, message.freeMemory.high >>> 0).toNumber() : message.freeMemory;
                if (message.cpuRate != null && message.hasOwnProperty("cpuRate"))
                    object.cpuRate = options.json && !isFinite(message.cpuRate) ? String(message.cpuRate) : message.cpuRate;
                if (message.javaVersion != null && message.hasOwnProperty("javaVersion"))
                    object.javaVersion = message.javaVersion;
                if (message.osName != null && message.hasOwnProperty("osName"))
                    object.osName = message.osName;
                if (message.jvmTotalMemoery != null && message.hasOwnProperty("jvmTotalMemoery"))
                    if (typeof message.jvmTotalMemoery === "number")
                        object.jvmTotalMemoery = options.longs === String ? String(message.jvmTotalMemoery) : message.jvmTotalMemoery;
                    else
                        object.jvmTotalMemoery = options.longs === String ? $util.Long.prototype.toString.call(message.jvmTotalMemoery) : options.longs === Number ? new $util.LongBits(message.jvmTotalMemoery.low >>> 0, message.jvmTotalMemoery.high >>> 0).toNumber() : message.jvmTotalMemoery;
                if (message.jvmFreeMemory != null && message.hasOwnProperty("jvmFreeMemory"))
                    if (typeof message.jvmFreeMemory === "number")
                        object.jvmFreeMemory = options.longs === String ? String(message.jvmFreeMemory) : message.jvmFreeMemory;
                    else
                        object.jvmFreeMemory = options.longs === String ? $util.Long.prototype.toString.call(message.jvmFreeMemory) : options.longs === Number ? new $util.LongBits(message.jvmFreeMemory.low >>> 0, message.jvmFreeMemory.high >>> 0).toNumber() : message.jvmFreeMemory;
                if (message.processCpuRate != null && message.hasOwnProperty("processCpuRate"))
                    object.processCpuRate = options.json && !isFinite(message.processCpuRate) ? String(message.processCpuRate) : message.processCpuRate;
                if (message.memoryDescInfoList && message.memoryDescInfoList.length) {
                    object.memoryDescInfoList = [];
                    for (var j = 0; j < message.memoryDescInfoList.length; ++j)
                        object.memoryDescInfoList[j] = $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.toObject(message.memoryDescInfoList[j], options);
                }
                if (message.deadLockThreadInfoList && message.deadLockThreadInfoList.length) {
                    object.deadLockThreadInfoList = [];
                    for (var j = 0; j < message.deadLockThreadInfoList.length; ++j)
                        object.deadLockThreadInfoList[j] = $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.toObject(message.deadLockThreadInfoList[j], options);
                }
                return object;
            };

            /**
             * Converts this MachineInfo to JSON.
             * @function toJSON
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MachineInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            MachineInfo.MemoryDescInfo = (function() {

                /**
                 * Properties of a MemoryDescInfo.
                 * @memberof protocol.NodeInfo.MachineInfo
                 * @interface IMemoryDescInfo
                 * @property {string|null} [name] MemoryDescInfo name
                 * @property {number|Long|null} [initSize] MemoryDescInfo initSize
                 * @property {number|Long|null} [useSize] MemoryDescInfo useSize
                 * @property {number|Long|null} [maxSize] MemoryDescInfo maxSize
                 * @property {number|null} [useRate] MemoryDescInfo useRate
                 */

                /**
                 * Constructs a new MemoryDescInfo.
                 * @memberof protocol.NodeInfo.MachineInfo
                 * @classdesc Represents a MemoryDescInfo.
                 * @implements IMemoryDescInfo
                 * @constructor
                 * @param {protocol.NodeInfo.MachineInfo.IMemoryDescInfo=} [properties] Properties to set
                 */
                function MemoryDescInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MemoryDescInfo name.
                 * @member {string} name
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 */
                MemoryDescInfo.prototype.name = "";

                /**
                 * MemoryDescInfo initSize.
                 * @member {number|Long} initSize
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 */
                MemoryDescInfo.prototype.initSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MemoryDescInfo useSize.
                 * @member {number|Long} useSize
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 */
                MemoryDescInfo.prototype.useSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MemoryDescInfo maxSize.
                 * @member {number|Long} maxSize
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 */
                MemoryDescInfo.prototype.maxSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MemoryDescInfo useRate.
                 * @member {number} useRate
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 */
                MemoryDescInfo.prototype.useRate = 0;

                /**
                 * Creates a new MemoryDescInfo instance using the specified properties.
                 * @function create
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IMemoryDescInfo=} [properties] Properties to set
                 * @returns {protocol.NodeInfo.MachineInfo.MemoryDescInfo} MemoryDescInfo instance
                 */
                MemoryDescInfo.create = function create(properties) {
                    return new MemoryDescInfo(properties);
                };

                /**
                 * Encodes the specified MemoryDescInfo message. Does not implicitly {@link protocol.NodeInfo.MachineInfo.MemoryDescInfo.verify|verify} messages.
                 * @function encode
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IMemoryDescInfo} message MemoryDescInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MemoryDescInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.initSize != null && Object.hasOwnProperty.call(message, "initSize"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.initSize);
                    if (message.useSize != null && Object.hasOwnProperty.call(message, "useSize"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.useSize);
                    if (message.maxSize != null && Object.hasOwnProperty.call(message, "maxSize"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.maxSize);
                    if (message.useRate != null && Object.hasOwnProperty.call(message, "useRate"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.useRate);
                    return writer;
                };

                /**
                 * Encodes the specified MemoryDescInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.MachineInfo.MemoryDescInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IMemoryDescInfo} message MemoryDescInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MemoryDescInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MemoryDescInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {protocol.NodeInfo.MachineInfo.MemoryDescInfo} MemoryDescInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MemoryDescInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.initSize = reader.int64();
                            break;
                        case 3:
                            message.useSize = reader.int64();
                            break;
                        case 4:
                            message.maxSize = reader.int64();
                            break;
                        case 5:
                            message.useRate = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MemoryDescInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {protocol.NodeInfo.MachineInfo.MemoryDescInfo} MemoryDescInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MemoryDescInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MemoryDescInfo message.
                 * @function verify
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MemoryDescInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.initSize != null && message.hasOwnProperty("initSize"))
                        if (!$util.isInteger(message.initSize) && !(message.initSize && $util.isInteger(message.initSize.low) && $util.isInteger(message.initSize.high)))
                            return "initSize: integer|Long expected";
                    if (message.useSize != null && message.hasOwnProperty("useSize"))
                        if (!$util.isInteger(message.useSize) && !(message.useSize && $util.isInteger(message.useSize.low) && $util.isInteger(message.useSize.high)))
                            return "useSize: integer|Long expected";
                    if (message.maxSize != null && message.hasOwnProperty("maxSize"))
                        if (!$util.isInteger(message.maxSize) && !(message.maxSize && $util.isInteger(message.maxSize.low) && $util.isInteger(message.maxSize.high)))
                            return "maxSize: integer|Long expected";
                    if (message.useRate != null && message.hasOwnProperty("useRate"))
                        if (typeof message.useRate !== "number")
                            return "useRate: number expected";
                    return null;
                };

                /**
                 * Creates a MemoryDescInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {protocol.NodeInfo.MachineInfo.MemoryDescInfo} MemoryDescInfo
                 */
                MemoryDescInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo)
                        return object;
                    var message = new $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.initSize != null)
                        if ($util.Long)
                            (message.initSize = $util.Long.fromValue(object.initSize)).unsigned = false;
                        else if (typeof object.initSize === "string")
                            message.initSize = parseInt(object.initSize, 10);
                        else if (typeof object.initSize === "number")
                            message.initSize = object.initSize;
                        else if (typeof object.initSize === "object")
                            message.initSize = new $util.LongBits(object.initSize.low >>> 0, object.initSize.high >>> 0).toNumber();
                    if (object.useSize != null)
                        if ($util.Long)
                            (message.useSize = $util.Long.fromValue(object.useSize)).unsigned = false;
                        else if (typeof object.useSize === "string")
                            message.useSize = parseInt(object.useSize, 10);
                        else if (typeof object.useSize === "number")
                            message.useSize = object.useSize;
                        else if (typeof object.useSize === "object")
                            message.useSize = new $util.LongBits(object.useSize.low >>> 0, object.useSize.high >>> 0).toNumber();
                    if (object.maxSize != null)
                        if ($util.Long)
                            (message.maxSize = $util.Long.fromValue(object.maxSize)).unsigned = false;
                        else if (typeof object.maxSize === "string")
                            message.maxSize = parseInt(object.maxSize, 10);
                        else if (typeof object.maxSize === "number")
                            message.maxSize = object.maxSize;
                        else if (typeof object.maxSize === "object")
                            message.maxSize = new $util.LongBits(object.maxSize.low >>> 0, object.maxSize.high >>> 0).toNumber();
                    if (object.useRate != null)
                        message.useRate = Number(object.useRate);
                    return message;
                };

                /**
                 * Creates a plain object from a MemoryDescInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.MemoryDescInfo} message MemoryDescInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MemoryDescInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.initSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.initSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.useSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.useSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.maxSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maxSize = options.longs === String ? "0" : 0;
                        object.useRate = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.initSize != null && message.hasOwnProperty("initSize"))
                        if (typeof message.initSize === "number")
                            object.initSize = options.longs === String ? String(message.initSize) : message.initSize;
                        else
                            object.initSize = options.longs === String ? $util.Long.prototype.toString.call(message.initSize) : options.longs === Number ? new $util.LongBits(message.initSize.low >>> 0, message.initSize.high >>> 0).toNumber() : message.initSize;
                    if (message.useSize != null && message.hasOwnProperty("useSize"))
                        if (typeof message.useSize === "number")
                            object.useSize = options.longs === String ? String(message.useSize) : message.useSize;
                        else
                            object.useSize = options.longs === String ? $util.Long.prototype.toString.call(message.useSize) : options.longs === Number ? new $util.LongBits(message.useSize.low >>> 0, message.useSize.high >>> 0).toNumber() : message.useSize;
                    if (message.maxSize != null && message.hasOwnProperty("maxSize"))
                        if (typeof message.maxSize === "number")
                            object.maxSize = options.longs === String ? String(message.maxSize) : message.maxSize;
                        else
                            object.maxSize = options.longs === String ? $util.Long.prototype.toString.call(message.maxSize) : options.longs === Number ? new $util.LongBits(message.maxSize.low >>> 0, message.maxSize.high >>> 0).toNumber() : message.maxSize;
                    if (message.useRate != null && message.hasOwnProperty("useRate"))
                        object.useRate = options.json && !isFinite(message.useRate) ? String(message.useRate) : message.useRate;
                    return object;
                };

                /**
                 * Converts this MemoryDescInfo to JSON.
                 * @function toJSON
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MemoryDescInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MemoryDescInfo;
            })();

            MachineInfo.DeadLockThreadInfo = (function() {

                /**
                 * Properties of a DeadLockThreadInfo.
                 * @memberof protocol.NodeInfo.MachineInfo
                 * @interface IDeadLockThreadInfo
                 * @property {string|null} [name] DeadLockThreadInfo name
                 * @property {string|null} [lockName] DeadLockThreadInfo lockName
                 * @property {string|null} [lockOwner] DeadLockThreadInfo lockOwner
                 * @property {string|null} [state] DeadLockThreadInfo state
                 * @property {number|Long|null} [blockTime] DeadLockThreadInfo blockTime
                 * @property {number|Long|null} [waitTime] DeadLockThreadInfo waitTime
                 * @property {string|null} [stackTrace] DeadLockThreadInfo stackTrace
                 */

                /**
                 * Constructs a new DeadLockThreadInfo.
                 * @memberof protocol.NodeInfo.MachineInfo
                 * @classdesc Represents a DeadLockThreadInfo.
                 * @implements IDeadLockThreadInfo
                 * @constructor
                 * @param {protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo=} [properties] Properties to set
                 */
                function DeadLockThreadInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeadLockThreadInfo name.
                 * @member {string} name
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.name = "";

                /**
                 * DeadLockThreadInfo lockName.
                 * @member {string} lockName
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.lockName = "";

                /**
                 * DeadLockThreadInfo lockOwner.
                 * @member {string} lockOwner
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.lockOwner = "";

                /**
                 * DeadLockThreadInfo state.
                 * @member {string} state
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.state = "";

                /**
                 * DeadLockThreadInfo blockTime.
                 * @member {number|Long} blockTime
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.blockTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * DeadLockThreadInfo waitTime.
                 * @member {number|Long} waitTime
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.waitTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * DeadLockThreadInfo stackTrace.
                 * @member {string} stackTrace
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.stackTrace = "";

                /**
                 * Creates a new DeadLockThreadInfo instance using the specified properties.
                 * @function create
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo=} [properties] Properties to set
                 * @returns {protocol.NodeInfo.MachineInfo.DeadLockThreadInfo} DeadLockThreadInfo instance
                 */
                DeadLockThreadInfo.create = function create(properties) {
                    return new DeadLockThreadInfo(properties);
                };

                /**
                 * Encodes the specified DeadLockThreadInfo message. Does not implicitly {@link protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.verify|verify} messages.
                 * @function encode
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo} message DeadLockThreadInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeadLockThreadInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.lockName != null && Object.hasOwnProperty.call(message, "lockName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.lockName);
                    if (message.lockOwner != null && Object.hasOwnProperty.call(message, "lockOwner"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.lockOwner);
                    if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.state);
                    if (message.blockTime != null && Object.hasOwnProperty.call(message, "blockTime"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.blockTime);
                    if (message.waitTime != null && Object.hasOwnProperty.call(message, "waitTime"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.waitTime);
                    if (message.stackTrace != null && Object.hasOwnProperty.call(message, "stackTrace"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.stackTrace);
                    return writer;
                };

                /**
                 * Encodes the specified DeadLockThreadInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo} message DeadLockThreadInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeadLockThreadInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeadLockThreadInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {protocol.NodeInfo.MachineInfo.DeadLockThreadInfo} DeadLockThreadInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeadLockThreadInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.lockName = reader.string();
                            break;
                        case 3:
                            message.lockOwner = reader.string();
                            break;
                        case 4:
                            message.state = reader.string();
                            break;
                        case 5:
                            message.blockTime = reader.int64();
                            break;
                        case 6:
                            message.waitTime = reader.int64();
                            break;
                        case 7:
                            message.stackTrace = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeadLockThreadInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {protocol.NodeInfo.MachineInfo.DeadLockThreadInfo} DeadLockThreadInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeadLockThreadInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DeadLockThreadInfo message.
                 * @function verify
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeadLockThreadInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.lockName != null && message.hasOwnProperty("lockName"))
                        if (!$util.isString(message.lockName))
                            return "lockName: string expected";
                    if (message.lockOwner != null && message.hasOwnProperty("lockOwner"))
                        if (!$util.isString(message.lockOwner))
                            return "lockOwner: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        if (!$util.isString(message.state))
                            return "state: string expected";
                    if (message.blockTime != null && message.hasOwnProperty("blockTime"))
                        if (!$util.isInteger(message.blockTime) && !(message.blockTime && $util.isInteger(message.blockTime.low) && $util.isInteger(message.blockTime.high)))
                            return "blockTime: integer|Long expected";
                    if (message.waitTime != null && message.hasOwnProperty("waitTime"))
                        if (!$util.isInteger(message.waitTime) && !(message.waitTime && $util.isInteger(message.waitTime.low) && $util.isInteger(message.waitTime.high)))
                            return "waitTime: integer|Long expected";
                    if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                        if (!$util.isString(message.stackTrace))
                            return "stackTrace: string expected";
                    return null;
                };

                /**
                 * Creates a DeadLockThreadInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {protocol.NodeInfo.MachineInfo.DeadLockThreadInfo} DeadLockThreadInfo
                 */
                DeadLockThreadInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo)
                        return object;
                    var message = new $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.lockName != null)
                        message.lockName = String(object.lockName);
                    if (object.lockOwner != null)
                        message.lockOwner = String(object.lockOwner);
                    if (object.state != null)
                        message.state = String(object.state);
                    if (object.blockTime != null)
                        if ($util.Long)
                            (message.blockTime = $util.Long.fromValue(object.blockTime)).unsigned = false;
                        else if (typeof object.blockTime === "string")
                            message.blockTime = parseInt(object.blockTime, 10);
                        else if (typeof object.blockTime === "number")
                            message.blockTime = object.blockTime;
                        else if (typeof object.blockTime === "object")
                            message.blockTime = new $util.LongBits(object.blockTime.low >>> 0, object.blockTime.high >>> 0).toNumber();
                    if (object.waitTime != null)
                        if ($util.Long)
                            (message.waitTime = $util.Long.fromValue(object.waitTime)).unsigned = false;
                        else if (typeof object.waitTime === "string")
                            message.waitTime = parseInt(object.waitTime, 10);
                        else if (typeof object.waitTime === "number")
                            message.waitTime = object.waitTime;
                        else if (typeof object.waitTime === "object")
                            message.waitTime = new $util.LongBits(object.waitTime.low >>> 0, object.waitTime.high >>> 0).toNumber();
                    if (object.stackTrace != null)
                        message.stackTrace = String(object.stackTrace);
                    return message;
                };

                /**
                 * Creates a plain object from a DeadLockThreadInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.DeadLockThreadInfo} message DeadLockThreadInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeadLockThreadInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.lockName = "";
                        object.lockOwner = "";
                        object.state = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.blockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.blockTime = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.waitTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.waitTime = options.longs === String ? "0" : 0;
                        object.stackTrace = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.lockName != null && message.hasOwnProperty("lockName"))
                        object.lockName = message.lockName;
                    if (message.lockOwner != null && message.hasOwnProperty("lockOwner"))
                        object.lockOwner = message.lockOwner;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = message.state;
                    if (message.blockTime != null && message.hasOwnProperty("blockTime"))
                        if (typeof message.blockTime === "number")
                            object.blockTime = options.longs === String ? String(message.blockTime) : message.blockTime;
                        else
                            object.blockTime = options.longs === String ? $util.Long.prototype.toString.call(message.blockTime) : options.longs === Number ? new $util.LongBits(message.blockTime.low >>> 0, message.blockTime.high >>> 0).toNumber() : message.blockTime;
                    if (message.waitTime != null && message.hasOwnProperty("waitTime"))
                        if (typeof message.waitTime === "number")
                            object.waitTime = options.longs === String ? String(message.waitTime) : message.waitTime;
                        else
                            object.waitTime = options.longs === String ? $util.Long.prototype.toString.call(message.waitTime) : options.longs === Number ? new $util.LongBits(message.waitTime.low >>> 0, message.waitTime.high >>> 0).toNumber() : message.waitTime;
                    if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                        object.stackTrace = message.stackTrace;
                    return object;
                };

                /**
                 * Converts this DeadLockThreadInfo to JSON.
                 * @function toJSON
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeadLockThreadInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeadLockThreadInfo;
            })();

            return MachineInfo;
        })();

        return NodeInfo;
    })();

    return protocol;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
